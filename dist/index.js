var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/react/cjs/react.production.js
var exports_react_production = {};
__export(exports_react_production, {
  version: () => $version,
  useTransition: () => $useTransition,
  useSyncExternalStore: () => $useSyncExternalStore,
  useState: () => $useState,
  useRef: () => $useRef,
  useReducer: () => $useReducer,
  useOptimistic: () => $useOptimistic,
  useMemo: () => $useMemo,
  useLayoutEffect: () => $useLayoutEffect,
  useInsertionEffect: () => $useInsertionEffect,
  useImperativeHandle: () => $useImperativeHandle,
  useId: () => $useId,
  useEffect: () => $useEffect,
  useDeferredValue: () => $useDeferredValue,
  useDebugValue: () => $useDebugValue,
  useContext: () => $useContext,
  useCallback: () => $useCallback,
  useActionState: () => $useActionState,
  use: () => $use,
  unstable_useCacheRefresh: () => $unstable_useCacheRefresh,
  startTransition: () => $startTransition,
  memo: () => $memo,
  lazy: () => $lazy,
  isValidElement: () => $isValidElement,
  forwardRef: () => $forwardRef,
  createRef: () => $createRef,
  createElement: () => $createElement,
  createContext: () => $createContext,
  cloneElement: () => $cloneElement,
  cache: () => $cache,
  __COMPILER_RUNTIME: () => $__COMPILER_RUNTIME,
  __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: () => $__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  Suspense: () => $Suspense,
  StrictMode: () => $StrictMode,
  PureComponent: () => $PureComponent,
  Profiler: () => $Profiler,
  Fragment: () => $Fragment,
  Component: () => $Component,
  Children: () => $Children
});
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== "object")
    return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
  return typeof maybeIterable === "function" ? maybeIterable : null;
}
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
function ComponentDummy() {
}
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
function ReactElement(type, key, self2, source, owner, props) {
  self2 = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type,
    key,
    ref: self2 !== undefined ? self2 : null,
    props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(oldElement.type, newKey, undefined, undefined, undefined, oldElement.props);
}
function isValidElement(object) {
  return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return "$" + key.replace(/[=:]/g, function(match) {
    return escaperLookup[match];
  });
}
function getElementKey(element, index) {
  return typeof element === "object" && element !== null && element.key != null ? escape("" + element.key) : index.toString(36);
}
function noop$1() {
}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch (typeof thenable.status === "string" ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
        thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
      }, function(error) {
        thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error);
      })), thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if (type === "undefined" || type === "boolean")
    children = null;
  var invokeCallback = false;
  if (children === null)
    invokeCallback = true;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = true;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
            break;
          case REACT_LAZY_TYPE:
            return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
        }
    }
  if (invokeCallback)
    return callback = callback(children), invokeCallback = nameSoFar === "" ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", invokeCallback != null && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
      return c;
    })) : callback != null && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
  invokeCallback = 0;
  var nextNamePrefix = nameSoFar === "" ? "." : nameSoFar + ":";
  if (isArrayImpl(children))
    for (var i = 0;i < children.length; i++)
      nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
  else if (i = getIteratorFn(children), typeof i === "function")
    for (children = i.call(children), i = 0;!(nameSoFar = children.next()).done; )
      nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
  else if (type === "object") {
    if (typeof children.then === "function")
      return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
    array = String(children);
    throw Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (children == null)
    return children;
  var result = [], count = 0;
  mapIntoArray(children, result, "", "", function(child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (payload._status === -1) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(function(moduleObject) {
      if (payload._status === 0 || payload._status === -1)
        payload._status = 1, payload._result = moduleObject;
    }, function(error) {
      if (payload._status === 0 || payload._status === -1)
        payload._status = 2, payload._result = error;
    });
    payload._status === -1 && (payload._status = 0, payload._result = ctor);
  }
  if (payload._status === 1)
    return payload._result.default;
  throw payload._result;
}
function noop() {
}
var REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE, REACT_FRAGMENT_TYPE, REACT_STRICT_MODE_TYPE, REACT_PROFILER_TYPE, REACT_CONSUMER_TYPE, REACT_CONTEXT_TYPE, REACT_FORWARD_REF_TYPE, REACT_SUSPENSE_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE, MAYBE_ITERATOR_SYMBOL, ReactNoopUpdateQueue, assign, emptyObject, pureComponentPrototype, isArrayImpl, ReactSharedInternals, hasOwnProperty, userProvidedKeyEscapeRegex, reportGlobalError, $Children, $Component, $Fragment, $Profiler, $PureComponent, $StrictMode, $Suspense, $__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, $__COMPILER_RUNTIME, $cache = function(fn) {
  return function() {
    return fn.apply(null, arguments);
  };
}, $cloneElement = function(element, config, children) {
  if (element === null || element === undefined)
    throw Error("The argument must be a React element, but you passed " + element + ".");
  var props = assign({}, element.props), key = element.key, owner = undefined;
  if (config != null)
    for (propName in config.ref !== undefined && (owner = undefined), config.key !== undefined && (key = "" + config.key), config)
      !hasOwnProperty.call(config, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config.ref === undefined || (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (propName === 1)
    props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0;i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, undefined, undefined, owner, props);
}, $createContext = function(defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
}, $createElement = function(type, config, children) {
  var propName, props = {}, key = null;
  if (config != null)
    for (propName in config.key !== undefined && (key = "" + config.key), config)
      hasOwnProperty.call(config, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1)
    props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0;i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in childrenLength = type.defaultProps, childrenLength)
      props[propName] === undefined && (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, undefined, undefined, null, props);
}, $createRef = function() {
  return { current: null };
}, $forwardRef = function(render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE, render };
}, $isValidElement, $lazy = function(ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
}, $memo = function(type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type,
    compare: compare === undefined ? null : compare
  };
}, $startTransition = function(scope) {
  var prevTransition = ReactSharedInternals.T, currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
    onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
    typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    ReactSharedInternals.T = prevTransition;
  }
}, $unstable_useCacheRefresh = function() {
  return ReactSharedInternals.H.useCacheRefresh();
}, $use = function(usable) {
  return ReactSharedInternals.H.use(usable);
}, $useActionState = function(action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
}, $useCallback = function(callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
}, $useContext = function(Context) {
  return ReactSharedInternals.H.useContext(Context);
}, $useDebugValue = function() {
}, $useDeferredValue = function(value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
}, $useEffect = function(create, createDeps, update) {
  var dispatcher = ReactSharedInternals.H;
  if (typeof update === "function")
    throw Error("useEffect CRUD overload is not enabled in this build of React.");
  return dispatcher.useEffect(create, createDeps);
}, $useId = function() {
  return ReactSharedInternals.H.useId();
}, $useImperativeHandle = function(ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
}, $useInsertionEffect = function(create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
}, $useLayoutEffect = function(create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
}, $useMemo = function(create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
}, $useOptimistic = function(passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
}, $useReducer = function(reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
}, $useRef = function(initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
}, $useState = function(initialState) {
  return ReactSharedInternals.H.useState(initialState);
}, $useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
  return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
}, $useTransition = function() {
  return ReactSharedInternals.H.useTransition();
}, $version = "19.1.0";
var init_react_production = __esm(() => {
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
  REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
  REACT_CONTEXT_TYPE = Symbol.for("react.context");
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
  REACT_MEMO_TYPE = Symbol.for("react.memo");
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  ReactNoopUpdateQueue = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  };
  assign = Object.assign;
  emptyObject = {};
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function(partialState, callback) {
    if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null)
      throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  ComponentDummy.prototype = Component.prototype;
  pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
  pureComponentPrototype.constructor = PureComponent;
  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;
  isArrayImpl = Array.isArray;
  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
  hasOwnProperty = Object.prototype.hasOwnProperty;
  userProvidedKeyEscapeRegex = /\/+/g;
  reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
    if (typeof window === "object" && typeof window.ErrorEvent === "function") {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event))
        return;
    } else if (typeof process === "object" && typeof process.emit === "function") {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  };
  $Children = {
    map: mapChildren,
    forEach: function(children, forEachFunc, forEachContext) {
      mapChildren(children, function() {
        forEachFunc.apply(this, arguments);
      }, forEachContext);
    },
    count: function(children) {
      var n = 0;
      mapChildren(children, function() {
        n++;
      });
      return n;
    },
    toArray: function(children) {
      return mapChildren(children, function(child) {
        return child;
      }) || [];
    },
    only: function(children) {
      if (!isValidElement(children))
        throw Error("React.Children.only expected to receive a single React element child.");
      return children;
    }
  };
  $Component = Component;
  $Fragment = REACT_FRAGMENT_TYPE;
  $Profiler = REACT_PROFILER_TYPE;
  $PureComponent = PureComponent;
  $StrictMode = REACT_STRICT_MODE_TYPE;
  $Suspense = REACT_SUSPENSE_TYPE;
  $__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  $__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(size) {
      return ReactSharedInternals.H.useMemoCache(size);
    }
  };
  $isValidElement = isValidElement;
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  init_react_production();
  if (true) {
    module.exports = exports_react_production;
  } else {
  }
});

// node_modules/scheduler/cjs/scheduler.production.js
var exports_scheduler_production = {};
__export(exports_scheduler_production, {
  unstable_wrapCallback: () => $unstable_wrapCallback,
  unstable_shouldYield: () => $unstable_shouldYield,
  unstable_scheduleCallback: () => $unstable_scheduleCallback,
  unstable_runWithPriority: () => $unstable_runWithPriority,
  unstable_requestPaint: () => $unstable_requestPaint,
  unstable_now: () => $unstable_now,
  unstable_next: () => $unstable_next,
  unstable_getCurrentPriorityLevel: () => $unstable_getCurrentPriorityLevel,
  unstable_forceFrameRate: () => $unstable_forceFrameRate,
  unstable_cancelCallback: () => $unstable_cancelCallback,
  unstable_UserBlockingPriority: () => $unstable_UserBlockingPriority,
  unstable_Profiling: () => $unstable_Profiling,
  unstable_NormalPriority: () => $unstable_NormalPriority,
  unstable_LowPriority: () => $unstable_LowPriority,
  unstable_ImmediatePriority: () => $unstable_ImmediatePriority,
  unstable_IdlePriority: () => $unstable_IdlePriority
});
function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a:
    for (;0 < index; ) {
      var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
      if (0 < compare(parent, node))
        heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
      else
        break a;
    }
}
function peek(heap) {
  return heap.length === 0 ? null : heap[0];
}
function pop(heap) {
  if (heap.length === 0)
    return null;
  var first = heap[0], last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a:
      for (var index = 0, length = heap.length, halfLength = length >>> 1;index < halfLength; ) {
        var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
        if (0 > compare(left, last))
          rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
        else if (rightIndex < length && 0 > compare(right, last))
          heap[index] = right, heap[rightIndex] = last, index = rightIndex;
        else
          break a;
      }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue);timer !== null; ) {
    if (timer.callback === null)
      pop(timerQueue);
    else if (timer.startTime <= currentTime)
      pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
    else
      break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled)
    if (peek(taskQueue) !== null)
      isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
    else {
      var firstTimer = peek(timerQueue);
      firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
}
function shouldYieldToHost() {
  return needsPaint ? true : $unstable_now() - startTime < frameInterval ? false : true;
}
function performWorkUntilDeadline() {
  needsPaint = false;
  if (isMessageLoopRunning) {
    var currentTime = $unstable_now();
    startTime = currentTime;
    var hasMoreWork = true;
    try {
      a: {
        isHostCallbackScheduled = false;
        isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
        isPerformingWork = true;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (currentTask = peek(taskQueue);currentTask !== null && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                currentTime = $unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = true;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else
                pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null)
              hasMoreWork = true;
            else {
              var firstTimer = peek(timerQueue);
              firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              hasMoreWork = false;
            }
          }
          break a;
        } finally {
          currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
        }
        hasMoreWork = undefined;
      }
    } finally {
      hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
    }
  }
}
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function() {
    callback($unstable_now());
  }, ms);
}
var $unstable_now = undefined, localPerformance, localDate, initialTime, taskQueue, timerQueue, taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout, localClearTimeout, localSetImmediate, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1, schedulePerformWorkUntilDeadline, channel, port, $unstable_IdlePriority = 5, $unstable_ImmediatePriority = 1, $unstable_LowPriority = 4, $unstable_NormalPriority = 3, $unstable_Profiling = null, $unstable_UserBlockingPriority = 2, $unstable_cancelCallback = function(task) {
  task.callback = null;
}, $unstable_forceFrameRate = function(fps) {
  0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1000 / fps) : 5;
}, $unstable_getCurrentPriorityLevel = function() {
  return currentPriorityLevel;
}, $unstable_next = function(eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}, $unstable_requestPaint = function() {
  needsPaint = true;
}, $unstable_runWithPriority = function(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}, $unstable_scheduleCallback = function(priorityLevel, callback, options) {
  var currentTime = $unstable_now();
  typeof options === "object" && options !== null ? (options = options.delay, options = typeof options === "number" && 0 < options ? currentTime + options : currentTime) : options = currentTime;
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5000;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
  return priorityLevel;
}, $unstable_shouldYield, $unstable_wrapCallback = function(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function() {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};
var init_scheduler_production = __esm(() => {
  if (typeof performance === "object" && typeof performance.now === "function") {
    localPerformance = performance;
    $unstable_now = function() {
      return localPerformance.now();
    };
  } else {
    localDate = Date, initialTime = localDate.now();
    $unstable_now = function() {
      return localDate.now() - initialTime;
    };
  }
  taskQueue = [];
  timerQueue = [];
  localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
  localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
  localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
  if (typeof localSetImmediate === "function")
    schedulePerformWorkUntilDeadline = function() {
      localSetImmediate(performWorkUntilDeadline);
    };
  else if (typeof MessageChannel !== "undefined") {
    channel = new MessageChannel, port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    schedulePerformWorkUntilDeadline = function() {
      port.postMessage(null);
    };
  } else
    schedulePerformWorkUntilDeadline = function() {
      localSetTimeout(performWorkUntilDeadline, 0);
    };
  $unstable_shouldYield = shouldYieldToHost;
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports, module) => {
  init_scheduler_production();
  if (true) {
    module.exports = exports_scheduler_production;
  } else {
  }
});

// node_modules/react-dom/cjs/react-dom.production.js
var exports_react_dom_production = {};
__export(exports_react_dom_production, {
  version: () => $version2,
  useFormStatus: () => $useFormStatus,
  useFormState: () => $useFormState,
  unstable_batchedUpdates: () => $unstable_batchedUpdates,
  requestFormReset: () => $requestFormReset,
  preloadModule: () => $preloadModule,
  preload: () => $preload,
  preinitModule: () => $preinitModule,
  preinit: () => $preinit,
  prefetchDNS: () => $prefetchDNS,
  preconnect: () => $preconnect,
  flushSync: () => $flushSync,
  createPortal: () => $createPortal,
  __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: () => $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
});
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2;i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function noop2() {
}
function createPortal$1(children, containerInfo, implementation) {
  var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE2,
    key: key == null ? null : "" + key,
    children,
    containerInfo,
    implementation
  };
}
function getCrossOriginStringAs(as, input) {
  if (as === "font")
    return "";
  if (typeof input === "string")
    return input === "use-credentials" ? input : "";
}
var React, Internals, REACT_PORTAL_TYPE2, ReactSharedInternals2, $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, $createPortal = function(children, container) {
  var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
  if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
}, $flushSync = function(fn) {
  var previousTransition = ReactSharedInternals2.T, previousUpdatePriority = Internals.p;
  try {
    if (ReactSharedInternals2.T = null, Internals.p = 2, fn)
      return fn();
  } finally {
    ReactSharedInternals2.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
  }
}, $preconnect = function(href, options) {
  typeof href === "string" && (options ? (options = options.crossOrigin, options = typeof options === "string" ? options === "use-credentials" ? options : "" : undefined) : options = null, Internals.d.C(href, options));
}, $prefetchDNS = function(href) {
  typeof href === "string" && Internals.d.D(href);
}, $preinit = function(href, options) {
  if (typeof href === "string" && options && typeof options.as === "string") {
    var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = typeof options.integrity === "string" ? options.integrity : undefined, fetchPriority = typeof options.fetchPriority === "string" ? options.fetchPriority : undefined;
    as === "style" ? Internals.d.S(href, typeof options.precedence === "string" ? options.precedence : undefined, {
      crossOrigin,
      integrity,
      fetchPriority
    }) : as === "script" && Internals.d.X(href, {
      crossOrigin,
      integrity,
      fetchPriority,
      nonce: typeof options.nonce === "string" ? options.nonce : undefined
    });
  }
}, $preinitModule = function(href, options) {
  if (typeof href === "string")
    if (typeof options === "object" && options !== null) {
      if (options.as == null || options.as === "script") {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.M(href, {
          crossOrigin,
          integrity: typeof options.integrity === "string" ? options.integrity : undefined,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined
        });
      }
    } else
      options == null && Internals.d.M(href);
}, $preload = function(href, options) {
  if (typeof href === "string" && typeof options === "object" && options !== null && typeof options.as === "string") {
    var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin,
      integrity: typeof options.integrity === "string" ? options.integrity : undefined,
      nonce: typeof options.nonce === "string" ? options.nonce : undefined,
      type: typeof options.type === "string" ? options.type : undefined,
      fetchPriority: typeof options.fetchPriority === "string" ? options.fetchPriority : undefined,
      referrerPolicy: typeof options.referrerPolicy === "string" ? options.referrerPolicy : undefined,
      imageSrcSet: typeof options.imageSrcSet === "string" ? options.imageSrcSet : undefined,
      imageSizes: typeof options.imageSizes === "string" ? options.imageSizes : undefined,
      media: typeof options.media === "string" ? options.media : undefined
    });
  }
}, $preloadModule = function(href, options) {
  if (typeof href === "string")
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as: typeof options.as === "string" && options.as !== "script" ? options.as : undefined,
        crossOrigin,
        integrity: typeof options.integrity === "string" ? options.integrity : undefined
      });
    } else
      Internals.d.m(href);
}, $requestFormReset = function(form) {
  Internals.d.r(form);
}, $unstable_batchedUpdates = function(fn, a) {
  return fn(a);
}, $useFormState = function(action, initialState, permalink) {
  return ReactSharedInternals2.H.useFormState(action, initialState, permalink);
}, $useFormStatus = function() {
  return ReactSharedInternals2.H.useHostTransitionStatus();
}, $version2 = "19.1.0";
var init_react_dom_production = __esm(() => {
  React = __toESM(require_react(), 1);
  Internals = {
    d: {
      f: noop2,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop2,
      C: noop2,
      L: noop2,
      m: noop2,
      X: noop2,
      S: noop2,
      M: noop2
    },
    p: 0,
    findDOMNode: null
  };
  REACT_PORTAL_TYPE2 = Symbol.for("react.portal");
  ReactSharedInternals2 = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS((exports, module) => {
  init_react_dom_production();
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    if (false) {
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  if (true) {
    checkDCE();
    module.exports = exports_react_dom_production;
  } else {
  }
});

// node_modules/react-dom/cjs/react-dom-client.production.js
var exports_react_dom_client_production = {};
__export(exports_react_dom_client_production, {
  version: () => $version3,
  hydrateRoot: () => $hydrateRoot,
  createRoot: () => $createRoot
});
function formatProdErrorMessage2(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2;i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function isValidContainer(node) {
  return !(!node || node.nodeType !== 1 && node.nodeType !== 9 && node.nodeType !== 11);
}
function getNearestMountedFiber(fiber) {
  var node = fiber, nearestMounted = fiber;
  if (fiber.alternate)
    for (;node.return; )
      node = node.return;
  else {
    fiber = node;
    do
      node = fiber, (node.flags & 4098) !== 0 && (nearestMounted = node.return), fiber = node.return;
    while (fiber);
  }
  return node.tag === 3 ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (fiber.tag === 13) {
    var suspenseState = fiber.memoizedState;
    suspenseState === null && (fiber = fiber.alternate, fiber !== null && (suspenseState = fiber.memoizedState));
    if (suspenseState !== null)
      return suspenseState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage2(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (alternate === null)
      throw Error(formatProdErrorMessage2(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate;; ) {
    var parentA = a.return;
    if (parentA === null)
      break;
    var parentB = parentA.alternate;
    if (parentB === null) {
      b = parentA.return;
      if (b !== null) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child;parentB; ) {
        if (parentB === a)
          return assertIsMounted(parentA), fiber;
        if (parentB === b)
          return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage2(188));
    }
    if (a.return !== b.return)
      a = parentA, b = parentB;
    else {
      for (var didFindChild = false, child$0 = parentA.child;child$0; ) {
        if (child$0 === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$0 === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        child$0 = child$0.sibling;
      }
      if (!didFindChild) {
        for (child$0 = parentB.child;child$0; ) {
          if (child$0 === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$0 === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild)
          throw Error(formatProdErrorMessage2(189));
      }
    }
    if (a.alternate !== b)
      throw Error(formatProdErrorMessage2(190));
  }
  if (a.tag !== 3)
    throw Error(formatProdErrorMessage2(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
    return node;
  for (node = node.child;node !== null; ) {
    tag = findCurrentHostFiberImpl(node);
    if (tag !== null)
      return tag;
    node = node.sibling;
  }
  return null;
}
function getIteratorFn2(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== "object")
    return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL2 && maybeIterable[MAYBE_ITERATOR_SYMBOL2] || maybeIterable["@@iterator"];
  return typeof maybeIterable === "function" ? maybeIterable : null;
}
function getComponentNameFromType(type) {
  if (type == null)
    return null;
  if (typeof type === "function")
    return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
  if (typeof type === "string")
    return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE2:
      return "Fragment";
    case REACT_PROFILER_TYPE2:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE2:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE2:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if (typeof type === "object")
    switch (type.$$typeof) {
      case REACT_PORTAL_TYPE3:
        return "Portal";
      case REACT_CONTEXT_TYPE2:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE2:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE2:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE2:
        return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE2:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {
        }
    }
  return null;
}
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop2(cursor) {
  0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
}
function push2(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
function pushHostContainer(fiber, nextRootInstance) {
  push2(rootInstanceStackCursor, nextRootInstance);
  push2(contextFiberStackCursor, fiber);
  push2(contextStackCursor, null);
  switch (nextRootInstance.nodeType) {
    case 9:
    case 11:
      fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
      break;
    default:
      if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
        nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
      else
        switch (fiber) {
          case "svg":
            fiber = 1;
            break;
          case "math":
            fiber = 2;
            break;
          default:
            fiber = 0;
        }
  }
  pop2(contextStackCursor);
  push2(contextStackCursor, fiber);
}
function popHostContainer() {
  pop2(contextStackCursor);
  pop2(contextFiberStackCursor);
  pop2(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  fiber.memoizedState !== null && push2(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result && (push2(contextFiberStackCursor, fiber), push2(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber && (pop2(contextStackCursor), pop2(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber && (pop2(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
}
function setIsStrictModeForDevtools(newIsStrictMode) {
  typeof log$1 === "function" && unstable_setDisableYieldValue2(newIsStrictMode);
  if (injectedHook && typeof injectedHook.setStrictMode === "function")
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {
    }
}
function clz32Fallback(x) {
  x >>>= 0;
  return x === 0 ? 32 : 31 - (log2(x) / LN2 | 0) | 0;
}
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (pendingSyncLanes !== 0)
    return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
      return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 4194048;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes, rootHasPendingCommit) {
  var pendingLanes = root.pendingLanes;
  if (pendingLanes === 0)
    return 0;
  var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
  root = root.warmLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  nonIdlePendingLanes !== 0 ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, pendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, nonIdlePendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
  return nextLanes === 0 ? 0 : wipLanes !== 0 && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === 0 && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || suspendedLanes === 32 && (rootHasPendingCommit & 4194048) !== 0) ? wipLanes : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes) === 0;
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
      return currentTime + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5000;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextTransitionLane() {
  var lane = nextTransitionLane;
  nextTransitionLane <<= 1;
  (nextTransitionLane & 4194048) === 0 && (nextTransitionLane = 256);
  return lane;
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  (nextRetryLane & 62914560) === 0 && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0;31 > i; i++)
    laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  updateLane !== 268435456 && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
}
function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var { entanglements, expirationTimes, hiddenUpdates } = root;
  for (remainingLanes = previouslyPendingLanes & ~remainingLanes;0 < remainingLanes; ) {
    var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
    entanglements[index$5] = 0;
    expirationTimes[index$5] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$5];
    if (hiddenUpdatesForLane !== null)
      for (hiddenUpdates[index$5] = null, index$5 = 0;index$5 < hiddenUpdatesForLane.length; index$5++) {
        var update = hiddenUpdatesForLane[index$5];
        update !== null && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  spawnedLane !== 0 && markSpawnedDeferredLane(root, spawnedLane, 0);
  suspendedRetryLanes !== 0 && updatedLanes === 0 && root.tag !== 0 && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = root.entangledLanes |= entangledLanes;
  for (root = root.entanglements;rootEntangledLanes; ) {
    var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
    lane & entangledLanes | root[index$6] & entangledLanes && (root[index$6] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function getBumpedLaneForHydrationByLane(lane) {
  switch (lane) {
    case 2:
      lane = 1;
      break;
    case 8:
      lane = 4;
      break;
    case 32:
      lane = 16;
      break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      lane = 128;
      break;
    case 268435456:
      lane = 134217728;
      break;
    default:
      lane = 0;
  }
  return lane;
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes ? 8 < lanes ? (lanes & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (updatePriority !== 0)
    return updatePriority;
  updatePriority = window.event;
  return updatePriority === undefined ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return ReactDOMSharedInternals.p = priority, fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst)
    return targetInst;
  for (var parentNode = targetNode.parentNode;parentNode; ) {
    if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
      parentNode = targetInst.alternate;
      if (targetInst.child !== null || parentNode !== null && parentNode.child !== null)
        for (targetNode = getParentSuspenseInstance(targetNode);targetNode !== null; ) {
          if (parentNode = targetNode[internalInstanceKey])
            return parentNode;
          targetNode = getParentSuspenseInstance(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
    var tag = node.tag;
    if (tag === 5 || tag === 6 || tag === 13 || tag === 26 || tag === 27 || tag === 3)
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
    return inst.stateNode;
  throw Error(formatProdErrorMessage2(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources || (resources = root[internalRootNodeResourcesKey] = { hoistableStyles: new Map, hoistableScripts: new Map });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = true;
}
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (registrationName = 0;registrationName < dependencies.length; registrationName++)
    allNativeEvents.add(dependencies[registrationName]);
}
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))
    return true;
  if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName))
    return false;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return validatedAttributeNameCache[attributeName] = true;
  illegalAttributeNameCache[attributeName] = true;
  return false;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (value === null)
      node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$8 = name.toLowerCase().slice(0, 5);
          if (prefix$8 !== "data-" && prefix$8 !== "aria-") {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (value === null)
    node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (value === null)
    node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function describeBuiltInComponentFrame(name) {
  if (prefix === undefined)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
  return `
` + prefix + name + suffix;
}
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry)
    return "";
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = undefined;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function() {
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$9) {
                control = x$9;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$10) {
              control = x$10;
            }
            (Fake = fn()) && typeof Fake.catch === "function" && Fake.catch(function() {
            });
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string")
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
    namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
      for (namePropDescriptor = RunInRootFrame = 0;RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
        RunInRootFrame++;
      for (;namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
        namePropDescriptor++;
      if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
        for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1;1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
          namePropDescriptor--;
      for (;1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (RunInRootFrame !== 1 || namePropDescriptor !== 1) {
            do
              if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                var frame = `
` + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
}
function describeFiber(fiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return describeNativeComponentFrame(fiber.type, false);
    case 11:
      return describeNativeComponentFrame(fiber.type.render, false);
    case 1:
      return describeNativeComponentFrame(fiber.type, true);
    case 31:
      return describeBuiltInComponentFrame("Activity");
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "";
    do
      info += describeFiber(workInProgress), workInProgress = workInProgress.return;
    while (workInProgress);
    return info;
  } catch (x) {
    return `
Error generating stack: ` + x.message + `
` + x.stack;
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (elem = elem.nodeName) && elem.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
}
function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField), currentValue = "" + node[valueField];
  if (!node.hasOwnProperty(valueField) && typeof descriptor !== "undefined" && typeof descriptor.get === "function" && typeof descriptor.set === "function") {
    var { get, set } = descriptor;
    Object.defineProperty(node, valueField, {
      configurable: true,
      get: function() {
        return get.call(this);
      },
      set: function(value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function() {
        return currentValue;
      },
      setValue: function(value) {
        currentValue = "" + value;
      },
      stopTracking: function() {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
}
function updateValueIfChanged(node) {
  if (!node)
    return false;
  var tracker = node._valueTracker;
  if (!tracker)
    return true;
  var lastValue = tracker.getValue();
  var value = "";
  node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), true) : false;
}
function getActiveElement(doc) {
  doc = doc || (typeof document !== "undefined" ? document : undefined);
  if (typeof doc === "undefined")
    return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
    return "\\" + ch.charCodeAt(0).toString(16) + " ";
  });
}
function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
  element.name = "";
  type != null && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean" ? element.type = type : element.removeAttribute("type");
  if (value != null)
    if (type === "number") {
      if (value === 0 && element.value === "" || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
  else
    type !== "submit" && type !== "reset" || element.removeAttribute("value");
  value != null ? setDefaultValue(element, type, getToStringValue(value)) : defaultValue != null ? setDefaultValue(element, type, getToStringValue(defaultValue)) : lastDefaultValue != null && element.removeAttribute("value");
  checked == null && defaultChecked != null && (element.defaultChecked = !!defaultChecked);
  checked != null && (element.checked = checked && typeof checked !== "function" && typeof checked !== "symbol");
  name != null && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean" ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
}
function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
  type != null && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean" && (element.type = type);
  if (value != null || defaultValue != null) {
    if (!(type !== "submit" && type !== "reset" || value !== undefined && value !== null))
      return;
    defaultValue = defaultValue != null ? "" + getToStringValue(defaultValue) : "";
    value = value != null ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = checked != null ? checked : defaultChecked;
  checked = typeof checked !== "function" && typeof checked !== "symbol" && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  name != null && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean" && (element.name = name);
}
function setDefaultValue(node, type, value) {
  type === "number" && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0;i < propValue.length; i++)
      multiple["$" + propValue[i]] = true;
    for (propValue = 0;propValue < node.length; propValue++)
      i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0;i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = true;
        setDefaultSelected && (node[i].defaultSelected = true);
        return;
      }
      multiple !== null || node[i].disabled || (multiple = node[i]);
    }
    multiple !== null && (multiple.selected = true);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (value != null && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), defaultValue == null)) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue = defaultValue != null ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (value == null) {
    if (children != null) {
      if (defaultValue != null)
        throw Error(formatProdErrorMessage2(92));
      if (isArrayImpl2(children)) {
        if (1 < children.length)
          throw Error(formatProdErrorMessage2(93));
        children = children[0];
      }
      defaultValue = children;
    }
    defaultValue == null && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue && children !== "" && children !== null && (element.value = children);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = styleName.indexOf("--") === 0;
  value == null || typeof value === "boolean" || value === "" ? isCustomProperty ? style.setProperty(styleName, "") : styleName === "float" ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : typeof value !== "number" || value === 0 || unitlessNumbers.has(styleName) ? styleName === "float" ? style.cssFloat = value : style[styleName] = ("" + value).trim() : style[styleName] = value + "px";
}
function setValueForStyles(node, styles, prevStyles) {
  if (styles != null && typeof styles !== "object")
    throw Error(formatProdErrorMessage2(62));
  node = node.style;
  if (prevStyles != null) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) || styles != null && styles.hasOwnProperty(styleName) || (styleName.indexOf("--") === 0 ? node.setProperty(styleName, "") : styleName === "float" ? node.cssFloat = "" : node[styleName] = "");
    for (var styleName$16 in styles)
      styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (tagName.indexOf("-") === -1)
    return false;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
}
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
  return nativeEvent.nodeType === 3 ? nativeEvent.parentNode : nativeEvent;
}
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a:
      switch (target = internalInstance.stateNode, internalInstance.type) {
        case "input":
          updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
          internalInstance = props.name;
          if (props.type === "radio" && internalInstance != null) {
            for (props = target;props.parentNode; )
              props = props.parentNode;
            props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
            for (internalInstance = 0;internalInstance < props.length; internalInstance++) {
              var otherNode = props[internalInstance];
              if (otherNode !== target && otherNode.form === target.form) {
                var otherProps = otherNode[internalPropsKey] || null;
                if (!otherProps)
                  throw Error(formatProdErrorMessage2(90));
                updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
              }
            }
            for (internalInstance = 0;internalInstance < props.length; internalInstance++)
              otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
          }
          break a;
        case "textarea":
          updateTextarea(target, props.value, props.defaultValue);
          break a;
        case "select":
          internalInstance = props.value, internalInstance != null && updateOptions(target, !!props.multiple, internalInstance, false);
      }
  }
}
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler)
    return fn(a, b);
  isInsideEventHandler = true;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (isInsideEventHandler = false, restoreTarget !== null || restoreQueue !== null) {
      if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
        for (a = 0;a < fn.length; a++)
          restoreStateOfTarget(fn[a]);
    }
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (stateNode === null)
    return null;
  var props = stateNode[internalPropsKey] || null;
  if (props === null)
    return null;
  stateNode = props[registrationName];
  a:
    switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (props = !props.disabled) || (inst = inst.type, props = !(inst === "button" || inst === "input" || inst === "select" || inst === "textarea"));
        inst = !props;
        break a;
      default:
        inst = false;
    }
  if (inst)
    return null;
  if (stateNode && typeof stateNode !== "function")
    throw Error(formatProdErrorMessage2(231, registrationName, typeof stateNode));
  return stateNode;
}
function getData() {
  if (fallbackText)
    return fallbackText;
  var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
  for (start = 0;start < startLength && startValue[start] === endValue[start]; start++)
    ;
  var minEnd = startLength - start;
  for (end = 1;end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
    ;
  return fallbackText = endValue.slice(start, 1 < end ? 1 - end : undefined);
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, nativeEvent === 0 && keyCode === 13 && (nativeEvent = 13)) : nativeEvent = keyCode;
  nativeEvent === 10 && (nativeEvent = 13);
  return 32 <= nativeEvent || nativeEvent === 13 ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return true;
}
function functionThatReturnsFalse() {
  return false;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
    this.isDefaultPrevented = (nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign2(SyntheticBaseEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : typeof event.returnValue !== "unknown" && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : typeof event.cancelBubble !== "unknown" && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function() {
    },
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
}
function getEventModifierState() {
  return modifierStateGetter;
}
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case "keydown":
      return nativeEvent.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return typeof nativeEvent === "object" && "data" in nativeEvent ? nativeEvent.data : null;
}
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (nativeEvent.which !== 32)
        return null;
      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;
    case "textInput":
      return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which)
          return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && nativeEvent.locale !== "ko" ? null : nativeEvent.data;
    default:
      return null;
  }
}
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === "input" ? !!supportedInputTypes[elem.type] : nodeName === "textarea" ? true : false;
}
function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode))
    return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if (domEventName === "change")
    return targetInst;
}
function stopWatchingForValueChange() {
  activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
}
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName === "value" && getInstIfValueChanged(activeElementInst$1)) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  domEventName === "focusin" ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : domEventName === "focusout" && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown")
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if (domEventName === "click")
    return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if (domEventName === "input" || domEventName === "change")
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null)
    return false;
  var keysA = Object.keys(objA), keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (keysB = 0;keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
      return false;
  }
  return true;
}
function getLeafNode(node) {
  for (;node && node.firstChild; )
    node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root2, offset) {
  var node = getLeafNode(root2);
  root2 = 0;
  for (var nodeEnd;node; ) {
    if (node.nodeType === 3) {
      nodeEnd = root2 + node.textContent.length;
      if (root2 <= offset && nodeEnd >= offset)
        return { node, offset: offset - root2 };
      root2 = nodeEnd;
    }
    a: {
      for (;node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = undefined;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && outerNode.nodeType === 3 ? false : innerNode && innerNode.nodeType === 3 ? containsNode(outerNode, innerNode.parentNode) : ("contains" in outerNode) ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
}
function getActiveElementDeep(containerInfo) {
  containerInfo = containerInfo != null && containerInfo.ownerDocument != null && containerInfo.ownerDocument.defaultView != null ? containerInfo.ownerDocument.defaultView : window;
  for (var element = getActiveElement(containerInfo.document);element instanceof containerInfo.HTMLIFrameElement; ) {
    try {
      var JSCompiler_inline_result = typeof element.contentWindow.location.href === "string";
    } catch (err) {
      JSCompiler_inline_result = false;
    }
    if (JSCompiler_inline_result)
      containerInfo = element.contentWindow;
    else
      break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
}
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === 9 ? nativeEventTarget : nativeEventTarget.ownerDocument;
  mouseDown || activeElement == null || activeElement !== getActiveElement(doc) || (doc = activeElement, ("selectionStart" in doc) && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
    anchorNode: doc.anchorNode,
    anchorOffset: doc.anchorOffset,
    focusNode: doc.focusNode,
    focusOffset: doc.focusOffset
  }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName])
    return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName])
    return eventName;
  var prefixMap = vendorPrefixes[eventName], styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return prefixedEventNames[eventName] = prefixMap[styleProp];
  return eventName;
}
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
function createCapturedValueAtFiber(value, source) {
  if (typeof value === "object" && value !== null) {
    var existing = CapturedStacks.get(value);
    if (existing !== undefined)
      return existing;
    source = {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value,
    source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
function finishQueueingConcurrentUpdates() {
  for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0;i < endIndex; ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (queue !== null && update !== null) {
      var pending = queue.pending;
      pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    lane !== 0 && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  fiber !== null && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  alternate !== null && (alternate.lanes |= lane);
  for (var isHidden = false, parent = sourceFiber.return;parent !== null; )
    parent.childLanes |= lane, alternate = parent.alternate, alternate !== null && (alternate.childLanes |= lane), parent.tag === 22 && (sourceFiber = parent.stateNode, sourceFiber === null || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
  return sourceFiber.tag === 3 ? (parent = sourceFiber.stateNode, isHidden && update !== null && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], alternate === null ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage2(185));
  for (var parent = sourceFiber.return;parent !== null; )
    sourceFiber = parent, parent = sourceFiber.return;
  return sourceFiber.tag === 3 ? sourceFiber.stateNode : null;
}
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component2) {
  Component2 = Component2.prototype;
  return !(!Component2 || !Component2.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  workInProgress === null ? (workInProgress = createFiberImplClass(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null);
  workInProgress.flags = current.flags & 65011712;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies = pendingProps === null ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 65011714;
  var current = workInProgress.alternate;
  current === null ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = renderLanes === null ? null : {
    lanes: renderLanes.lanes,
    firstContext: renderLanes.firstContext
  });
  return workInProgress;
}
function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
  var fiberTag = 0;
  owner = type;
  if (typeof type === "function")
    shouldConstruct(type) && (fiberTag = 1);
  else if (typeof type === "string")
    fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : type === "html" || type === "head" || type === "body" ? 27 : 5;
  else
    a:
      switch (type) {
        case REACT_ACTIVITY_TYPE:
          return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
        case REACT_FRAGMENT_TYPE2:
          return createFiberFromFragment(pendingProps.children, mode, lanes, key);
        case REACT_STRICT_MODE_TYPE2:
          fiberTag = 8;
          mode |= 24;
          break;
        case REACT_PROFILER_TYPE2:
          return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE2, type.lanes = lanes, type;
        case REACT_SUSPENSE_TYPE2:
          return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE2, type.lanes = lanes, type;
        case REACT_SUSPENSE_LIST_TYPE:
          return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
        default:
          if (typeof type === "object" && type !== null)
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE2:
                fiberTag = 10;
                break a;
              case REACT_CONSUMER_TYPE2:
                fiberTag = 9;
                break a;
              case REACT_FORWARD_REF_TYPE2:
                fiberTag = 11;
                break a;
              case REACT_MEMO_TYPE2:
                fiberTag = 14;
                break a;
              case REACT_LAZY_TYPE2:
                fiberTag = 16;
                owner = null;
                break a;
            }
          fiberTag = 29;
          pendingProps = Error(formatProdErrorMessage2(130, type === null ? "null" : typeof type, ""));
          owner = null;
      }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(4, portal.children !== null ? portal.children : [], portal.key, mode);
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index2) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index2 += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - baseLength % 5;
    length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else
    treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
}
function pushMaterializedTreeId(workInProgress) {
  workInProgress.return !== null && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (;workInProgress === treeForkProvider; )
    treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
  for (;workInProgress === treeContextProvider; )
    treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
}
function throwOnHydrationMismatch(fiber) {
  var error = Error(formatProdErrorMessage2(418, ""));
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var { stateNode: instance, type, memoizedProps: props } = fiber;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0;type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(instance, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, true);
      track(instance);
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
  }
  type = props.children;
  typeof type !== "string" && typeof type !== "number" && typeof type !== "bigint" || instance.textContent === "" + type || props.suppressHydrationWarning === true || checkForUnmatchedText(instance.textContent, type) ? (props.popover != null && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), props.onScroll != null && listenToNonDelegatedEvent("scroll", instance), props.onScrollEnd != null && listenToNonDelegatedEvent("scrollend", instance), props.onClick != null && (instance.onclick = noop$12), instance = true) : instance = false;
  instance || throwOnHydrationMismatch(fiber);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return;hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 5:
      case 13:
        rootOrSingletonContext = false;
        return;
      case 27:
      case 3:
        rootOrSingletonContext = true;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber)
    return false;
  if (!isHydrating)
    return popToNextHostParent(fiber), isHydrating = true, false;
  var tag = fiber.tag, JSCompiler_temp;
  if (JSCompiler_temp = tag !== 3 && tag !== 27) {
    if (JSCompiler_temp = tag === 5)
      JSCompiler_temp = fiber.type, JSCompiler_temp = !(JSCompiler_temp !== "form" && JSCompiler_temp !== "button") || shouldSetTextContent(fiber.type, fiber.memoizedProps);
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (tag === 13) {
    fiber = fiber.memoizedState;
    fiber = fiber !== null ? fiber.dehydrated : null;
    if (!fiber)
      throw Error(formatProdErrorMessage2(317));
    a: {
      fiber = fiber.nextSibling;
      for (tag = 0;fiber; ) {
        if (fiber.nodeType === 8)
          if (JSCompiler_temp = fiber.data, JSCompiler_temp === "/$") {
            if (tag === 0) {
              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
              break a;
            }
            tag--;
          } else
            JSCompiler_temp !== "$" && JSCompiler_temp !== "$!" && JSCompiler_temp !== "$?" || tag++;
        fiber = fiber.nextSibling;
      }
      nextHydratableInstance = null;
    }
  } else
    tag === 27 ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
  return true;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = false;
}
function upgradeHydrationErrorsToRecoverable() {
  var queuedErrors = hydrationErrors;
  queuedErrors !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
  return queuedErrors;
}
function queueHydrationError(error) {
  hydrationErrors === null ? hydrationErrors = [error] : hydrationErrors.push(error);
}
function pushProvider(providerFiber, context, nextValue) {
  push2(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop2(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (;parent !== null; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, alternate !== null && (alternate.childLanes |= renderLanes)) : alternate !== null && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot)
      break;
    parent = parent.return;
  }
}
function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
  var fiber = workInProgress.child;
  fiber !== null && (fiber.return = workInProgress);
  for (;fiber !== null; ) {
    var list = fiber.dependencies;
    if (list !== null) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a:
        for (;list !== null; ) {
          var dependency = list;
          list = fiber;
          for (var i = 0;i < contexts.length; i++)
            if (dependency.context === contexts[i]) {
              list.lanes |= renderLanes;
              dependency = list.alternate;
              dependency !== null && (dependency.lanes |= renderLanes);
              scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
              forcePropagateEntireTree || (nextFiber = null);
              break a;
            }
          list = dependency.next;
        }
    } else if (fiber.tag === 18) {
      nextFiber = fiber.return;
      if (nextFiber === null)
        throw Error(formatProdErrorMessage2(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      list !== null && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else
      nextFiber = fiber.child;
    if (nextFiber !== null)
      nextFiber.return = fiber;
    else
      for (nextFiber = fiber;nextFiber !== null; ) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (fiber !== null) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
  current = null;
  for (var parent = workInProgress, isInsidePropagationBailout = false;parent !== null; ) {
    if (!isInsidePropagationBailout) {
      if ((parent.flags & 524288) !== 0)
        isInsidePropagationBailout = true;
      else if ((parent.flags & 262144) !== 0)
        break;
    }
    if (parent.tag === 10) {
      var currentParent = parent.alternate;
      if (currentParent === null)
        throw Error(formatProdErrorMessage2(387));
      currentParent = currentParent.memoizedProps;
      if (currentParent !== null) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) || (current !== null ? current.push(context) : current = [context]);
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (currentParent === null)
        throw Error(formatProdErrorMessage2(387));
      currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (current !== null ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
    }
    parent = parent.return;
  }
  current !== null && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (currentDependencies = currentDependencies.firstContext;currentDependencies !== null; ) {
    if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue))
      return true;
    currentDependencies = currentDependencies.next;
  }
  return false;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber$1 = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  workInProgress !== null && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber$1, context);
}
function readContextDuringReconciliation(consumer, context) {
  currentlyRenderingFiber$1 === null && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context, memoizedValue: value, next: null };
  if (lastContextDependency === null) {
    if (consumer === null)
      throw Error(formatProdErrorMessage2(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else
    lastContextDependency = lastContextDependency.next = context;
  return value;
}
function createCache() {
  return {
    controller: new AbortControllerLocal,
    data: new Map,
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  cache.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
    cache.controller.abort();
  });
}
function entangleAsyncAction(transition, thenable) {
  if (currentEntangledListeners === null) {
    var entangledListeners = currentEntangledListeners = [];
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: undefined,
      then: function(resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (--currentEntangledPendingCount === 0 && currentEntangledListeners !== null) {
    currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0;i < listeners.length; i++)
      (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [], thenableWithOverride = {
    status: "pending",
    value: null,
    reason: null,
    then: function(resolve) {
      listeners.push(resolve);
    }
  };
  thenable.then(function() {
    thenableWithOverride.status = "fulfilled";
    thenableWithOverride.value = result;
    for (var i = 0;i < listeners.length; i++)
      (0, listeners[i])(result);
  }, function(error) {
    thenableWithOverride.status = "rejected";
    thenableWithOverride.reason = error;
    for (error = 0;error < listeners.length; error++)
      (0, listeners[error])(undefined);
  });
  return thenableWithOverride;
}
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return cacheResumedFromPreviousRender !== null ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  prevCachePool === null ? push2(resumedCache, resumedCache.current) : push2(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return cacheFromPool === null ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return thenable === "fulfilled" || thenable === "rejected";
}
function noop$3() {
}
function trackUsedThenable(thenableState, thenable, index2) {
  index2 = thenableState[index2];
  index2 === undefined ? thenableState.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
    default:
      if (typeof thenable.status === "string")
        thenable.then(noop$3, noop$3);
      else {
        thenableState = workInProgressRoot;
        if (thenableState !== null && 100 < thenableState.shellSuspendCounter)
          throw Error(formatProdErrorMessage2(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(function(fulfilledValue) {
          if (thenable.status === "pending") {
            var fulfilledThenable = thenable;
            fulfilledThenable.status = "fulfilled";
            fulfilledThenable.value = fulfilledValue;
          }
        }, function(error) {
          if (thenable.status === "pending") {
            var rejectedThenable = thenable;
            rejectedThenable.status = "rejected";
            rejectedThenable.reason = error;
          }
        });
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
function getSuspendedThenable() {
  if (suspendedThenable === null)
    throw Error(formatProdErrorMessage2(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function checkIfUseWrappedInAsyncCatch(rejectedReason) {
  if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
    throw Error(formatProdErrorMessage2(483));
}
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current && (workInProgress.updateQueue = {
    baseState: current.baseState,
    firstBaseUpdate: current.firstBaseUpdate,
    lastBaseUpdate: current.lastBaseUpdate,
    shared: current.shared,
    callbacks: null
  });
}
function createUpdate(lane) {
  return { lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null)
    return null;
  updateQueue = updateQueue.shared;
  if ((executionContext & 2) !== 0) {
    var pending = updateQueue.pending;
    pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root2, fiber, lane) {
  fiber = fiber.updateQueue;
  if (fiber !== null && (fiber = fiber.shared, (lane & 4194048) !== 0)) {
    var queueLanes = fiber.lanes;
    queueLanes &= root2.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root2, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var { updateQueue: queue, alternate: current } = workInProgress;
  if (current !== null && (current = current.updateQueue, queue === current)) {
    var newFirst = null, newLast = null;
    queue = queue.firstBaseUpdate;
    if (queue !== null) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        newLast === null ? newFirst = newLast = clone : newLast = newLast.next = clone;
        queue = queue.next;
      } while (queue !== null);
      newLast === null ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
    } else
      newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  workInProgress === null ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
  queue.lastBaseUpdate = capturedUpdate;
}
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (entangledActionThenable !== null)
      throw entangledActionThenable;
  }
}
function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes) {
  didReadFromEntangledAsyncAction = false;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = false;
  var { firstBaseUpdate, lastBaseUpdate } = queue, pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    current !== null && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (pendingQueue === null ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
  }
  if (firstBaseUpdate !== null) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
        updateLane !== 0 && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
        current !== null && (current = current.next = {
          lane: 0,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: null,
          next: null
        });
        a: {
          var workInProgress = workInProgress$jscomp$0, update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if (typeof workInProgress === "function") {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = workInProgress.flags & -65537 | 128;
            case 0:
              workInProgress = update.payload;
              updateLane = typeof workInProgress === "function" ? workInProgress.call(instance, newState, updateLane) : workInProgress;
              if (updateLane === null || updateLane === undefined)
                break a;
              newState = assign2({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = true;
          }
        }
        updateLane = pendingQueue.callback;
        updateLane !== null && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, isHiddenUpdate === null ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
      } else
        isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }, current === null ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
      pendingQueue = pendingQueue.next;
      if (pendingQueue === null)
        if (pendingQueue = queue.shared.pending, pendingQueue === null)
          break;
        else
          isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
    } while (1);
    current === null && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    firstBaseUpdate === null && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if (typeof callback !== "function")
    throw Error(formatProdErrorMessage2(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (callbacks !== null)
    for (updateQueue.callbacks = null, updateQueue = 0;updateQueue < callbacks.length; updateQueue++)
      callCallback(callbacks[updateQueue], context);
}
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push2(prevEntangledRenderLanesCursor, fiber);
  push2(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push2(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push2(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop2(currentTreeHiddenStackCursor);
  pop2(prevEntangledRenderLanesCursor);
}
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage2(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null)
    return false;
  for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i]))
      return false;
  return true;
}
function renderWithHooks(current, workInProgress, Component2, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals3.H = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = false;
  nextRenderLanes = Component2(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = false;
  didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress, Component2, props, secondArg));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals3.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdate = false;
  thenableIndexCounter$1 = 0;
  thenableState$1 = null;
  if (didRenderTooFewHooks)
    throw Error(formatProdErrorMessage2(300));
  current === null || didReceiveUpdate || (current = current.dependencies, current !== null && checkIfContextChanged(current) && (didReceiveUpdate = true));
}
function renderWithHooksAgain(workInProgress, Component2, props, secondArg) {
  currentlyRenderingFiber = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
    thenableIndexCounter$1 = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    if (25 <= numberOfReRenders)
      throw Error(formatProdErrorMessage2(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (workInProgress.updateQueue != null) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      children.memoCache != null && (children.memoCache.index = 0);
    }
    ReactSharedInternals3.H = HooksDispatcherOnRerender;
    children = Component2(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals3.H, maybeThenable = dispatcher.useState()[0];
  maybeThenable = typeof maybeThenable.then === "function" ? useThenable(maybeThenable) : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (currentHook !== null ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = localIdCounter !== 0;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (workInProgress = workInProgress.memoizedState;workInProgress !== null; ) {
      var queue = workInProgress.queue;
      queue !== null && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = false;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdateDuringThisPass = false;
  thenableIndexCounter$1 = localIdCounter = 0;
  thenableState$1 = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (currentHook === null) {
    var nextCurrentHook = currentlyRenderingFiber.alternate;
    nextCurrentHook = nextCurrentHook !== null ? nextCurrentHook.memoizedState : null;
  } else
    nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook = workInProgressHook === null ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
  if (nextWorkInProgressHook !== null)
    workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
  else {
    if (nextCurrentHook === null) {
      if (currentlyRenderingFiber.alternate === null)
        throw Error(formatProdErrorMessage2(467));
      throw Error(formatProdErrorMessage2(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
  }
  return workInProgressHook;
}
function createFunctionComponentUpdateQueue() {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
}
function useThenable(thenable) {
  var index2 = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  thenableState$1 === null && (thenableState$1 = []);
  thenable = trackUsedThenable(thenableState$1, thenable, index2);
  index2 = currentlyRenderingFiber;
  (workInProgressHook === null ? index2.memoizedState : workInProgressHook.next) === null && (index2 = index2.alternate, ReactSharedInternals3.H = index2 === null || index2.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
  return thenable;
}
function use(usable) {
  if (usable !== null && typeof usable === "object") {
    if (typeof usable.then === "function")
      return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE2)
      return readContext(usable);
  }
  throw Error(formatProdErrorMessage2(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
  updateQueue !== null && (memoCache = updateQueue.memoCache);
  if (memoCache == null) {
    var current = currentlyRenderingFiber.alternate;
    current !== null && (current = current.updateQueue, current !== null && (current = current.memoCache, current != null && (memoCache = {
      data: current.data.map(function(array) {
        return array.slice();
      }),
      index: 0
    })));
  }
  memoCache == null && (memoCache = { data: [], index: 0 });
  updateQueue === null && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (updateQueue === undefined)
    for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;current < size; current++)
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return typeof action === "function" ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (queue === null)
    throw Error(formatProdErrorMessage2(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
  if (pendingQueue !== null) {
    if (baseQueue !== null) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (baseQueue === null)
    hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
    do {
      var updateLane = update.lane & -536870913;
      if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
        var revertLane = update.revertLane;
        if (revertLane === 0)
          newBaseQueueLast !== null && (newBaseQueueLast = newBaseQueueLast.next = {
            lane: 0,
            revertLane: 0,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
          continue;
        } else
          updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
      } else
        revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
      update = update.next;
    } while (update !== null && update !== current);
    newBaseQueueLast === null ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
    if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, reducer !== null)))
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  baseQueue === null && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(), queue = hook.queue;
  if (queue === null)
    throw Error(formatProdErrorMessage2(311));
  queue.lastRenderedReducer = reducer;
  var { dispatch, pending: lastRenderPhaseUpdate } = queue, newState = hook.memoizedState;
  if (lastRenderPhaseUpdate !== null) {
    queue.pending = null;
    var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    do
      newState = reducer(newState, update.action), update = update.next;
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
    hook.memoizedState = newState;
    hook.baseQueue === null && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (getServerSnapshot === undefined)
      throw Error(formatProdErrorMessage2(407));
    getServerSnapshot = getServerSnapshot();
  } else
    getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
  snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
  hook = hook.queue;
  var create = subscribeToStore.bind(null, fiber, hook, subscribe);
  updateEffectImpl(2048, 8, create, [subscribe]);
  if (hook.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & 1) {
    fiber.flags |= 2048;
    pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
    if (workInProgressRoot === null)
      throw Error(formatProdErrorMessage2(349));
    isHydrating$jscomp$0 || (renderLanes & 124) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber.updateQueue;
  getSnapshot === null ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, renderedSnapshot === null ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function() {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return true;
  }
}
function forceStoreRerender(fiber) {
  var root2 = enqueueConcurrentRenderForLane(fiber, 2);
  root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if (typeof initialState === "function") {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(hook, currentHook, typeof reducer === "function" ? reducer : basicStateReducer);
}
function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
  if (isRenderPhaseUpdate(fiber))
    throw Error(formatProdErrorMessage2(485));
  fiber = actionQueue.action;
  if (fiber !== null) {
    var actionNode = {
      payload,
      action: fiber,
      next: null,
      isTransition: true,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function(listener) {
        actionNode.listeners.push(listener);
      }
    };
    ReactSharedInternals3.T !== null ? setPendingState(true) : actionNode.isTransition = false;
    setState(actionNode);
    setPendingState = actionQueue.pending;
    setPendingState === null ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
  }
}
function runActionStateAction(actionQueue, node) {
  var { action, payload } = node, prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals3.T, currentTransition = {};
    ReactSharedInternals3.T = currentTransition;
    try {
      var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals3.S;
      onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      ReactSharedInternals3.T = prevTransition;
    }
  } else
    try {
      prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$38) {
      onActionError(actionQueue, node, error$38);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function" ? returnValue.then(function(nextState) {
    onActionSuccess(actionQueue, node, nextState);
  }, function(error) {
    return onActionError(actionQueue, node, error);
  }) : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  actionNode !== null && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (last !== null) {
    last = last.next;
    do
      actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0;i < actionNode.length; i++)
    (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (ssrFormState !== null) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (var inRootOrSingleton = rootOrSingletonContext;JSCompiler_inline_result$jscomp$0.nodeType !== 8; ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
                if (JSCompiler_inline_result$jscomp$0 === null) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 = inRootOrSingleton === "F!" || inRootOrSingleton === "F" ? JSCompiler_inline_result$jscomp$0 : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
              JSCompiler_inline_result = JSCompiler_inline_result$jscomp$0.data === "F!";
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = false;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result);
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(false);
  inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, JSCompiler_inline_result.queue);
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result$jscomp$0, inRootOrSingleton, ssrFormState);
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, false];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
  stateHook = updateReducer(basicStateReducer)[0];
  if (typeof currentStateHook === "object" && currentStateHook !== null && typeof currentStateHook.then === "function")
    try {
      var state = useThenable(currentStateHook);
    } catch (x) {
      if (x === SuspenseException)
        throw SuspenseActionException;
      throw x;
    }
  else
    state = currentStateHook;
  currentStateHook = updateWorkInProgressHook();
  var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
  action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(9, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null));
  return [state, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
  if (currentStateHook !== null)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, false];
}
function pushSimpleEffect(tag, inst, create, createDeps) {
  tag = { tag, create, deps: createDeps, inst, next: null };
  inst = currentlyRenderingFiber.updateQueue;
  inst === null && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
  create = inst.lastEffect;
  create === null ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
  return tag;
}
function createEffectInstance() {
  return { destroy: undefined, resource: undefined };
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
  var hook = mountWorkInProgressHook();
  createDeps = createDeps === undefined ? null : createDeps;
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(1 | hookFlags, createEffectInstance(), create, createDeps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = deps === undefined ? null : deps;
  var inst = hook.memoizedState.inst;
  currentHook !== null && deps !== null && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create, deps));
}
function mountEffect(create, createDeps) {
  mountEffectImpl(8390656, 8, create, createDeps);
}
function updateEffect(create, createDeps) {
  updateEffectImpl(2048, 8, create, createDeps);
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if (typeof ref === "function") {
    create = create();
    var refCleanup = ref(create);
    return function() {
      typeof refCleanup === "function" ? refCleanup() : ref(null);
    };
  }
  if (ref !== null && ref !== undefined)
    return create = create(), ref.current = create, function() {
      ref.current = null;
    };
}
function updateImperativeHandle(ref, create, deps) {
  deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {
}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;
  if (deps !== null && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;
  if (deps !== null && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(true);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (initialValue === undefined || (renderLanes & 1073741824) !== 0)
    return hook.memoizedState = value;
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue))
    return value;
  if (currentTreeHiddenStackCursor.current !== null)
    return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
  if ((renderLanes & 42) === 0)
    return didReceiveUpdate = true, hook.memoizedState = value;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p = previousPriority !== 0 && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals3.T, currentTransition = {};
  ReactSharedInternals3.T = currentTransition;
  dispatchOptimisticSetState(fiber, false, queue, pendingState);
  try {
    var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals3.S;
    onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
    if (returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function") {
      var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
      dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
    } else
      dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
  } catch (error) {
    dispatchSetStateInternal(fiber, queue, { then: function() {
    }, status: "rejected", reason: error }, requestUpdateLane());
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals3.T = prevTransition;
  }
}
function noop$2() {
}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (formFiber.tag !== 5)
    throw Error(formatProdErrorMessage2(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(formFiber, queue, pendingState, sharedNotPendingObject, action === null ? noop$2 : function() {
    requestFormReset$1(formFiber);
    return action(formData);
  });
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (existingStateHook !== null)
    return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  formFiber !== null && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return;provider !== null; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$41 = enqueueUpdate(provider, fiber, lane);
        root$41 !== null && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane,
    revertLane: 0,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), action !== null && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane,
    revertLane: 0,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber))
    enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (fiber.lanes === 0 && (alternate === null || alternate.lanes === 0) && (alternate = queue.lastRenderedReducer, alternate !== null))
      try {
        var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
        update.hasEagerState = true;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return enqueueUpdate$1(fiber, queue, update, 0), workInProgressRoot === null && finishQueueingConcurrentUpdates(), false;
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (action !== null)
      return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
  }
  return false;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender)
      throw Error(formatProdErrorMessage2(479));
  } else
    throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), throwIfDuringRender !== null && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  var pending = queue.pending;
  pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
  queue.pending = update;
}
function entangleTransitionUpdate(root2, queue, lane) {
  if ((lane & 4194048) !== 0) {
    var queueLanes = queue.lanes;
    queueLanes &= root2.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root2, lane);
  }
}
function unwrapThenable(thenable) {
  var index2 = thenableIndexCounter;
  thenableIndexCounter += 1;
  thenableState === null && (thenableState = []);
  return trackUsedThenable(thenableState, thenable, index2);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = element !== undefined ? element : null;
}
function throwOnInvalidObjectType(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage2(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(formatProdErrorMessage2(31, returnFiber === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
}
function resolveLazy(lazyType) {
  var init = lazyType._init;
  return init(lazyType._payload);
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects)
      return null;
    for (;currentFirstChild !== null; )
      deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map;currentFirstChild !== null; )
      currentFirstChild.key !== null ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return newFiber.flags |= 1048576, lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (newIndex !== null)
      return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
    newFiber.flags |= 67108866;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= 67108866);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (current === null || current.tag !== 6)
      return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE2)
      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
    if (current !== null && (current.elementType === elementType || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE2 && resolveLazy(elementType) === current.type))
      return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
    current = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (current === null || current.tag !== 4 || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
      return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (current === null || current.tag !== 7)
      return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
      return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE2:
          return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
        case REACT_PORTAL_TYPE3:
          return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
        case REACT_LAZY_TYPE2:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return createChild(returnFiber, newChild, lanes);
      }
      if (isArrayImpl2(newChild) || getIteratorFn2(newChild))
        return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
      if (typeof newChild.then === "function")
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE2)
        return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = oldFiber !== null ? oldFiber.key : null;
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
      return key !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE2:
          return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
        case REACT_PORTAL_TYPE3:
          return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
        case REACT_LAZY_TYPE2:
          return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
      }
      if (isArrayImpl2(newChild) || getIteratorFn2(newChild))
        return key !== null ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if (typeof newChild.then === "function")
        return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE2)
        return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
      return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE2:
          return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
        case REACT_PORTAL_TYPE3:
          return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
        case REACT_LAZY_TYPE2:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
      }
      if (isArrayImpl2(newChild) || getIteratorFn2(newChild))
        return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
      if (typeof newChild.then === "function")
        return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE2)
        return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
      if (newFiber === null) {
        oldFiber === null && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
    if (oldFiber === null) {
      for (;newIdx < newChildren.length; newIdx++)
        oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), oldFiber !== null && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (oldFiber = mapRemainingChildren(oldFiber);newIdx < newChildren.length; newIdx++)
      nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), nextOldFiber !== null && (shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
    shouldTrackSideEffects && oldFiber.forEach(function(child) {
      return deleteChild(returnFiber, child);
    });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
    if (newChildren == null)
      throw Error(formatProdErrorMessage2(151));
    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next();oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (newFiber === null) {
        oldFiber === null && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
    if (oldFiber === null) {
      for (;!step.done; newIdx++, step = newChildren.next())
        step = createChild(returnFiber, step.value, lanes), step !== null && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (oldFiber = mapRemainingChildren(oldFiber);!step.done; newIdx++, step = newChildren.next())
      step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), step !== null && (shouldTrackSideEffects && step.alternate !== null && oldFiber.delete(step.key === null ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
    shouldTrackSideEffects && oldFiber.forEach(function(child) {
      return deleteChild(returnFiber, child);
    });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
    typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE2 && newChild.key === null && (newChild = newChild.props.children);
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE2:
          a: {
            for (var key = newChild.key;currentFirstChild !== null; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE2) {
                  if (currentFirstChild.tag === 7) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    lanes = useFiber(currentFirstChild, newChild.props.children);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (currentFirstChild.elementType === key || typeof key === "object" && key !== null && key.$$typeof === REACT_LAZY_TYPE2 && resolveLazy(key) === currentFirstChild.type) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else
                deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE2 ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE3:
          a: {
            for (key = newChild.key;currentFirstChild !== null; ) {
              if (currentFirstChild.key === key)
                if (currentFirstChild.tag === 4 && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else
                deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE2:
          return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
      }
      if (isArrayImpl2(newChild))
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
      if (getIteratorFn2(newChild)) {
        key = getIteratorFn2(newChild);
        if (typeof key !== "function")
          throw Error(formatProdErrorMessage2(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
      }
      if (typeof newChild.then === "function")
        return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE2)
        return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint" ? (newChild = "" + newChild, currentFirstChild !== null && currentFirstChild.tag === 6 ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function(returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter = 0;
      var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
      thenableState = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException || x === SuspenseActionException)
        throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push2(suspenseStackCursor, suspenseStackCursor.current & 1);
  push2(suspenseHandlerStackCursor, handler);
  shellBoundary === null && (current === null || currentTreeHiddenStackCursor.current !== null ? shellBoundary = handler : current.memoizedState !== null && (shellBoundary = handler));
}
function pushOffscreenSuspenseHandler(fiber) {
  if (fiber.tag === 22) {
    if (push2(suspenseStackCursor, suspenseStackCursor.current), push2(suspenseHandlerStackCursor, fiber), shellBoundary === null) {
      var current = fiber.alternate;
      current !== null && current.memoizedState !== null && (shellBoundary = fiber);
    }
  } else
    reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push2(suspenseStackCursor, suspenseStackCursor.current);
  push2(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop2(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop2(suspenseStackCursor);
}
function findFirstSuspended(row) {
  for (var node = row;node !== null; ) {
    if (node.tag === 13) {
      var state = node.memoizedState;
      if (state !== null && (state = state.dehydrated, state === null || state.data === "$?" || isSuspenseInstanceFallback(state)))
        return node;
    } else if (node.tag === 19 && node.memoizedProps.revealOrder !== undefined) {
      if ((node.flags & 128) !== 0)
        return node;
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row)
      break;
    for (;node.sibling === null; ) {
      if (node.return === null || node.return === row)
        return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps = getDerivedStateFromProps === null || getDerivedStateFromProps === undefined ? ctor : assign2({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  workInProgress.lanes === 0 && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  workInProgress = workInProgress.stateNode;
  return typeof workInProgress.shouldComponentUpdate === "function" ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
}
function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  workInProgress = instance.state;
  typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps(newProps, nextContext);
  typeof instance.UNSAFE_componentWillReceiveProps === "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component2, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      propName !== "ref" && (newProps[propName] = baseProps[propName]);
  }
  if (Component2 = Component2.defaultProps) {
    newProps === baseProps && (newProps = assign2({}, newProps));
    for (var propName$73 in Component2)
      newProps[propName$73] === undefined && (newProps[propName$73] = Component2[propName$73]);
  }
  return newProps;
}
function defaultOnUncaughtError(error) {
  reportGlobalError2(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError2(error);
}
function logUncaughtError(root2, errorInfo) {
  try {
    var onUncaughtError = root2.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$74) {
    setTimeout(function() {
      throw e$74;
    });
  }
}
function logCaughtError(root2, boundary, errorInfo) {
  try {
    var onCaughtError = root2.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: boundary.tag === 1 ? boundary.stateNode : null
    });
  } catch (e$75) {
    setTimeout(function() {
      throw e$75;
    });
  }
}
function createRootErrorUpdate(root2, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function() {
    logUncaughtError(root2, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if (typeof getDerivedStateFromError === "function") {
    var error = errorInfo.value;
    update.payload = function() {
      return getDerivedStateFromError(error);
    };
    update.callback = function() {
      logCaughtError(root2, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  inst !== null && typeof inst.componentDidCatch === "function" && (update.callback = function() {
    logCaughtError(root2, fiber, errorInfo);
    typeof getDerivedStateFromError !== "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
    var stack = errorInfo.stack;
    this.componentDidCatch(errorInfo.value, {
      componentStack: stack !== null ? stack : ""
    });
  });
}
function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
  sourceFiber.flags |= 32768;
  if (value !== null && typeof value === "object" && typeof value.then === "function") {
    returnFiber = sourceFiber.alternate;
    returnFiber !== null && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
    sourceFiber = suspenseHandlerStackCursor.current;
    if (sourceFiber !== null) {
      switch (sourceFiber.tag) {
        case 13:
          return shellBoundary === null ? renderDidSuspendDelayIfPossible() : sourceFiber.alternate === null && workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
        case 22:
          return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? (returnFiber = {
            transitions: null,
            markerInstances: null,
            retryQueue: new Set([value])
          }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, sourceFiber === null ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
      }
      throw Error(formatProdErrorMessage2(435, sourceFiber.tag));
    }
    attachPingListener(root2, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return false;
  }
  if (isHydrating)
    return returnFiber = suspenseHandlerStackCursor.current, returnFiber !== null ? ((returnFiber.flags & 65536) === 0 && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage2(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage2(423), {
      cause: value
    }), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root2.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2)), false;
  var wrapperError = Error(formatProdErrorMessage2(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
  workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2);
  if (returnFiber === null)
    return true;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
      case 1:
        if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, (sourceFiber.flags & 128) === 0 && (typeof returnFiber.getDerivedStateFromError === "function" || wrapperError !== null && typeof wrapperError.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
          return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root2, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
    }
    sourceFiber = sourceFiber.return;
  } while (sourceFiber !== null);
  return false;
}
function reconcileChildren(current, workInProgress, nextChildren, renderLanes2) {
  workInProgress.child = current === null ? mountChildFibers(workInProgress, null, nextChildren, renderLanes2) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes2);
}
function updateForwardRef(current, workInProgress, Component2, nextProps, renderLanes2) {
  Component2 = Component2.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      key !== "ref" && (propsWithoutRef[key] = nextProps[key]);
  } else
    propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(current, workInProgress, Component2, propsWithoutRef, ref, renderLanes2);
  key = checkDidRenderIdHook();
  if (current !== null && !didReceiveUpdate)
    return bailoutHooks(current, workInProgress, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes2);
  return workInProgress.child;
}
function updateMemoComponent(current, workInProgress, Component2, nextProps, renderLanes2) {
  if (current === null) {
    var type = Component2.type;
    if (typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined && Component2.compare === null)
      return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current, workInProgress, type, nextProps, renderLanes2);
    current = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes2);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return workInProgress.child = current;
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
    var prevProps = type.memoizedProps;
    Component2 = Component2.compare;
    Component2 = Component2 !== null ? Component2 : shallowEqual;
    if (Component2(prevProps, nextProps) && current.ref === workInProgress.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return workInProgress.child = current;
}
function updateSimpleMemoComponent(current, workInProgress, Component2, nextProps, renderLanes2) {
  if (current !== null) {
    var prevProps = current.memoizedProps;
    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref)
      if (didReceiveUpdate = false, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
        (current.flags & 131072) !== 0 && (didReceiveUpdate = true);
      else
        return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
  }
  return updateFunctionComponent(current, workInProgress, Component2, nextProps, renderLanes2);
}
function updateOffscreenComponent(current, workInProgress, renderLanes2) {
  var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, prevState = current !== null ? current.memoizedState : null;
  if (nextProps.mode === "hidden") {
    if ((workInProgress.flags & 128) !== 0) {
      nextProps = prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2;
      if (current !== null) {
        nextChildren = workInProgress.child = current.child;
        for (prevState = 0;nextChildren !== null; )
          prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
        workInProgress.childLanes = prevState & ~nextProps;
      } else
        workInProgress.childLanes = 0, workInProgress.child = null;
      return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes2);
    }
    if ((renderLanes2 & 536870912) !== 0)
      workInProgress.memoizedState = { baseLanes: 0, cachePool: null }, current !== null && pushTransition(workInProgress, prevState !== null ? prevState.cachePool : null), prevState !== null ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress);
    else
      return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2, renderLanes2);
  } else
    prevState !== null ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (current !== null && pushTransition(workInProgress, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes2);
  return workInProgress.child;
}
function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes2) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result = JSCompiler_inline_result === null ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  current !== null && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  current !== null && propagateParentContextChanges(current, workInProgress, renderLanes2, true);
  return null;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (ref === null)
    current !== null && current.ref !== null && (workInProgress.flags |= 4194816);
  else {
    if (typeof ref !== "function" && typeof ref !== "object")
      throw Error(formatProdErrorMessage2(284));
    if (current === null || current.ref !== ref)
      workInProgress.flags |= 4194816;
  }
}
function updateFunctionComponent(current, workInProgress, Component2, nextProps, renderLanes2) {
  prepareToReadContext(workInProgress);
  Component2 = renderWithHooks(current, workInProgress, Component2, nextProps, undefined, renderLanes2);
  nextProps = checkDidRenderIdHook();
  if (current !== null && !didReceiveUpdate)
    return bailoutHooks(current, workInProgress, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component2, renderLanes2);
  return workInProgress.child;
}
function replayFunctionComponent(current, workInProgress, nextProps, Component2, secondArg, renderLanes2) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(workInProgress, Component2, nextProps, secondArg);
  finishRenderingHooks(current);
  Component2 = checkDidRenderIdHook();
  if (current !== null && !didReceiveUpdate)
    return bailoutHooks(current, workInProgress, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
  isHydrating && Component2 && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes2);
  return workInProgress.child;
}
function updateClassComponent(current, workInProgress, Component2, nextProps, renderLanes2) {
  prepareToReadContext(workInProgress);
  if (workInProgress.stateNode === null) {
    var context = emptyContextObject, contextType = Component2.contextType;
    typeof contextType === "object" && contextType !== null && (context = readContext(contextType));
    context = new Component2(nextProps, context);
    workInProgress.memoizedState = context.state !== null && context.state !== undefined ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component2.contextType;
    context.context = typeof contextType === "object" && contextType !== null ? readContext(contextType) : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component2.getDerivedStateFromProps;
    typeof contextType === "function" && (applyDerivedStateFromProps(workInProgress, Component2, contextType, nextProps), context.state = workInProgress.memoizedState);
    typeof Component2.getDerivedStateFromProps === "function" || typeof context.getSnapshotBeforeUpdate === "function" || typeof context.UNSAFE_componentWillMount !== "function" && typeof context.componentWillMount !== "function" || (contextType = context.state, typeof context.componentWillMount === "function" && context.componentWillMount(), typeof context.UNSAFE_componentWillMount === "function" && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress.memoizedState);
    typeof context.componentDidMount === "function" && (workInProgress.flags |= 4194308);
    nextProps = true;
  } else if (current === null) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps, oldProps = resolveClassComponentProps(Component2, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context, contextType$jscomp$0 = Component2.contextType;
    contextType = emptyContextObject;
    typeof contextType$jscomp$0 === "object" && contextType$jscomp$0 !== null && (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component2.getDerivedStateFromProps;
    contextType$jscomp$0 = typeof getDerivedStateFromProps === "function" || typeof context.getSnapshotBeforeUpdate === "function";
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 || typeof context.UNSAFE_componentWillReceiveProps !== "function" && typeof context.componentWillReceiveProps !== "function" || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, context, nextProps, contextType);
    hasForceUpdate = false;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes2);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (typeof getDerivedStateFromProps === "function" && (applyDerivedStateFromProps(workInProgress, Component2, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component2, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || typeof context.UNSAFE_componentWillMount !== "function" && typeof context.componentWillMount !== "function" || (typeof context.componentWillMount === "function" && context.componentWillMount(), typeof context.UNSAFE_componentWillMount === "function" && context.UNSAFE_componentWillMount()), typeof context.componentDidMount === "function" && (workInProgress.flags |= 4194308)) : (typeof context.componentDidMount === "function" && (workInProgress.flags |= 4194308), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : (typeof context.componentDidMount === "function" && (workInProgress.flags |= 4194308), nextProps = false);
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component2, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component2.contextType;
    oldProps = emptyContextObject;
    typeof oldContext === "object" && oldContext !== null && (oldProps = readContext(oldContext));
    unresolvedOldProps = Component2.getDerivedStateFromProps;
    (oldContext = typeof unresolvedOldProps === "function" || typeof context.getSnapshotBeforeUpdate === "function") || typeof context.UNSAFE_componentWillReceiveProps !== "function" && typeof context.componentWillReceiveProps !== "function" || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(workInProgress, context, nextProps, oldProps);
    hasForceUpdate = false;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes2);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies) ? (typeof unresolvedOldProps === "function" && (applyDerivedStateFromProps(workInProgress, Component2, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component2, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies)) ? (oldContext || typeof context.UNSAFE_componentWillUpdate !== "function" && typeof context.componentWillUpdate !== "function" || (typeof context.componentWillUpdate === "function" && context.componentWillUpdate(nextProps, newState, oldProps), typeof context.UNSAFE_componentWillUpdate === "function" && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), typeof context.componentDidUpdate === "function" && (workInProgress.flags |= 4), typeof context.getSnapshotBeforeUpdate === "function" && (workInProgress.flags |= 1024)) : (typeof context.componentDidUpdate !== "function" || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), typeof context.getSnapshotBeforeUpdate !== "function" || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : (typeof context.componentDidUpdate !== "function" || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), typeof context.getSnapshotBeforeUpdate !== "function" || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), nextProps = false);
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = (workInProgress.flags & 128) !== 0;
  context || nextProps ? (context = workInProgress.stateNode, Component2 = nextProps && typeof Component2.getDerivedStateFromError !== "function" ? null : context.render(), workInProgress.flags |= 1, current !== null && nextProps ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes2), workInProgress.child = reconcileChildFibers(workInProgress, null, Component2, renderLanes2)) : reconcileChildren(current, workInProgress, Component2, renderLanes2), workInProgress.memoizedState = context.state, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
  return current;
}
function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes2) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes2);
  return workInProgress.child;
}
function mountSuspenseOffscreenState(renderLanes2) {
  return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
  current = current !== null ? current.childLanes & ~renderLanes2 : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes2) {
  var nextProps = workInProgress.pendingProps, showFallback = false, didSuspend = (workInProgress.flags & 128) !== 0, JSCompiler_temp;
  (JSCompiler_temp = didSuspend) || (JSCompiler_temp = current !== null && current.memoizedState === null ? false : (suspenseStackCursor.current & 2) !== 0);
  JSCompiler_temp && (showFallback = true, workInProgress.flags &= -129);
  JSCompiler_temp = (workInProgress.flags & 32) !== 0;
  workInProgress.flags &= -33;
  if (current === null) {
    if (isHydrating) {
      showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
      if (isHydrating) {
        var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
        if (JSCompiler_temp$jscomp$0 = nextInstance) {
          c: {
            JSCompiler_temp$jscomp$0 = nextInstance;
            for (nextInstance = rootOrSingletonContext;JSCompiler_temp$jscomp$0.nodeType !== 8; ) {
              if (!nextInstance) {
                nextInstance = null;
                break c;
              }
              JSCompiler_temp$jscomp$0 = getNextHydratable(JSCompiler_temp$jscomp$0.nextSibling);
              if (JSCompiler_temp$jscomp$0 === null) {
                nextInstance = null;
                break c;
              }
            }
            nextInstance = JSCompiler_temp$jscomp$0;
          }
          nextInstance !== null ? (workInProgress.memoizedState = {
            dehydrated: nextInstance,
            treeContext: treeContextProvider !== null ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, JSCompiler_temp$jscomp$0 = createFiberImplClass(18, null, null, 0), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress, workInProgress.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
        }
        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
      }
      nextInstance = workInProgress.memoizedState;
      if (nextInstance !== null && (nextInstance = nextInstance.dehydrated, nextInstance !== null))
        return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 32 : workInProgress.lanes = 536870912, null;
      popSuspenseHandler(workInProgress);
    }
    nextInstance = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({ mode: "hidden", children: nextInstance }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes2, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes2), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
  }
  JSCompiler_temp$jscomp$0 = current.memoizedState;
  if (JSCompiler_temp$jscomp$0 !== null && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, nextInstance !== null)) {
    if (didSuspend)
      workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes2)) : workInProgress.memoizedState !== null ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({ mode: "visible", children: nextProps.children }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes2, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes2), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes2), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);
    else if (pushPrimaryTreeSuspenseHandler(workInProgress), isSuspenseInstanceFallback(nextInstance)) {
      JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
      if (JSCompiler_temp)
        var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage2(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes2);
    } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes2, false), JSCompiler_temp = (renderLanes2 & current.childLanes) !== 0, didReceiveUpdate || JSCompiler_temp) {
      JSCompiler_temp = workInProgressRoot;
      if (JSCompiler_temp !== null && (nextProps = renderLanes2 & -renderLanes2, nextProps = (nextProps & 42) !== 0 ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) !== 0 ? 0 : nextProps, nextProps !== 0 && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
        throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
      nextInstance.data === "$?" || renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes2);
    } else
      nextInstance.data === "$?" ? (workInProgress.flags |= 192, workInProgress.child = current.child, workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(nextInstance.nextSibling), hydrationParentFiber = workInProgress, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, current !== null && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);
    return workInProgress;
  }
  if (showFallback)
    return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
      mode: "hidden",
      children: nextProps.children
    }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, digest !== null ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes2, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, nextInstance === null ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, JSCompiler_temp$jscomp$0 !== null ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
      baseLanes: nextInstance.baseLanes | renderLanes2,
      cachePool: JSCompiler_temp$jscomp$0
    }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes2), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes2 = current.child;
  current = renderLanes2.sibling;
  renderLanes2 = createWorkInProgress(renderLanes2, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes2.return = workInProgress;
  renderLanes2.sibling = null;
  current !== null && (JSCompiler_temp = workInProgress.deletions, JSCompiler_temp === null ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes2;
  workInProgress.memoizedState = null;
  return renderLanes2;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber({ mode: "visible", children: primaryChildren }, workInProgress.mode);
  primaryChildren.return = workInProgress;
  return workInProgress.child = primaryChildren;
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
  offscreenProps.lanes = 0;
  offscreenProps.stateNode = {
    _visibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null
  };
  return offscreenProps;
}
function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes2) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes2);
  current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
  fiber.lanes |= renderLanes2;
  var alternate = fiber.alternate;
  alternate !== null && (alternate.lanes |= renderLanes2);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
}
function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
  var renderState = workInProgress.memoizedState;
  renderState === null ? workInProgress.memoizedState = {
    isBackwards,
    rendering: null,
    renderingStartTime: 0,
    last: lastContentRow,
    tail,
    tailMode
  } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
}
function updateSuspenseListComponent(current, workInProgress, renderLanes2) {
  var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
  reconcileChildren(current, workInProgress, nextProps.children, renderLanes2);
  nextProps = suspenseStackCursor.current;
  if ((nextProps & 2) !== 0)
    nextProps = nextProps & 1 | 2, workInProgress.flags |= 128;
  else {
    if (current !== null && (current.flags & 128) !== 0)
      a:
        for (current = workInProgress.child;current !== null; ) {
          if (current.tag === 13)
            current.memoizedState !== null && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress);
          else if (current.tag === 19)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress);
          else if (current.child !== null) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress)
            break a;
          for (;current.sibling === null; ) {
            if (current.return === null || current.return === workInProgress)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
    nextProps &= 1;
  }
  push2(suspenseStackCursor, nextProps);
  switch (revealOrder) {
    case "forwards":
      renderLanes2 = workInProgress.child;
      for (revealOrder = null;renderLanes2 !== null; )
        current = renderLanes2.alternate, current !== null && findFirstSuspended(current) === null && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
      renderLanes2 = revealOrder;
      renderLanes2 === null ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
      initSuspenseListRenderState(workInProgress, false, revealOrder, renderLanes2, tailMode);
      break;
    case "backwards":
      renderLanes2 = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null;revealOrder !== null; ) {
        current = revealOrder.alternate;
        if (current !== null && findFirstSuspended(current) === null) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes2;
        renderLanes2 = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(workInProgress, true, renderLanes2, null, tailMode);
      break;
    case "together":
      initSuspenseListRenderState(workInProgress, false, null, null, undefined);
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2) {
  current !== null && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if ((renderLanes2 & workInProgress.childLanes) === 0)
    if (current !== null) {
      if (propagateParentContextChanges(current, workInProgress, renderLanes2, false), (renderLanes2 & workInProgress.childLanes) === 0)
        return null;
    } else
      return null;
  if (current !== null && workInProgress.child !== current.child)
    throw Error(formatProdErrorMessage2(153));
  if (workInProgress.child !== null) {
    current = workInProgress.child;
    renderLanes2 = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes2;
    for (renderLanes2.return = workInProgress;current.sibling !== null; )
      current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress;
    renderLanes2.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes2) {
  if ((current.lanes & renderLanes2) !== 0)
    return true;
  current = current.dependencies;
  return current !== null && checkIfContextChanged(current) ? true : false;
}
function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes2) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
      break;
    case 13:
      var state = workInProgress.memoizedState;
      if (state !== null) {
        if (state.dehydrated !== null)
          return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
        if ((renderLanes2 & workInProgress.child.childLanes) !== 0)
          return updateSuspenseComponent(current, workInProgress, renderLanes2);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
        return current !== null ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = (current.flags & 128) !== 0;
      state = (renderLanes2 & workInProgress.childLanes) !== 0;
      state || (propagateParentContextChanges(current, workInProgress, renderLanes2, false), state = (renderLanes2 & workInProgress.childLanes) !== 0);
      if (didSuspendBefore) {
        if (state)
          return updateSuspenseListComponent(current, workInProgress, renderLanes2);
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      didSuspendBefore !== null && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
      push2(suspenseStackCursor, suspenseStackCursor.current);
      if (state)
        break;
      else
        return null;
    case 22:
    case 23:
      return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes2);
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
}
function beginWork(current, workInProgress, renderLanes2) {
  if (current !== null)
    if (current.memoizedProps !== workInProgress.pendingProps)
      didReceiveUpdate = true;
    else {
      if (!checkScheduledUpdateOrContext(current, renderLanes2) && (workInProgress.flags & 128) === 0)
        return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes2);
      didReceiveUpdate = (current.flags & 131072) !== 0 ? true : false;
    }
  else
    didReceiveUpdate = false, isHydrating && (workInProgress.flags & 1048576) !== 0 && pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        current = workInProgress.pendingProps;
        var lazyComponent = workInProgress.elementType, init = lazyComponent._init;
        lazyComponent = init(lazyComponent._payload);
        workInProgress.type = lazyComponent;
        if (typeof lazyComponent === "function")
          shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress.tag = 1, workInProgress = updateClassComponent(null, workInProgress, lazyComponent, current, renderLanes2)) : (workInProgress.tag = 0, workInProgress = updateFunctionComponent(null, workInProgress, lazyComponent, current, renderLanes2));
        else {
          if (lazyComponent !== undefined && lazyComponent !== null) {
            if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE2) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(null, workInProgress, lazyComponent, current, renderLanes2);
              break a;
            } else if (init === REACT_MEMO_TYPE2) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(null, workInProgress, lazyComponent, current, renderLanes2);
              break a;
            }
          }
          workInProgress = getComponentNameFromType(lazyComponent) || lazyComponent;
          throw Error(formatProdErrorMessage2(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes2);
    case 1:
      return lazyComponent = workInProgress.type, init = resolveClassComponentProps(lazyComponent, workInProgress.pendingProps), updateClassComponent(current, workInProgress, lazyComponent, init, renderLanes2);
    case 3:
      a: {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        if (current === null)
          throw Error(formatProdErrorMessage2(387));
        lazyComponent = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        init = prevState.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes2);
        var nextState = workInProgress.memoizedState;
        lazyComponent = nextState.cache;
        pushProvider(workInProgress, CacheContext, lazyComponent);
        lazyComponent !== prevState.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes2, true);
        suspendIfUpdateReadFromEntangledAsyncAction();
        lazyComponent = nextState.element;
        if (prevState.isDehydrated)
          if (prevState = {
            element: lazyComponent,
            isDehydrated: false,
            cache: nextState.cache
          }, workInProgress.updateQueue.baseState = prevState, workInProgress.memoizedState = prevState, workInProgress.flags & 256) {
            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, lazyComponent, renderLanes2);
            break a;
          } else if (lazyComponent !== init) {
            init = createCapturedValueAtFiber(Error(formatProdErrorMessage2(424)), workInProgress);
            queueHydrationError(init);
            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, lazyComponent, renderLanes2);
            break a;
          } else {
            current = workInProgress.stateNode.containerInfo;
            switch (current.nodeType) {
              case 9:
                current = current.body;
                break;
              default:
                current = current.nodeName === "HTML" ? current.ownerDocument.body : current;
            }
            nextHydratableInstance = getNextHydratable(current.firstChild);
            hydrationParentFiber = workInProgress;
            isHydrating = true;
            hydrationErrors = null;
            rootOrSingletonContext = true;
            renderLanes2 = mountChildFibers(workInProgress, null, lazyComponent, renderLanes2);
            for (workInProgress.child = renderLanes2;renderLanes2; )
              renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
          }
        else {
          resetHydrationState();
          if (lazyComponent === init) {
            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes2);
            break a;
          }
          reconcileChildren(current, workInProgress, lazyComponent, renderLanes2);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return markRef(current, workInProgress), current === null ? (renderLanes2 = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress.type, current = workInProgress.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress.stateNode = lazyComponent) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
    case 27:
      return pushHostContext(workInProgress), current === null && isHydrating && (lazyComponent = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, rootInstanceStackCursor.current), hydrationParentFiber = workInProgress, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(lazyComponent.firstChild)) : nextHydratableInstance = init), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes2), markRef(current, workInProgress), current === null && (workInProgress.flags |= 4194304), workInProgress.child;
    case 5:
      if (current === null && isHydrating) {
        if (init = lazyComponent = nextHydratableInstance)
          lazyComponent = canHydrateInstance(lazyComponent, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), lazyComponent !== null ? (workInProgress.stateNode = lazyComponent, hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(lazyComponent.firstChild), rootOrSingletonContext = false, init = true) : init = false;
        init || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      init = workInProgress.type;
      prevState = workInProgress.pendingProps;
      nextState = current !== null ? current.memoizedProps : null;
      lazyComponent = prevState.children;
      shouldSetTextContent(init, prevState) ? lazyComponent = null : nextState !== null && shouldSetTextContent(init, nextState) && (workInProgress.flags |= 32);
      workInProgress.memoizedState !== null && (init = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes2), HostTransitionContext._currentValue = init);
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, lazyComponent, renderLanes2);
      return workInProgress.child;
    case 6:
      if (current === null && isHydrating) {
        if (current = renderLanes2 = nextHydratableInstance)
          renderLanes2 = canHydrateTextInstance(renderLanes2, workInProgress.pendingProps, rootOrSingletonContext), renderLanes2 !== null ? (workInProgress.stateNode = renderLanes2, hydrationParentFiber = workInProgress, nextHydratableInstance = null, current = true) : current = false;
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes2);
    case 4:
      return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), lazyComponent = workInProgress.pendingProps, current === null ? workInProgress.child = reconcileChildFibers(workInProgress, null, lazyComponent, renderLanes2) : reconcileChildren(current, workInProgress, lazyComponent, renderLanes2), workInProgress.child;
    case 11:
      return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes2);
    case 7:
      return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes2), workInProgress.child;
    case 8:
      return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes2), workInProgress.child;
    case 12:
      return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes2), workInProgress.child;
    case 10:
      return lazyComponent = workInProgress.pendingProps, pushProvider(workInProgress, workInProgress.type, lazyComponent.value), reconcileChildren(current, workInProgress, lazyComponent.children, renderLanes2), workInProgress.child;
    case 9:
      return init = workInProgress.type._context, lazyComponent = workInProgress.pendingProps.children, prepareToReadContext(workInProgress), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, lazyComponent, renderLanes2), workInProgress.child;
    case 14:
      return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes2);
    case 15:
      return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes2);
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes2);
    case 31:
      return lazyComponent = workInProgress.pendingProps, renderLanes2 = workInProgress.mode, lazyComponent = {
        mode: lazyComponent.mode,
        children: lazyComponent.children
      }, current === null ? (renderLanes2 = mountWorkInProgressOffscreenFiber(lazyComponent, renderLanes2), renderLanes2.ref = workInProgress.ref, workInProgress.child = renderLanes2, renderLanes2.return = workInProgress, workInProgress = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress.ref, workInProgress.child = renderLanes2, renderLanes2.return = workInProgress, workInProgress = renderLanes2), workInProgress;
    case 22:
      return updateOffscreenComponent(current, workInProgress, renderLanes2);
    case 24:
      return prepareToReadContext(workInProgress), lazyComponent = readContext(CacheContext), current === null ? (init = peekCacheFromPool(), init === null && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, prevState !== null && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress.memoizedState = {
        parent: lazyComponent,
        cache: init
      }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, init)) : ((current.lanes & renderLanes2) !== 0 && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress.memoizedState = init, workInProgress.lanes === 0 && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = init), pushProvider(workInProgress, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes2, true))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes2), workInProgress.child;
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage2(156, workInProgress.tag));
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if (resource.type !== "stylesheet" || (resource.state.loading & 4) !== 0)
    workInProgress.flags &= -16777217;
  else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
    resource = suspenseHandlerStackCursor.current;
    if (resource !== null && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? shellBoundary !== null : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && (workInProgressRootRenderLanes & 536870912) === 0 || resource !== shellBoundary))
      throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    workInProgress.flags |= 8192;
  }
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  retryQueue !== null && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 && (retryQueue = workInProgress.tag !== 22 ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null;hasRenderedATailFallback !== null; )
          hasRenderedATailFallback.alternate !== null && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
        lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$113 = null;lastTailNode !== null; )
          lastTailNode.alternate !== null && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
        lastTailNode$113 === null ? hasRenderedATailFallback || renderState.tail === null ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
    }
}
function bubbleProperties(completedWork) {
  var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
  if (didBailout)
    for (var child$114 = completedWork.child;child$114 !== null; )
      newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
  else
    for (child$114 = completedWork.child;child$114 !== null; )
      newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes2) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 31:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes2 = workInProgress.stateNode;
      newProps = null;
      current !== null && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
      if (current === null || current.child === null)
        popHydrationState(workInProgress) ? markUpdate(workInProgress) : current === null || current.memoizedState.isDehydrated && (workInProgress.flags & 256) === 0 || (workInProgress.flags |= 1024, upgradeHydrationErrorsToRecoverable());
      bubbleProperties(workInProgress);
      return null;
    case 26:
      return renderLanes2 = workInProgress.memoizedState, current === null ? (markUpdate(workInProgress), renderLanes2 !== null ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes2)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes2)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
    case 27:
      popHostContext(workInProgress);
      renderLanes2 = rootInstanceStackCursor.current;
      var type = workInProgress.type;
      if (current !== null && workInProgress.stateNode != null)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (workInProgress.stateNode === null)
            throw Error(formatProdErrorMessage2(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress.stateNode = current, markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      renderLanes2 = workInProgress.type;
      if (current !== null && workInProgress.stateNode != null)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (workInProgress.stateNode === null)
            throw Error(formatProdErrorMessage2(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        if (popHydrationState(workInProgress))
          prepareToHydrateHostInstance(workInProgress, current);
        else {
          type = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
          switch (current) {
            case 1:
              current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes2);
              break;
            case 2:
              current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes2);
              break;
            default:
              switch (renderLanes2) {
                case "svg":
                  current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes2);
                  break;
                case "math":
                  current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes2);
                  break;
                case "script":
                  current = type.createElement("div");
                  current.innerHTML = "<script></script>";
                  current = current.removeChild(current.firstChild);
                  break;
                case "select":
                  current = typeof newProps.is === "string" ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                  newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                  break;
                default:
                  current = typeof newProps.is === "string" ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
              }
          }
          current[internalInstanceKey] = workInProgress;
          current[internalPropsKey] = newProps;
          a:
            for (type = workInProgress.child;type !== null; ) {
              if (type.tag === 5 || type.tag === 6)
                current.appendChild(type.stateNode);
              else if (type.tag !== 4 && type.tag !== 27 && type.child !== null) {
                type.child.return = type;
                type = type.child;
                continue;
              }
              if (type === workInProgress)
                break a;
              for (;type.sibling === null; ) {
                if (type.return === null || type.return === workInProgress)
                  break a;
                type = type.return;
              }
              type.sibling.return = type.return;
              type = type.sibling;
            }
          workInProgress.stateNode = current;
          a:
            switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                current = !!newProps.autoFocus;
                break a;
              case "img":
                current = true;
                break a;
              default:
                current = false;
            }
          current && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      workInProgress.flags &= -16777217;
      return null;
    case 6:
      if (current && workInProgress.stateNode != null)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (typeof newProps !== "string" && workInProgress.stateNode === null)
          throw Error(formatProdErrorMessage2(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes2 = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (type !== null)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress;
          current = current.nodeValue === renderLanes2 || newProps !== null && newProps.suppressHydrationWarning === true || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
          current || throwOnHydrationMismatch(workInProgress);
        } else
          current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {
        type = popHydrationState(workInProgress);
        if (newProps !== null && newProps.dehydrated !== null) {
          if (current === null) {
            if (!type)
              throw Error(formatProdErrorMessage2(318));
            type = workInProgress.memoizedState;
            type = type !== null ? type.dehydrated : null;
            if (!type)
              throw Error(formatProdErrorMessage2(317));
            type[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(), (workInProgress.flags & 128) === 0 && (workInProgress.memoizedState = null), workInProgress.flags |= 4;
          bubbleProperties(workInProgress);
          type = false;
        } else
          type = upgradeHydrationErrorsToRecoverable(), current !== null && current.memoizedState !== null && (current.memoizedState.hydrationErrors = type), type = true;
        if (!type) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if ((workInProgress.flags & 128) !== 0)
        return workInProgress.lanes = renderLanes2, workInProgress;
      renderLanes2 = newProps !== null;
      current = current !== null && current.memoizedState !== null;
      if (renderLanes2) {
        newProps = workInProgress.child;
        type = null;
        newProps.alternate !== null && newProps.alternate.memoizedState !== null && newProps.alternate.memoizedState.cachePool !== null && (type = newProps.alternate.memoizedState.cachePool.pool);
        var cache$127 = null;
        newProps.memoizedState !== null && newProps.memoizedState.cachePool !== null && (cache$127 = newProps.memoizedState.cachePool.pool);
        cache$127 !== type && (newProps.flags |= 2048);
      }
      renderLanes2 !== current && renderLanes2 && (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return popHostContainer(), current === null && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
    case 10:
      return popProvider(workInProgress.type), bubbleProperties(workInProgress), null;
    case 19:
      pop2(suspenseStackCursor);
      type = workInProgress.memoizedState;
      if (type === null)
        return bubbleProperties(workInProgress), null;
      newProps = (workInProgress.flags & 128) !== 0;
      cache$127 = type.rendering;
      if (cache$127 === null)
        if (newProps)
          cutOffTailIfNeeded(type, false);
        else {
          if (workInProgressRootExitStatus !== 0 || current !== null && (current.flags & 128) !== 0)
            for (current = workInProgress.child;current !== null; ) {
              cache$127 = findFirstSuspended(current);
              if (cache$127 !== null) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(type, false);
                current = cache$127.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes2;
                for (renderLanes2 = workInProgress.child;renderLanes2 !== null; )
                  resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                push2(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
                return workInProgress.child;
              }
              current = current.sibling;
            }
          type.tail !== null && now() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
        }
      else {
        if (!newProps)
          if (current = findFirstSuspended(cache$127), current !== null) {
            if (workInProgress.flags |= 128, newProps = true, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(type, true), type.tail === null && type.tailMode === "hidden" && !cache$127.alternate && !isHydrating)
              return bubbleProperties(workInProgress), null;
          } else
            2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && renderLanes2 !== 536870912 && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
        type.isBackwards ? (cache$127.sibling = workInProgress.child, workInProgress.child = cache$127) : (current = type.last, current !== null ? current.sibling = cache$127 : workInProgress.child = cache$127, type.last = cache$127);
      }
      if (type.tail !== null)
        return workInProgress = type.tail, type.rendering = workInProgress, type.tail = workInProgress.sibling, type.renderingStartTime = now(), workInProgress.sibling = null, current = suspenseStackCursor.current, push2(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress;
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return popSuspenseHandler(workInProgress), popHiddenContext(), newProps = workInProgress.memoizedState !== null, current !== null ? current.memoizedState !== null !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? (renderLanes2 & 536870912) !== 0 && (workInProgress.flags & 128) === 0 && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes2 = workInProgress.updateQueue, renderLanes2 !== null && scheduleRetryEffect(workInProgress, renderLanes2.retryQueue), renderLanes2 = null, current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress.flags |= 2048), current !== null && pop2(resumedCache), null;
    case 24:
      return renderLanes2 = null, current !== null && (renderLanes2 = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes2 && (workInProgress.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress), null;
    case 25:
      return null;
    case 30:
      return null;
  }
  throw Error(formatProdErrorMessage2(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 3:
      return popProvider(CacheContext), popHostContainer(), current = workInProgress.flags, (current & 65536) !== 0 && (current & 128) === 0 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (current !== null && current.dehydrated !== null) {
        if (workInProgress.alternate === null)
          throw Error(formatProdErrorMessage2(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 19:
      return pop2(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return popSuspenseHandler(workInProgress), popHiddenContext(), current !== null && pop2(resumedCache), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop2(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      current !== null && pop2(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
    if (lastEffect !== null) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = undefined;
          var { create, inst } = updateQueue;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
  try {
    var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
    if (lastEffect !== null) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst, destroy = inst.destroy;
          if (destroy !== undefined) {
            inst.destroy = undefined;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
            try {
              destroy_();
            } catch (error) {
              captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (updateQueue !== null) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
  instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (ref !== null) {
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = current.stateNode;
          break;
        case 30:
          instanceToUse = current.stateNode;
          break;
        default:
          instanceToUse = current.stateNode;
      }
      typeof ref === "function" ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var { ref, refCleanup } = current;
  if (ref !== null)
    if (typeof refCleanup === "function")
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        current.refCleanup = null, current = current.alternate, current != null && (current.refCleanup = null);
      }
    else if (typeof ref === "function")
      try {
        ref(null);
      } catch (error$143) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$143);
      }
    else
      ref.current = null;
}
function commitHostMount(finishedWork) {
  var { type, memoizedProps: props, stateNode: instance } = finishedWork;
  try {
    a:
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          props.autoFocus && instance.focus();
          break a;
        case "img":
          props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
      }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return fiber.tag === 5 || fiber.tag === 3 || fiber.tag === 26 || fiber.tag === 27 && isSingletonScope(fiber.type) || fiber.tag === 4;
}
function getHostSibling(fiber) {
  a:
    for (;; ) {
      for (;fiber.sibling === null; ) {
        if (fiber.return === null || isHostParent(fiber.return))
          return null;
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      for (fiber = fiber.sibling;fiber.tag !== 5 && fiber.tag !== 6 && fiber.tag !== 18; ) {
        if (fiber.tag === 27 && isSingletonScope(fiber.type))
          continue a;
        if (fiber.flags & 2)
          continue a;
        if (fiber.child === null || fiber.tag === 4)
          continue a;
        else
          fiber.child.return = fiber, fiber = fiber.child;
      }
      if (!(fiber.flags & 2))
        return fiber.stateNode;
    }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (tag === 5 || tag === 6)
    node = node.stateNode, before ? (parent.nodeType === 9 ? parent.body : parent.nodeName === "HTML" ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = parent.nodeType === 9 ? parent.body : parent.nodeName === "HTML" ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, parent !== null && parent !== undefined || before.onclick !== null || (before.onclick = noop$12));
  else if (tag !== 4 && (tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, node !== null))
    for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;node !== null; )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (tag === 5 || tag === 6)
    node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (tag !== 4 && (tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, node !== null))
    for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling;node !== null; )
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
}
function commitHostSingletonAcquisition(finishedWork) {
  var { stateNode: singleton, memoizedProps: props } = finishedWork;
  try {
    for (var type = finishedWork.type, attributes = singleton.attributes;attributes.length; )
      singleton.removeAttributeNode(attributes[0]);
    setInitialProperties(singleton, type, props);
    singleton[internalInstanceKey] = finishedWork;
    singleton[internalPropsKey] = props;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitBeforeMutationEffects(root2, firstChild) {
  root2 = root2.containerInfo;
  eventsEnabled = _enabled;
  root2 = getActiveElementDeep(root2);
  if (hasSelectionCapabilities(root2)) {
    if ("selectionStart" in root2)
      var JSCompiler_temp = {
        start: root2.selectionStart,
        end: root2.selectionEnd
      };
    else
      a: {
        JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
        var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && selection.rangeCount !== 0) {
          JSCompiler_temp = selection.anchorNode;
          var { anchorOffset, focusNode } = selection;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
          b:
            for (;; ) {
              for (var next;; ) {
                node !== JSCompiler_temp || anchorOffset !== 0 && node.nodeType !== 3 || (start = length + anchorOffset);
                node !== focusNode || selection !== 0 && node.nodeType !== 3 || (end = length + selection);
                node.nodeType === 3 && (length += node.nodeValue.length);
                if ((next = node.firstChild) === null)
                  break;
                parentNode = node;
                node = next;
              }
              for (;; ) {
                if (node === root2)
                  break b;
                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                if ((next = node.nextSibling) !== null)
                  break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
          JSCompiler_temp = start === -1 || end === -1 ? null : { start, end };
        } else
          JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else
    JSCompiler_temp = null;
  selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
  _enabled = false;
  for (nextEffect = firstChild;nextEffect !== null; )
    if (firstChild = nextEffect, root2 = firstChild.child, (firstChild.subtreeFlags & 1024) !== 0 && root2 !== null)
      root2.return = firstChild, nextEffect = root2;
    else
      for (;nextEffect !== null; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root2 = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if ((root2 & 1024) !== 0 && focusNode !== null) {
              root2 = undefined;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(JSCompiler_temp.type, anchorOffset, JSCompiler_temp.elementType === JSCompiler_temp.type);
                root2 = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
                selection.__reactInternalSnapshotBeforeUpdate = root2;
              } catch (error) {
                captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
              }
            }
            break;
          case 3:
            if ((root2 & 1024) !== 0) {
              if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, JSCompiler_temp === 9)
                clearContainerSparingly(root2);
              else if (JSCompiler_temp === 1)
                switch (root2.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root2);
                    break;
                  default:
                    root2.textContent = "";
                }
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if ((root2 & 1024) !== 0)
              throw Error(formatProdErrorMessage2(163));
        }
        root2 = firstChild.sibling;
        if (root2 !== null) {
          root2.return = firstChild.return;
          nextEffect = root2;
          break;
        }
        nextEffect = firstChild.return;
      }
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (finishedRoot = finishedWork.stateNode, current === null)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
          } catch (error$142) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error$142);
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 64 && (finishedRoot = finishedWork.updateQueue, finishedRoot !== null)) {
        current = null;
        if (finishedWork.child !== null)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              current = finishedWork.child.stateNode;
              break;
            case 1:
              current = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(finishedRoot, current);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 27:
      current === null && flags & 4 && commitHostSingletonAcquisition(finishedWork);
    case 26:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      current === null && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      flags & 64 && (finishedRoot = finishedWork.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
      break;
    case 22:
      flags = finishedWork.memoizedState !== null || offscreenSubtreeIsHidden;
      if (!flags) {
        current = current !== null && current.memoizedState !== null || offscreenSubtreeWasHidden;
        prevProps = offscreenSubtreeIsHidden;
        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = flags;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, (finishedWork.subtreeFlags & 8772) !== 0) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevProps;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      break;
    case 30:
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  fiber.tag === 5 && (alternate = fiber.stateNode, alternate !== null && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  for (parent = parent.child;parent !== null; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function")
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {
    }
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
      isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      releaseSingletonInstance(deletedFiber.stateNode);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      if (hostParent !== null)
        if (hostParentIsContainer)
          try {
            (hostParent.nodeType === 9 ? hostParent.body : hostParent.nodeName === "HTML" ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
          }
      break;
    case 18:
      hostParent !== null && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(finishedRoot.nodeType === 9 ? finishedRoot.body : finishedRoot.nodeName === "HTML" ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = true;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      break;
    case 1:
      offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, typeof prevHostParent.componentWillUnmount === "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      break;
    case 21:
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      break;
    case 22:
      offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || deletedFiber.memoizedState !== null;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null))))
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet);
      return retryCache;
    case 22:
      return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, retryCache === null && (retryCache = finishedWork._retryCache = new PossiblyWeakSet), retryCache;
    default:
      throw Error(formatProdErrorMessage2(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function(wakeable) {
    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
    retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (deletions !== null)
    for (var i = 0;i < deletions.length; i++) {
      var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
      a:
        for (;parent !== null; ) {
          switch (parent.tag) {
            case 27:
              if (isSingletonScope(parent.type)) {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              }
              break;
            case 5:
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break a;
            case 3:
            case 4:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = true;
              break a;
          }
          parent = parent.return;
        }
      if (hostParent === null)
        throw Error(formatProdErrorMessage2(160));
      commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = false;
      root2 = childToDelete.alternate;
      root2 !== null && (root2.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13878)
    for (parentFiber = parentFiber.child;parentFiber !== null; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
}
function commitMutationEffectsOnFiber(finishedWork, root2) {
  var { alternate: current, flags } = finishedWork;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return));
      flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, finishedWork !== null && (flags = finishedWork.callbacks, flags !== null && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = current === null ? flags : current.concat(flags))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = current !== null ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (current === null)
          if (flags === null)
            if (finishedWork.stateNode === null) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b:
                  switch (flags) {
                    case "title":
                      currentResource = hoistableRoot.getElementsByTagName("title")[0];
                      if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === "http://www.w3.org/2000/svg" || currentResource.hasAttribute("itemprop"))
                        currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(currentResource, hoistableRoot.querySelector("head > title"));
                      setInitialProperties(currentResource, flags, current);
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache("link", "href", hoistableRoot).get(flags + (current.href || ""));
                      if (maybeNodes) {
                        for (var i = 0;i < maybeNodes.length; i++)
                          if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (current.href == null || current.href === "" ? null : current.href) && currentResource.getAttribute("rel") === (current.rel == null ? null : current.rel) && currentResource.getAttribute("title") === (current.title == null ? null : current.title) && currentResource.getAttribute("crossorigin") === (current.crossOrigin == null ? null : current.crossOrigin)) {
                            maybeNodes.splice(i, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache("meta", "content", hoistableRoot).get(flags + (current.content || ""))) {
                        for (i = 0;i < maybeNodes.length; i++)
                          if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (current.content == null ? null : "" + current.content) && currentResource.getAttribute("name") === (current.name == null ? null : current.name) && currentResource.getAttribute("property") === (current.property == null ? null : current.property) && currentResource.getAttribute("http-equiv") === (current.httpEquiv == null ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (current.charSet == null ? null : current.charSet)) {
                            maybeNodes.splice(i, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    default:
                      throw Error(formatProdErrorMessage2(468, flags));
                  }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
          else
            finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
        else
          currentResource !== flags ? (currentResource === null ? current.stateNode !== null && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, flags === null ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : flags === null && finishedWork.stateNode !== null && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
      }
      break;
    case 27:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return));
      current !== null && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
      break;
    case 5:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 && finishedWork.stateNode != null && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(finishedWork, hoistableRoot, current !== null ? current.memoizedProps : hoistableRoot));
      flags & 1024 && (needsFormReset = true);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (finishedWork.stateNode === null)
          throw Error(formatProdErrorMessage2(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root2.containerInfo);
      recursivelyTraverseMutationEffects(root2, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && current !== null && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root2.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 13:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 && finishedWork.memoizedState !== null !== (current !== null && current.memoizedState !== null) && (globalMostRecentFallbackTime = now());
      flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      hoistableRoot = finishedWork.memoizedState !== null;
      var wasHidden = current !== null && current.memoizedState !== null, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
      recursivelyTraverseMutationEffects(root2, finishedWork);
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
      commitReconciliationEffects(finishedWork);
      if (flags & 8192)
        a:
          for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (current === null || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork;; ) {
            if (root2.tag === 5 || root2.tag === 26) {
              if (current === null) {
                wasHidden = current = root2;
                try {
                  if (currentResource = wasHidden.stateNode, hoistableRoot)
                    maybeNodes = currentResource.style, typeof maybeNodes.setProperty === "function" ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                  else {
                    i = wasHidden.stateNode;
                    var styleProp = wasHidden.memoizedProps.style, display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                    i.style.display = display == null || typeof display === "boolean" ? "" : ("" + display).trim();
                  }
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (root2.tag === 6) {
              if (current === null) {
                wasHidden = root2;
                try {
                  wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if ((root2.tag !== 22 && root2.tag !== 23 || root2.memoizedState === null || root2 === finishedWork) && root2.child !== null) {
              root2.child.return = root2;
              root2 = root2.child;
              continue;
            }
            if (root2 === finishedWork)
              break a;
            for (;root2.sibling === null; ) {
              if (root2.return === null || root2.return === finishedWork)
                break a;
              current === root2 && (current = null);
              root2 = root2.return;
            }
            current === root2 && (current = null);
            root2.sibling.return = root2.return;
            root2 = root2.sibling;
          }
      flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (current = flags.retryQueue, current !== null && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 30:
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      for (var hostParentFiber, parentFiber = finishedWork.return;parentFiber !== null; ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (hostParentFiber == null)
        throw Error(formatProdErrorMessage2(160));
      switch (hostParentFiber.tag) {
        case 27:
          var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before, parent);
          break;
        case 5:
          var parent$144 = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
          var before$145 = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
          break;
        case 3:
        case 4:
          var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(finishedWork, before$147, parent$146);
          break;
        default:
          throw Error(formatProdErrorMessage2(161));
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child;parentFiber !== null; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      fiber.tag === 5 && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root2, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child;parentFiber !== null; )
      commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child;parentFiber !== null; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        typeof instance.componentWillUnmount === "function" && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 27:
        releaseSingletonInstance(finishedWork.stateNode);
      case 26:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        finishedWork.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 30:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
  includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 8772) !== 0;
  for (parentFiber = parentFiber.child;parentFiber !== null; ) {
    var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        current = finishedWork;
        finishedRoot = current.stateNode;
        if (typeof finishedRoot.componentDidMount === "function")
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (finishedRoot !== null) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (hiddenCallbacks !== null)
              for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;finishedRoot < hiddenCallbacks.length; finishedRoot++)
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 27:
        commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        includeWorkInProgressEffects && current === null && flags & 4 && commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        finishedWork.memoizedState === null && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 30:
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null && (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null && (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache && (current != null && current.refCount++, previousCache != null && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  finishedWork.alternate !== null && (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current && (finishedWork.refCount++, current != null && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child;parentFiber !== null; )
      commitPassiveMountOnFiber(root2, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 1:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      flags & 2048 && (finishedRoot = null, finishedWork.alternate !== null && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, finishedRoot != null && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
          typeof onPostCommit === "function" && onPostCommit(id, finishedWork.alternate === null ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      break;
    case 13:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      id = finishedWork.alternate;
      finishedWork.memoizedState !== null ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, (finishedWork.subtreeFlags & 10256) !== 0));
      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
  }
}
function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
  includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 10256) !== 0;
  for (parentFiber = parentFiber.child;parentFiber !== null; ) {
    var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        finishedWork.memoizedState !== null ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child;parentFiber !== null; ) {
      var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyAccumulateSuspenseyCommit(parentFiber) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child;parentFiber !== null; )
      accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
}
function accumulateSuspenseyCommitOnFiber(fiber) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(fiber);
      fiber.flags & suspenseyCommitFlag && fiber.memoizedState !== null && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(fiber);
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(fiber);
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      fiber.memoizedState === null && (previousHoistableRoot = fiber.alternate, previousHoistableRoot !== null && previousHoistableRoot.memoizedState !== null ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(fiber);
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (previousFiber !== null && (parentFiber = previousFiber.child, parentFiber !== null)) {
    previousFiber.child = null;
    do
      previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
    while (parentFiber !== null);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if ((parentFiber.flags & 16) !== 0) {
    if (deletions !== null)
      for (var i = 0;i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child;parentFiber !== null; )
      commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      finishedWork.memoizedState !== null && instance._visibility & 2 && (finishedWork.return === null || finishedWork.return.tag !== 13) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if ((parentFiber.flags & 16) !== 0) {
    if (deletions !== null)
      for (var i = 0;i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child;parentFiber !== null; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
  for (;nextEffect !== null; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (fiber.memoizedState !== null && fiber.memoizedState.cachePool !== null) {
          var cache = fiber.memoizedState.cachePool.pool;
          cache != null && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (cache !== null)
      cache.return = fiber, nextEffect = cache;
    else
      a:
        for (fiber = deletedSubtreeRoot;nextEffect !== null; ) {
          cache = nextEffect;
          var { sibling, return: returnFiber } = cache;
          detachFiberAfterEffects(cache);
          if (cache === fiber) {
            nextEffect = null;
            break a;
          }
          if (sibling !== null) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            break a;
          }
          nextEffect = returnFiber;
        }
  }
}
function requestUpdateLane() {
  if ((executionContext & 2) !== 0 && workInProgressRootRenderLanes !== 0)
    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
  if (ReactSharedInternals3.T !== null) {
    var actionScopeLane = currentEntangledLane;
    return actionScopeLane !== 0 ? actionScopeLane : requestTransitionLane();
  }
  return resolveUpdatePriority();
}
function requestDeferredLane() {
  workInProgressDeferredLane === 0 && (workInProgressDeferredLane = (workInProgressRootRenderLanes & 536870912) === 0 || isHydrating ? claimNextTransitionLane() : 536870912);
  var suspenseHandler = suspenseHandlerStackCursor.current;
  suspenseHandler !== null && (suspenseHandler.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root2, fiber, lane) {
  if (root2 === workInProgressRoot && (workInProgressSuspendedReason === 2 || workInProgressSuspendedReason === 9) || root2.cancelPendingCommit !== null)
    prepareFreshStack(root2, 0), markRootSuspended(root2, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
  markRootUpdated$1(root2, lane);
  if ((executionContext & 2) === 0 || root2 !== workInProgressRoot)
    root2 === workInProgressRoot && ((executionContext & 2) === 0 && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === 4 && markRootSuspended(root2, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root2);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if ((executionContext & 6) !== 0)
    throw Error(formatProdErrorMessage2(327));
  var shouldTimeSlice = !forceSync && (lanes & 124) === 0 && (lanes & root$jscomp$0.expiredLanes) === 0 || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
  do {
    if (exitStatus === 0) {
      workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
      break;
    } else {
      forceSync = root$jscomp$0.current.alternate;
      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, false);
        renderWasConcurrent = false;
        continue;
      }
      if (exitStatus === 2) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = JSCompiler_inline_result !== 0 ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
        if (JSCompiler_inline_result !== 0) {
          lanes = JSCompiler_inline_result;
          a: {
            var root2 = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
            wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(root2, JSCompiler_inline_result, false);
            if (JSCompiler_inline_result !== 2) {
              if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              renderWasConcurrent !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, renderWasConcurrent));
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = false;
          if (exitStatus !== 2)
            continue;
        }
      }
      if (exitStatus === 1) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, true);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        renderWasConcurrent = exitStatus;
        switch (renderWasConcurrent) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage2(345));
          case 4:
            if ((lanes & 4194048) !== lanes)
              break;
          case 6:
            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
            break a;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage2(329));
        }
        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
          markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
          if (getNextLanes(shouldTimeSlice, 0, true) !== 0)
            break a;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 2, -0, 0), exitStatus);
          break a;
        }
        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 0, -0, 0);
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
  root2.timeoutHandle = -1;
  suspendedCommitReason = finishedWork.subtreeFlags;
  if (suspendedCommitReason & 8192 || (suspendedCommitReason & 16785408) === 16785408) {
    if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop3 }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), suspendedCommitReason !== null) {
      root2.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, 1, completedRenderStartTime, completedRenderEndTime));
      markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  }
  commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork;; ) {
    var tag = node.tag;
    if ((tag === 0 || tag === 11 || tag === 15) && node.flags & 16384 && (tag = node.updateQueue, tag !== null && (tag = tag.stores, tag !== null)))
      for (var i = 0;i < tag.length; i++) {
        var check = tag[i], getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check))
            return false;
        } catch (error) {
          return false;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && tag !== null)
      tag.return = node, node = tag;
    else {
      if (node === finishedWork)
        break;
      for (;node.sibling === null; ) {
        if (node.return === null || node.return === finishedWork)
          return true;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return true;
}
function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root2.suspendedLanes |= suspendedLanes;
  root2.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root2.expirationTimes;
  for (var lanes = suspendedLanes;0 < lanes; ) {
    var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
    didAttemptEntireTree[index$4] = -1;
    lanes &= ~lane;
  }
  spawnedLane !== 0 && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return (executionContext & 6) === 0 ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
}
function resetWorkInProgressStack() {
  if (workInProgress !== null) {
    if (workInProgressSuspendedReason === 0)
      var interruptedWork = workInProgress.return;
    else
      interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
    for (;interruptedWork !== null; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
    workInProgress = null;
  }
}
function prepareFreshStack(root2, lanes) {
  var timeoutHandle = root2.timeoutHandle;
  timeoutHandle !== -1 && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
  timeoutHandle = root2.cancelPendingCommit;
  timeoutHandle !== null && (root2.cancelPendingCommit = null, timeoutHandle());
  resetWorkInProgressStack();
  workInProgressRoot = root2;
  workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = false;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
  workInProgressRootDidAttachPingListener = false;
  workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = false;
  (lanes & 8) !== 0 && (lanes |= lanes & 32);
  var allEntangledLanes = root2.entangledLanes;
  if (allEntangledLanes !== 0)
    for (root2 = root2.entanglements, allEntangledLanes &= lanes;0 < allEntangledLanes; ) {
      var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
      lanes |= root2[index$2];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root2, thrownValue) {
  currentlyRenderingFiber = null;
  ReactSharedInternals3.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function" ? 6 : 1;
  workInProgressThrownValue = thrownValue;
  workInProgress === null && (workInProgressRootExitStatus = 1, logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current)));
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals3.H;
  ReactSharedInternals3.H = ContextOnlyDispatcher;
  return prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals3.A;
  ReactSharedInternals3.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = true);
  (workInProgressRootSkippedLanes & 134217727) === 0 && (workInProgressRootInterleavedUpdatedLanes & 134217727) === 0 || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
}
function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
    workInProgressTransitions = null, prepareFreshStack(root2, lanes);
  lanes = false;
  var exitStatus = workInProgressRootExitStatus;
  a:
    do
      try {
        if (workInProgressSuspendedReason !== 0 && workInProgress !== null) {
          var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
          switch (workInProgressSuspendedReason) {
            case 8:
              resetWorkInProgressStack();
              exitStatus = 6;
              break a;
            case 3:
            case 2:
            case 9:
            case 6:
              suspenseHandlerStackCursor.current === null && (lanes = true);
              var reason = workInProgressSuspendedReason;
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                exitStatus = 0;
                break a;
              }
              break;
            default:
              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
          }
        }
        workLoopSync();
        exitStatus = workInProgressRootExitStatus;
        break;
      } catch (thrownValue$167) {
        handleThrow(root2, thrownValue$167);
      }
    while (1);
  lanes && root2.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber$1 = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals3.H = prevDispatcher;
  ReactSharedInternals3.A = prevAsyncDispatcher;
  workInProgress === null && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (;workInProgress !== null; )
    performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root2, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
  a:
    do
      try {
        if (workInProgressSuspendedReason !== 0 && workInProgress !== null) {
          lanes = workInProgress;
          var thrownValue = workInProgressThrownValue;
          b:
            switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  workInProgressSuspendedReason !== 2 && workInProgressSuspendedReason !== 9 || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root2);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : 1) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (sibling !== null)
                        workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        returnFiber !== null ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage2(462));
            }
        }
        workLoopConcurrentByScheduler();
        break;
      } catch (thrownValue$169) {
        handleThrow(root2, thrownValue$169);
      }
    while (1);
  lastContextDependency = currentlyRenderingFiber$1 = null;
  ReactSharedInternals3.H = prevDispatcher;
  ReactSharedInternals3.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (workInProgress !== null)
    return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrentByScheduler() {
  for (;workInProgress !== null && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next;
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(current, next, next.pendingProps, next.type, undefined, workInProgressRootRenderLanes);
      break;
    case 11:
      next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next;
}
function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
  lastContextDependency = currentlyRenderingFiber$1 = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState = null;
  thenableIndexCounter = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (throwException(root2, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (returnFiber !== null)
      throw workInProgress = returnFiber, error;
    workInProgressRootExitStatus = 1;
    logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || suspendedReason === 1)
      root2 = true;
    else if (workInProgressRootIsPrerendering || (workInProgressRootRenderLanes & 536870912) !== 0)
      root2 = false;
    else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === 2 || suspendedReason === 9 || suspendedReason === 3 || suspendedReason === 6)
      suspendedReason = suspenseHandlerStackCursor.current, suspendedReason !== null && suspendedReason.tag === 13 && (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root2);
  } else
    completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if ((completedWork.flags & 32768) !== 0) {
      unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
    if (next !== null) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (completedWork !== null) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (completedWork !== null);
  workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (next !== null) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    next !== null && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
    if (!skipSiblings && (unitOfWork = unitOfWork.sibling, unitOfWork !== null)) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (unitOfWork !== null);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
  root2.cancelPendingCommit = null;
  do
    flushPendingEffects();
  while (pendingEffectsStatus !== 0);
  if ((executionContext & 6) !== 0)
    throw Error(formatProdErrorMessage2(327));
  if (finishedWork !== null) {
    if (finishedWork === root2.current)
      throw Error(formatProdErrorMessage2(177));
    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
    markRootFinished(root2, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
    root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
    pendingFinishedWork = finishedWork;
    pendingEffectsRoot = root2;
    pendingEffectsLanes = lanes;
    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
    pendingPassiveTransitions = transitions;
    pendingRecoverableErrors = recoverableErrors;
    (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0 ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
      flushPassiveEffects(true);
      return null;
    })) : (root2.callbackNode = null, root2.callbackPriority = 0);
    recoverableErrors = (finishedWork.flags & 13878) !== 0;
    if ((finishedWork.subtreeFlags & 13878) !== 0 || recoverableErrors) {
      recoverableErrors = ReactSharedInternals3.T;
      ReactSharedInternals3.T = null;
      transitions = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      spawnedLane = executionContext;
      executionContext |= 4;
      try {
        commitBeforeMutationEffects(root2, finishedWork, lanes);
      } finally {
        executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals3.T = recoverableErrors;
      }
    }
    pendingEffectsStatus = 1;
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
  }
}
function flushMutationEffects() {
  if (pendingEffectsStatus === 1) {
    pendingEffectsStatus = 0;
    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = (finishedWork.flags & 13878) !== 0;
    if ((finishedWork.subtreeFlags & 13878) !== 0 || rootMutationHasEffect) {
      rootMutationHasEffect = ReactSharedInternals3.T;
      ReactSharedInternals3.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitMutationEffectsOnFiber(finishedWork, root2);
        var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
          if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
            var { start, end } = priorSelectionRange;
            end === undefined && (end = start);
            if ("selectionStart" in priorFocusedElem)
              priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);
            else {
              var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
              if (win.getSelection) {
                var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = priorSelectionRange.end === undefined ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                if (startMarker && endMarker && (selection.rangeCount !== 1 || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                  var range = doc.createRange();
                  range.setStart(startMarker.node, startMarker.offset);
                  selection.removeAllRanges();
                  start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                }
              }
            }
          }
          doc = [];
          for (selection = priorFocusedElem;selection = selection.parentNode; )
            selection.nodeType === 1 && doc.push({
              element: selection,
              left: selection.scrollLeft,
              top: selection.scrollTop
            });
          typeof priorFocusedElem.focus === "function" && priorFocusedElem.focus();
          for (priorFocusedElem = 0;priorFocusedElem < doc.length; priorFocusedElem++) {
            var info = doc[priorFocusedElem];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
        _enabled = !!eventsEnabled;
        selectionInformation = eventsEnabled = null;
      } finally {
        executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals3.T = rootMutationHasEffect;
      }
    }
    root2.current = finishedWork;
    pendingEffectsStatus = 2;
  }
}
function flushLayoutEffects() {
  if (pendingEffectsStatus === 2) {
    pendingEffectsStatus = 0;
    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = (finishedWork.flags & 8772) !== 0;
    if ((finishedWork.subtreeFlags & 8772) !== 0 || rootHasLayoutEffect) {
      rootHasLayoutEffect = ReactSharedInternals3.T;
      ReactSharedInternals3.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
      } finally {
        executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals3.T = rootHasLayoutEffect;
      }
    }
    pendingEffectsStatus = 3;
  }
}
function flushSpawnedWork() {
  if (pendingEffectsStatus === 4 || pendingEffectsStatus === 3) {
    pendingEffectsStatus = 0;
    requestPaint();
    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
    (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0 ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
    var remainingLanes = root2.pendingLanes;
    remainingLanes === 0 && (legacyErrorBoundariesThatAlreadyFailed = null);
    lanesToEventPriority(lanes);
    finishedWork = finishedWork.stateNode;
    if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function")
      try {
        injectedHook.onCommitFiberRoot(rendererID, finishedWork, undefined, (finishedWork.current.flags & 128) === 128);
      } catch (err) {
      }
    if (recoverableErrors !== null) {
      finishedWork = ReactSharedInternals3.T;
      remainingLanes = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      ReactSharedInternals3.T = null;
      try {
        for (var onRecoverableError = root2.onRecoverableError, i = 0;i < recoverableErrors.length; i++) {
          var recoverableError = recoverableErrors[i];
          onRecoverableError(recoverableError.value, {
            componentStack: recoverableError.stack
          });
        }
      } finally {
        ReactSharedInternals3.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
      }
    }
    (pendingEffectsLanes & 3) !== 0 && flushPendingEffects();
    ensureRootIsScheduled(root2);
    remainingLanes = root2.pendingLanes;
    (lanes & 4194090) !== 0 && (remainingLanes & 42) !== 0 ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
    flushSyncWorkAcrossRoots_impl(0, false);
  }
}
function releaseRootPooledCache(root2, remainingLanes) {
  (root2.pooledCacheLanes &= remainingLanes) === 0 && (remainingLanes = root2.pooledCache, remainingLanes != null && (root2.pooledCache = null, releaseCache(remainingLanes)));
}
function flushPendingEffects(wasDelayedCommit) {
  flushMutationEffects();
  flushLayoutEffects();
  flushSpawnedWork();
  return flushPassiveEffects(wasDelayedCommit);
}
function flushPassiveEffects() {
  if (pendingEffectsStatus !== 5)
    return false;
  var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
  pendingEffectsRemainingLanes = 0;
  var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals3.T, previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
    ReactSharedInternals3.T = null;
    renderPriority = pendingPassiveTransitions;
    pendingPassiveTransitions = null;
    var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
    pendingEffectsStatus = 0;
    pendingFinishedWork = pendingEffectsRoot = null;
    pendingEffectsLanes = 0;
    if ((executionContext & 6) !== 0)
      throw Error(formatProdErrorMessage2(331));
    var prevExecutionContext = executionContext;
    executionContext |= 4;
    commitPassiveUnmountOnFiber(root$jscomp$0.current);
    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, renderPriority);
    executionContext = prevExecutionContext;
    flushSyncWorkAcrossRoots_impl(0, false);
    if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function")
      try {
        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
      } catch (err) {
      }
    return true;
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals3.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
  }
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  rootFiber !== null && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (sourceFiber.tag === 3)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (;nearestMountedAncestor !== null; ) {
      if (nearestMountedAncestor.tag === 3) {
        captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
        break;
      } else if (nearestMountedAncestor.tag === 1) {
        var instance = nearestMountedAncestor.stateNode;
        if (typeof nearestMountedAncestor.type.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          instance !== null && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root2, wakeable, lanes) {
  var pingCache = root2.pingCache;
  if (pingCache === null) {
    pingCache = root2.pingCache = new PossiblyWeakMap;
    var threadIDs = new Set;
    pingCache.set(wakeable, threadIDs);
  } else
    threadIDs = pingCache.get(wakeable), threadIDs === undefined && (threadIDs = new Set, pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
}
function pingSuspendedRoot(root2, wakeable, pingedLanes) {
  var pingCache = root2.pingCache;
  pingCache !== null && pingCache.delete(wakeable);
  root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
  root2.warmLanes &= ~pingedLanes;
  workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === 4 || workInProgressRootExitStatus === 3 && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? (executionContext & 2) === 0 && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root2);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  retryLane === 0 && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  boundaryFiber !== null && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
  suspenseState !== null && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      suspenseState !== null && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage2(314));
  }
  retryCache !== null && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
function ensureRootIsScheduled(root2) {
  root2 !== lastScheduledRoot && root2.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
  mightHavePendingSyncWork = true;
  didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = true;
    do {
      var didPerformSomeWork = false;
      for (var root$174 = firstScheduledRoot;root$174 !== null; ) {
        if (!onlyLegacy)
          if (syncTransitionLanes !== 0) {
            var pendingLanes = root$174.pendingLanes;
            if (pendingLanes === 0)
              var JSCompiler_inline_result = 0;
            else {
              var { suspendedLanes, pingedLanes } = root$174;
              JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
              JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
            }
            JSCompiler_inline_result !== 0 && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
          } else
            JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(root$174, root$174 === workInProgressRoot ? JSCompiler_inline_result : 0, root$174.cancelPendingCommit !== null || root$174.timeoutHandle !== -1), (JSCompiler_inline_result & 3) === 0 || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
        root$174 = root$174.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = false;
  }
}
function processRootScheduleInImmediateTask() {
  processRootScheduleInMicrotask();
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = false;
  var syncTransitionLanes = 0;
  currentEventTransitionLane !== 0 && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
  for (var currentTime = now(), prev = null, root2 = firstScheduledRoot;root2 !== null; ) {
    var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
    if (nextLanes === 0)
      root2.next = null, prev === null ? firstScheduledRoot = next : prev.next = next, next === null && (lastScheduledRoot = prev);
    else if (prev = root2, syncTransitionLanes !== 0 || (nextLanes & 3) !== 0)
      mightHavePendingSyncWork = true;
    root2 = next;
  }
  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
}
function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
  for (var { suspendedLanes, pingedLanes, expirationTimes } = root2, lanes = root2.pendingLanes & -62914561;0 < lanes; ) {
    var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
    if (expirationTime === -1) {
      if ((lane & suspendedLanes) === 0 || (lane & pingedLanes) !== 0)
        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
    } else
      expirationTime <= currentTime && (root2.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(root2, root2 === currentTime ? suspendedLanes : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== -1);
  pingedLanes = root2.callbackNode;
  if (suspendedLanes === 0 || root2 === currentTime && (workInProgressSuspendedReason === 2 || workInProgressSuspendedReason === 9) || root2.cancelPendingCommit !== null)
    return pingedLanes !== null && pingedLanes !== null && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
  if ((suspendedLanes & 3) === 0 || checkIfRootIsPrerendering(root2, suspendedLanes)) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root2.callbackPriority)
      return currentTime;
    pingedLanes !== null && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root2.callbackPriority = currentTime;
    root2.callbackNode = suspendedLanes;
    return currentTime;
  }
  pingedLanes !== null && pingedLanes !== null && cancelCallback$1(pingedLanes);
  root2.callbackPriority = 2;
  root2.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
  if (pendingEffectsStatus !== 0 && pendingEffectsStatus !== 5)
    return root2.callbackNode = null, root2.callbackPriority = 0, null;
  var originalCallbackNode = root2.callbackNode;
  if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== -1);
  if (workInProgressRootRenderLanes$jscomp$0 === 0)
    return null;
  performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root2, now());
  return root2.callbackNode != null && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
}
function performSyncWorkOnRoot(root2, lanes) {
  if (flushPendingEffects())
    return null;
  performWorkOnRoot(root2, lanes, true);
}
function scheduleImmediateRootScheduleTask() {
  scheduleMicrotask(function() {
    (executionContext & 6) !== 0 ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
  });
}
function requestTransitionLane() {
  currentEventTransitionLane === 0 && (currentEventTransitionLane = claimNextTransitionLane());
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return actionProp == null || typeof actionProp === "symbol" || typeof actionProp === "boolean" ? null : typeof actionProp === "function" ? actionProp : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
  if (domEventName === "submit" && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
    var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;
    submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), domEventName !== null && (action = domEventName, submitter = null));
    var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event,
      listeners: [
        {
          instance: null,
          listener: function() {
            if (nativeEvent.defaultPrevented) {
              if (currentEventTransitionLane !== 0) {
                var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                startHostTransition(maybeTargetInst, {
                  pending: true,
                  data: formData,
                  method: nativeEventTarget.method,
                  action
                }, null, formData);
              }
            } else
              typeof action === "function" && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(maybeTargetInst, {
                pending: true,
                data: formData,
                method: nativeEventTarget.method,
                action
              }, action, formData));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = (eventSystemFlags & 4) !== 0;
  for (var i = 0;i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = undefined;
      if (eventSystemFlags)
        for (var i$jscomp$0 = _dispatchQueue$i.length - 1;0 <= i$jscomp$0; i$jscomp$0--) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError2(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (i$jscomp$0 = 0;i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError2(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  JSCompiler_inline_result === undefined && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set);
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(function(domEventName) {
      domEventName !== "selectionchange" && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
    });
    var ownerDocument = rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument;
    ownerDocument === null || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
  }
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
  listenerWrapper = undefined;
  !passiveBrowserEventsSupported || domEventName !== "touchstart" && domEventName !== "touchmove" && domEventName !== "wheel" || (listenerWrapper = true);
  isCapturePhaseListener ? listenerWrapper !== undefined ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
    capture: true,
    passive: listenerWrapper
  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : listenerWrapper !== undefined ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
    passive: listenerWrapper
  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
}
function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
  var ancestorInst = targetInst$jscomp$0;
  if ((eventSystemFlags & 1) === 0 && (eventSystemFlags & 2) === 0 && targetInst$jscomp$0 !== null)
    a:
      for (;; ) {
        if (targetInst$jscomp$0 === null)
          return;
        var nodeTag = targetInst$jscomp$0.tag;
        if (nodeTag === 3 || nodeTag === 4) {
          var container = targetInst$jscomp$0.stateNode.containerInfo;
          if (container === targetContainer)
            break;
          if (nodeTag === 4)
            for (nodeTag = targetInst$jscomp$0.return;nodeTag !== null; ) {
              var grandTag = nodeTag.tag;
              if ((grandTag === 3 || grandTag === 4) && nodeTag.stateNode.containerInfo === targetContainer)
                return;
              nodeTag = nodeTag.return;
            }
          for (;container !== null; ) {
            nodeTag = getClosestInstanceFromNode(container);
            if (nodeTag === null)
              return;
            grandTag = nodeTag.tag;
            if (grandTag === 5 || grandTag === 6 || grandTag === 26 || grandTag === 27) {
              targetInst$jscomp$0 = ancestorInst = nodeTag;
              continue a;
            }
            container = container.parentNode;
          }
        }
        targetInst$jscomp$0 = targetInst$jscomp$0.return;
      }
  batchedUpdates$1(function() {
    var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (reactName !== undefined) {
        var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (getEventCharCode(nativeEvent) === 0)
              break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (nativeEvent.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = (eventSystemFlags & 4) !== 0, accumulateTargetOnly = !inCapturePhase && (domEventName === "scroll" || domEventName === "scrollend"), reactEventName = inCapturePhase ? reactName !== null ? reactName + "Capture" : null : reactName;
        inCapturePhase = [];
        for (var instance = targetInst, lastHostComponent;instance !== null; ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          _instance !== 5 && _instance !== 26 && _instance !== 27 || lastHostComponent === null || reactEventName === null || (_instance = getListener(instance, reactEventName), _instance != null && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent)));
          if (accumulateTargetOnly)
            break;
          instance = instance.return;
        }
        0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if ((eventSystemFlags & 7) === 0) {
      a: {
        reactName = domEventName === "mouseover" || domEventName === "pointerover";
        SyntheticEventCtor = domEventName === "mouseout" || domEventName === "pointerout";
        if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
          if (SyntheticEventCtor) {
            if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, reactEventType !== null && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || inCapturePhase !== 5 && inCapturePhase !== 27 && inCapturePhase !== 6))
              reactEventType = null;
          } else
            SyntheticEventCtor = null, reactEventType = targetInst;
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover")
              inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
            accumulateTargetOnly = SyntheticEventCtor == null ? reactName : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent = reactEventType == null ? reactName : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(_instance, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = SyntheticEventCtor;
                reactEventName = reactEventType;
                instance = 0;
                for (lastHostComponent = inCapturePhase;lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                  instance++;
                lastHostComponent = 0;
                for (_instance = reactEventName;_instance; _instance = getParent(_instance))
                  lastHostComponent++;
                for (;0 < instance - lastHostComponent; )
                  inCapturePhase = getParent(inCapturePhase), instance--;
                for (;0 < lastHostComponent - instance; )
                  reactEventName = getParent(reactEventName), lastHostComponent--;
                for (;instance--; ) {
                  if (inCapturePhase === reactEventName || reactEventName !== null && inCapturePhase === reactEventName.alternate)
                    break b;
                  inCapturePhase = getParent(inCapturePhase);
                  reactEventName = getParent(reactEventName);
                }
                inCapturePhase = null;
              }
            else
              inCapturePhase = null;
            SyntheticEventCtor !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, false);
            reactEventType !== null && accumulateTargetOnly !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, true);
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
        if (SyntheticEventCtor === "select" || SyntheticEventCtor === "input" && reactName.type === "file")
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || SyntheticEventCtor.toLowerCase() !== "input" || reactName.type !== "checkbox" && reactName.type !== "radio" ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
        if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
          createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        domEventName === "focusout" && targetInst && reactName.type === "number" && targetInst.memoizedProps.value != null && setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (isTextInputElement(handleEventFunc) || handleEventFunc.contentEditable === "true")
            activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = false;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent)
            break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = undefined;
        }
      else
        isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : domEventName === "keydown" && nativeEvent.keyCode === 229 && (eventType = "onCompositionStart");
      eventType && (useFallbackCompositionData && nativeEvent.locale !== "ko" && (isComposing || eventType !== "onCompositionStart" ? eventType === "onCompositionEnd" && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = ("value" in root) ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), fallbackData !== null && (eventType.data = fallbackData))));
      if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
        eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
          event: handleEventFunc,
          listeners: eventType
        }), handleEventFunc.data = fallbackData);
      extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (var captureName = reactName + "Capture", listeners = [];targetFiber !== null; ) {
    var _instance2 = targetFiber, stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    _instance2 !== 5 && _instance2 !== 26 && _instance2 !== 27 || stateNode === null || (_instance2 = getListener(targetFiber, captureName), _instance2 != null && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)), _instance2 = getListener(targetFiber, reactName), _instance2 != null && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
    if (targetFiber.tag === 3)
      return listeners;
    targetFiber = targetFiber.return;
  }
  return [];
}
function getParent(inst) {
  if (inst === null)
    return null;
  do
    inst = inst.return;
  while (inst && inst.tag !== 5 && inst.tag !== 27);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  for (var registrationName = event._reactName, listeners = [];target !== null && target !== common; ) {
    var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (alternate !== null && alternate === common)
      break;
    _instance3 !== 5 && _instance3 !== 26 && _instance3 !== 27 || stateNode === null || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), stateNode != null && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), stateNode != null && listeners.push(createDispatchListener(target, stateNode, alternate))));
    target = target.return;
  }
  listeners.length !== 0 && dispatchQueue.push({ event, listeners });
}
function normalizeMarkupForTextOrAttribute(markup) {
  return (typeof markup === "string" ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
}
function noop$12() {
}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      typeof value === "string" ? tag === "body" || tag === "textarea" && value === "" || setTextContent(domElement, value) : (typeof value === "number" || typeof value === "bigint") && tag !== "body" && setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if (tag !== "object") {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if (value === "" && (tag !== "a" || key !== "href")) {
        domElement.removeAttribute(key);
        break;
      }
      if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean") {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if (typeof value === "function") {
        domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
        break;
      } else
        typeof prevValue === "function" && (key === "formAction" ? (tag !== "input" && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
      if (value == null || typeof value === "symbol" || typeof value === "boolean") {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      value != null && (domElement.onclick = noop$12);
      break;
    case "onScroll":
      value != null && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      value != null && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (value != null) {
        if (typeof value !== "object" || !("__html" in value))
          throw Error(formatProdErrorMessage2(61));
        key = value.__html;
        if (key != null) {
          if (props.children != null)
            throw Error(formatProdErrorMessage2(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple = value && typeof value !== "function" && typeof value !== "symbol";
      break;
    case "muted":
      domElement.muted = value && typeof value !== "function" && typeof value !== "symbol";
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (value == null || typeof value === "function" || typeof value === "boolean" || typeof value === "symbol") {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", key);
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      value != null && typeof value !== "function" && typeof value !== "symbol" ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && typeof value !== "function" && typeof value !== "symbol" ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      value === true ? domElement.setAttribute(key, "") : value !== false && value != null && typeof value !== "function" && typeof value !== "symbol" ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      value != null && typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      value == null || typeof value === "function" || typeof value === "symbol" || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:actuate", value);
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:arcrole", value);
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:role", value);
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:show", value);
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:title", value);
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:type", value);
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:base", value);
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:lang", value);
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:space", value);
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!(2 < key.length) || key[0] !== "o" && key[0] !== "O" || key[1] !== "n" && key[1] !== "N")
        key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (value != null) {
        if (typeof value !== "object" || !("__html" in value))
          throw Error(formatProdErrorMessage2(61));
        key = value.__html;
        if (key != null) {
          if (props.children != null)
            throw Error(formatProdErrorMessage2(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      typeof value === "string" ? setTextContent(domElement, value) : (typeof value === "number" || typeof value === "bigint") && setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      value != null && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      value != null && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      value != null && (domElement.onclick = noop$12);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if (key[0] === "o" && key[1] === "n" && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : undefined), prevValue = domElement[internalPropsKey] || null, prevValue = prevValue != null ? prevValue[key] : null, typeof prevValue === "function" && domElement.removeEventListener(tag, prevValue, props), typeof value === "function")) {
            typeof prevValue !== "function" && prevValue !== null && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement ? domElement[key] = value : value === true ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = false, hasSrcSet = false, propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "src":
                hasSrc = true;
                break;
              case "srcSet":
                hasSrcSet = true;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage2(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$188 = props[hasSrc];
          if (propValue$188 != null)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$188;
                break;
              case "type":
                propValue = propValue$188;
                break;
              case "checked":
                checked = propValue$188;
                break;
              case "defaultChecked":
                defaultChecked = propValue$188;
                break;
              case "value":
                propKey = propValue$188;
                break;
              case "defaultValue":
                defaultValue = propValue$188;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (propValue$188 != null)
                  throw Error(formatProdErrorMessage2(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$188, props, null);
            }
        }
      initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, false);
      track(domElement);
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], defaultValue != null))
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      tag != null ? updateOptions(domElement, !!hasSrc, tag, false) : props != null && updateOptions(domElement, !!hasSrc, props, true);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], defaultValue != null))
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (defaultValue != null)
                throw Error(formatProdErrorMessage2(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      track(domElement);
      return;
    case "option":
      for (checked in props)
        if (props.hasOwnProperty(checked) && (hasSrc = props[checked], hasSrc != null))
          switch (checked) {
            case "selected":
              domElement.selected = hasSrc && typeof hasSrc !== "function" && typeof hasSrc !== "symbol";
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0;hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], hasSrc != null))
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage2(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$188 in props)
          props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], hasSrc !== undefined && setPropOnCustomElement(domElement, tag, propValue$188, hasSrc, props, undefined));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], hasSrc != null && setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && lastProp != null)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$205 in nextProps) {
        var propKey = nextProps[propKey$205];
        lastProp = lastProps[propKey$205];
        if (nextProps.hasOwnProperty(propKey$205) && (propKey != null || lastProp != null))
          switch (propKey$205) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (propKey != null)
                throw Error(formatProdErrorMessage2(137, tag));
              break;
            default:
              propKey !== lastProp && setProp(domElement, tag, propKey$205, propKey, nextProps, lastProp);
          }
      }
      updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
      return;
    case "select":
      propKey = value = defaultValue = propKey$205 = null;
      for (type in lastProps)
        if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && lastDefaultValue != null)
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
          }
      for (name in nextProps)
        if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (type != null || lastDefaultValue != null))
          switch (name) {
            case "value":
              propKey$205 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      propKey$205 != null ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (tag != null ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
      return;
    case "textarea":
      propKey = propKey$205 = null;
      for (defaultValue in lastProps)
        if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && name != null && !nextProps.hasOwnProperty(defaultValue))
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (name != null || type != null))
          switch (value) {
            case "value":
              propKey$205 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (name != null)
                throw Error(formatProdErrorMessage2(91));
              break;
            default:
              name !== type && setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$205, propKey);
      return;
    case "option":
      for (var propKey$221 in lastProps)
        if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && propKey$205 != null && !nextProps.hasOwnProperty(propKey$221))
          switch (propKey$221) {
            case "selected":
              domElement.selected = false;
              break;
            default:
              setProp(domElement, tag, propKey$221, null, nextProps, propKey$205);
          }
      for (lastDefaultValue in nextProps)
        if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (propKey$205 != null || propKey != null))
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected = propKey$205 && typeof propKey$205 !== "function" && typeof propKey$205 !== "symbol";
              break;
            default:
              setProp(domElement, tag, lastDefaultValue, propKey$205, nextProps, propKey);
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$226 in lastProps)
        propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && propKey$205 != null && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
      for (checked in nextProps)
        if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (propKey$205 != null || propKey != null))
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (propKey$205 != null)
                throw Error(formatProdErrorMessage2(137, tag));
              break;
            default:
              setProp(domElement, tag, checked, propKey$205, nextProps, propKey);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$231 in lastProps)
          propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && propKey$205 !== undefined && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(domElement, tag, propKey$231, undefined, nextProps, propKey$205);
        for (defaultChecked in nextProps)
          propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || propKey$205 === undefined && propKey === undefined || setPropOnCustomElement(domElement, tag, defaultChecked, propKey$205, nextProps, propKey);
        return;
      }
  }
  for (var propKey$236 in lastProps)
    propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && propKey$205 != null && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
  for (lastProp in nextProps)
    propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || propKey$205 == null && propKey == null || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
}
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (parentNamespace === 0)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return parentNamespace === 1 && type === "foreignObject" ? 0 : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.children === "bigint" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && event.type === "popstate") {
    if (event === currentPopstateTransitionEvent)
      return false;
    currentPopstateTransitionEvent = event;
    return true;
  }
  currentPopstateTransitionEvent = null;
  return false;
}
function handleErrorInNextTick(error) {
  setTimeout(function() {
    throw error;
  });
}
function isSingletonScope(type) {
  return type === "head";
}
function clearSuspenseBoundary(parentInstance, suspenseInstance) {
  var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && nextNode.nodeType === 8)
      if (node = nextNode.data, node === "/$") {
        if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
          node = possiblePreambleContribution;
          var ownerDocument = parentInstance.ownerDocument;
          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
          node & 2 && releaseSingletonInstance(ownerDocument.body);
          if (node & 4)
            for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild;ownerDocument; ) {
              var { nextSibling: nextNode$jscomp$0, nodeName } = ownerDocument;
              ownerDocument[internalHoistableMarker] || nodeName === "SCRIPT" || nodeName === "STYLE" || nodeName === "LINK" && ownerDocument.rel.toLowerCase() === "stylesheet" || node.removeChild(ownerDocument);
              ownerDocument = nextNode$jscomp$0;
            }
        }
        if (depth === 0) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(suspenseInstance);
          return;
        }
        depth--;
      } else
        node === "$" || node === "$?" || node === "$!" ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
    else
      possiblePreambleContribution = 0;
    node = nextNode;
  } while (node);
  retryIfBlockedOn(suspenseInstance);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && nextNode.nodeType === 10 && (nextNode = nextNode.nextSibling);
  for (;nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if (node.rel.toLowerCase() === "stylesheet")
          continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (;instance.nodeType === 1; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (!inRootOrSingleton && (instance.nodeName !== "INPUT" || instance.type !== "hidden"))
        break;
    } else if (!inRootOrSingleton)
      if (type === "input" && instance.type === "hidden") {
        var name = anyProps.name == null ? null : "" + anyProps.name;
        if (anyProps.type === "hidden" && instance.getAttribute("name") === name)
          return instance;
      } else
        return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop"))
            break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if (name === "stylesheet" && instance.hasAttribute("data-precedence"))
            break;
          else if (name !== anyProps.rel || instance.getAttribute("href") !== (anyProps.href == null || anyProps.href === "" ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (anyProps.crossOrigin == null ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (anyProps.title == null ? null : anyProps.title))
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence"))
            break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if ((name !== (anyProps.src == null ? null : anyProps.src) || instance.getAttribute("type") !== (anyProps.type == null ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (anyProps.crossOrigin == null ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (instance === null)
      break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if (text === "")
    return null;
  for (;instance.nodeType !== 3; ) {
    if ((instance.nodeType !== 1 || instance.nodeName !== "INPUT" || instance.type !== "hidden") && !inRootOrSingleton)
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (instance === null)
      return null;
  }
  return instance;
}
function isSuspenseInstanceFallback(instance) {
  return instance.data === "$!" || instance.data === "$?" && instance.ownerDocument.readyState === "complete";
}
function registerSuspenseInstanceRetry(instance, callback) {
  var ownerDocument = instance.ownerDocument;
  if (instance.data !== "$?" || ownerDocument.readyState === "complete")
    callback();
  else {
    var listener = function() {
      callback();
      ownerDocument.removeEventListener("DOMContentLoaded", listener);
    };
    ownerDocument.addEventListener("DOMContentLoaded", listener);
    instance._reactRetry = listener;
  }
}
function getNextHydratable(node) {
  for (;node != null; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (nodeType === 1 || nodeType === 3)
      break;
    if (nodeType === 8) {
      nodeType = node.data;
      if (nodeType === "$" || nodeType === "$!" || nodeType === "$?" || nodeType === "F!" || nodeType === "F")
        break;
      if (nodeType === "/$")
        return null;
    }
  }
  return node;
}
function getParentSuspenseInstance(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0;targetInstance; ) {
    if (targetInstance.nodeType === 8) {
      var data = targetInstance.data;
      if (data === "$" || data === "$!" || data === "$?") {
        if (depth === 0)
          return targetInstance;
        depth--;
      } else
        data === "/$" && depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type)
        throw Error(formatProdErrorMessage2(452));
      return type;
    case "head":
      type = props.head;
      if (!type)
        throw Error(formatProdErrorMessage2(453));
      return type;
    case "body":
      type = props.body;
      if (!type)
        throw Error(formatProdErrorMessage2(454));
      return type;
    default:
      throw Error(formatProdErrorMessage2(451));
  }
}
function releaseSingletonInstance(instance) {
  for (var attributes = instance.attributes;attributes.length; )
    instance.removeAttributeNode(attributes[0]);
  detachDeletedInstance(instance);
}
function getHoistableRoot(container) {
  return typeof container.getRootNode === "function" ? container.getRootNode() : container.nodeType === 9 ? container : container.ownerDocument;
}
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  formInst !== null && formInst.tag === 5 && formInst.type === "form" ? requestFormReset$1(formInst) : previousDispatcher.r(form);
}
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && typeof href === "string" && href) {
    var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    typeof crossOrigin === "string" && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, ownerDocument.querySelector(limitedEscapedHref) === null && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
    as === "image" ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', typeof options.imageSizes === "string" && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) || (href = assign2({
      rel: "preload",
      href: as === "image" && options && options.imageSrcSet ? undefined : href,
      as
    }, options), preloadPropsMap.set(key, href), ownerDocument.querySelector(preloadSelector) !== null || as === "style" && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || as === "script" && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && typeof options.as === "string" ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (!preloadPropsMap.has(key) && (href = assign2({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), ownerDocument.querySelector(preloadSelector) === null)) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key)))
        state.loading = 5;
      else {
        href = assign2({ rel: "stylesheet", href, "data-precedence": precedence }, options);
        (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
        var link = resource = ownerDocument.createElement("link");
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function(resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function() {
          state.loading |= 1;
        });
        link.addEventListener("error", function() {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
      type: "script",
      instance: resource,
      count: 1,
      state: null
    }, scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
      type: "script",
      instance: resource,
      count: 1,
      state: null
    }, scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
  if (!JSCompiler_inline_result)
    throw Error(formatProdErrorMessage2(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return typeof pendingProps.precedence === "string" && typeof pendingProps.href === "string" ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
        type: "style",
        instance: null,
        count: 0,
        state: null
      }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (pendingProps.rel === "stylesheet" && typeof pendingProps.href === "string" && typeof pendingProps.precedence === "string") {
        type = getStyleKey(pendingProps.href);
        var styles$244 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, resource$245 = styles$244.get(type);
        resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
          type: "stylesheet",
          instance: null,
          count: 0,
          state: { loading: 0, preload: null }
        }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type))) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
          rel: "preload",
          as: "style",
          href: pendingProps.href,
          crossOrigin: pendingProps.crossOrigin,
          integrity: pendingProps.integrity,
          media: pendingProps.media,
          hrefLang: pendingProps.hrefLang,
          referrerPolicy: pendingProps.referrerPolicy
        }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(JSCompiler_inline_result, type, pendingProps, resource$245.state)));
        if (currentProps && currentResource === null)
          throw Error(formatProdErrorMessage2(528, ""));
        return resource$245;
      }
      if (currentProps && currentResource !== null)
        throw Error(formatProdErrorMessage2(529, ""));
      return null;
    case "script":
      return currentProps = pendingProps.async, pendingProps = pendingProps.src, typeof pendingProps === "string" && currentProps && typeof currentProps !== "function" && typeof currentProps !== "symbol" ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
        type: "script",
        instance: null,
        count: 0,
        state: null
      }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
    default:
      throw Error(formatProdErrorMessage2(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign2({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
    return state.loading |= 1;
  }), key.addEventListener("error", function() {
    return state.loading |= 2;
  }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (resource.instance === null)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
        if (instance)
          return resource.instance = instance, markNodeAsHoistable(instance), instance;
        var styleProps = assign2({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return resource.instance = instance;
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$250 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
        if (instance$250)
          return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
        markNodeAsHoistable(instance$250);
        var linkInstance = instance$250;
        linkInstance._p = new Promise(function(resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$250, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$250, props.precedence, hoistableRoot);
        return resource.instance = instance$250;
      case "script":
        instance$250 = getScriptKey(props.src);
        if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$250)))
          return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
        instance = props;
        if (styleProps = preloadPropsMap.get(instance$250))
          instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return resource.instance = styleProps;
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage2(443, resource.type));
    }
  else
    resource.type === "stylesheet" && (resource.state.loading & 4) === 0 && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root2) {
  for (var nodes = root2.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0;i < nodes.length; i++) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence)
      prior = node;
    else if (prior !== last)
      break;
  }
  prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = root2.nodeType === 9 ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  stylesheetProps.crossOrigin == null && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  stylesheetProps.referrerPolicy == null && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  stylesheetProps.title == null && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  scriptProps.crossOrigin == null && (scriptProps.crossOrigin = preloadProps.crossOrigin);
  scriptProps.referrerPolicy == null && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  scriptProps.integrity == null && (scriptProps.integrity = preloadProps.integrity);
}
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (tagCaches === null) {
    var cache = new Map;
    var caches = tagCaches = new Map;
    caches.set(ownerDocument, cache);
  } else
    caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map, caches.set(ownerDocument, cache));
  if (cache.has(type))
    return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0;caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (!(node[internalHoistableMarker] || node[internalInstanceKey] || type === "link" && node.getAttribute("rel") === "stylesheet") && node.namespaceURI !== "http://www.w3.org/2000/svg") {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(instance, type === "title" ? hoistableRoot.querySelector("head > title") : null);
}
function isHostHoistableType(type, props, hostContext) {
  if (hostContext === 1 || props.itemProp != null)
    return false;
  switch (type) {
    case "meta":
    case "title":
      return true;
    case "style":
      if (typeof props.precedence !== "string" || typeof props.href !== "string" || props.href === "")
        break;
      return true;
    case "link":
      if (typeof props.rel !== "string" || typeof props.href !== "string" || props.href === "" || props.onLoad || props.onError)
        break;
      switch (props.rel) {
        case "stylesheet":
          return type = props.disabled, typeof props.precedence === "string" && type == null;
        default:
          return true;
      }
    case "script":
      if (props.async && typeof props.async !== "function" && typeof props.async !== "symbol" && !props.onLoad && !props.onError && props.src && typeof props.src === "string")
        return true;
  }
  return false;
}
function preloadResource(resource) {
  return resource.type === "stylesheet" && (resource.state.loading & 3) === 0 ? false : true;
}
function noop3() {
}
function suspendResource(hoistableRoot, resource, props) {
  if (suspendedState === null)
    throw Error(formatProdErrorMessage2(475));
  var state = suspendedState;
  if (resource.type === "stylesheet" && (typeof props.media !== "string" || matchMedia(props.media).matches !== false) && (resource.state.loading & 4) === 0) {
    if (resource.instance === null) {
      var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
      if (instance) {
        hoistableRoot = instance._p;
        hoistableRoot !== null && typeof hoistableRoot === "object" && typeof hoistableRoot.then === "function" && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function(resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    state.stylesheets === null && (state.stylesheets = new Map);
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) && (resource.state.loading & 3) === 0 && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
  }
}
function waitForCommitToBeReady() {
  if (suspendedState === null)
    throw Error(formatProdErrorMessage2(475));
  var state = suspendedState;
  state.stylesheets && state.count === 0 && insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count ? function(commit) {
    var stylesheetTimer = setTimeout(function() {
      state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
      if (state.unsuspend) {
        var unsuspend = state.unsuspend;
        state.unsuspend = null;
        unsuspend();
      }
    }, 60000);
    state.unsuspend = commit;
    return function() {
      state.unsuspend = null;
      clearTimeout(stylesheetTimer);
    };
  } : null;
}
function onUnsuspend() {
  this.count--;
  if (this.count === 0) {
    if (this.stylesheets)
      insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
  }
}
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  state.unsuspend !== null && (state.count++, precedencesByRoot = new Map, resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root2, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root2);
    if (precedences)
      var last = precedences.get(null);
    else {
      precedences = new Map;
      precedencesByRoot.set(root2, precedences);
      for (var nodes = root2.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0;i < nodes.length; i++) {
        var node = nodes[i];
        if (node.nodeName === "LINK" || node.getAttribute("media") !== "not all")
          precedences.set(node.dataset.precedence, node), last = node;
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = root2.nodeType === 9 ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
    resource.state.loading |= 4;
  }
}
function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map;
}
function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
  containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
  tag = 1;
  isStrictMode === true && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent)
    return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
  parentComponent = getContextForSubtree(parentComponent);
  container.context === null ? container.context = parentComponent : container.pendingContext = parentComponent;
  container = createUpdate(lane);
  container.payload = { element };
  callback = callback === undefined ? null : callback;
  callback !== null && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  element !== null && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (fiber !== null && fiber.dehydrated !== null) {
    var a = fiber.retryLane;
    fiber.retryLane = a !== 0 && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (fiber.tag === 13) {
    var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
    root2 !== null && scheduleUpdateOnFiber(root2, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  var prevTransition = ReactSharedInternals3.T;
  ReactSharedInternals3.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals3.T = prevTransition;
  }
}
function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  var prevTransition = ReactSharedInternals3.T;
  ReactSharedInternals3.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals3.T = prevTransition;
  }
}
function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (blockedOn === null)
      dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
    else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent))
      nativeEvent.stopPropagation();
    else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
      for (;blockedOn !== null; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (fiber !== null)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (lanes !== 0) {
                  var root2 = fiber;
                  root2.pendingLanes |= 2;
                  for (root2.entangledLanes |= 2;lanes; ) {
                    var lane = 1 << 31 - clz32(lanes);
                    root2.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  (executionContext & 6) === 0 && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                }
              }
              break;
            case 13:
              root2 = enqueueConcurrentRenderForLane(fiber, 2), root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        fiber === null && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
        if (fiber === blockedOn)
          break;
        blockedOn = fiber;
      }
      blockedOn !== null && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (targetNode !== null) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (nearestMounted === null)
      targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (tag === 13) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (targetNode !== null)
          return targetNode;
        targetNode = null;
      } else if (tag === 3) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null;
        targetNode = null;
      } else
        nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent)
    return existingQueuedEvent = {
      blockedOn,
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetContainers: [targetContainer]
    }, blockedOn !== null && (blockedOn = getInstanceFromNode(blockedOn), blockedOn !== null && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  targetContainer !== null && blockedOn.indexOf(targetContainer) === -1 && blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  switch (domEventName) {
    case "focusin":
      return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
    case "dragenter":
      return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
    case "mouseover":
      return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
      return true;
    case "gotpointercapture":
      return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true;
  }
  return false;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (nearestMounted !== null) {
      if (targetInst = nearestMounted.tag, targetInst === 13) {
        if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), targetInst !== null) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function() {
            if (nearestMounted.tag === 13) {
              var lane = requestUpdateLane();
              lane = getBumpedLaneForHydrationByLane(lane);
              var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
              root2 !== null && scheduleUpdateOnFiber(root2, nearestMounted, lane);
              markRetryLaneIfNotHydrated(nearestMounted, lane);
            }
          });
          return;
        }
      } else if (targetInst === 3 && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
        queuedTarget.blockedOn = nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null;
        return;
      }
    }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (queuedEvent.blockedOn !== null)
    return false;
  for (var targetContainers = queuedEvent.targetContainers;0 < targetContainers.length; ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (nextBlockedOn === null) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return targetContainers = getInstanceFromNode(nextBlockedOn), targetContainers !== null && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
    targetContainers.shift();
  }
  return true;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = false;
  queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
  queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
  queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
}
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
    lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
    for (var i = 0;i < formReplayingQueue.length; i += 3) {
      var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
      if (typeof submitterOrAction !== "function")
        if (findInstanceBlockingTarget(submitterOrAction || form) === null)
          continue;
        else
          break;
      var formInst = getInstanceFromNode(form);
      formInst !== null && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(formInst, {
        pending: true,
        data: formData,
        method: form.method,
        action: submitterOrAction
      }, submitterOrAction, formData));
    }
  }));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0;i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (;0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], i.blockedOn === null); )
    attemptExplicitHydrationTarget(i), i.blockedOn === null && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (i != null)
    for (queuedTarget = 0;queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
      if (typeof submitterOrAction === "function")
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
            action = formProps.formAction;
          else {
            if (findInstanceBlockingTarget(form) !== null)
              continue;
          }
        else
          action = formProps.action;
        typeof action === "function" ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
var Scheduler, React2, ReactDOM, assign2, REACT_LEGACY_ELEMENT_TYPE, REACT_ELEMENT_TYPE2, REACT_PORTAL_TYPE3, REACT_FRAGMENT_TYPE2, REACT_STRICT_MODE_TYPE2, REACT_PROFILER_TYPE2, REACT_PROVIDER_TYPE, REACT_CONSUMER_TYPE2, REACT_CONTEXT_TYPE2, REACT_FORWARD_REF_TYPE2, REACT_SUSPENSE_TYPE2, REACT_SUSPENSE_LIST_TYPE, REACT_MEMO_TYPE2, REACT_LAZY_TYPE2, REACT_ACTIVITY_TYPE, REACT_MEMO_CACHE_SENTINEL, MAYBE_ITERATOR_SYMBOL2, REACT_CLIENT_REFERENCE, isArrayImpl2, ReactSharedInternals3, ReactDOMSharedInternals, sharedNotPendingObject, valueStack, index = -1, contextStackCursor, contextFiberStackCursor, rootInstanceStackCursor, hostTransitionProviderCursor, hasOwnProperty2, scheduleCallback$3, cancelCallback$1, shouldYield, requestPaint, now, getCurrentPriorityLevel, ImmediatePriority, UserBlockingPriority, NormalPriority$1, LowPriority, IdlePriority, log$1, unstable_setDisableYieldValue2, rendererID = null, injectedHook = null, clz32, log2, LN2, nextTransitionLane = 256, nextRetryLane = 4194304, randomKey, internalInstanceKey, internalPropsKey, internalContainerInstanceKey, internalEventHandlersKey, internalEventHandlerListenersKey, internalEventHandlesSetKey, internalRootNodeResourcesKey, internalHoistableMarker, allNativeEvents, registrationNameDependencies, VALID_ATTRIBUTE_NAME_REGEX, illegalAttributeNameCache, validatedAttributeNameCache, prefix, suffix, reentry = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex, unitlessNumbers, aliases, isJavaScriptProtocol, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM, passiveBrowserEventsSupported = false, options, root = null, startText = null, fallbackText = null, EventInterface, SyntheticEvent, UIEventInterface, SyntheticUIEvent, lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface, SyntheticMouseEvent, DragEventInterface, SyntheticDragEvent, FocusEventInterface, SyntheticFocusEvent, AnimationEventInterface, SyntheticAnimationEvent, ClipboardEventInterface, SyntheticClipboardEvent, CompositionEventInterface, SyntheticCompositionEvent, normalizeKey, translateToKey, modifierKeyToProp, KeyboardEventInterface, SyntheticKeyboardEvent, PointerEventInterface, SyntheticPointerEvent, TouchEventInterface, SyntheticTouchEvent, TransitionEventInterface, SyntheticTransitionEvent, WheelEventInterface, SyntheticWheelEvent, ToggleEventInterface, SyntheticToggleEvent, END_KEYCODES, canUseCompositionEvent, documentMode = null, canUseTextInputEvent, useFallbackCompositionData, SPACEBAR_CHAR, hasSpaceKeypress = false, isComposing = false, supportedInputTypes, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false, JSCompiler_inline_result$jscomp$282, isSupported$jscomp$inline_417, element$jscomp$inline_418, objectIs, skipSelectionChangeEvent, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes, prefixedEventNames, style, ANIMATION_END, ANIMATION_ITERATION, ANIMATION_START, TRANSITION_RUN, TRANSITION_START, TRANSITION_CANCEL, TRANSITION_END, topLevelEventsToReactNames, simpleEventPluginEvents, CapturedStacks, concurrentQueues, concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject, forkStack, forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack, idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException, valueCursor, currentlyRenderingFiber$1 = null, lastContextDependency = null, AbortControllerLocal, scheduleCallback$2, NormalPriority, CacheContext, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish, resumedCache, SuspenseException, SuspenseyCommitException, SuspenseActionException, noopSuspenseyCommitThenable, suspendedThenable = null, hasForceUpdate = false, didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor, prevEntangledRenderLanesCursor, renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, ContextOnlyDispatcher, HooksDispatcherOnMount, HooksDispatcherOnUpdate, HooksDispatcherOnRerender, thenableState = null, thenableIndexCounter = 0, reconcileChildFibers, mountChildFibers, suspenseHandlerStackCursor, shellBoundary = null, suspenseStackCursor, classComponentUpdater, reportGlobalError2, SelectiveHydrationException, didReceiveUpdate = false, SUSPENDED_MARKER, offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet, nextEffect = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher, PossiblyWeakMap, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, eventName$jscomp$inline_1529, domEventName$jscomp$inline_1530, capitalizedEvent$jscomp$inline_1531, i$jscomp$inline_1528, mediaEventTypes, nonDelegatedEvents, listeningMarker, NORMALIZE_NEWLINES_REGEX, NORMALIZE_NULL_AND_REPLACEMENT_REGEX, eventsEnabled = null, selectionInformation = null, currentPopstateTransitionEvent = null, scheduleTimeout, cancelTimeout, localPromise, scheduleMicrotask, previousHydratableOnEnteringScopedSingleton = null, preloadPropsMap, preconnectsSet, previousDispatcher, globalDocument, tagCaches = null, suspendedState = null, precedencesByRoot = null, HostTransitionContext, _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers, queuedPointerCaptures, queuedExplicitHydrationTargets, discreteReplayableEvents, lastScheduledReplayQueue = null, isomorphicReactPackageVersion$jscomp$inline_1785, internals$jscomp$inline_2256, hook$jscomp$inline_2257, $createRoot = function(container, options) {
  if (!isValidContainer(container))
    throw Error(formatProdErrorMessage2(299));
  var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
  options !== null && options !== undefined && (options.unstable_strictMode === true && (isStrictMode = true), options.identifierPrefix !== undefined && (identifierPrefix = options.identifierPrefix), options.onUncaughtError !== undefined && (onUncaughtError = options.onUncaughtError), options.onCaughtError !== undefined && (onCaughtError = options.onCaughtError), options.onRecoverableError !== undefined && (onRecoverableError = options.onRecoverableError), options.unstable_transitionCallbacks !== undefined && (transitionCallbacks = options.unstable_transitionCallbacks));
  options = createFiberRoot(container, 1, false, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMRoot(options);
}, $hydrateRoot = function(container, initialChildren, options) {
  if (!isValidContainer(container))
    throw Error(formatProdErrorMessage2(299));
  var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
  options !== null && options !== undefined && (options.unstable_strictMode === true && (isStrictMode = true), options.identifierPrefix !== undefined && (identifierPrefix = options.identifierPrefix), options.onUncaughtError !== undefined && (onUncaughtError = options.onUncaughtError), options.onCaughtError !== undefined && (onCaughtError = options.onCaughtError), options.onRecoverableError !== undefined && (onRecoverableError = options.onRecoverableError), options.unstable_transitionCallbacks !== undefined && (transitionCallbacks = options.unstable_transitionCallbacks), options.formState !== undefined && (formState = options.formState));
  initialChildren = createFiberRoot(container, 1, true, initialChildren, options != null ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  options = isStrictMode;
  initialChildren.current.lanes = options;
  markRootUpdated$1(initialChildren, options);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
}, $version3 = "19.1.0";
var init_react_dom_client_production = __esm(() => {
  Scheduler = __toESM(require_scheduler(), 1);
  React2 = __toESM(require_react(), 1);
  ReactDOM = __toESM(require_react_dom(), 1);
  assign2 = Object.assign;
  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
  REACT_ELEMENT_TYPE2 = Symbol.for("react.transitional.element");
  REACT_PORTAL_TYPE3 = Symbol.for("react.portal");
  REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
  REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode");
  REACT_PROFILER_TYPE2 = Symbol.for("react.profiler");
  REACT_PROVIDER_TYPE = Symbol.for("react.provider");
  REACT_CONSUMER_TYPE2 = Symbol.for("react.consumer");
  REACT_CONTEXT_TYPE2 = Symbol.for("react.context");
  REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref");
  REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense");
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
  REACT_MEMO_TYPE2 = Symbol.for("react.memo");
  REACT_LAZY_TYPE2 = Symbol.for("react.lazy");
  Symbol.for("react.scope");
  REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  Symbol.for("react.legacy_hidden");
  Symbol.for("react.tracing_marker");
  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  Symbol.for("react.view_transition");
  MAYBE_ITERATOR_SYMBOL2 = Symbol.iterator;
  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  isArrayImpl2 = Array.isArray;
  ReactSharedInternals3 = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  sharedNotPendingObject = {
    pending: false,
    data: null,
    method: null,
    action: null
  };
  valueStack = [];
  contextStackCursor = createCursor(null);
  contextFiberStackCursor = createCursor(null);
  rootInstanceStackCursor = createCursor(null);
  hostTransitionProviderCursor = createCursor(null);
  hasOwnProperty2 = Object.prototype.hasOwnProperty;
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
  cancelCallback$1 = Scheduler.unstable_cancelCallback;
  shouldYield = Scheduler.unstable_shouldYield;
  requestPaint = Scheduler.unstable_requestPaint;
  now = Scheduler.unstable_now;
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
  ImmediatePriority = Scheduler.unstable_ImmediatePriority;
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
  NormalPriority$1 = Scheduler.unstable_NormalPriority;
  LowPriority = Scheduler.unstable_LowPriority;
  IdlePriority = Scheduler.unstable_IdlePriority;
  log$1 = Scheduler.log;
  unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue;
  clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
  log2 = Math.log;
  LN2 = Math.LN2;
  randomKey = Math.random().toString(36).slice(2);
  internalInstanceKey = "__reactFiber$" + randomKey;
  internalPropsKey = "__reactProps$" + randomKey;
  internalContainerInstanceKey = "__reactContainer$" + randomKey;
  internalEventHandlersKey = "__reactEvents$" + randomKey;
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
  internalEventHandlesSetKey = "__reactHandles$" + randomKey;
  internalRootNodeResourcesKey = "__reactResources$" + randomKey;
  internalHoistableMarker = "__reactMarker$" + randomKey;
  allNativeEvents = new Set;
  registrationNameDependencies = {};
  VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  illegalAttributeNameCache = {};
  validatedAttributeNameCache = {};
  escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
  unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
  aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]);
  isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  canUseDOM = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined");
  if (canUseDOM)
    try {
      options = {};
      Object.defineProperty(options, "passive", {
        get: function() {
          passiveBrowserEventsSupported = true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (e) {
      passiveBrowserEventsSupported = false;
    }
  EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  };
  SyntheticEvent = createSyntheticEvent(EventInterface);
  UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 });
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
  MouseEventInterface = assign2({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function(event) {
      return event.relatedTarget === undefined ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
    },
    movementX: function(event) {
      if ("movementX" in event)
        return event.movementX;
      event !== lastMouseEvent && (lastMouseEvent && event.type === "mousemove" ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
      return lastMovementX;
    },
    movementY: function(event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  });
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
  DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 });
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
  FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 });
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
  AnimationEventInterface = assign2({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  });
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
  ClipboardEventInterface = assign2({}, EventInterface, {
    clipboardData: function(event) {
      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
    }
  });
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
  CompositionEventInterface = assign2({}, EventInterface, { data: 0 });
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  };
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  };
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  KeyboardEventInterface = assign2({}, UIEventInterface, {
    key: function(nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if (key !== "Unidentified")
          return key;
      }
      return nativeEvent.type === "keypress" ? (nativeEvent = getEventCharCode(nativeEvent), nativeEvent === 13 ? "Enter" : String.fromCharCode(nativeEvent)) : nativeEvent.type === "keydown" || nativeEvent.type === "keyup" ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      return event.type === "keypress" ? getEventCharCode(event) : 0;
    },
    keyCode: function(event) {
      return event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
    },
    which: function(event) {
      return event.type === "keypress" ? getEventCharCode(event) : event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
    }
  });
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
  PointerEventInterface = assign2({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  });
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
  TouchEventInterface = assign2({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  });
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
  TransitionEventInterface = assign2({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  });
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
  WheelEventInterface = assign2({}, MouseEventInterface, {
    deltaX: function(event) {
      return "deltaX" in event ? event.deltaX : ("wheelDeltaX" in event) ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return "deltaY" in event ? event.deltaY : ("wheelDeltaY" in event) ? -event.wheelDeltaY : ("wheelDelta" in event) ? -event.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  });
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
  ToggleEventInterface = assign2({}, EventInterface, {
    newState: 0,
    oldState: 0
  });
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
  END_KEYCODES = [9, 13, 27, 32];
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
  canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
  useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
  SPACEBAR_CHAR = String.fromCharCode(32);
  supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  if (canUseDOM) {
    if (canUseDOM) {
      isSupported$jscomp$inline_417 = "oninput" in document;
      if (!isSupported$jscomp$inline_417) {
        element$jscomp$inline_418 = document.createElement("div");
        element$jscomp$inline_418.setAttribute("oninput", "return;");
        isSupported$jscomp$inline_417 = typeof element$jscomp$inline_418.oninput === "function";
      }
      JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
    } else
      JSCompiler_inline_result$jscomp$282 = false;
    isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
  }
  objectIs = typeof Object.is === "function" ? Object.is : is;
  skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
  vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  prefixedEventNames = {};
  style = {};
  canUseDOM && (style = document.createElement("div").style, ("AnimationEvent" in window) || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), ("TransitionEvent" in window) || delete vendorPrefixes.transitionend.transition);
  ANIMATION_END = getVendorPrefixedEventName("animationend");
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
  ANIMATION_START = getVendorPrefixedEventName("animationstart");
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
  TRANSITION_START = getVendorPrefixedEventName("transitionstart");
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
  TRANSITION_END = getVendorPrefixedEventName("transitionend");
  topLevelEventsToReactNames = new Map;
  simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  simpleEventPluginEvents.push("scrollEnd");
  CapturedStacks = new WeakMap;
  concurrentQueues = [];
  emptyContextObject = {};
  forkStack = [];
  idStack = [];
  HydrationMismatchException = Error(formatProdErrorMessage2(519));
  valueCursor = createCursor(null);
  AbortControllerLocal = typeof AbortController !== "undefined" ? AbortController : function() {
    var listeners = [], signal = this.signal = {
      aborted: false,
      addEventListener: function(type, listener) {
        listeners.push(listener);
      }
    };
    this.abort = function() {
      signal.aborted = true;
      listeners.forEach(function(listener) {
        return listener();
      });
    };
  };
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
  NormalPriority = Scheduler.unstable_NormalPriority;
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE2,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  prevOnStartTransitionFinish = ReactSharedInternals3.S;
  ReactSharedInternals3.S = function(transition, returnValue) {
    typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && entangleAsyncAction(transition, returnValue);
    prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(transition, returnValue);
  };
  resumedCache = createCursor(null);
  SuspenseException = Error(formatProdErrorMessage2(460));
  SuspenseyCommitException = Error(formatProdErrorMessage2(474));
  SuspenseActionException = Error(formatProdErrorMessage2(542));
  noopSuspenseyCommitThenable = { then: function() {
  } };
  currentTreeHiddenStackCursor = createCursor(null);
  prevEntangledRenderLanesCursor = createCursor(0);
  ContextOnlyDispatcher = {
    readContext,
    use,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useInsertionEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useSyncExternalStore: throwInvalidHookError,
    useId: throwInvalidHookError,
    useHostTransitionStatus: throwInvalidHookError,
    useFormState: throwInvalidHookError,
    useActionState: throwInvalidHookError,
    useOptimistic: throwInvalidHookError,
    useMemoCache: throwInvalidHookError,
    useCacheRefresh: throwInvalidHookError
  };
  HooksDispatcherOnMount = {
    readContext,
    use,
    useCallback: function(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        deps === undefined ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function(ref, create, deps) {
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create, ref), deps);
    },
    useLayoutEffect: function(create, deps) {
      return mountEffectImpl(4194308, 4, create, deps);
    },
    useInsertionEffect: function(create, deps) {
      mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (init !== undefined) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else
        initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
      return [hook.memoizedState, reducer];
    },
    useRef: function(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    },
    useState: function(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    },
    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (getServerSnapshot === undefined)
          throw Error(formatProdErrorMessage2(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (workInProgressRoot === null)
          throw Error(formatProdErrorMessage2(349));
        (workInProgressRootRenderLanes & 124) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot), null);
      return getServerSnapshot;
    },
    useId: function() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
        identifierPrefix = "«" + identifierPrefix + "R" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "»";
      } else
        JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "«" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "»";
      return hook.memoizedState = identifierPrefix;
    },
    useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache,
    useCacheRefresh: function() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
    }
  };
  HooksDispatcherOnUpdate = {
    readContext,
    use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function() {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    },
    useTransition: function() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  };
  HooksDispatcherOnRerender = {
    readContext,
    use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function() {
      return rerenderReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return currentHook === null ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    },
    useTransition: function() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: rerenderActionState,
    useActionState: rerenderActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (currentHook !== null)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  };
  reconcileChildFibers = createChildReconciler(true);
  mountChildFibers = createChildReconciler(false);
  suspenseHandlerStackCursor = createCursor(null);
  suspenseStackCursor = createCursor(0);
  classComponentUpdater = {
    enqueueSetState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.payload = payload;
      callback !== undefined && callback !== null && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      payload !== null && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueReplaceState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 1;
      update.payload = payload;
      callback !== undefined && callback !== null && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      payload !== null && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueForceUpdate: function(inst, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 2;
      callback !== undefined && callback !== null && (update.callback = callback);
      callback = enqueueUpdate(inst, update, lane);
      callback !== null && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
    }
  };
  reportGlobalError2 = typeof reportError === "function" ? reportError : function(error) {
    if (typeof window === "object" && typeof window.ErrorEvent === "function") {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event))
        return;
    } else if (typeof process === "object" && typeof process.emit === "function") {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  };
  SelectiveHydrationException = Error(formatProdErrorMessage2(461));
  SUSPENDED_MARKER = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
  DefaultAsyncDispatcher = {
    getCacheForType: function(resourceType) {
      var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
      cacheForType === undefined && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
      return cacheForType;
    }
  };
  PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
  for (i$jscomp$inline_1528 = 0;i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
    eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
    registerSimpleEvent(domEventName$jscomp$inline_1530, "on" + capitalizedEvent$jscomp$inline_1531);
  }
  registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
  registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
  registerSimpleEvent(ANIMATION_START, "onAnimationStart");
  registerSimpleEvent("dblclick", "onDoubleClick");
  registerSimpleEvent("focusin", "onFocus");
  registerSimpleEvent("focusout", "onBlur");
  registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
  registerSimpleEvent(TRANSITION_START, "onTransitionStart");
  registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
  registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
  registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  registerTwoPhaseEvent("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
  nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
  listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
  NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
  scheduleTimeout = typeof setTimeout === "function" ? setTimeout : undefined;
  cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : undefined;
  localPromise = typeof Promise === "function" ? Promise : undefined;
  scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
    return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
  } : scheduleTimeout;
  preloadPropsMap = new Map;
  preconnectsSet = new Set;
  previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: flushSyncWork,
    r: requestFormReset,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  globalDocument = typeof document === "undefined" ? null : document;
  HostTransitionContext = {
    $$typeof: REACT_CONTEXT_TYPE2,
    Provider: null,
    Consumer: null,
    _currentValue: sharedNotPendingObject,
    _currentValue2: sharedNotPendingObject,
    _threadCount: 0
  };
  queuedPointers = new Map;
  queuedPointerCaptures = new Map;
  queuedExplicitHydrationTargets = [];
  discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
    var root2 = this._internalRoot;
    if (root2 === null)
      throw Error(formatProdErrorMessage2(409));
    var current = root2.current, lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root2, null, null);
  };
  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
    var root2 = this._internalRoot;
    if (root2 !== null) {
      this._internalRoot = null;
      var container = root2.containerInfo;
      updateContainerImpl(root2.current, 2, null, root2, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
    if (target) {
      var updatePriority = resolveUpdatePriority();
      target = { blockedOn: null, target, priority: updatePriority };
      for (var i = 0;i < queuedExplicitHydrationTargets.length && updatePriority !== 0 && updatePriority < queuedExplicitHydrationTargets[i].priority; i++)
        ;
      queuedExplicitHydrationTargets.splice(i, 0, target);
      i === 0 && attemptExplicitHydrationTarget(target);
    }
  };
  isomorphicReactPackageVersion$jscomp$inline_1785 = React2.version;
  if (isomorphicReactPackageVersion$jscomp$inline_1785 !== "19.1.0")
    throw Error(formatProdErrorMessage2(527, isomorphicReactPackageVersion$jscomp$inline_1785, "19.1.0"));
  ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
    var fiber = componentOrElement._reactInternals;
    if (fiber === undefined) {
      if (typeof componentOrElement.render === "function")
        throw Error(formatProdErrorMessage2(188));
      componentOrElement = Object.keys(componentOrElement).join(",");
      throw Error(formatProdErrorMessage2(268, componentOrElement));
    }
    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
    componentOrElement = componentOrElement !== null ? findCurrentHostFiberImpl(componentOrElement) : null;
    componentOrElement = componentOrElement === null ? null : componentOrElement.stateNode;
    return componentOrElement;
  };
  internals$jscomp$inline_2256 = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: ReactSharedInternals3,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
    hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
      try {
        rendererID = hook$jscomp$inline_2257.inject(internals$jscomp$inline_2256), injectedHook = hook$jscomp$inline_2257;
      } catch (err) {
      }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS((exports, module) => {
  init_react_dom_client_production();
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    if (false) {
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  if (true) {
    checkDCE();
    module.exports = exports_react_dom_client_production;
  } else {
  }
});

// node_modules/typescript-result/dist/index.js
function isPromise(value) {
  if (value === null || value === undefined) {
    return false;
  }
  if (typeof value !== "object") {
    return false;
  }
  return value instanceof Promise || "then" in value;
}
function isFunction(value) {
  return typeof value === "function";
}
function isAsyncFn(fn) {
  return fn.constructor.name === "AsyncFunction";
}
var AsyncResult, Result = class _Result {
  constructor(_value, _error) {
    this._value = _value;
    this._error = _error;
  }
  get isResult() {
    return true;
  }
  get value() {
    return this._value;
  }
  get error() {
    return this._error;
  }
  get success() {
    return this.error === undefined;
  }
  get failure() {
    return this.error !== undefined;
  }
  isOk() {
    return this.success;
  }
  isError() {
    return this.failure;
  }
  toTuple() {
    return [this._value ?? null, this._error ?? null];
  }
  errorOrNull() {
    return this.failure ? this._error : null;
  }
  getOrNull() {
    return this.success ? this._value : null;
  }
  getOrDefault(defaultValue) {
    return this.success ? this._value : defaultValue;
  }
  getOrElse(onFailure) {
    if (isAsyncFn(onFailure)) {
      return this.success ? Promise.resolve(this._value) : onFailure(this._error);
    }
    return this.success ? this._value : onFailure(this._error);
  }
  getOrThrow() {
    if (this.success) {
      return this._value;
    }
    throw this._error;
  }
  fold(onSuccess, onFailure) {
    const isAsync = isAsyncFn(onSuccess) || isAsyncFn(onFailure);
    const outcome = this.success ? onSuccess(this._value) : onFailure(this._error);
    return isAsync && !isPromise(outcome) ? Promise.resolve(outcome) : outcome;
  }
  onFailure(action) {
    const isAsync = isAsyncFn(action);
    if (this.failure) {
      const outcome = action(this._error);
      if (isAsync) {
        return new AsyncResult((resolve) => {
          outcome.then(() => resolve(_Result.error(this._error)));
        });
      }
      return this;
    }
    return isAsync ? AsyncResult.ok(this._value) : this;
  }
  onSuccess(action) {
    const isAsync = isAsyncFn(action);
    if (this.success) {
      const outcome = action(this._value);
      if (isAsync) {
        return new AsyncResult((resolve) => {
          outcome.then(() => resolve(_Result.ok(this._value)));
        });
      }
      return this;
    }
    return isAsync ? AsyncResult.error(this._error) : this;
  }
  map(transform) {
    return this.success ? _Result.run(() => transform(this._value)) : isAsyncFn(transform) ? AsyncResult.error(this._error) : this;
  }
  mapCatching(transformValue, transformError) {
    return this.success ? _Result.try(() => transformValue(this._value), transformError) : this;
  }
  mapError(transform) {
    if (this.success) {
      return this;
    }
    return _Result.error(transform(this._error));
  }
  recover(onFailure) {
    return this.success ? isAsyncFn(onFailure) ? AsyncResult.ok(this._value) : this : _Result.run(() => onFailure(this._error));
  }
  recoverCatching(onFailure) {
    return this.success ? isAsyncFn(onFailure) ? AsyncResult.ok(this._value) : this : _Result.try(() => onFailure(this._error));
  }
  toString() {
    if (this.success) {
      return `Result.ok(${this._value})`;
    }
    return `Result.error(${this.error})`;
  }
  static ok(value) {
    return new _Result(value, undefined);
  }
  static error(error) {
    return new _Result(undefined, error);
  }
  static isResult(possibleResult) {
    return possibleResult instanceof _Result;
  }
  static isAsyncResult(possibleAsyncResult) {
    return possibleAsyncResult instanceof AsyncResult;
  }
  static run(fn) {
    const returnValue = fn();
    if (isPromise(returnValue)) {
      return AsyncResult.fromPromise(returnValue);
    }
    return _Result.isResult(returnValue) ? returnValue : _Result.ok(returnValue);
  }
  static allInternal(items, opts) {
    const runner = opts.catching ? _Result.try : _Result.run;
    const flattened = [];
    let isAsync = items.some(isPromise);
    let hasFailure = false;
    for (const item of items) {
      if (isFunction(item)) {
        if (hasFailure) {
          continue;
        }
        const returnValue = runner(item);
        if (_Result.isResult(returnValue) && returnValue.isError()) {
          hasFailure = true;
          if (!isAsync) {
            return returnValue;
          }
        }
        if (_Result.isAsyncResult(returnValue)) {
          isAsync = true;
        }
        flattened.push(returnValue);
      } else if (_Result.isResult(item)) {
        if (item.isError()) {
          hasFailure = true;
          if (!isAsync) {
            return item;
          }
        }
        flattened.push(item);
      } else if (_Result.isAsyncResult(item)) {
        isAsync = true;
        flattened.push(item);
      } else if (isPromise(item)) {
        isAsync = true;
        flattened.push(opts.catching ? AsyncResult.fromPromiseCatching(item) : AsyncResult.fromPromise(item));
      } else {
        flattened.push(_Result.ok(item));
      }
    }
    if (isAsync) {
      return new AsyncResult((resolve, reject) => {
        const asyncResults = [];
        const asyncIndexes = [];
        for (let i = 0;i < flattened.length; i++) {
          const item = flattened[i];
          if (_Result.isAsyncResult(item)) {
            asyncResults.push(item);
            asyncIndexes.push(i);
          }
        }
        Promise.all(asyncResults).then((resolvedResults) => {
          const merged = [...flattened];
          for (let i = 0;i < resolvedResults.length; i++) {
            merged[asyncIndexes[i]] = resolvedResults[i];
          }
          const firstFailedResult = merged.find((resolvedResult) => resolvedResult.isError());
          if (firstFailedResult) {
            resolve(firstFailedResult);
            return;
          }
          resolve(_Result.ok(merged.map((result) => result.getOrNull())));
        }).catch((reason) => {
          reject(reason);
        });
      });
    }
    return _Result.ok(flattened.map((result) => result.getOrNull()));
  }
  static all(...items) {
    return _Result.allInternal(items, {
      catching: false
    });
  }
  static allCatching(...items) {
    return _Result.allInternal(items, {
      catching: true
    });
  }
  static wrap(fn) {
    return function wrapped(...args) {
      return _Result.try(() => fn(...args));
    };
  }
  static try(fn, transform) {
    try {
      const returnValue = fn();
      if (isPromise(returnValue)) {
        return AsyncResult.fromPromiseCatching(returnValue, transform);
      }
      return _Result.isResult(returnValue) ? returnValue : _Result.ok(returnValue);
    } catch (caughtError) {
      return _Result.error(transform?.(caughtError) ?? caughtError);
    }
  }
  static fromAsync(value) {
    return _Result.run(() => value);
  }
  static fromAsyncCatching(value) {
    return _Result.try(() => value);
  }
  static assertOk(result) {
    if (result.isError()) {
      throw new Error("Expected a successful result, but got an error instead");
    }
  }
  static assertError(result) {
    if (result.isOk()) {
      throw new Error("Expected a failed result, but got a value instead");
    }
  }
};
var init_dist = __esm(() => {
  AsyncResult = class _AsyncResult extends Promise {
    get isAsyncResult() {
      return true;
    }
    async toTuple() {
      const result = await this;
      return result.toTuple();
    }
    async errorOrNull() {
      const result = await this;
      return result.errorOrNull();
    }
    async getOrNull() {
      const result = await this;
      return result.getOrNull();
    }
    async getOrDefault(defaultValue) {
      const result = await this;
      return result.getOrDefault(defaultValue);
    }
    async getOrElse(onFailure) {
      const result = await this;
      return result.getOrElse(onFailure);
    }
    async getOrThrow() {
      const result = await this;
      return result.getOrThrow();
    }
    async fold(onSuccess, onFailure) {
      const result = await this;
      return result.fold(onSuccess, onFailure);
    }
    onFailure(action) {
      return new _AsyncResult((resolve, reject) => this.then(async (result) => {
        try {
          if (result.isError()) {
            await action(result.error);
          }
          resolve(result);
        } catch (e) {
          reject(e);
        }
      }).catch(reject));
    }
    onSuccess(action) {
      return new _AsyncResult((resolve, reject) => this.then(async (result) => {
        try {
          if (result.isOk()) {
            await action(result.value);
          }
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }).catch(reject));
    }
    map(transform) {
      return new _AsyncResult((resolve, reject) => this.then((result) => {
        if (result.isOk()) {
          try {
            const returnValue = transform(result.value);
            if (isPromise(returnValue)) {
              returnValue.then((value) => resolve(Result.isResult(value) ? value : Result.ok(value))).catch(reject);
            } else {
              resolve(Result.isResult(returnValue) ? returnValue : Result.ok(returnValue));
            }
          } catch (error) {
            reject(error);
          }
        } else {
          resolve(result);
        }
      }).catch(reject));
    }
    mapCatching(transformValue, transformError) {
      return new _AsyncResult((resolve, reject) => {
        this.map(transformValue).then((result) => resolve(result)).catch((error) => {
          try {
            resolve(Result.error(transformError ? transformError(error) : error));
          } catch (err) {
            reject(err);
          }
        });
      });
    }
    mapError(transform) {
      return new _AsyncResult((resolve, reject) => this.then(async (result) => {
        try {
          resolve(result.mapError(transform));
        } catch (error) {
          reject(error);
        }
      }).catch(reject));
    }
    recover(onFailure) {
      return new _AsyncResult((resolve, reject) => this.then(async (result) => {
        try {
          const outcome = await result.recover(onFailure);
          resolve(outcome);
        } catch (error) {
          reject(error);
        }
      }).catch(reject));
    }
    recoverCatching(onFailure) {
      return new _AsyncResult((resolve, reject) => this.then((result) => {
        resolve(result.recoverCatching(onFailure));
      }).catch(reject));
    }
    toString() {
      return "AsyncResult";
    }
    static error(error) {
      return new _AsyncResult((resolve) => resolve(Result.error(error)));
    }
    static ok(value) {
      return new _AsyncResult((resolve) => resolve(Result.ok(value)));
    }
    static fromPromise(promise) {
      return new _AsyncResult((resolve, reject) => {
        promise.then((value) => resolve(Result.isResult(value) ? value : Result.ok(value))).catch(reject);
      });
    }
    static fromPromiseCatching(promise, transform) {
      return new _AsyncResult((resolve) => {
        promise.then((value) => resolve(Result.isResult(value) ? value : Result.ok(value))).catch((caughtError) => {
          resolve(Result.error(transform?.(caughtError) ?? caughtError));
        });
      });
    }
  };
});

// src/studio/utils.ts
async function handleStudioFunc(studioFunction, ...functionArgs) {
  const result = await Result.wrap(studioFunction)(...functionArgs);
  return result.map((er) => {
    if (er.success) {
      const data = er.parsedData;
      if (data == null) {
        return Result.error(Error(`parsedData is null`));
      } else {
        return data;
      }
    } else {
      return Result.error(Error(`Studio Returned Error ${er.status}:${er.error}`));
    }
  });
}
var init_utils = __esm(() => {
  init_dist();
});

// node_modules/@chili-publish/studio-sdk/_bundles/main.js
var require_main = __commonJS((exports, module) => {
  (function(root2, factory) {
    typeof exports == "object" && typeof module == "object" ? module.exports = factory() : typeof define == "function" && define.amd ? define("StudioSDK", [], factory) : typeof exports == "object" ? exports.StudioSDK = factory() : root2.StudioSDK = factory();
  })(exports, () => (() => {
    var __webpack_require__ = { d: (exports2, definition) => {
      for (var key in definition)
        __webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key) && Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
    }, o: (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), r: (exports2) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(exports2, "__esModule", { value: true });
    } }, __webpack_exports__ = {};
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, { ActionAsyncError: () => ActionAsyncError, ActionEditorEvent: () => ActionEditorEvent, Alignment: () => Alignment, AnchorTargetEdgeType: () => AnchorTargetEdgeType, AnchorTargetType: () => AnchorTargetType, AuthCredentialsTypeEnum: () => AuthCredentialsTypeEnum, AuthRefreshTypeEnum: () => AuthRefreshTypeEnum, AutoGrowDirection: () => AutoGrowDirection, BarcodeCharacterSet: () => BarcodeCharacterSet, BarcodeErrorCorrectionLevel: () => BarcodeErrorCorrectionLevel, BarcodeSourceTypeEnum: () => BarcodeSourceTypeEnum, BarcodeType: () => BarcodeType, BarcodeValidationResult: () => BarcodeValidationResult, BasicAnimationsEmphasisStyles: () => BasicAnimationsEmphasisStyles, BlendMode: () => BlendMode, Case: () => Case, ColorType: () => ColorType, ColorUsageType: () => ColorUsageType, ConnectorConfigValueType: () => ConnectorConfigValueType, ConnectorEventType: () => ConnectorEventType, ConnectorHttpError: () => ConnectorHttpError, ConnectorMapping: () => ConnectorMapping, ConnectorMappingDirection: () => ConnectorMappingDirection, ConnectorMappingSource: () => ConnectorMappingSource, ConnectorRegistrationSource: () => ConnectorRegistrationSource, ConnectorStateType: () => ConnectorStateType, ConnectorType: () => ConnectorType, CornerRadiusType: () => CornerRadiusType, DataRowAsyncError: () => DataRowAsyncError, Day: () => Day, DeprecatedMediaConnectorDownloadType: () => DeprecatedMediaConnectorDownloadType, DeprecatedMediaType: () => DeprecatedMediaType, DocumentIssueTypeEnum: () => DocumentIssueTypeEnum, DocumentType: () => DocumentType, DownloadFormats: () => DownloadFormats, EaseTypes: () => EaseTypes, EngineEditModeType: () => EngineEditModeType, EnvironmentType: () => EnvironmentType, FitMode: () => FitMode, FitModePosition: () => FitModePosition, FlowDirection: () => FlowDirection, FontPreviewFormat: () => FontPreviewFormat, FontWeights: () => FontWeights, FrameAnchorTarget: () => FrameAnchorTarget, FrameAnchorType: () => FrameAnchorType, FramePropertyNames: () => FramePropertyNames, FrameTypeEnum: () => FrameTypeEnum, GrafxTokenAuthCredentials: () => GrafxTokenAuthCredentials, ImageSourceTypeEnum: () => ImageSourceTypeEnum, LayoutIntent: () => LayoutIntent, LayoutPropertyNames: () => LayoutPropertyNames, LayoutType: () => LayoutType, Locale: () => Locale, MeasurementUnit: () => MeasurementUnit, MediaDownloadIntent: () => MediaDownloadIntent, MediaDownloadType: () => MediaDownloadType, MediaType: () => MediaType, PageAnchorTarget: () => PageAnchorTarget, PositionEnum: () => PositionEnum, RefreshedAuthCredendentials: () => RefreshedAuthCredendentials, Scripting: () => Scripting, SelectedTextStyleSections: () => SelectedTextStyleSections, SelectedTextStyles: () => SelectedTextStyles, ShakeDirections: () => ShakeDirections, ShapeType: () => ShapeType, SlideDirections: () => SlideDirections, SortBy: () => SortBy, SortOrder: () => SortOrder, TextDirection: () => TextDirection, TextPosition: () => TextPosition, ToolType: () => ToolType, TweenTypes: () => TweenTypes, UpdateZIndexMethod: () => UpdateZIndexMethod, VariableType: () => VariableType, VariableVisibilityOperator: () => VariableVisibilityOperator, VariableVisibilityTargetType: () => VariableVisibilityTargetType, VariableVisibilityType: () => VariableVisibilityType, VerticalAlign: () => VerticalAlign, ViewMode: () => ViewMode, WellKnownConfigurationKeys: () => WellKnownConfigurationKeys, default: () => src, grafxMediaConnectorRegistration: () => grafxMediaConnectorRegistration });
    const editor_engine_namespaceObject_V = "2.6.latest", package_namespaceObject_i8 = "1.23.0";
    var enums_MessageType, Resolution, ErrorCode, NativeErrorName, enums_NativeEventType;
    (function(MessageType) {
      MessageType.Call = "call", MessageType.Reply = "reply", MessageType.Syn = "syn", MessageType.SynAck = "synAck", MessageType.Ack = "ack";
    })(enums_MessageType || (enums_MessageType = {})), function(Resolution2) {
      Resolution2.Fulfilled = "fulfilled", Resolution2.Rejected = "rejected";
    }(Resolution || (Resolution = {})), function(ErrorCode2) {
      ErrorCode2.ConnectionDestroyed = "ConnectionDestroyed", ErrorCode2.ConnectionTimeout = "ConnectionTimeout", ErrorCode2.NoIframeSrc = "NoIframeSrc";
    }(ErrorCode || (ErrorCode = {})), function(NativeErrorName2) {
      NativeErrorName2.DataCloneError = "DataCloneError";
    }(NativeErrorName || (NativeErrorName = {})), function(NativeEventType) {
      NativeEventType.Message = "message";
    }(enums_NativeEventType || (enums_NativeEventType = {}));
    const DEFAULT_PORT_BY_PROTOCOL = { "http:": "80", "https:": "443" }, URL_REGEX = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/, opaqueOriginSchemes = ["file:", "data:"], serializeError = ({ name, message, stack }) => ({ name, message, stack });
    let id = 0;
    const generateId = () => ++id, keyPathToSegments = (keyPath) => keyPath ? keyPath.split(".") : [], setAtKeyPath = (subject, keyPath, value) => {
      const segments = keyPathToSegments(keyPath);
      return segments.reduce((prevSubject, key, idx) => (prevSubject[key] === undefined && (prevSubject[key] = {}), idx === segments.length - 1 && (prevSubject[key] = value), prevSubject[key]), subject), subject;
    }, methodSerialization_serializeMethods = (methods, prefix2) => {
      const flattenedMethods = {};
      return Object.keys(methods).forEach((key) => {
        const value = methods[key], keyPath = ((key2, prefix3) => {
          const segments = keyPathToSegments(prefix3 || "");
          return segments.push(key2), ((segments2) => segments2.join("."))(segments);
        })(key, prefix2);
        typeof value == "object" && Object.assign(flattenedMethods, methodSerialization_serializeMethods(value, keyPath)), typeof value == "function" && (flattenedMethods[keyPath] = value);
      }), flattenedMethods;
    }, lib_connectCallSender = (callSender, info, methodKeyPaths, destroyConnection, log3) => {
      const { localName, local, remote, originForSending, originForReceiving } = info;
      let destroyed = false;
      log3(`${localName}: Connecting call sender`);
      const createMethodProxy = (methodName) => (...args) => {
        let iframeRemoved;
        log3(`${localName}: Sending ${methodName}() call`);
        try {
          remote.closed && (iframeRemoved = true);
        } catch (e) {
          iframeRemoved = true;
        }
        if (iframeRemoved && destroyConnection(), destroyed) {
          const error = new Error(`Unable to send ${methodName}() call due to destroyed connection`);
          throw error.code = ErrorCode.ConnectionDestroyed, error;
        }
        return new Promise((resolve, reject) => {
          const id2 = generateId(), handleMessageEvent = (event) => {
            if (event.source !== remote || event.data.penpal !== enums_MessageType.Reply || event.data.id !== id2)
              return;
            if (event.origin !== originForReceiving)
              return void log3(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
            const replyMessage = event.data;
            log3(`${localName}: Received ${methodName}() reply`), local.removeEventListener(enums_NativeEventType.Message, handleMessageEvent);
            let returnValue = replyMessage.returnValue;
            replyMessage.returnValueIsError && (returnValue = ((obj) => {
              const deserializedError = new Error;
              return Object.keys(obj).forEach((key) => deserializedError[key] = obj[key]), deserializedError;
            })(returnValue)), (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);
          };
          local.addEventListener(enums_NativeEventType.Message, handleMessageEvent);
          const callMessage = { penpal: enums_MessageType.Call, id: id2, methodName, args };
          remote.postMessage(callMessage, originForSending);
        });
      }, flattenedMethods = methodKeyPaths.reduce((api, name) => (api[name] = createMethodProxy(name), api), {});
      return Object.assign(callSender, ((flattenedMethods2) => {
        const methods = {};
        for (const keyPath in flattenedMethods2)
          setAtKeyPath(methods, keyPath, flattenedMethods2[keyPath]);
        return methods;
      })(flattenedMethods)), () => {
        destroyed = true;
      };
    }, handleAckMessageFactory = (serializedMethods, childOrigin, originForSending, destructor, log3) => {
      const { destroy, onDestroy } = destructor;
      let destroyCallReceiver, receiverMethodNames;
      const callSender = {};
      return (event) => {
        if (event.origin !== childOrigin)
          return void log3(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
        log3("Parent: Handshake - Received ACK");
        const info = { localName: "Parent", local: window, remote: event.source, originForSending, originForReceiving: childOrigin };
        destroyCallReceiver && destroyCallReceiver(), destroyCallReceiver = ((info2, serializedMethods2, log4) => {
          const { localName, local, remote, originForSending: originForSending2, originForReceiving } = info2;
          let destroyed = false;
          const handleMessageEvent = (event2) => {
            if (event2.source !== remote || event2.data.penpal !== enums_MessageType.Call)
              return;
            if (event2.origin !== originForReceiving)
              return void log4(`${localName} received message from origin ${event2.origin} which did not match expected origin ${originForReceiving}`);
            const callMessage = event2.data, { methodName, args, id: id2 } = callMessage;
            log4(`${localName}: Received ${methodName}() call`);
            const createPromiseHandler = (resolution) => (returnValue) => {
              if (log4(`${localName}: Sending ${methodName}() reply`), destroyed)
                return void log4(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);
              const message = { penpal: enums_MessageType.Reply, id: id2, resolution, returnValue };
              resolution === Resolution.Rejected && returnValue instanceof Error && (message.returnValue = serializeError(returnValue), message.returnValueIsError = true);
              try {
                remote.postMessage(message, originForSending2);
              } catch (err) {
                if (err.name === NativeErrorName.DataCloneError) {
                  const errorReplyMessage = { penpal: enums_MessageType.Reply, id: id2, resolution: Resolution.Rejected, returnValue: serializeError(err), returnValueIsError: true };
                  remote.postMessage(errorReplyMessage, originForSending2);
                }
                throw err;
              }
            };
            new Promise((resolve) => resolve(serializedMethods2[methodName].apply(serializedMethods2, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));
          };
          return local.addEventListener(enums_NativeEventType.Message, handleMessageEvent), () => {
            destroyed = true, local.removeEventListener(enums_NativeEventType.Message, handleMessageEvent);
          };
        })(info, serializedMethods, log3), onDestroy(destroyCallReceiver), receiverMethodNames && receiverMethodNames.forEach((receiverMethodName) => {
          delete callSender[receiverMethodName];
        }), receiverMethodNames = event.data.methodNames;
        const destroyCallSender = lib_connectCallSender(callSender, info, receiverMethodNames, destroy, log3);
        return onDestroy(destroyCallSender), callSender;
      };
    }, connectToChild = (options) => {
      let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;
      const log3 = ((debug2) => (...args) => {
        debug2 && console.log("[Penpal]", ...args);
      })(debug), destructor = ((localName, log4) => {
        const callbacks = [];
        let destroyed = false;
        return { destroy(error) {
          destroyed || (destroyed = true, log4(`${localName}: Destroying connection`), callbacks.forEach((callback) => {
            callback(error);
          }));
        }, onDestroy(callback) {
          destroyed ? callback() : callbacks.push(callback);
        } };
      })("Parent", log3), { onDestroy, destroy } = destructor;
      childOrigin || (((iframe2) => {
        if (!iframe2.src && !iframe2.srcdoc) {
          const error = new Error("Iframe must have src or srcdoc property defined.");
          throw error.code = ErrorCode.NoIframeSrc, error;
        }
      })(iframe), childOrigin = ((src2) => {
        if (src2 && opaqueOriginSchemes.find((scheme) => src2.startsWith(scheme)))
          return "null";
        const location = document.location, regexResult = URL_REGEX.exec(src2);
        let protocol, hostname, port;
        return regexResult ? (protocol = regexResult[1] ? regexResult[1] : location.protocol, hostname = regexResult[2], port = regexResult[4]) : (protocol = location.protocol, hostname = location.hostname, port = location.port), `${protocol}//${hostname}${port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : ""}`;
      })(iframe.src));
      const originForSending = childOrigin === "null" ? "*" : childOrigin, serializedMethods = methodSerialization_serializeMethods(methods), handleSynMessage = ((log4, serializedMethods2, childOrigin2, originForSending2) => (event) => {
        if (event.origin !== childOrigin2)
          return void log4(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin2}`);
        log4("Parent: Handshake - Received SYN, responding with SYN-ACK");
        const synAckMessage = { penpal: enums_MessageType.SynAck, methodNames: Object.keys(serializedMethods2) };
        event.source.postMessage(synAckMessage, originForSending2);
      })(log3, serializedMethods, childOrigin, originForSending), handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log3), promise = new Promise((resolve, reject) => {
        const stopConnectionTimeout = ((timeout2, callback) => {
          let timeoutId;
          return timeout2 !== undefined && (timeoutId = window.setTimeout(() => {
            const error = new Error(`Connection timed out after ${timeout2}ms`);
            error.code = ErrorCode.ConnectionTimeout, callback(error);
          }, timeout2)), () => {
            clearTimeout(timeoutId);
          };
        })(timeout, destroy), handleMessage = (event) => {
          if (event.source === iframe.contentWindow && event.data)
            if (event.data.penpal !== enums_MessageType.Syn)
              if (event.data.penpal !== enums_MessageType.Ack)
                ;
              else {
                const callSender = handleAckMessage(event);
                callSender && (stopConnectionTimeout(), resolve(callSender));
              }
            else
              handleSynMessage(event);
        };
        window.addEventListener(enums_NativeEventType.Message, handleMessage), log3("Parent: Awaiting handshake"), ((iframe2, destructor2) => {
          const { destroy: destroy2, onDestroy: onDestroy2 } = destructor2, checkIframeInDocIntervalId = setInterval(() => {
            iframe2.isConnected || (clearInterval(checkIframeInDocIntervalId), destroy2());
          }, 60000);
          onDestroy2(() => {
            clearInterval(checkIframeInDocIntervalId);
          });
        })(iframe, destructor), onDestroy((error) => {
          window.removeEventListener(enums_NativeEventType.Message, handleMessage), error && reject(error);
        });
      });
      return { promise, destroy() {
        destroy();
      } };
    }, setupFrame = (iframe, editorLink, styling) => {
      const link = ((editorLink2) => {
        let link2 = "";
        return new RegExp(/^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w]+\/$/).test(editorLink2) ? link2 = editorLink2 : editorLink2.indexOf("/index.html") > -1 ? link2 = editorLink2.replace("/index.html", "/") : editorLink2.charAt(-1) !== "/" && (link2 = `${editorLink2}/`), link2;
      })(editorLink), html = `<html>
        <head>
            <base href="/" />
            <meta charset="UTF-8"/>
            <!--  use this property to pass the StudioStyling to the engine -->
            <meta name="studio-styling" content='${JSON.stringify(styling || {})}'>
        </head>
        <body>
            <script>                
            </script>
            <script src="${link}init.js" async></script>
            <script src="${link}init_engine.js"></script>
            <script>
                initializeStudioEngine({
                    assetBase: '${link}',
                    entryPointUrl: '${link}main.dart.js',
                });
            </script>
        </body>
        </html>
    `;
      iframe.srcdoc = html;
    }, Connector = (editorLink, params, setConnection, editorId = "chili-editor", styling) => {
      const editorSelectorId = `#${editorId}`, iframe = document.createElement("iframe");
      iframe.setAttribute("srcdoc", " "), iframe.setAttribute("title", "Chili-Editor"), iframe.setAttribute("style", "width: 100%; height: 100%;"), iframe.setAttribute("frameBorder", "0"), iframe.setAttribute("referrerpolicy", "origin");
      const setupNewFrame = () => {
        const iframeContainer = document.querySelector(editorSelectorId);
        iframeContainer && (iframeContainer == null || iframeContainer.appendChild(iframe), setupFrame(iframe, editorLink, styling));
      };
      document.readyState === "complete" || document.readyState === "interactive" ? setupNewFrame() : document.addEventListener("DOMContentLoaded", () => {
        setupNewFrame();
      }), setConnection(connectToChild({ iframe, methods: { actionsChanged: params.onActionsChanged, stateChanged: params.onStateChanged, documentLoaded: params.onDocumentLoaded, authExpired: params.onAuthExpired, viewportRequested: params.onViewportRequested, selectedFramesContent: params.onSelectedFramesContentChanged, selectedFramesLayout: params.onSelectedFramesLayoutChanged, allFramesLayout: params.onFramesLayoutChanged, selectedLayoutProperties: params.onSelectedLayoutPropertiesChanged, openLayoutPropertiesPanel: params.onPageSelectionChanged, selectedLayoutUnit: params.onSelectedLayoutUnitChanged, scrubberPositionChanged: params.onScrubberPositionChanged, frameAnimationsChanged: params.onFrameAnimationsChanged, selectedToolChanged: params.onSelectedToolChanged, variableListChanged: params.onVariableListChanged, undoStackStateChanged: params.onUndoStateChanged, selectedLayoutFramesChanged: params.onSelectedLayoutFramesChanged, selectedTextStyleChanged: params.onSelectedTextStyleChanged, colorsChanged: params.onColorsChanged, paragraphStylesChanged: params.onParagraphStylesChanged, characterStylesChanged: params.onCharacterStylesChanged, fontFamiliesChanged: params.onFontFamiliesChanged, selectedLayoutId: params.onSelectedLayoutIdChanged, layoutListChanged: params.onLayoutsChanged, connectorEvent: params.onConnectorEvent, connectorsChanged: params.onConnectorsChanged, zoomChanged: params.onZoomChanged, pageSnapshotInvalidated: params.onPageSnapshotInvalidated, pagesChanged: params.onPagesChanged, pageSizeChanged: params.onPageSizeChanged, shapeCornerRadiusChanged: params.onShapeCornerRadiusChanged, cropActiveFrameIdChanged: params.onCropActiveFrameIdChanged, asyncError: params.onAsyncError, viewModeChanged: params.onViewModeChanged, barcodeValidationChanged: params.onBarcodeValidationChanged, selectedPageIdChanged: params.onSelectedPageIdChanged, dataSourceIdChanged: params.onDataSourceIdChanged, documentIssueListChanged: params.onDocumentIssueListChanged, customUndoDataChanged: params.onCustomUndoDataChanged, engineEditingModeChanged: params.onEngineEditModeChanged } }));
    };
    var WellKnownConfigurationKeys;
    (function(WellKnownConfigurationKeys2) {
      WellKnownConfigurationKeys2.GraFxStudioEnvironmentApiUrl = "ENVIRONMENT_API", WellKnownConfigurationKeys2.GraFxStudioSdkVersion = "SDK_VERSION", WellKnownConfigurationKeys2.GraFxStudioDocumentType = "DOCUMENT_TYPE", WellKnownConfigurationKeys2.GraFxStudioTemplateId = "TEMPLATE_ID", WellKnownConfigurationKeys2.GraFxStudioAuthToken = "GRAFX_AUTH_TOKEN", WellKnownConfigurationKeys2.QueryCallCacheEnabled = "ENABLE_QUERY_CALL_CACHE";
    })(WellKnownConfigurationKeys || (WellKnownConfigurationKeys = {}));
    const defaultStudioOptions = { shortcutOptions: { debugPanel: { enabled: false }, ellipse: { enabled: false }, hand: { enabled: false }, image: { enabled: false }, polygon: { enabled: false }, rectangle: { enabled: false }, select: { enabled: false }, text: { enabled: false }, zoom: { enabled: false }, copyPaste: { enabled: false }, viewMode: { enabled: false } } };
    var DocumentIssueTypeEnum, ImageFrameSourceType, FramePropertiesType, DocumentType;
    (function(DocumentIssueTypeEnum2) {
      DocumentIssueTypeEnum2.overflow = "overflow", DocumentIssueTypeEnum2.fontLoading = "fontLoading", DocumentIssueTypeEnum2.actionRegister = "actionRegister", DocumentIssueTypeEnum2.actionExecution = "actionExecution", DocumentIssueTypeEnum2.actionCircular = "actionCircular";
    })(DocumentIssueTypeEnum || (DocumentIssueTypeEnum = {})), function(ImageFrameSourceType2) {
      ImageFrameSourceType2.url = "url", ImageFrameSourceType2.assetProvider = "assetProvider", ImageFrameSourceType2.variable = "variable";
    }(ImageFrameSourceType || (ImageFrameSourceType = {})), function(FramePropertiesType2) {
      FramePropertiesType2.top = "top", FramePropertiesType2.child = "child";
    }(FramePropertiesType || (FramePropertiesType = {})), function(DocumentType2) {
      DocumentType2.project = "project", DocumentType2.template = "template";
    }(DocumentType || (DocumentType = {}));
    function getEditorResponseData(response, parse = true) {
      var _a, _b;
      try {
        if (!response.success) {
          const parsedError = (_a = response.error) !== null && _a !== undefined ? _a : "Yikes, something went wrong", parsedCause = { cause: { name: String(response.status), message: (_b = response.error) !== null && _b !== undefined ? _b : "Yikes, something went wrong" } };
          if (response.status === 404075) {
            const httpStatusCode = JSON.parse(response.data).statusCode;
            throw new ConnectorHttpError(httpStatusCode, parsedError, parsedCause);
          }
          throw new Error(parsedError, parsedCause);
        }
        const dataShouldBeParsed = response.data && parse;
        return Object.assign(Object.assign({}, response), { parsedData: dataShouldBeParsed ? JSON.parse(response.data) : response.data });
      } catch (error) {
        throw console.error(error), error;
      }
    }

    class ConnectorHttpError extends Error {
      constructor(statusCode, message, options) {
        super(message, options), this.statusCode = statusCode;
      }
    }
    var _ActionController_editorAPI, __awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ActionController {
      constructor(editorAPI) {
        _ActionController_editorAPI.set(this, undefined), this.getAll = () => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).getActions().then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).getActionById(id2).then((result) => getEditorResponseData(result));
        }), this.create = () => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).createAction().then((result) => getEditorResponseData(result));
        }), this.duplicate = (id2) => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).duplicateAction(id2).then((result) => getEditorResponseData(result));
        }), this.remove = (id2) => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).removeAction(id2).then((result) => getEditorResponseData(result));
        }), this.update = (id2, update) => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).updateAction(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.rename = (id2, name) => __awaiter(this, undefined, undefined, function* () {
          return this.update(id2, { name });
        }), this.updateScript = (id2, actionScript) => __awaiter(this, undefined, undefined, function* () {
          return this.update(id2, { script: actionScript });
        }), this.updateTriggers = (id2, triggers) => __awaiter(this, undefined, undefined, function* () {
          return this.update(id2, { triggers });
        }), this.move = (order, ids) => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).moveActions(order, ids).then((result) => getEditorResponseData(result));
        }), this.setTypeError = (id2, hasTypeErrors) => __awaiter(this, undefined, undefined, function* () {
          return this.update(id2, { hasTypeError: hasTypeErrors });
        }), this.disable = () => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).disableActions().then((result) => getEditorResponseData(result));
        }), this.enable = () => __awaiter(this, undefined, undefined, function* () {
          return (yield __classPrivateFieldGet(this, _ActionController_editorAPI, "f")).enableActions().then((result) => getEditorResponseData(result));
        }), __classPrivateFieldSet(this, _ActionController_editorAPI, editorAPI, "f");
      }
    }
    _ActionController_editorAPI = new WeakMap;
    var _AnimationController_editorAPI, BarcodeType, BarcodeErrorCorrectionLevel, BarcodeCharacterSet, BarcodeValidationResult, PositionEnum, LayoutType, MeasurementUnit, LayoutIntent, AnimationController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, AnimationController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, AnimationController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class AnimationController {
      constructor(children) {
        _AnimationController_editorAPI.set(this, undefined), this.getAllOnSelectedLayout = () => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).getAnimationsOnSelectedLayout().then((result) => getEditorResponseData(result));
        }), this.getByFrameId = (id2, layoutId) => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).getAnimationByFrameId(id2, layoutId).then((result) => getEditorResponseData(result));
        }), this.getByLayoutId = (id2) => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).getAnimationsByLayoutId(id2).then((result) => getEditorResponseData(result));
        }), this.setFrameAnimation = (animation) => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).setFrameAnimation(JSON.stringify(animation)).then((result) => getEditorResponseData(Object.assign(Object.assign({}, result), { data: JSON.stringify(animation) })));
        }), this.play = () => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).playAnimation().then((result) => getEditorResponseData(result));
        }), this.pause = () => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).pauseAnimation().then((result) => getEditorResponseData(result));
        }), this.setScrubberPosition = (timeInMS) => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).setScrubberPosition(timeInMS).then((result) => getEditorResponseData(result));
        }), this.setDuration = (timeInMS) => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).setAnimationDuration(timeInMS).then((result) => getEditorResponseData(result));
        }), this.resetFrameAnimation = (id2) => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).resetFrameAnimation(id2).then((result) => getEditorResponseData(result));
        }), this.reset = () => AnimationController_awaiter(this, undefined, undefined, function* () {
          return (yield AnimationController_classPrivateFieldGet(this, _AnimationController_editorAPI, "f")).resetAnimation().then((result) => getEditorResponseData(result));
        }), AnimationController_classPrivateFieldSet(this, _AnimationController_editorAPI, children, "f");
      }
    }
    _AnimationController_editorAPI = new WeakMap, function(BarcodeType2) {
      BarcodeType2.code39 = "code39", BarcodeType2.code93 = "code93", BarcodeType2.code128 = "code128", BarcodeType2.dataMatrix = "dataMatrix", BarcodeType2.ean13 = "ean13", BarcodeType2.ean8 = "ean8", BarcodeType2.qr = "qr", BarcodeType2.upca = "upca", BarcodeType2.upce = "upce", BarcodeType2.gs1128 = "gs1128";
    }(BarcodeType || (BarcodeType = {})), function(BarcodeErrorCorrectionLevel2) {
      BarcodeErrorCorrectionLevel2.low = "low", BarcodeErrorCorrectionLevel2.medium = "medium", BarcodeErrorCorrectionLevel2.quartile = "quartile", BarcodeErrorCorrectionLevel2.high = "high";
    }(BarcodeErrorCorrectionLevel || (BarcodeErrorCorrectionLevel = {})), function(BarcodeCharacterSet2) {
      BarcodeCharacterSet2.utf8 = "utf8", BarcodeCharacterSet2.iso8859_1 = "iso8859_1", BarcodeCharacterSet2.code128a = "code128a", BarcodeCharacterSet2.code128b = "code128b", BarcodeCharacterSet2.code128c = "code128c";
    }(BarcodeCharacterSet || (BarcodeCharacterSet = {})), function(BarcodeValidationResult2) {
      BarcodeValidationResult2.success = "success", BarcodeValidationResult2.empty = "empty", BarcodeValidationResult2.invalidLength = "invalidLength", BarcodeValidationResult2.invalidCharacters = "invalidCharacters", BarcodeValidationResult2.invalidChecksum = "invalidChecksum", BarcodeValidationResult2.invalidUPCE = "invalidUPCE", BarcodeValidationResult2.otherError = "otherError";
    }(BarcodeValidationResult || (BarcodeValidationResult = {})), function(PositionEnum2) {
      PositionEnum2.top = "top", PositionEnum2.right = "right", PositionEnum2.bottom = "bottom", PositionEnum2.left = "left";
    }(PositionEnum || (PositionEnum = {})), function(LayoutType2) {
      LayoutType2.top = "top", LayoutType2.child = "child";
    }(LayoutType || (LayoutType = {})), function(MeasurementUnit2) {
      MeasurementUnit2.px = "px", MeasurementUnit2.mm = "mm", MeasurementUnit2.cm = "cm", MeasurementUnit2.inch = "inch", MeasurementUnit2.pt = "pt";
    }(MeasurementUnit || (MeasurementUnit = {})), function(LayoutIntent2) {
      LayoutIntent2.print = "print", LayoutIntent2.digitalStatic = "digitalStatic", LayoutIntent2.digitalAnimated = "digitalAnimated";
    }(LayoutIntent || (LayoutIntent = {}));
    var _BarcodeController_editorAPI, BarcodeController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, BarcodeController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, BarcodeController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class BarcodeController {
      constructor(editorAPI) {
        _BarcodeController_editorAPI.set(this, undefined), this.setBarcodeProperties = (id2, properties) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeProperties(id2, JSON.stringify(properties)).then((result) => getEditorResponseData(result));
        }), this.setEnableBackground = (id2, enableBackground) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { enableBackground };
          return this.setBarcodeProperties(id2, properties);
        }), this.setBackgroundColor = (id2, backgroundColor) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { backgroundColor };
          return this.setBarcodeProperties(id2, properties);
        }), this.setEnableBars = (id2, enableBars) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { enableBars };
          return this.setBarcodeProperties(id2, properties);
        }), this.setBarColor = (id2, barColor) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { barColor };
          return this.setBarcodeProperties(id2, properties);
        }), this.setBarcodeSource = (id2, source) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeSource(id2, JSON.stringify(source)).then((result) => getEditorResponseData(result));
        }), this.removeBarcodeSource = (id2) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeSource(id2, null).then((result) => getEditorResponseData(result));
        }), this.setEnableText = (id2, enableText) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { enableText };
          return this.setBarcodeProperties(id2, properties);
        }), this.setBarHeight = (id2, barHeight) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { barHeight };
          return this.setBarcodeProperties(id2, properties);
        }), this.setMagnification = (id2, magnification) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { magnification };
          return this.setBarcodeProperties(id2, properties);
        }), this.setQuietZoneValue = (id2, value, position) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const update = position ? { left: position === PositionEnum.left ? value : undefined, top: position === PositionEnum.top ? value : undefined, right: position === PositionEnum.right ? value : undefined, bottom: position === PositionEnum.bottom ? value : undefined } : { left: value, top: value, right: value, bottom: value };
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeProperties(id2, JSON.stringify({ quietZone: update })).then((result) => getEditorResponseData(result));
        }), this.setAreQuietZoneValuesCombined = (id2, value) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const update = { areQuietZoneValuesCombined: value };
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeProperties(id2, JSON.stringify({ quietZone: update })).then((result) => getEditorResponseData(result));
        }), this.setErrorCorrectionLevel = (id2, errorCorrectionLevel) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeProperties(id2, JSON.stringify({ errorCorrectionLevel })).then((result) => getEditorResponseData(result));
        }), this.setCharacterSet = (id2, characterSet) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          return (yield BarcodeController_classPrivateFieldGet(this, _BarcodeController_editorAPI, "f")).setBarcodeProperties(id2, JSON.stringify({ characterSet })).then((result) => getEditorResponseData(result));
        }), this.setDrawLightMarginIndicator = (id2, drawLightMarginIndicator) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { drawStartStopChars: drawLightMarginIndicator };
          return this.setBarcodeProperties(id2, properties);
        }), this.setDrawStartStopChars = (id2, drawStartStopChars) => BarcodeController_awaiter(this, undefined, undefined, function* () {
          const properties = { drawStartStopChars };
          return this.setBarcodeProperties(id2, properties);
        }), this.getBarcodeConfigationOptions = (type) => {
          let allowedCharacterSets, allowedErrorCorrectionLevels, allowToggleText = true, allowBarHeight = true, allowEnableMagnification = true, quietZoneAlwaysCombined = false, allowToggleLightMarginIndicator = false, allowToggleDrawStartAndEndChar = false;
          switch (type) {
            case BarcodeType.qr:
              allowedCharacterSets = [BarcodeCharacterSet.iso8859_1, BarcodeCharacterSet.utf8], allowedErrorCorrectionLevels = [BarcodeErrorCorrectionLevel.low, BarcodeErrorCorrectionLevel.medium, BarcodeErrorCorrectionLevel.quartile, BarcodeErrorCorrectionLevel.high];
            case BarcodeType.dataMatrix:
              allowToggleText = false, allowBarHeight = false, allowEnableMagnification = false, quietZoneAlwaysCombined = true;
              break;
            case BarcodeType.ean13:
              allowToggleText = false, allowToggleLightMarginIndicator = true;
              break;
            case BarcodeType.ean8:
              allowToggleLightMarginIndicator = true;
            case BarcodeType.upca:
            case BarcodeType.upce:
              allowToggleText = false;
              break;
            case BarcodeType.code128:
            case BarcodeType.gs1128:
              allowedCharacterSets = [BarcodeCharacterSet.code128a, BarcodeCharacterSet.code128b, BarcodeCharacterSet.code128c];
              break;
            case BarcodeType.code39:
              allowToggleDrawStartAndEndChar = true;
          }
          return { allowEnableMagnification, allowBarHeight, allowQuietZone: true, allowedCharacterSets, allowedErrorCorrectionLevels, allowToggleText, quietZoneAlwaysCombined, allowToggleLightMarginIndicator, allowToggleDrawStartAndEndChar };
        }, BarcodeController_classPrivateFieldSet(this, _BarcodeController_editorAPI, editorAPI, "f");
      }
    }
    _BarcodeController_editorAPI = new WeakMap;
    var _CanvasController_editorAPI, CanvasController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, CanvasController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, CanvasController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class CanvasController {
      constructor(editorAPI) {
        _CanvasController_editorAPI.set(this, undefined), this.zoomToPage = (_id, left, top, width, height) => CanvasController_awaiter(this, undefined, undefined, function* () {
          _id !== undefined && console.warn("id has no effect and will be deprecated in the future");
          return (yield CanvasController_classPrivateFieldGet(this, _CanvasController_editorAPI, "f")).zoomToPage(left, top, width, height).then((result) => getEditorResponseData(result));
        }), this.getZoomPercentage = () => CanvasController_awaiter(this, undefined, undefined, function* () {
          return (yield CanvasController_classPrivateFieldGet(this, _CanvasController_editorAPI, "f")).getZoomPercentage().then((result) => getEditorResponseData(result));
        }), this.setZoomPercentage = (scaleFactor) => CanvasController_awaiter(this, undefined, undefined, function* () {
          return (yield CanvasController_classPrivateFieldGet(this, _CanvasController_editorAPI, "f")).setZoomPercentage(scaleFactor).then((result) => getEditorResponseData(result));
        }), this.setViewMode = (viewMode) => CanvasController_awaiter(this, undefined, undefined, function* () {
          return (yield CanvasController_classPrivateFieldGet(this, _CanvasController_editorAPI, "f")).setViewMode(viewMode).then((result) => getEditorResponseData(result));
        }), CanvasController_classPrivateFieldSet(this, _CanvasController_editorAPI, editorAPI, "f");
      }
    }
    _CanvasController_editorAPI = new WeakMap;
    var _CharacterStyleController_editorAPI, CharacterStyleController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, CharacterStyleController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, CharacterStyleController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class CharacterStyleController {
      constructor(editorAPI) {
        _CharacterStyleController_editorAPI.set(this, undefined), this.getAll = () => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).getCharacterStyles().then((result) => getEditorResponseData(result));
        }), this.getById = (characterStyleId) => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).getCharacterStyleById(characterStyleId).then((result) => getEditorResponseData(result));
        }), this.create = () => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).createCharacterStyle().then((result) => getEditorResponseData(result));
        }), this.update = (characterStyleId, characterStyle) => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).updateCharacterStyle(characterStyleId, JSON.stringify(characterStyle)).then((result) => getEditorResponseData(result));
        }), this.remove = (characterStyleId) => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).removeCharacterStyle(characterStyleId).then((result) => getEditorResponseData(result));
        }), this.duplicate = (characterStyleId) => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).duplicateCharacterStyle(characterStyleId).then((result) => getEditorResponseData(result));
        }), this.rename = (characterStyleId, characterStyleName) => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).renameCharacterStyle(characterStyleId, characterStyleName).then((result) => getEditorResponseData(result));
        }), this.move = (order, ids) => CharacterStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield CharacterStyleController_classPrivateFieldGet(this, _CharacterStyleController_editorAPI, "f")).moveCharacterStyles(order, ids).then((result) => getEditorResponseData(result));
        }), CharacterStyleController_classPrivateFieldSet(this, _CharacterStyleController_editorAPI, editorAPI, "f");
      }
    }
    _CharacterStyleController_editorAPI = new WeakMap;
    var _ClipboardController_editorAPI, ClipboardController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ClipboardController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ClipboardController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ClipboardController {
      constructor(editorAPI) {
        _ClipboardController_editorAPI.set(this, undefined), this.copyFrames = (ids) => ClipboardController_awaiter(this, undefined, undefined, function* () {
          const res = yield ClipboardController_classPrivateFieldGet(this, _ClipboardController_editorAPI, "f"), frameData = yield res.copyFrames(ids);
          return frameData.data && (yield navigator.clipboard.writeText(frameData.data)), getEditorResponseData(frameData);
        }), this.cutFrames = (ids) => ClipboardController_awaiter(this, undefined, undefined, function* () {
          const res = yield ClipboardController_classPrivateFieldGet(this, _ClipboardController_editorAPI, "f"), frameData = yield res.cutFrames(ids);
          return frameData.data && (yield navigator.clipboard.writeText(frameData.data)), getEditorResponseData(frameData);
        }), this.pasteFrames = () => ClipboardController_awaiter(this, undefined, undefined, function* () {
          const res = yield ClipboardController_classPrivateFieldGet(this, _ClipboardController_editorAPI, "f"), clipboardData = yield navigator.clipboard.readText();
          return getEditorResponseData(yield res.pasteFrames(clipboardData));
        }), this.getContentType = () => ClipboardController_awaiter(this, undefined, undefined, function* () {
          const res = yield ClipboardController_classPrivateFieldGet(this, _ClipboardController_editorAPI, "f"), clipboardData = yield navigator.clipboard.readText();
          return getEditorResponseData(yield res.getClipboardContentType(clipboardData));
        }), ClipboardController_classPrivateFieldSet(this, _ClipboardController_editorAPI, editorAPI, "f");
      }
    }
    _ClipboardController_editorAPI = new WeakMap;
    var _ColorConversionController_editorAPI, ColorType, ColorUsageType, ColorConversionController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ColorConversionController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ColorConversionController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ColorConversionController {
      constructor(editorAPI) {
        _ColorConversionController_editorAPI.set(this, undefined), this.convertToRgb = (color) => ColorConversionController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorConversionController_classPrivateFieldGet(this, _ColorConversionController_editorAPI, "f")).colorToRgb(JSON.stringify(color)).then((result) => getEditorResponseData(result));
        }), ColorConversionController_classPrivateFieldSet(this, _ColorConversionController_editorAPI, editorAPI, "f");
      }
    }
    _ColorConversionController_editorAPI = new WeakMap, function(ColorType2) {
      ColorType2.rgb = "rgb", ColorType2.hex = "hex", ColorType2.cmyk = "cmyk", ColorType2.gray = "gray", ColorType2.hsl = "hsl", ColorType2.spot = "spot", ColorType2.spotCMYK = "spotCMYK", ColorType2.spotRGB = "spotRGB";
    }(ColorType || (ColorType = {})), function(ColorUsageType2) {
      ColorUsageType2.local = "local", ColorUsageType2.stylekit = "stylekit";
    }(ColorUsageType || (ColorUsageType = {}));
    var _ColorStyleController_editorAPI, DeprecatedMediaType, DeprecatedMediaConnectorDownloadType, MediaType, ConnectorType, SortBy, SortOrder, ConnectorRegistrationSource, ConnectorMappingSource, ConnectorMappingDirection, ConnectorStateType, ConnectorEventType, ColorStyleController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ColorStyleController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ColorStyleController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ColorStyleController {
      constructor(editorAPI) {
        _ColorStyleController_editorAPI.set(this, undefined), this.getAll = () => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).getColors().then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).getColorById(id2).then((result) => getEditorResponseData(result));
        }), this.create = () => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).createColor().then((result) => getEditorResponseData(result));
        }), this.duplicate = (id2) => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).duplicateColor(id2).then((result) => getEditorResponseData(result));
        }), this.move = (order, ids) => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).moveColors(order, ids).then((result) => getEditorResponseData(result));
        }), this.rename = (id2, newColorName) => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).renameColor(id2, newColorName).then((result) => getEditorResponseData(result));
        }), this.update = (id2, newColorProperties) => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          const res = yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f"), properties = newColorProperties;
          return properties.type === ColorType.spot && (properties.type = ColorType.spotCMYK), res.updateColor(id2, JSON.stringify(properties)).then((result) => getEditorResponseData(result));
        }), this.remove = (id2) => ColorStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ColorStyleController_classPrivateFieldGet(this, _ColorStyleController_editorAPI, "f")).removeColor(id2).then((result) => getEditorResponseData(result));
        }), ColorStyleController_classPrivateFieldSet(this, _ColorStyleController_editorAPI, editorAPI, "f");
      }
    }
    _ColorStyleController_editorAPI = new WeakMap, function(DeprecatedMediaType2) {
      DeprecatedMediaType2[DeprecatedMediaType2.file = 0] = "file", DeprecatedMediaType2[DeprecatedMediaType2.collection = 1] = "collection";
    }(DeprecatedMediaType || (DeprecatedMediaType = {})), function(DeprecatedMediaConnectorDownloadType2) {
      DeprecatedMediaConnectorDownloadType2.LowResolutionWeb = "lowresWeb", DeprecatedMediaConnectorDownloadType2.HighResolutionWeb = "highresWeb";
    }(DeprecatedMediaConnectorDownloadType || (DeprecatedMediaConnectorDownloadType = {})), function(MediaType2) {
      MediaType2.file = "file", MediaType2.collection = "collection";
    }(MediaType || (MediaType = {})), function(ConnectorType2) {
      ConnectorType2.media = "media", ConnectorType2.fonts = "fonts", ConnectorType2.data = "data";
    }(ConnectorType || (ConnectorType = {})), function(SortBy2) {
      SortBy2.name = "name", SortBy2.path = "relativePath", SortBy2.id = "id";
    }(SortBy || (SortBy = {})), function(SortOrder2) {
      SortOrder2.ascending = "asc", SortOrder2.descending = "desc";
    }(SortOrder || (SortOrder = {})), function(ConnectorRegistrationSource2) {
      ConnectorRegistrationSource2.url = "url", ConnectorRegistrationSource2.grafx = "grafx", ConnectorRegistrationSource2.local = "local";
    }(ConnectorRegistrationSource || (ConnectorRegistrationSource = {}));

    class ConnectorMapping {
      constructor(contextProperty, mapFrom, sourceValue, direction = ConnectorMappingDirection.engineToConnector) {
        this.direction = ConnectorMappingDirection.engineToConnector, this.name = contextProperty, this.direction = direction, mapFrom === ConnectorMappingSource.variable ? this.value = `${mapFrom}.${sourceValue}` : this.value = sourceValue;
      }
    }
    (function(ConnectorMappingSource2) {
      ConnectorMappingSource2.variable = "var", ConnectorMappingSource2.value = "value";
    })(ConnectorMappingSource || (ConnectorMappingSource = {})), function(ConnectorMappingDirection2) {
      ConnectorMappingDirection2.engineToConnector = "engineToConnector", ConnectorMappingDirection2.connectorToEngine = "connectorToEngine";
    }(ConnectorMappingDirection || (ConnectorMappingDirection = {})), function(ConnectorStateType2) {
      ConnectorStateType2.loading = "loading", ConnectorStateType2.loaded = "loaded", ConnectorStateType2.running = "running", ConnectorStateType2.ready = "ready", ConnectorStateType2.error = "error";
    }(ConnectorStateType || (ConnectorStateType = {})), function(ConnectorEventType2) {
      ConnectorEventType2.stateChanged = "stateChanged", ConnectorEventType2.authChanged = "authChanged", ConnectorEventType2.reloadRequired = "reloadRequired", ConnectorEventType2.unloaded = "unloaded";
    }(ConnectorEventType || (ConnectorEventType = {}));
    const grafxMediaConnectorRegistration = { url: "grafx-media.json", source: ConnectorRegistrationSource.local };

    class GrafxTokenAuthCredentials {
      constructor(token) {
        this.type = AuthCredentialsTypeEnum.grafxToken, this.token = token;
      }
    }

    class RefreshedAuthCredendentials {
      constructor() {
        this.type = AuthCredentialsTypeEnum.refreshed;
      }
    }
    var AuthCredentialsTypeEnum, AuthRefreshTypeEnum;
    (function(AuthCredentialsTypeEnum2) {
      AuthCredentialsTypeEnum2.grafxToken = "grafxToken", AuthCredentialsTypeEnum2.refreshed = "refreshed";
    })(AuthCredentialsTypeEnum || (AuthCredentialsTypeEnum = {})), function(AuthRefreshTypeEnum2) {
      AuthRefreshTypeEnum2.grafxToken = "grafxToken", AuthRefreshTypeEnum2.any = "any";
    }(AuthRefreshTypeEnum || (AuthRefreshTypeEnum = {}));

    class ConnectorCompatibilityTools {
      constructor() {
        this.makeConnectorSourceForwardsCompatible = (registration) => {
          if (registration.source != ConnectorRegistrationSource.grafx)
            return registration;
          if (this.isSourceMigrated(registration))
            return registration;
          let url = registration.url;
          for (;url.endsWith("/"); )
            url = url.substring(0, url.length - 1);
          const pathChunks = url.split("/");
          return { id: pathChunks[pathChunks.length - 1], source: ConnectorRegistrationSource.grafx };
        }, this.makeMultipleConnectorsBackwardsCompatible = (connectors, baseUrl) => connectors.map((connector) => this.makeSingleConnectorBackwardsCompatible(connector, baseUrl)), this.makeSingleConnectorBackwardsCompatible = (connector, baseUrl) => connector.source.source != ConnectorRegistrationSource.grafx ? connector : { id: connector.id, name: connector.name, iconUrl: connector.iconUrl, source: this.makeConnectorSourceBackwardsCompatible(connector.source, baseUrl) }, this.makeConnectorSourceBackwardsCompatible = (connector, baseUrl) => {
          let url = baseUrl;
          for (;url == null ? undefined : url.endsWith("/"); )
            url = url.substring(0, url.length - 1);
          return { url: `${url}/connectors/${connector.id}`, source: ConnectorRegistrationSource.grafx };
        }, this.isSourceMigrated = (registration) => ("id" in registration);
      }
    }
    var _ConnectorController_editorAPI, _ConnectorController_localConfig, _ConnectorController_connectorCompatibilityTools, _ConnectorConfigurator_connectorId, _ConnectorConfigurator_res, ConnectorController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ConnectorController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ConnectorController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ConnectorController {
      constructor(editorAPI, localConfig) {
        _ConnectorController_editorAPI.set(this, undefined), _ConnectorController_localConfig.set(this, undefined), _ConnectorController_connectorCompatibilityTools.set(this, undefined), this.getById = (id2) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f")).getConnectorById(id2).then((result) => getEditorResponseData(result)).then((resp) => {
            const update = Object.assign(Object.assign({}, resp), { parsedData: null });
            return resp.parsedData && (update.parsedData = ConnectorController_classPrivateFieldGet(this, _ConnectorController_connectorCompatibilityTools, "f").makeSingleConnectorBackwardsCompatible(resp.parsedData, ConnectorController_classPrivateFieldGet(this, _ConnectorController_localConfig, "f").get(WellKnownConfigurationKeys.GraFxStudioEnvironmentApiUrl))), update;
          });
        }), this.getAllByType = (type) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f")).getConnectors(type).then((result) => getEditorResponseData(result)).then((resp) => {
            const update = Object.assign(Object.assign({}, resp), { parsedData: null });
            return resp.parsedData && (update.parsedData = ConnectorController_classPrivateFieldGet(this, _ConnectorController_connectorCompatibilityTools, "f").makeMultipleConnectorsBackwardsCompatible(resp.parsedData, ConnectorController_classPrivateFieldGet(this, _ConnectorController_localConfig, "f").get(WellKnownConfigurationKeys.GraFxStudioEnvironmentApiUrl))), update;
          });
        }), this.register = (registration) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          const res = yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f"), connectorRegistration = ConnectorController_classPrivateFieldGet(this, _ConnectorController_connectorCompatibilityTools, "f").makeConnectorSourceForwardsCompatible(registration);
          return res.registerConnector(JSON.stringify(connectorRegistration)).then((result) => getEditorResponseData(result));
        }), this.unregister = (id2) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f")).unregisterConnector(id2).then((result) => getEditorResponseData(result));
        }), this.configure = (id2, configurationCallback) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          const res = yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f");
          return yield this.waitToBeReady(id2), yield configurationCallback(new ConnectorConfigurator(id2, res)), res.updateConnectorConfiguration(id2).then((result) => getEditorResponseData(result));
        }), this.getState = (id2) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f")).getConnectorState(id2).then((result) => getEditorResponseData(result));
        }), this.getOptions = (id2) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f")).getConnectorOptions(id2).then((result) => getEditorResponseData(result));
        }), this.waitToBeReady = (id_1, ...args_1) => ConnectorController_awaiter(this, [id_1, ...args_1], undefined, function* (id2, timeoutMilliseconds = 2000) {
          let timeout = Math.max(timeoutMilliseconds, 500);
          timeout = Math.min(timeout, 5000);
          let retries = 0;
          try {
            for (;100 * retries < timeout; ) {
              const result = yield this.getState(id2);
              if (result.success && result.parsedData && (result.parsedData.type === ConnectorStateType.running || result.parsedData.type === ConnectorStateType.ready))
                return getEditorResponseData({ data: null, success: true, error: undefined, status: 0, parsedData: undefined }, false);
              yield new Promise((resolve) => setTimeout(resolve, 100)), retries++;
            }
          } catch (err) {
            return getEditorResponseData({ data: null, success: false, error: `Error while getting connector state ${err}`, status: 50000, parsedData: undefined }, false);
          }
          return getEditorResponseData({ data: null, success: false, error: "Timed out waiting for connector", status: 50000, parsedData: undefined }, false);
        }), this.updateMappings = (id2, mappings) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return yield this.configure(id2, (config) => ConnectorController_awaiter(this, undefined, undefined, function* () {
            var _a;
            const { parsedData: existingMappings } = yield this.getMappings(id2), combinedMappings = [...(_a = existingMappings == null ? undefined : existingMappings.filter((mapping) => !mappings.some((newMapping) => newMapping.name === mapping.name && newMapping.direction === mapping.direction))) !== null && _a !== undefined ? _a : [], ...mappings.filter((i) => i.name !== "" && i.value !== "")];
            yield config.setMappings(combinedMappings);
          }));
        }), ConnectorController_classPrivateFieldSet(this, _ConnectorController_editorAPI, editorAPI, "f"), ConnectorController_classPrivateFieldSet(this, _ConnectorController_localConfig, localConfig, "f"), ConnectorController_classPrivateFieldSet(this, _ConnectorController_connectorCompatibilityTools, new ConnectorCompatibilityTools, "f");
      }
      getMappings(id2, direction) {
        return ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield ConnectorController_classPrivateFieldGet(this, _ConnectorController_editorAPI, "f")).getConnectorMappings(id2).then((result) => getEditorResponseData(result)).then((result) => {
            var _a;
            return direction ? Object.assign(Object.assign({}, result), { parsedData: (_a = result.parsedData) === null || _a === undefined ? undefined : _a.filter((cm) => cm.direction === direction) }) : result;
          });
        });
      }
    }
    _ConnectorController_editorAPI = new WeakMap, _ConnectorController_localConfig = new WeakMap, _ConnectorController_connectorCompatibilityTools = new WeakMap;

    class ConnectorConfigurator {
      constructor(id2, res) {
        _ConnectorConfigurator_connectorId.set(this, undefined), _ConnectorConfigurator_res.set(this, undefined), this.setOptions = (options) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return ConnectorController_classPrivateFieldGet(this, _ConnectorConfigurator_res, "f").setConnectorOptions(ConnectorController_classPrivateFieldGet(this, _ConnectorConfigurator_connectorId, "f"), JSON.stringify(options)).then((result) => getEditorResponseData(result));
        }), this.setMappings = (mappings) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return getEditorResponseData(yield ConnectorController_classPrivateFieldGet(this, _ConnectorConfigurator_res, "f").setConnectorMappings(ConnectorController_classPrivateFieldGet(this, _ConnectorConfigurator_connectorId, "f"), mappings.map(function(m) {
            return JSON.stringify(m);
          })));
        }), this.setHttpHeader = (headerName, headerValue) => ConnectorController_awaiter(this, undefined, undefined, function* () {
          return ConnectorController_classPrivateFieldGet(this, _ConnectorConfigurator_res, "f").connectorAuthenticationSetHttpHeader(ConnectorController_classPrivateFieldGet(this, _ConnectorConfigurator_connectorId, "f"), headerName, headerValue).then((result) => getEditorResponseData(result));
        }), ConnectorController_classPrivateFieldSet(this, _ConnectorConfigurator_connectorId, id2, "f"), ConnectorController_classPrivateFieldSet(this, _ConnectorConfigurator_res, res, "f");
      }
    }
    _ConnectorConfigurator_connectorId = new WeakMap, _ConnectorConfigurator_res = new WeakMap;
    var _DataConnectorController_editorAPI, _DataConnectorController_dataItemMappingTools, DataConnectorController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, DataConnectorController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, DataConnectorController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class DataConnectorController {
      constructor(editorAPI, dataItemMappingTools) {
        _DataConnectorController_editorAPI.set(this, undefined), _DataConnectorController_dataItemMappingTools.set(this, undefined), this.getPage = (connectorId_1, config_1, ...args_1) => DataConnectorController_awaiter(this, [connectorId_1, config_1, ...args_1], undefined, function* (connectorId, config, context = {}) {
          return (yield DataConnectorController_classPrivateFieldGet(this, _DataConnectorController_editorAPI, "f")).dataConnectorGetPage(connectorId, JSON.stringify(config), JSON.stringify(context)).then((result) => getEditorResponseData(result)).then((resp) => {
            const update = Object.assign(Object.assign({}, resp), { parsedData: null });
            return resp.parsedData && (update.parsedData = { data: resp.parsedData.data.map((e) => DataConnectorController_classPrivateFieldGet(this, _DataConnectorController_dataItemMappingTools, "f").mapEngineToDataItem(e)), continuationToken: resp.parsedData.continuationToken }), update;
          });
        }), this.getModel = (connectorId_1, ...args_1) => DataConnectorController_awaiter(this, [connectorId_1, ...args_1], undefined, function* (connectorId, context = {}) {
          return (yield DataConnectorController_classPrivateFieldGet(this, _DataConnectorController_editorAPI, "f")).dataConnectorGetModel(connectorId, JSON.stringify(context)).then((result) => getEditorResponseData(result));
        }), this.getConfigurationOptions = (connectorId) => DataConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield DataConnectorController_classPrivateFieldGet(this, _DataConnectorController_editorAPI, "f")).dataConnectorGetConfigurationOptions(connectorId).then((result) => getEditorResponseData(result));
        }), this.getCapabilities = (connectorId) => DataConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield DataConnectorController_classPrivateFieldGet(this, _DataConnectorController_editorAPI, "f")).dataConnectorGetCapabilities(connectorId).then((result) => getEditorResponseData(result));
        }), DataConnectorController_classPrivateFieldSet(this, _DataConnectorController_editorAPI, editorAPI, "f"), DataConnectorController_classPrivateFieldSet(this, _DataConnectorController_dataItemMappingTools, dataItemMappingTools, "f");
      }
    }
    _DataConnectorController_editorAPI = new WeakMap, _DataConnectorController_dataItemMappingTools = new WeakMap;
    var _DataSourceController_editorAPI, _DataSourceController_dataItemMappingTools, DataSourceController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, DataSourceController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, DataSourceController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class DataSourceController {
      constructor(editorAPI, dataItemMappingTools) {
        _DataSourceController_editorAPI.set(this, undefined), _DataSourceController_dataItemMappingTools.set(this, undefined), this.setDataSource = (connectorId) => DataSourceController_awaiter(this, undefined, undefined, function* () {
          return (yield DataSourceController_classPrivateFieldGet(this, _DataSourceController_editorAPI, "f")).setDataSource(connectorId).then((result) => getEditorResponseData(result));
        }), this.getDataSource = () => DataSourceController_awaiter(this, undefined, undefined, function* () {
          return (yield DataSourceController_classPrivateFieldGet(this, _DataSourceController_editorAPI, "f")).getDataSource().then((result) => getEditorResponseData(result));
        }), this.removeDataSource = () => DataSourceController_awaiter(this, undefined, undefined, function* () {
          return (yield DataSourceController_classPrivateFieldGet(this, _DataSourceController_editorAPI, "f")).removeDataSource().then((result) => getEditorResponseData(result));
        }), this.setDataRow = (dataRow) => DataSourceController_awaiter(this, undefined, undefined, function* () {
          const res = yield DataSourceController_classPrivateFieldGet(this, _DataSourceController_editorAPI, "f"), engineDataItem = DataSourceController_classPrivateFieldGet(this, _DataSourceController_dataItemMappingTools, "f").mapDataItemToEngine(dataRow);
          return res.setDataRow(JSON.stringify(engineDataItem)).then((result) => getEditorResponseData(result));
        }), DataSourceController_classPrivateFieldSet(this, _DataSourceController_editorAPI, editorAPI, "f"), DataSourceController_classPrivateFieldSet(this, _DataSourceController_dataItemMappingTools, dataItemMappingTools, "f");
      }
    }
    _DataSourceController_editorAPI = new WeakMap, _DataSourceController_dataItemMappingTools = new WeakMap;
    var _DebugController_editorAPI, DebugController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, DebugController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, DebugController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class DebugController {
      constructor(editorAPI) {
        _DebugController_editorAPI.set(this, undefined), this.getAllLogs = () => DebugController_awaiter(this, undefined, undefined, function* () {
          return (yield DebugController_classPrivateFieldGet(this, _DebugController_editorAPI, "f")).getLogs().then((result) => getEditorResponseData(result));
        }), this.toggleDebugPanel = () => DebugController_awaiter(this, undefined, undefined, function* () {
          return (yield DebugController_classPrivateFieldGet(this, _DebugController_editorAPI, "f")).toggleDebugPanel().then((result) => getEditorResponseData(result));
        }), this.enableDebug = () => DebugController_awaiter(this, undefined, undefined, function* () {
          return (yield DebugController_classPrivateFieldGet(this, _DebugController_editorAPI, "f")).enableDebug().then((result) => getEditorResponseData(result));
        }), this.disableDebug = () => DebugController_awaiter(this, undefined, undefined, function* () {
          return (yield DebugController_classPrivateFieldGet(this, _DebugController_editorAPI, "f")).disableDebug().then((result) => getEditorResponseData(result));
        }), DebugController_classPrivateFieldSet(this, _DebugController_editorAPI, editorAPI, "f");
      }
    }
    _DebugController_editorAPI = new WeakMap;
    var _DocumentController_editorAPI, AutoGrowDirection, ImageSourceTypeEnum, FrameTypeEnum, BarcodeSourceTypeEnum, TextDirection, FlowDirection, VerticalAlign, BlendMode, FitMode, FitModePosition, UpdateZIndexMethod, FrameAnchorType, AnchorTargetType, AnchorTargetEdgeType, DocumentController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, DocumentController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, DocumentController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class DocumentController {
      constructor(editorAPI) {
        _DocumentController_editorAPI.set(this, undefined), this.getCurrentState = () => DocumentController_awaiter(this, undefined, undefined, function* () {
          return (yield DocumentController_classPrivateFieldGet(this, _DocumentController_editorAPI, "f")).getCurrentDocumentState().then((result) => getEditorResponseData(result));
        }), this.load = (doc_1, ...args_1) => DocumentController_awaiter(this, [doc_1, ...args_1], undefined, function* (doc, options = { keepConnectors: false }) {
          const res = yield DocumentController_classPrivateFieldGet(this, _DocumentController_editorAPI, "f"), parsedDoc = typeof doc != "string" ? JSON.stringify(doc) : doc;
          return res.loadDocument(parsedDoc, JSON.stringify(options)).then((result) => getEditorResponseData(result));
        }), this.createAndLoad = (preset) => DocumentController_awaiter(this, undefined, undefined, function* () {
          const res = yield DocumentController_classPrivateFieldGet(this, _DocumentController_editorAPI, "f"), parsedDoc = JSON.stringify(preset);
          return res.createAndLoadDocument(parsedDoc).then((result) => getEditorResponseData(result));
        }), DocumentController_classPrivateFieldSet(this, _DocumentController_editorAPI, editorAPI, "f");
      }
    }
    _DocumentController_editorAPI = new WeakMap, function(AutoGrowDirection2) {
      AutoGrowDirection2.top = "top", AutoGrowDirection2.bottom = "bottom", AutoGrowDirection2.left = "left", AutoGrowDirection2.right = "right";
    }(AutoGrowDirection || (AutoGrowDirection = {})), function(ImageSourceTypeEnum2) {
      ImageSourceTypeEnum2.url = "url", ImageSourceTypeEnum2.variable = "variable", ImageSourceTypeEnum2.connector = "connector";
    }(ImageSourceTypeEnum || (ImageSourceTypeEnum = {})), function(FrameTypeEnum2) {
      FrameTypeEnum2.text = "text", FrameTypeEnum2.image = "image", FrameTypeEnum2.shape = "shape", FrameTypeEnum2.barcode = "barcode";
    }(FrameTypeEnum || (FrameTypeEnum = {})), function(BarcodeSourceTypeEnum2) {
      BarcodeSourceTypeEnum2.variable = "variable", BarcodeSourceTypeEnum2.text = "text";
    }(BarcodeSourceTypeEnum || (BarcodeSourceTypeEnum = {})), function(TextDirection2) {
      TextDirection2.leftToRight = "leftToRight", TextDirection2.rightToLeft = "rightToLeft", TextDirection2.weak = "weak";
    }(TextDirection || (TextDirection = {})), function(FlowDirection2) {
      FlowDirection2.horizontal = "horizontal", FlowDirection2.vertical = "vertical", FlowDirection2.onPath = "onPath";
    }(FlowDirection || (FlowDirection = {})), function(VerticalAlign2) {
      VerticalAlign2.top = "top", VerticalAlign2.bottom = "bottom", VerticalAlign2.middle = "middle", VerticalAlign2.justify = "justify";
    }(VerticalAlign || (VerticalAlign = {})), function(BlendMode2) {
      BlendMode2.normal = "normal", BlendMode2.screen = "screen", BlendMode2.overlay = "overlay", BlendMode2.darken = "darken", BlendMode2.lighten = "lighten", BlendMode2.colorDodge = "colorDodge", BlendMode2.colorBurn = "colorBurn", BlendMode2.hardLight = "hardLight", BlendMode2.softLight = "softLight", BlendMode2.difference = "difference", BlendMode2.exclusion = "exclusion", BlendMode2.multiply = "multiply", BlendMode2.hue = "hue", BlendMode2.saturation = "saturation", BlendMode2.color = "color", BlendMode2.luminosity = "luminosity";
    }(BlendMode || (BlendMode = {})), function(FitMode2) {
      FitMode2.fill = "fill", FitMode2.fit = "fit", FitMode2.smartCrop = "smartCrop", FitMode2.manualCrop = "manualCrop";
    }(FitMode || (FitMode = {})), function(FitModePosition2) {
      FitModePosition2.topLeft = "topLeft", FitModePosition2.topCenter = "topCenter", FitModePosition2.topRight = "topRight", FitModePosition2.centerLeft = "centerLeft", FitModePosition2.center = "center", FitModePosition2.centerRight = "centerRight", FitModePosition2.bottomLeft = "bottomLeft", FitModePosition2.bottomCenter = "bottomCenter", FitModePosition2.bottomRight = "bottomRight";
    }(FitModePosition || (FitModePosition = {})), function(UpdateZIndexMethod2) {
      UpdateZIndexMethod2.bringToFront = "bringToFront", UpdateZIndexMethod2.sendToBack = "sendToBack", UpdateZIndexMethod2.bringForward = "bringForward", UpdateZIndexMethod2.sendBackward = "sendBackward";
    }(UpdateZIndexMethod || (UpdateZIndexMethod = {})), function(FrameAnchorType2) {
      FrameAnchorType2.relative = "relative", FrameAnchorType2.start = "start", FrameAnchorType2.end = "end", FrameAnchorType2.startAndEnd = "startAndEnd", FrameAnchorType2.center = "center";
    }(FrameAnchorType || (FrameAnchorType = {})), function(AnchorTargetType2) {
      AnchorTargetType2.page = "page", AnchorTargetType2.frame = "frame";
    }(AnchorTargetType || (AnchorTargetType = {})), function(AnchorTargetEdgeType2) {
      AnchorTargetEdgeType2.start = "start", AnchorTargetEdgeType2.end = "end", AnchorTargetEdgeType2.center = "center";
    }(AnchorTargetEdgeType || (AnchorTargetEdgeType = {}));

    class PageAnchorTarget {
      constructor() {
        this.type = AnchorTargetType.page;
      }
    }

    class FrameAnchorTarget {
      constructor(id2, edge) {
        this.type = AnchorTargetType.frame, this.frameId = id2, this.edge = edge;
      }
    }
    var _ExperimentController_editorAPI, ExperimentController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ExperimentController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ExperimentController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ExperimentController {
      constructor(editorAPI) {
        _ExperimentController_editorAPI.set(this, undefined), this.insertImageVariableToFrame = (imageFrameId, variableId) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          const res = yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f"), src2 = { id: variableId, type: ImageSourceTypeEnum.variable };
          return res.setImageSource(imageFrameId, JSON.stringify(src2)).then((result) => getEditorResponseData(result));
        }), this.insertTextVariable = (id2) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).insertTextVariable(id2).then((result) => getEditorResponseData(result));
        }), this.enterTextEditMode = (id2) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).enterTextEditMode(id2).then((result) => getEditorResponseData(result));
        }), this.exitTextEditMode = () => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).exitTextEditMode().then((result) => getEditorResponseData(result));
        }), this.getText = (frameId, textType) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).getTextByFrameId(frameId, textType).then((result) => getEditorResponseData(result));
        }), this.setText = (frameId, text) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).setTextByFrameId(frameId, text).then((result) => getEditorResponseData(result));
        }), this.selectText = (frameId, startIndex, length) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).selectTextById(frameId, startIndex, length).then((result) => getEditorResponseData(result));
        }), this.addCustomUndoData = (key, value, skipEvent) => ExperimentController_awaiter(this, undefined, undefined, function* () {
          return (yield ExperimentController_classPrivateFieldGet(this, _ExperimentController_editorAPI, "f")).setCustomUndoData(key, value, skipEvent != null && skipEvent).then((result) => getEditorResponseData(result));
        }), ExperimentController_classPrivateFieldSet(this, _ExperimentController_editorAPI, editorAPI, "f");
      }
    }
    _ExperimentController_editorAPI = new WeakMap;
    var _FontConnectorController_editorAPI, _FontConnectorController_blobAPI, FontConnectorController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, FontConnectorController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, FontConnectorController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class FontConnectorController {
      constructor(editorAPI) {
        _FontConnectorController_editorAPI.set(this, undefined), _FontConnectorController_blobAPI.set(this, undefined), this.query = (connectorId_1, queryOptions_1, ...args_1) => FontConnectorController_awaiter(this, [connectorId_1, queryOptions_1, ...args_1], undefined, function* (connectorId, queryOptions, context = {}) {
          return (yield FontConnectorController_classPrivateFieldGet(this, _FontConnectorController_editorAPI, "f")).fontConnectorQuery(connectorId, JSON.stringify(queryOptions), JSON.stringify(context)).then((result) => getEditorResponseData(result));
        }), this.detail = (connectorId_1, fontFamilyId_1, ...args_1) => FontConnectorController_awaiter(this, [connectorId_1, fontFamilyId_1, ...args_1], undefined, function* (connectorId, fontFamilyId, context = {}) {
          return (yield FontConnectorController_classPrivateFieldGet(this, _FontConnectorController_editorAPI, "f")).fontConnectorDetail(connectorId, fontFamilyId, JSON.stringify(context)).then((result) => getEditorResponseData(result));
        }), this.download = (connectorId_1, fontStyleId_1, ...args_1) => FontConnectorController_awaiter(this, [connectorId_1, fontStyleId_1, ...args_1], undefined, function* (connectorId, fontStyleId, context = {}) {
          return (yield FontConnectorController_classPrivateFieldGet(this, _FontConnectorController_blobAPI, "f")).fontConnectorDownload(connectorId, fontStyleId, JSON.stringify(context)).then((result) => {
            var _a;
            return (_a = result) !== null && _a !== undefined ? _a : result;
          });
        }), this.preview = (connectorId_1, fontFamilyId_1, previewFormat_1, ...args_1) => FontConnectorController_awaiter(this, [connectorId_1, fontFamilyId_1, previewFormat_1, ...args_1], undefined, function* (connectorId, fontFamilyId, previewFormat, context = {}) {
          return (yield FontConnectorController_classPrivateFieldGet(this, _FontConnectorController_blobAPI, "f")).fontConnectorPreview(connectorId, fontFamilyId, previewFormat, JSON.stringify(context)).then((result) => {
            var _a;
            return (_a = result) !== null && _a !== undefined ? _a : result;
          });
        }), this.getConfigurationOptions = (connectorId) => FontConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield FontConnectorController_classPrivateFieldGet(this, _FontConnectorController_editorAPI, "f")).fontConnectorGetConfigurationOptions(connectorId).then((result) => getEditorResponseData(result));
        }), this.getCapabilities = (connectorId) => FontConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield FontConnectorController_classPrivateFieldGet(this, _FontConnectorController_editorAPI, "f")).fontConnectorGetCapabilities(connectorId).then((result) => getEditorResponseData(result));
        }), this.parseDeprecatedFontType = (deprecatedType) => deprecatedType === DeprecatedMediaType.file ? MediaType.file : deprecatedType === DeprecatedMediaType.collection ? MediaType.collection : undefined, FontConnectorController_classPrivateFieldSet(this, _FontConnectorController_editorAPI, editorAPI, "f"), FontConnectorController_classPrivateFieldSet(this, _FontConnectorController_blobAPI, editorAPI, "f");
      }
    }
    _FontConnectorController_editorAPI = new WeakMap, _FontConnectorController_blobAPI = new WeakMap;
    var _FontController_editorAPI, FontController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, FontController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, FontController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class FontController {
      constructor(editorAPI) {
        _FontController_editorAPI.set(this, undefined), this.addFontFamily = (connectorId, fontFamily) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).addFontFamily(connectorId, JSON.stringify(fontFamily)).then((result) => getEditorResponseData(result));
        }), this.removeFontFamily = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).removeFontFamily(id2).then((result) => getEditorResponseData(result));
        }), this.addFontStyle = (connectorId, fontStyle) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).addFontStyle(connectorId, JSON.stringify(fontStyle)).then((result) => getEditorResponseData(result));
        }), this.removeFontStyle = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).removeFontStyle(id2).then((result) => getEditorResponseData(result));
        }), this.getFontFamilies = () => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).getFontFamilies().then((result) => getEditorResponseData(result));
        }), this.getFontStyles = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).getFontStyles(id2).then((result) => getEditorResponseData(result));
        }), this.getFontFamilyById = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).getFontFamilyById(id2).then((result) => getEditorResponseData(result));
        }), this.getFontStyleById = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).getFontStyleById(id2).then((result) => getEditorResponseData(result));
        }), this.getDefaultFontStyle = () => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).getDefaultFontStyle().then((result) => getEditorResponseData(result));
        }), this.getDefaultFontFamily = () => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).getDefaultFontFamily().then((result) => getEditorResponseData(result));
        }), this.isFontFamilyUsed = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).isFontFamilyUsed(id2).then((result) => getEditorResponseData(result));
        }), this.isFontStyleUsed = (id2) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).isFontStyleUsed(id2).then((result) => getEditorResponseData(result));
        }), this.moveFontFamilies = (order, ids) => FontController_awaiter(this, undefined, undefined, function* () {
          return (yield FontController_classPrivateFieldGet(this, _FontController_editorAPI, "f")).moveFontFamilies(order, ids).then((result) => getEditorResponseData(result));
        }), FontController_classPrivateFieldSet(this, _FontController_editorAPI, editorAPI, "f");
      }
    }
    _FontController_editorAPI = new WeakMap;
    var _ShapeController_editorAPI, ShapeController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ShapeController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ShapeController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ShapeController {
      constructor(editorAPI) {
        _ShapeController_editorAPI.set(this, undefined), this.setShapeProperties = (id2, properties) => ShapeController_awaiter(this, undefined, undefined, function* () {
          return (yield ShapeController_classPrivateFieldGet(this, _ShapeController_editorAPI, "f")).setShapeProperties(id2, JSON.stringify(properties)).then((result) => getEditorResponseData(result));
        }), this.setEnableFill = (id2, enableFill) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const properties = { enableFill };
          return this.setShapeProperties(id2, properties);
        }), this.setFillColor = (id2, fillColor) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const properties = { fillColor };
          return this.setShapeProperties(id2, properties);
        }), this.setEnableStroke = (id2, enableStroke) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const properties = { enableStroke };
          return this.setShapeProperties(id2, properties);
        }), this.setStrokeColor = (id2, strokeColor) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const properties = { strokeColor };
          return this.setShapeProperties(id2, properties);
        }), this.setStrokeWeight = (id2, strokeWeight) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const properties = { strokeWeight };
          return this.setShapeProperties(id2, properties);
        }), this.setFlagAllCornersSame = (id2, allCornersSame) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const properties = { allCornersSame };
          return this.setShapeProperties(id2, properties);
        }), this.setShapeCorners = (id2, radius) => ShapeController_awaiter(this, undefined, undefined, function* () {
          return (yield ShapeController_classPrivateFieldGet(this, _ShapeController_editorAPI, "f")).setShapeCorners(id2, JSON.stringify(radius)).then((result) => getEditorResponseData(result));
        }), this.setRadiusAll = (id2, radius) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const cornerRadius = { radiusAll: radius };
          return this.setShapeCorners(id2, cornerRadius);
        }), this.setRadiusTopLeft = (id2, radius) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const cornerRadius = { topLeft: radius };
          return this.setShapeCorners(id2, cornerRadius);
        }), this.setRadiusBottomLeft = (id2, radius) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const cornerRadius = { bottomLeft: radius };
          return this.setShapeCorners(id2, cornerRadius);
        }), this.setRadiusTopRight = (id2, radius) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const cornerRadius = { topRight: radius };
          return this.setShapeCorners(id2, cornerRadius);
        }), this.setRadiusBottomRight = (id2, radius) => ShapeController_awaiter(this, undefined, undefined, function* () {
          const cornerRadius = { bottomRight: radius };
          return this.setShapeCorners(id2, cornerRadius);
        }), ShapeController_classPrivateFieldSet(this, _ShapeController_editorAPI, editorAPI, "f");
      }
    }
    _ShapeController_editorAPI = new WeakMap;
    var _FrameController_editorAPI, FrameController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, FrameController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, FrameController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class FrameController {
      constructor(editorAPI) {
        _FrameController_editorAPI.set(this, undefined), this.getAll = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFrames().then((result) => getEditorResponseData(result));
        }), this.getSelected = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getSelectedFrames().then((result) => getEditorResponseData(result));
        }), this.getAllByPageId = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFramesByPageId(id2).then((result) => getEditorResponseData(result));
        }), this.getByName = (name) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFrameByName(name).then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFrameById(id2).then((result) => getEditorResponseData(result));
        }), this.getPropertiesOnSelectedLayout = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFramePropertiesOnSelectedLayout().then((result) => getEditorResponseData(result));
        }), this.getLayoutProperties = (id2, layoutId) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFramePropertiesByFrameId(id2, layoutId).then((result) => getEditorResponseData(result));
        }), this.getAllLayoutProperties = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFramesProperties(id2).then((result) => getEditorResponseData(result));
        }), this.resetTransformation = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetSize = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.select = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).selectFrames([id2]).then((result) => getEditorResponseData(result));
        }), this.selectMultiple = (ids) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).selectFrames(ids).then((result) => getEditorResponseData(result));
        }), this.deselectAll = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).deselectFrames().then((result) => getEditorResponseData(result));
        }), this.reorderFrames = (order, ids) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).reorderFrames(order, ids).then((result) => getEditorResponseData(result));
        }), this.setZIndex = (id2, method) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameZIndex(id2, method).then((result) => getEditorResponseData(result));
        }), this.setHeight = (id2, height) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameHeight(id2, height).then((result) => getEditorResponseData(result));
        }), this.setRotation = (id2, rotation) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameRotation(id2, rotation).then((result) => getEditorResponseData(result));
        }), this.setWidth = (id2, width) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameWidth(id2, width).then((result) => getEditorResponseData(result));
        }), this.setX = (id2, XValue) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameX(id2, XValue).then((result) => getEditorResponseData(result));
        }), this.setY = (id2, YValue) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameY(id2, YValue).then((result) => getEditorResponseData(result));
        }), this.rename = (id2, name) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).renameFrame(id2, name).then((result) => getEditorResponseData(result));
        }), this.reset = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrame(id2).then((result) => getEditorResponseData(result));
        }), this.resetX = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetY = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetRotation = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetWidth = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetHeight = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetImageFrameFitMode = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetImageFrameFitMode(id2).then((result) => getEditorResponseData(result));
        }), this.setVisibility = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameIsVisible(id2, value).then((result) => getEditorResponseData(result));
        }), this.setIsVisible = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameIsVisible(id2, value).then((result) => getEditorResponseData(result));
        }), this.remove = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).removeFrames([id2]).then((result) => getEditorResponseData(result));
        }), this.removeFrames = (ids) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).removeFrames(ids).then((result) => getEditorResponseData(result));
        }), this.create = (type, x, y, width, height) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).addFrame(type, x, y, width, height).then((result) => getEditorResponseData(result));
        }), this.createShapeFrame = (type, x, y, width, height) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).addFrame(type, x, y, width, height).then((result) => getEditorResponseData(result));
        }), this.createBarcodeFrame = (type, position) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).addBarcodeFrame(type, position == null ? undefined : position.x, position == null ? undefined : position.y).then((result) => getEditorResponseData(result));
        }), this.duplicateFrames = (ids) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).duplicateFrames(ids).then((result) => getEditorResponseData(result));
        }), this.updateImageSource = (imageFrameId, src2) => FrameController_awaiter(this, undefined, undefined, function* () {
          const res = yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f"), srcJson = src2 !== null ? JSON.stringify(src2) : null;
          return res.setImageSource(imageFrameId, srcJson).then((result) => getEditorResponseData(result));
        }), this.removeImageSource = (imageFrameId) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.updateImageSource(imageFrameId, null);
        }), this.setImageFromConnector = (imageFrameId, connectorId, assetId) => FrameController_awaiter(this, undefined, undefined, function* () {
          const src2 = { id: connectorId, assetId, type: ImageSourceTypeEnum.connector };
          return this.updateImageSource(imageFrameId, src2);
        }), this.setImageFromUrl = (imageFrameId, url) => FrameController_awaiter(this, undefined, undefined, function* () {
          const source = { url, type: ImageSourceTypeEnum.url };
          return this.updateImageSource(imageFrameId, source);
        }), this.setImageFrameFitMode = (imageFrameId, fitMode) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setImageFrameFitMode(imageFrameId, fitMode).then((result) => getEditorResponseData(result));
        }), this.setImageFrameFitModePosition = (imageFrameId, position) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setImageFrameFitModePosition(imageFrameId, position).then((result) => getEditorResponseData(result));
        }), this.setFrameConstrainProportions = (_id, _constrainProportions) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("setFrameConstrainProportions is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "setFrameConstrainProportions is not supported anymore", parsedData: null });
        }), this.setVerticalAlign = (id2, verticalAlign) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setVerticalAlignment(id2, verticalAlign).then((result) => getEditorResponseData(result));
        }), this.setMinCopyfitting = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setMinCopyfitting(id2, value).then((result) => getEditorResponseData(result));
        }), this.setMaxCopyfitting = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setMaxCopyfitting(id2, value).then((result) => getEditorResponseData(result));
        }), this.setEnableCopyfitting = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setEnableCopyfitting(id2, value).then((result) => getEditorResponseData(result));
        }), this.resetMinCopyfitting = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetMinCopyfitting(id2).then((result) => getEditorResponseData(result));
        }), this.resetMaxCopyfitting = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetMaxCopyfitting(id2).then((result) => getEditorResponseData(result));
        }), this.resetEnableCopyfitting = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetEnableCopyfitting(id2).then((result) => getEditorResponseData(result));
        }), this.setShapeFrameEnableFill = (shapeFrameId, enableFill) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.shapeController.setEnableFill(shapeFrameId, enableFill);
        }), this.setShapeFrameFillColor = (shapeFrameId, fillColor) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.shapeController.setFillColor(shapeFrameId, fillColor);
        }), this.setShapeFrameEnableStroke = (shapeFrameId, enableStroke) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.shapeController.setEnableStroke(shapeFrameId, enableStroke);
        }), this.setShapeFrameStrokeColor = (shapeFrameId, strokeColor) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.shapeController.setStrokeColor(shapeFrameId, strokeColor);
        }), this.setShapeFrameStrokeWeight = (shapeFrameId, strokeWeight) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.shapeController.setStrokeWeight(shapeFrameId, strokeWeight);
        }), this.setBlendMode = (id2, blendMode) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameBlendMode(id2, blendMode).then((result) => getEditorResponseData(result));
        }), this.enterCropMode = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).enterCropMode(id2).then((result) => getEditorResponseData(result));
        }), this.applyCropMode = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).applyCropMode().then((result) => getEditorResponseData(result));
        }), this.exitCropMode = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).cancelCropMode().then((result) => getEditorResponseData(result));
        }), this.enterSubjectMode = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).enterSubjectMode(id2).then((result) => getEditorResponseData(result));
        }), this.applySubjectMode = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).applySubjectMode().then((result) => getEditorResponseData(result));
        }), this.exitSubjectMode = () => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).cancelSubjectMode().then((result) => getEditorResponseData(result));
        }), this.resetCropMode = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetCropMode is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetCropMode is not supported anymore", parsedData: null });
        }), this.setEnableAutoGrow = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          const update = { enabled: { value } };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).updateAutoGrowSettings(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.setAutoGrowMinWidth = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          const update = { minWidth: { value } };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).updateAutoGrowSettings(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.setAutoGrowMaxWidth = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          const update = { maxWidth: { value } };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).updateAutoGrowSettings(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.setAutoGrowMinHeight = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          const update = { minHeight: { value } };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).updateAutoGrowSettings(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.setAutoGrowMaxHeight = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          const update = { maxHeight: { value } };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).updateAutoGrowSettings(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.setAutoGrowDirections = (id2, value) => FrameController_awaiter(this, undefined, undefined, function* () {
          const update = { directions: { value } };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).updateAutoGrowSettings(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.resetAutoGrowSettingsEnabled = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrowSettingsEnabled is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrowSettingsEnabled is not supported anymore", parsedData: null });
        }), this.resetAutoGrowMinWidth = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrowMinWidth is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrowMinWidth is not supported anymore", parsedData: null });
        }), this.resetAutoGrowMaxWidth = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrowMaxWidth is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrowMaxWidth is not supported anymore", parsedData: null });
        }), this.resetAutoGrowMinHeight = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrowMinHeight is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrowMinHeight is not supported anymore", parsedData: null });
        }), this.resetAutoGrowMaxHeight = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrowMaxHeight is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrowMaxHeight is not supported anymore", parsedData: null });
        }), this.resetAutoGrowDirections = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrowDirections is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrowDirections is not supported anymore", parsedData: null });
        }), this.resetAutoGrow = (_id) => FrameController_awaiter(this, undefined, undefined, function* () {
          console.error("resetAutoGrow is not supported anymore");
          return getEditorResponseData({ success: false, status: 0, error: "resetAutoGrow is not supported anymore", parsedData: null });
        }), this.setAnchor = (id2, horizontal, anchorType, anchorTarget, endAnchorTarget) => FrameController_awaiter(this, undefined, undefined, function* () {
          const properties = { horizontal, type: anchorType, target: anchorTarget, endTarget: endAnchorTarget };
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setAnchorProperties(id2, JSON.stringify(properties)).then((result) => getEditorResponseData(result));
        }), this.setVerticalAnchor = (id2, anchorType, anchorTarget, endAnchorTarget) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.setAnchor(id2, false, anchorType, anchorTarget, endAnchorTarget);
        }), this.setHorizontalAnchor = (id2, anchorType, anchorTarget, endAnchorTarget) => FrameController_awaiter(this, undefined, undefined, function* () {
          return this.setAnchor(id2, true, anchorType, anchorTarget, endAnchorTarget);
        }), this.resetAnchoring = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).resetFrameTransformation(id2).then((result) => getEditorResponseData(result));
        }), this.resetVisibility = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).setFrameIsVisible(id2, null).then((result) => getEditorResponseData(result));
        }), this.getConfiguration = (id2) => FrameController_awaiter(this, undefined, undefined, function* () {
          return (yield FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f")).getFrameConfiguration(id2).then((result) => getEditorResponseData(result));
        }), FrameController_classPrivateFieldSet(this, _FrameController_editorAPI, editorAPI, "f"), this.shapeController = new ShapeController(FrameController_classPrivateFieldGet(this, _FrameController_editorAPI, "f"));
      }
    }
    _FrameController_editorAPI = new WeakMap;

    class InfoController {
      constructor() {
        this.currentEngineVersion = editor_engine_namespaceObject_V, this.currentSDKVersion = package_namespaceObject_i8;
      }
    }
    var _LayoutController_editorAPI, _LayoutController_blobAPI, MediaDownloadType, MediaDownloadIntent, LayoutController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, LayoutController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, LayoutController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class LayoutController {
      constructor(editorAPI) {
        _LayoutController_editorAPI.set(this, undefined), _LayoutController_blobAPI.set(this, undefined), this.getAll = () => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).getLayouts().then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).getLayoutById(id2).then((result) => getEditorResponseData(result));
        }), this.getByName = (name) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).getLayoutByName(name).then((result) => getEditorResponseData(result));
        }), this.getSelected = () => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).getSelectedLayout().then((result) => getEditorResponseData(result));
        }), this.remove = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).removeLayout(id2).then((result) => getEditorResponseData(result));
        }), this.create = (parentId, presets) => LayoutController_awaiter(this, undefined, undefined, function* () {
          const res = yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f");
          return (presets == null ? undefined : presets.length) ? res.addLayouts(parentId, JSON.stringify(presets)).then((result) => getEditorResponseData(result)) : res.addLayout(parentId).then((result) => getEditorResponseData(result));
        }), this.rename = (id2, name) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).renameLayout(id2, name).then((result) => getEditorResponseData(result));
        }), this.select = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).selectLayout(id2).then((result) => getEditorResponseData(result));
        }), this.duplicate = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).duplicateLayout(id2).then((result) => getEditorResponseData(result));
        }), this.reset = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).resetLayout(id2).then((result) => getEditorResponseData(result));
        }), this.setHeight = (id2, height) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutHeight(id2, height).then((result) => getEditorResponseData(result));
        }), this.setWidth = (id2, width) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutWidth(id2, width).then((result) => getEditorResponseData(result));
        }), this.setUnit = (id2, unit) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutUnit(id2, unit).then((result) => getEditorResponseData(result));
        }), this.resetHeight = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).resetLayoutHeight(id2).then((result) => getEditorResponseData(result));
        }), this.resetWidth = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).resetLayoutWidth(id2).then((result) => getEditorResponseData(result));
        }), this.resetUnit = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).resetLayoutUnit(id2).then((result) => getEditorResponseData(result));
        }), this.getSelectedSnapshot = () => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_blobAPI, "f")).getPageSnapshot().then((result) => {
            var _a;
            return (_a = result) !== null && _a !== undefined ? _a : result;
          });
        }), this.setIntent = (id2, intent) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutIntent(id2, intent).then((result) => getEditorResponseData(result));
        }), this.resetIntent = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).resetLayoutIntent(id2).then((result) => getEditorResponseData(result));
        }), this.setFillColor = (id2, color) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutFillColor(id2, JSON.stringify(color)).then((result) => getEditorResponseData(result));
        }), this.setFillColorEnabled = (id2, enabled) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutFillColorEnabled(id2, enabled).then((result) => getEditorResponseData(result));
        }), this.resetFillColor = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).resetLayoutFillColor(id2).then((result) => getEditorResponseData(result));
        }), this.setBleedValue = (id2, value, position) => LayoutController_awaiter(this, undefined, undefined, function* () {
          const update = position ? { left: position === PositionEnum.left ? value : undefined, top: position === PositionEnum.top ? value : undefined, right: position === PositionEnum.right ? value : undefined, bottom: position === PositionEnum.bottom ? value : undefined } : { left: value, top: value, right: value, bottom: value };
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).updateLayoutBleed(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.setAreBleedValuesCombined = (id2, value) => LayoutController_awaiter(this, undefined, undefined, function* () {
          const update = { areBleedValuesCombined: value };
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).updateLayoutBleed(id2, JSON.stringify(update)).then((result) => getEditorResponseData(result));
        }), this.resetBleedValues = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).updateLayoutBleed(id2, null).then((result) => getEditorResponseData(result));
        }), this.setPrivateData = (id2, privateData) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutPrivateData(id2, JSON.stringify(privateData)).then((result) => getEditorResponseData(result));
        }), this.getPrivateData = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).getLayoutPrivateData(id2).then((result) => getEditorResponseData(result));
        }), this.setDisplayName = (id2, displayName) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutDisplayName(id2, displayName).then((result) => getEditorResponseData(result));
        }), this.getDisplayName = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).getLayoutDisplayName(id2).then((result) => getEditorResponseData(result));
        }), this.resetDisplayName = (id2) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutDisplayName(id2, null).then((result) => getEditorResponseData(result));
        }), this.setAvailableForUser = (id2, isAvailable) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutAvailableForUser(id2, isAvailable).then((result) => getEditorResponseData(result));
        }), this.setSelectedByUser = (id2, isSelected) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutSelectedByUser(id2, isSelected).then((result) => getEditorResponseData(result));
        }), this.setResizableByUser = (id2, resizableLayoutProperties) => LayoutController_awaiter(this, undefined, undefined, function* () {
          return (yield LayoutController_classPrivateFieldGet(this, _LayoutController_editorAPI, "f")).setLayoutResizableByUser(id2, JSON.stringify(resizableLayoutProperties)).then((result) => getEditorResponseData(result));
        }), LayoutController_classPrivateFieldSet(this, _LayoutController_editorAPI, editorAPI, "f"), LayoutController_classPrivateFieldSet(this, _LayoutController_blobAPI, editorAPI, "f");
      }
    }
    _LayoutController_editorAPI = new WeakMap, _LayoutController_blobAPI = new WeakMap, function(MediaDownloadType2) {
      MediaDownloadType2.thumbnail = "thumbnail", MediaDownloadType2.mediumres = "mediumres", MediaDownloadType2.highres = "highres", MediaDownloadType2.original = "original";
    }(MediaDownloadType || (MediaDownloadType = {})), function(MediaDownloadIntent2) {
      MediaDownloadIntent2.web = "web";
    }(MediaDownloadIntent || (MediaDownloadIntent = {}));
    var _MediaConnectorController_editorAPI, _MediaConnectorController_blobAPI, MediaConnectorController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, MediaConnectorController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, MediaConnectorController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class MediaConnectorController {
      constructor(editorAPI) {
        _MediaConnectorController_editorAPI.set(this, undefined), _MediaConnectorController_blobAPI.set(this, undefined), this.query = (id_1, queryOptions_1, ...args_1) => MediaConnectorController_awaiter(this, [id_1, queryOptions_1, ...args_1], undefined, function* (id2, queryOptions, context = {}) {
          return (yield MediaConnectorController_classPrivateFieldGet(this, _MediaConnectorController_editorAPI, "f")).mediaConnectorQuery(id2, JSON.stringify(queryOptions), JSON.stringify(context)).then((result) => getEditorResponseData(result));
        }), this.detail = (id_1, mediaId_1, ...args_1) => MediaConnectorController_awaiter(this, [id_1, mediaId_1, ...args_1], undefined, function* (id2, mediaId, context = {}) {
          return (yield MediaConnectorController_classPrivateFieldGet(this, _MediaConnectorController_editorAPI, "f")).mediaConnectorDetail(id2, mediaId, JSON.stringify(context)).then((result) => getEditorResponseData(result));
        }), this.download = (id_1, mediaId_1, downloadType_1, ...args_1) => MediaConnectorController_awaiter(this, [id_1, mediaId_1, downloadType_1, ...args_1], undefined, function* (id2, mediaId, downloadType, context = {}) {
          const compatibleDownloadType = this.parseDeprecatedMediaDownloadType(downloadType);
          return (yield MediaConnectorController_classPrivateFieldGet(this, _MediaConnectorController_blobAPI, "f")).mediaConnectorDownload(id2, mediaId, compatibleDownloadType, MediaDownloadIntent.web, JSON.stringify(context)).then((result) => {
            var _a;
            return (_a = result) !== null && _a !== undefined ? _a : result;
          });
        }), this.getConfigurationOptions = (id2) => MediaConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield MediaConnectorController_classPrivateFieldGet(this, _MediaConnectorController_editorAPI, "f")).mediaConnectorGetConfigurationOptions(id2).then((result) => getEditorResponseData(result));
        }), this.getCapabilities = (id2) => MediaConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield MediaConnectorController_classPrivateFieldGet(this, _MediaConnectorController_editorAPI, "f")).mediaConnectorGetCapabilities(id2).then((result) => getEditorResponseData(result));
        }), this.parseDeprecatedMediaType = (deprecatedType) => deprecatedType === DeprecatedMediaType.file ? MediaType.file : deprecatedType === DeprecatedMediaType.collection ? MediaType.collection : undefined, MediaConnectorController_classPrivateFieldSet(this, _MediaConnectorController_editorAPI, editorAPI, "f"), MediaConnectorController_classPrivateFieldSet(this, _MediaConnectorController_blobAPI, editorAPI, "f");
      }
      parseDeprecatedMediaDownloadType(deprecatedMediaDownloadType) {
        switch (deprecatedMediaDownloadType) {
          case DeprecatedMediaConnectorDownloadType.HighResolutionWeb:
            return MediaDownloadType.highres;
          case DeprecatedMediaConnectorDownloadType.LowResolutionWeb:
            return MediaDownloadType.thumbnail;
          default:
            return deprecatedMediaDownloadType;
        }
      }
    }
    _MediaConnectorController_editorAPI = new WeakMap, _MediaConnectorController_blobAPI = new WeakMap;
    var _PageController_editorAPI, _PageController_blobAPI, PageController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, PageController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, PageController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class PageController {
      constructor(editorAPI) {
        _PageController_editorAPI.set(this, undefined), _PageController_blobAPI.set(this, undefined), this.add = () => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).addPage().then((result) => getEditorResponseData(result));
        }), this.remove = (pageId) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).removePage(pageId).then((result) => getEditorResponseData(result));
        }), this.select = (pageId) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).selectPage(pageId).then((result) => getEditorResponseData(result));
        }), this.setVisibility = (pageId, isVisible) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).setPageIsVisible(pageId, isVisible).then((result) => getEditorResponseData(result));
        }), this.duplicate = (pageId) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).duplicatePage(pageId).then((result) => getEditorResponseData(result));
        }), this.getAll = () => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).getPages().then((result) => getEditorResponseData(result));
        }), this.getById = (pageId) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).getPageById(pageId).then((result) => getEditorResponseData(result));
        }), this.getSnapshot = (pageId, settings) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_blobAPI, "f")).getPageSnapshotWithSettings(pageId, settings == null ? null : JSON.stringify(settings)).then((result) => {
            var _a;
            return (_a = result) !== null && _a !== undefined ? _a : result;
          });
        }), this.setWidth = (_pageId, width) => PageController_awaiter(this, undefined, undefined, function* () {
          _pageId !== undefined && console.warn("pageId has no effect since all pages are being updated simultaneously.");
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).setPageWidth(width).then((result) => getEditorResponseData(result));
        }), this.setHeight = (_pageId, height) => PageController_awaiter(this, undefined, undefined, function* () {
          _pageId !== undefined && console.warn("pageId has no effect since all pages are being updated simultaneously.");
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).setPageHeight(height).then((result) => getEditorResponseData(result));
        }), this.move = (order, ids) => PageController_awaiter(this, undefined, undefined, function* () {
          return (yield PageController_classPrivateFieldGet(this, _PageController_editorAPI, "f")).reorderPages(order, ids).then((result) => getEditorResponseData(result));
        }), PageController_classPrivateFieldSet(this, _PageController_editorAPI, editorAPI, "f"), PageController_classPrivateFieldSet(this, _PageController_blobAPI, editorAPI, "f");
      }
    }
    _PageController_editorAPI = new WeakMap, _PageController_blobAPI = new WeakMap;
    var _ParagraphStyleController_editorAPI, LogLevel, LogCategory, CallbackErrorBehavior, ConnectorConfigValueType, AsyncErrorType, VariableType, Day, Locale, VariableVisibilityType, VariableVisibilityTargetType, VariableVisibilityOperator, ParagraphStyleController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ParagraphStyleController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ParagraphStyleController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ParagraphStyleController {
      constructor(editorAPI) {
        _ParagraphStyleController_editorAPI.set(this, undefined), this.getAll = () => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).getParagraphStyles().then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).getParagraphStyleById(id2).then((result) => getEditorResponseData(result));
        }), this.create = () => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).createParagraphStyle().then((result) => getEditorResponseData(result));
        }), this.duplicate = (id2) => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).duplicateParagraphStyle(id2).then((result) => getEditorResponseData(result));
        }), this.update = (id2, properties) => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).updateParagraphStyle(id2, JSON.stringify(properties)).then((result) => getEditorResponseData(result));
        }), this.rename = (id2, name) => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).renameParagraphStyle(id2, name).then((result) => getEditorResponseData(result));
        }), this.remove = (id2) => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).removeParagraphStyle(id2).then((result) => getEditorResponseData(result));
        }), this.move = (order, ids) => ParagraphStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield ParagraphStyleController_classPrivateFieldGet(this, _ParagraphStyleController_editorAPI, "f")).moveParagraphStyles(order, ids).then((result) => getEditorResponseData(result));
        }), ParagraphStyleController_classPrivateFieldSet(this, _ParagraphStyleController_editorAPI, editorAPI, "f");
      }
    }
    _ParagraphStyleController_editorAPI = new WeakMap, function(LogLevel2) {
      LogLevel2.info = "info", LogLevel2.warn = "warn", LogLevel2.error = "error";
    }(LogLevel || (LogLevel = {})), function(LogCategory2) {
      LogCategory2.general = "general", LogCategory2.connector = "connector", LogCategory2.event = "event", LogCategory2.engine = "engine";
    }(LogCategory || (LogCategory = {})), function(CallbackErrorBehavior2) {
      CallbackErrorBehavior2.throw = "throw", CallbackErrorBehavior2.log = "log";
    }(CallbackErrorBehavior || (CallbackErrorBehavior = {})), function(ConnectorConfigValueType2) {
      ConnectorConfigValueType2.text = "text", ConnectorConfigValueType2.boolean = "boolean";
    }(ConnectorConfigValueType || (ConnectorConfigValueType = {}));

    class ActionAsyncError {
      constructor(message, id2, event, eventChain) {
        this.type = AsyncErrorType.action, this.message = message, this.id = id2, this.event = event, this.eventChain = eventChain;
      }
    }

    class DataRowAsyncError {
      constructor(count, message, exceptions) {
        this.type = AsyncErrorType.dataRow, this.count = count, this.message = message, this.exceptions = exceptions;
      }
    }
    (function(AsyncErrorType2) {
      AsyncErrorType2.action = "action", AsyncErrorType2.dataRow = "dataRow";
    })(AsyncErrorType || (AsyncErrorType = {})), function(VariableType2) {
      VariableType2.shortText = "shortText", VariableType2.longText = "longText", VariableType2.image = "image", VariableType2.list = "list", VariableType2.boolean = "boolean", VariableType2.group = "group", VariableType2.number = "number", VariableType2.date = "date";
    }(VariableType || (VariableType = {})), function(Day2) {
      Day2.Monday = "monday", Day2.Tuesday = "tuesday", Day2.Wednesday = "wednesday", Day2.Thursday = "thursday", Day2.Friday = "friday", Day2.Saturday = "saturday", Day2.Sunday = "sunday";
    }(Day || (Day = {})), function(Locale2) {
      Locale2.en_US = "en_US", Locale2.cs = "cs", Locale2.da = "da", Locale2.nl = "nl", Locale2.fi = "fi", Locale2.fr = "fr", Locale2.de = "de", Locale2.it = "it", Locale2.no = "no", Locale2.pl = "pl", Locale2.pt_PT = "pt_PT", Locale2.es_ES = "es_ES", Locale2.sv = "sv";
    }(Locale || (Locale = {})), function(VariableVisibilityType2) {
      VariableVisibilityType2.visible = "visible", VariableVisibilityType2.invisible = "invisible", VariableVisibilityType2.conditional = "conditional";
    }(VariableVisibilityType || (VariableVisibilityType = {})), function(VariableVisibilityTargetType2) {
      VariableVisibilityTargetType2.boolean = "boolean", VariableVisibilityTargetType2.text = "text", VariableVisibilityTargetType2.number = "number";
    }(VariableVisibilityTargetType || (VariableVisibilityTargetType = {})), function(VariableVisibilityOperator2) {
      VariableVisibilityOperator2.equals = "=", VariableVisibilityOperator2.notEquals = "!=", VariableVisibilityOperator2.greaterThan = ">", VariableVisibilityOperator2.greaterThanOrEquals = ">=", VariableVisibilityOperator2.lessThan = "<", VariableVisibilityOperator2.lessThanOrEquals = "<=";
    }(VariableVisibilityOperator || (VariableVisibilityOperator = {}));
    var SubscriberController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    class SubscriberController {
      constructor(config, localConfig) {
        this.onActionsChanged = (actions) => {
          this.config.events.onActionsChanged.trigger(JSON.parse(actions));
        }, this.onAnimationChanged = (animation) => {
          this.config.events.onFrameAnimationsChanged.trigger(JSON.parse(animation));
        }, this.onAnimationPlaybackChanged = (animationPlaybackState) => {
          this.config.events.onScrubberPositionChanged.trigger(JSON.parse(animationPlaybackState));
        }, this.onSelectedLayoutPropertiesChanged = (layoutProperties) => {
          this.config.events.onSelectedLayoutPropertiesChanged.trigger(JSON.parse(layoutProperties));
        }, this.onSelectedLayoutUnitChanged = (unit) => {
          this.config.events.onSelectedLayoutUnitChanged.trigger(unit);
        }, this.onFramesLayoutChanged = (framesLayout) => {
          const frames = JSON.parse(framesLayout);
          this.config.events.onFramesLayoutChanged.trigger(frames);
        }, this.onSelectedFramesLayoutChanged = (framesLayout) => {
          const frames = JSON.parse(framesLayout);
          this.config.events.onSelectedFramesLayoutChanged.trigger(frames);
          const singleFrameCallBack = this.config.onSelectedFrameLayoutChanged;
          singleFrameCallBack && singleFrameCallBack(frames.length > 1 ? undefined : frames[0]);
        }, this.onSelectedFramesContentChanged = (framesContent) => {
          const frames = JSON.parse(framesContent);
          this.config.events.onSelectedFramesContentChanged.trigger(frames);
          const singleFrameCallBack = this.config.onSelectedFrameContentChanged;
          singleFrameCallBack && singleFrameCallBack(frames.length > 1 ? null : frames[0]);
        }, this.onStateChanged = () => {
          this.config.events.onStateChanged.trigger();
        }, this.onAuthExpired = (authRefreshRequest) => SubscriberController_awaiter(this, undefined, undefined, function* () {
          const authCredentials = yield this.config.handlers.onAuthExpired.trigger(JSON.parse(authRefreshRequest));
          return authCredentials != null ? JSON.stringify(authCredentials) : null;
        }), this.onViewportRequested = () => {
          const viewport = this.config.handlers.onViewportRequested.trigger();
          return viewport != null ? JSON.stringify(viewport) : null;
        }, this.onDocumentLoaded = () => {
          this.config.events.onDocumentLoaded.trigger();
        }, this.onPageSelectionChanged = (id2) => {
          this.config.events.onPageSelectionChanged.trigger(id2);
        }, this.onVariableListChanged = (variablesJson) => {
          const updated = JSON.parse(variablesJson).map((variable) => {
            var _a;
            return variable.type === VariableType.list ? Object.assign(Object.assign({}, variable), { items: variable.items.map((item) => item.value), selected: (_a = variable.selected) === null || _a === undefined ? undefined : _a.value }) : variable;
          });
          this.config.events.onVariableListChanged.trigger(updated);
        }, this.onSelectedToolChanged = (tool) => {
          this.config.events.onSelectedToolChanged.trigger(tool);
        }, this.onUndoStateChanged = (undoState) => {
          this.config.events.onUndoStackStateChanged.trigger(JSON.parse(undoState));
        }, this.onCustomUndoDataChanged = (customData) => {
          this.config.events.onCustomUndoDataChanged.trigger(JSON.parse(customData));
        }, this.onSelectedLayoutFramesChanged = (layoutFrames) => {
          this.config.events.onSelectedLayoutFramesChanged.trigger(JSON.parse(layoutFrames));
        }, this.onSelectedTextStyleChanged = (styles) => {
          this.config.events.onSelectedTextStyleChanged.trigger(JSON.parse(styles));
        }, this.onColorsChanged = (colors) => {
          this.config.events.onColorsChanged.trigger(JSON.parse(colors));
        }, this.onParagraphStylesChanged = (paragraphStyles) => {
          this.config.events.onParagraphStylesChanged.trigger(JSON.parse(paragraphStyles));
        }, this.onCharacterStylesChanged = (characterStyles) => {
          this.config.events.onCharacterStylesChanged.trigger(JSON.parse(characterStyles));
        }, this.onFontFamiliesChanged = (fonts) => {
          this.config.events.onFontFamiliesChanged.trigger(JSON.parse(fonts));
        }, this.onSelectedLayoutIdChanged = (id2) => {
          this.config.events.onSelectedLayoutIdChanged.trigger(id2);
        }, this.onLayoutsChanged = (layouts) => {
          this.config.events.onLayoutsChanged.trigger(JSON.parse(layouts));
        }, this.onZoomChanged = (zoom) => {
          this.config.events.onZoomChanged.trigger(JSON.parse(zoom));
        }, this.onConnectorEvent = (connectorEvent) => {
          this.config.events.onConnectorEvent.trigger(JSON.parse(connectorEvent));
        }, this.onConnectorsChanged = (connectors) => {
          const compatibleConnectors = new ConnectorCompatibilityTools().makeMultipleConnectorsBackwardsCompatible(JSON.parse(connectors), this.localConfig.get(WellKnownConfigurationKeys.GraFxStudioEnvironmentApiUrl));
          this.config.events.onConnectorsChanged.trigger(compatibleConnectors);
        }, this.onSelectedPageIdChanged = (pageId) => {
          this.config.events.onSelectedPageIdChanged.trigger(pageId);
        }, this.onPagesChanged = (pages) => {
          this.config.events.onPagesChanged.trigger(JSON.parse(pages));
        }, this.onPageSnapshotInvalidated = (page) => {
          this.config.events.onPageSnapshotInvalidated.trigger(JSON.parse(page));
        }, this.onPageSizeChanged = (pageSize) => {
          this.config.events.onPageSizeChanged.trigger(JSON.parse(pageSize));
        }, this.onShapeCornerRadiusChanged = (cornerRadius) => {
          this.config.events.onShapeCornerRadiusChanged.trigger(JSON.parse(cornerRadius));
        }, this.onCropActiveFrameIdChanged = (id2) => {
          this.config.events.onCropActiveFrameIdChanged.trigger(id2);
        }, this.onAsyncError = (asyncError) => {
          const parsedError = JSON.parse(asyncError);
          if ((parsedError == null ? undefined : parsedError.type) === "dataRow") {
            const dataRowException = new DataRowAsyncError(parsedError.count, parsedError.message, parsedError.exceptions);
            this.config.events.onAsyncError.trigger(dataRowException);
          } else if ((parsedError == null ? undefined : parsedError.type) === "action") {
            const actionException = new ActionAsyncError(parsedError.message, parsedError.id, parsedError.event, parsedError.eventChain);
            this.config.events.onAsyncError.trigger(actionException);
          } else
            this.config.events.onAsyncError.trigger(parsedError);
        }, this.onViewModeChanged = (viewMode) => {
          this.config.events.onViewModeChanged.trigger(viewMode);
        }, this.onBarcodeValidationChanged = (validationResults) => {
          this.config.events.onBarcodeValidationChanged.trigger(JSON.parse(validationResults));
        }, this.onDataSourceIdChanged = (connectorId) => {
          this.config.events.onDataSourceIdChanged.trigger(connectorId);
        }, this.onDocumentIssueListChanged = (documentIssues) => {
          this.config.events.onDocumentIssueListChanged.trigger(JSON.parse(documentIssues));
        }, this.onEngineEditModeChanged = (engineEditMode) => {
          this.config.events.onEngineEditModeChanged.trigger(JSON.parse(engineEditMode));
        }, this.config = config, this.localConfig = localConfig;
      }
    }
    var _TextStyleController_editorAPI, FramePropertyNames, LayoutPropertyNames, ToolType, DownloadFormats, EnvironmentType, TextStyleController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, TextStyleController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, TextStyleController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class TextStyleController {
      constructor(editorAPI) {
        _TextStyleController_editorAPI.set(this, undefined), this.set = (style2) => TextStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield TextStyleController_classPrivateFieldGet(this, _TextStyleController_editorAPI, "f")).selectedTextStyleDeltaUpdate(JSON.stringify(style2)).then((result) => getEditorResponseData(result));
        }), this.removeSelected = () => TextStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield TextStyleController_classPrivateFieldGet(this, _TextStyleController_editorAPI, "f")).selectedTextStyleClean().then((result) => getEditorResponseData(result));
        }), this.getSelected = () => TextStyleController_awaiter(this, undefined, undefined, function* () {
          return (yield TextStyleController_classPrivateFieldGet(this, _TextStyleController_editorAPI, "f")).getSelectedTextStyle().then((result) => getEditorResponseData(result));
        }), TextStyleController_classPrivateFieldSet(this, _TextStyleController_editorAPI, editorAPI, "f");
      }
    }
    _TextStyleController_editorAPI = new WeakMap, function(FramePropertyNames2) {
      FramePropertyNames2.FRAME_X = "frameX", FramePropertyNames2.FRAME_Y = "frameY", FramePropertyNames2.WIDTH = "width", FramePropertyNames2.HEIGHT = "height", FramePropertyNames2.FRAME_ROTATION = "frameRotation";
    }(FramePropertyNames || (FramePropertyNames = {})), function(LayoutPropertyNames2) {
      LayoutPropertyNames2.LAYOUT_HEIGHT = "layoutHeight", LayoutPropertyNames2.LAYOUT_WIDTH = "layoutWidth", LayoutPropertyNames2.BLEED_TOP = "bleedTop", LayoutPropertyNames2.BLEED_BOTTOM = "bleedBottom", LayoutPropertyNames2.BLEED_LEFT = "bleedLeft", LayoutPropertyNames2.BLEED_RIGHT = "bleedRight", LayoutPropertyNames2.BLEED_VALUES_COMBINED = "areBleedValuesCombined";
    }(LayoutPropertyNames || (LayoutPropertyNames = {})), function(ToolType2) {
      ToolType2.SELECT = "select", ToolType2.ZOOM = "zoom", ToolType2.HAND = "hand", ToolType2.IMAGE_FRAME = "imageFrame", ToolType2.TEXT_FRAME = "textFrame", ToolType2.SHAPE_RECT = "rect", ToolType2.SHAPE_ELLIPSE = "ellipse", ToolType2.SHAPE_POLYGON = "polygon";
    }(ToolType || (ToolType = {})), function(DownloadFormats2) {
      DownloadFormats2.MP4 = "mp4", DownloadFormats2.GIF = "gif", DownloadFormats2.PNG = "png", DownloadFormats2.JPG = "jpg", DownloadFormats2.PDF = "pdf";
    }(DownloadFormats || (DownloadFormats = {})), function(EnvironmentType2) {
      EnvironmentType2.SANDBOX = "sandbox", EnvironmentType2.PRODUCTION = "online";
    }(EnvironmentType || (EnvironmentType = {}));
    var _ToolController_editorAPI, ToolController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ToolController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ToolController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ToolController {
      constructor(editorAPI) {
        _ToolController_editorAPI.set(this, undefined), this.setTool = (tool) => ToolController_awaiter(this, undefined, undefined, function* () {
          return (yield ToolController_classPrivateFieldGet(this, _ToolController_editorAPI, "f")).setTool(tool).then((result) => getEditorResponseData(result));
        }), this.getSelected = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return (yield ToolController_classPrivateFieldGet(this, _ToolController_editorAPI, "f")).getSelectedTool().then((result) => getEditorResponseData(result));
        }), this.setPointer = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.SELECT);
        }), this.setSelect = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.SELECT);
        }), this.setHand = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.HAND);
        }), this.setZoom = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.ZOOM);
        }), this.setTextFrame = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.TEXT_FRAME);
        }), this.setImageFrame = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.IMAGE_FRAME);
        }), this.setShapeRect = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.SHAPE_RECT);
        }), this.setShapeEllipse = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.SHAPE_ELLIPSE);
        }), this.setShapePolygon = () => ToolController_awaiter(this, undefined, undefined, function* () {
          return this.setTool(ToolType.SHAPE_POLYGON);
        }), ToolController_classPrivateFieldSet(this, _ToolController_editorAPI, editorAPI, "f");
      }
    }
    _ToolController_editorAPI = new WeakMap;
    var _UndoManagerController_editorAPI, _UndoManagerController_advanced, _UndoManagerController_sdk, _AdvancedUndoManagerController_editorAPI, UndoManagerController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, UndoManagerController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, UndoManagerController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class UndoManagerController {
      constructor(children, sdk) {
        _UndoManagerController_editorAPI.set(this, undefined), _UndoManagerController_advanced.set(this, undefined), _UndoManagerController_sdk.set(this, undefined), this.undo = () => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_editorAPI, "f")).undo().then((result) => getEditorResponseData(result));
        }), this.redo = () => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_editorAPI, "f")).redo().then((result) => getEditorResponseData(result));
        }), this.addCustomData = (key, value) => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_editorAPI, "f")).setCustomUndoData(key, value, false).then((result) => getEditorResponseData(result));
        }), this.record = (operationName, undoOperationCallback) => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          try {
            yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_advanced, "f").beginIfNoneActive(operationName), yield undoOperationCallback(UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_sdk, "f"));
          } catch (error) {
            throw error;
          } finally {
            yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_advanced, "f").end();
          }
        }), this.pause = () => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_editorAPI, "f")).pause().then((result) => getEditorResponseData(result));
        }), this.resume = () => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _UndoManagerController_editorAPI, "f")).resume().then((result) => getEditorResponseData(result));
        }), UndoManagerController_classPrivateFieldSet(this, _UndoManagerController_editorAPI, children, "f"), UndoManagerController_classPrivateFieldSet(this, _UndoManagerController_sdk, sdk, "f"), UndoManagerController_classPrivateFieldSet(this, _UndoManagerController_advanced, new AdvancedUndoManagerController(children), "f");
      }
    }
    _UndoManagerController_editorAPI = new WeakMap, _UndoManagerController_advanced = new WeakMap, _UndoManagerController_sdk = new WeakMap;

    class AdvancedUndoManagerController {
      constructor(children) {
        _AdvancedUndoManagerController_editorAPI.set(this, undefined), this.begin = (operationName) => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _AdvancedUndoManagerController_editorAPI, "f")).begin(operationName).then((result) => getEditorResponseData(result));
        }), this.beginIfNoneActive = (operationName) => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _AdvancedUndoManagerController_editorAPI, "f")).beginIfNoneActive(operationName).then((result) => getEditorResponseData(result));
        }), this.end = () => UndoManagerController_awaiter(this, undefined, undefined, function* () {
          return (yield UndoManagerController_classPrivateFieldGet(this, _AdvancedUndoManagerController_editorAPI, "f")).end().then((result) => getEditorResponseData(result));
        }), UndoManagerController_classPrivateFieldSet(this, _AdvancedUndoManagerController_editorAPI, children, "f");
      }
    }
    _AdvancedUndoManagerController_editorAPI = new WeakMap;
    const round = (val, precision = 2) => {
      const hundred = Math.pow(10, precision);
      return Math.round(val * hundred) / hundred;
    };

    class UtilsController {
      constructor() {
        this.round = (val, precision) => getEditorResponseData({ data: String(round(val, precision)), success: true, status: 200, parsedData: null }), this.createEnvironmentBaseURL = (parameters) => {
          const { type = EnvironmentType.SANDBOX, environment = "ft-nostress", version: version2 = "1" } = parameters;
          return `https://${environment}.${type == EnvironmentType.SANDBOX ? "chili-publish-sandbox" : "chili-publish"}.online/grafx/api/v${version2}/environment/${environment}`;
        };
      }
    }
    var _NumberVariable_editorAPI, _DateVariable_editorAPI, _VariableController_editorAPI, _VariableController_setPlaceholder, _VariableController_setHelpText, VariableController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, VariableController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, VariableController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class NumberVariable {
      constructor(editorAPI) {
        _NumberVariable_editorAPI.set(this, undefined), this.setMinimum = (id2, minimum) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { minValue: { value: minimum } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setMaximum = (id2, maximum) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { maxValue: { value: maximum } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setShowStepper = (id2, showStepper) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { showStepper: { value: showStepper } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setStepSize = (id2, stepSize) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { stepSize: { value: stepSize } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setThousandsSeparator = (id2, thousandsSeparator) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { thousandsSeparator: { value: thousandsSeparator } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setDecimalSeparator = (id2, decimalSeparator) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { decimalSeparator: { value: decimalSeparator } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setDecimalCharacterStyle = (id2, characterStyleId) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { decimalCharacterStyleId: { value: characterStyleId } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setNumberOfDecimals = (id2, numberOfDecimals) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { numberOfDecimals: { value: numberOfDecimals } };
          return this.applyPropertiesUpdate(id2, update);
        }), VariableController_classPrivateFieldSet(this, _NumberVariable_editorAPI, editorAPI, "f");
      }
      applyPropertiesUpdate(id2, update) {
        return VariableController_awaiter(this, undefined, undefined, function* () {
          const res = yield VariableController_classPrivateFieldGet(this, _NumberVariable_editorAPI, "f");
          return getEditorResponseData(yield res.updateNumberVariableProperties(id2, JSON.stringify(update)));
        });
      }
    }
    _NumberVariable_editorAPI = new WeakMap;

    class DateVariable {
      constructor(editorAPI) {
        _DateVariable_editorAPI.set(this, undefined), this.setDisplayFormat = (id2, displayFormat) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { displayFormat: { value: displayFormat } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setLocale = (id2, locale) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { locale: { value: locale } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setStartDate = (id2, date) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { startDate: { value: date } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setEndDate = (id2, date) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { endDate: { value: date } };
          return this.applyPropertiesUpdate(id2, update);
        }), this.setExcludedDays = (id2, excludedDays) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { excludedDays: { value: excludedDays } };
          return this.applyPropertiesUpdate(id2, update);
        }), VariableController_classPrivateFieldSet(this, _DateVariable_editorAPI, editorAPI, "f");
      }
      applyPropertiesUpdate(id2, update) {
        return VariableController_awaiter(this, undefined, undefined, function* () {
          const res = yield VariableController_classPrivateFieldGet(this, _DateVariable_editorAPI, "f");
          return getEditorResponseData(yield res.updateDateVariableProperties(id2, JSON.stringify(update)));
        });
      }
    }
    _DateVariable_editorAPI = new WeakMap;

    class VariableController {
      constructor(editorAPI) {
        _VariableController_editorAPI.set(this, undefined), this.getAll = () => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).getVariables().then((result) => getEditorResponseData(result)).then((resp) => {
            const update = resp;
            return update.parsedData && (update.parsedData = this.makeVariablesBackwardsCompatible(update.parsedData)), update;
          });
        }), this.getById = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).getVariableById(id2).then((result) => getEditorResponseData(result)).then((resp) => {
            const update = resp;
            return update.parsedData && (update.parsedData = this.makeVariableBackwardsCompatible(update.parsedData)), update;
          });
        }), this.getByName = (name) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).getVariableByName(name).then((result) => getEditorResponseData(result)).then((resp) => {
            const update = resp;
            return update.parsedData && (update.parsedData = this.makeVariableBackwardsCompatible(update.parsedData)), update;
          });
        }), this.create = (parentId, type) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).addVariable(parentId, type).then((result) => getEditorResponseData(result));
        }), this.remove = (ids) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).removeVariables(ids).then((result) => getEditorResponseData(result));
        }), this.rename = (id2, name) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableName(id2, name).then((result) => getEditorResponseData(result));
        }), this.setLabel = (id2, label) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableLabel(id2, label).then((result) => getEditorResponseData(result));
        }), _VariableController_setPlaceholder.set(this, (id2, placeholder) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariablePlaceholder(id2, placeholder).then((result) => getEditorResponseData(result));
        })), this.setPlaceholder = (id2, placeholder) => VariableController_awaiter(this, undefined, undefined, function* () {
          return VariableController_classPrivateFieldGet(this, _VariableController_setPlaceholder, "f").call(this, id2, placeholder);
        }), this.resetPlaceholder = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return VariableController_classPrivateFieldGet(this, _VariableController_setPlaceholder, "f").call(this, id2, null);
        }), _VariableController_setHelpText.set(this, (id2, helpText) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableHelpText(id2, helpText).then((result) => getEditorResponseData(result));
        })), this.setHelpText = (id2, helpText) => VariableController_awaiter(this, undefined, undefined, function* () {
          return VariableController_classPrivateFieldGet(this, _VariableController_setHelpText, "f").call(this, id2, helpText);
        }), this.resetHelpText = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return VariableController_classPrivateFieldGet(this, _VariableController_setHelpText, "f").call(this, id2, null);
        }), this.setType = (id2, type) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableType(id2, type).then((result) => getEditorResponseData(result));
        }), this.setListVariable = (id2, items) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setListVariableItems(id2, items.map((item) => JSON.stringify({ value: item }))).then((result) => getEditorResponseData(result));
        }), this.setValue = (id2, value) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableValue(id2, value).then((result) => getEditorResponseData(result));
        }), this.duplicate = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).duplicateVariable(id2).then((result) => getEditorResponseData(result));
        }), this.groupVariables = (name, ids) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).groupVariables(name, ids).then((result) => getEditorResponseData(result));
        }), this.ungroupVariables = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).ungroupVariable(id2).then((result) => getEditorResponseData(result));
        }), this.move = (order, id2, parentId) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).moveVariable(id2, parentId, order).then((result) => getEditorResponseData(result));
        }), this.moveVariables = (order, ids, parentId) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).moveVariables(ids, parentId, order).then((result) => getEditorResponseData(result));
        }), this.setIsVisible = (id2, isVisible) => VariableController_awaiter(this, undefined, undefined, function* () {
          const config = isVisible ? { type: VariableVisibilityType.visible } : { type: VariableVisibilityType.invisible };
          return this.setVariableVisibility(id2, config);
        }), this.setIsHidden = (id2, isHidden) => VariableController_awaiter(this, undefined, undefined, function* () {
          const config = isHidden ? { type: VariableVisibilityType.invisible } : { type: VariableVisibilityType.visible };
          return this.setVariableVisibility(id2, config);
        }), this.setVariableVisibility = (id2, config) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableVisibility(id2, JSON.stringify(config)).then((result) => getEditorResponseData(result));
        }), this.setLayoutsForVariableVisibility = (layoutIdList) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setLayoutsForVariableVisibility(layoutIdList ? JSON.stringify(layoutIdList) : null).then((result) => getEditorResponseData(result));
        }), this.setIsRequired = (id2, isRequired) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableIsRequired(id2, isRequired).then((result) => getEditorResponseData(result));
        }), this.setIsReadonly = (id2, isReadonly) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariableIsReadonly(id2, isReadonly).then((result) => getEditorResponseData(result));
        }), this.getImageVariableConnectorId = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).getImageVariableConnectorId(id2).then((result) => getEditorResponseData(result));
        }), this.setImageVariableConnector = (id2, registration) => VariableController_awaiter(this, undefined, undefined, function* () {
          const res = yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f"), connectorRegistration = new ConnectorCompatibilityTools().makeConnectorSourceForwardsCompatible(registration);
          return res.setImageVariableConnector(id2, JSON.stringify(connectorRegistration)).then((result) => getEditorResponseData(result));
        }), this.removeSource = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return this.setValue(id2, null);
        }), this.setPrefix = (id2, prefix2) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { prefix: { value: prefix2 } };
          return this.applyPrefixSuffixDeltaUpdate(id2, update);
        }), this.setSuffix = (id2, suffix2) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { suffix: { value: suffix2 } };
          return this.applyPrefixSuffixDeltaUpdate(id2, update);
        }), this.setPrefixCharacterStyle = (id2, characterStyleId) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { prefixCharacterStyleId: { value: characterStyleId } };
          return this.applyPrefixSuffixDeltaUpdate(id2, update);
        }), this.setSuffixCharacterStyle = (id2, characterStyleId) => VariableController_awaiter(this, undefined, undefined, function* () {
          const update = { suffixCharacterStyleId: { value: characterStyleId } };
          return this.applyPrefixSuffixDeltaUpdate(id2, update);
        }), this.setPrivateData = (id2, privateData) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).setVariablePrivateData(id2, JSON.stringify(privateData)).then((result) => getEditorResponseData(result));
        }), this.getPrivateData = (id2) => VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")).getVariablePrivateData(id2).then((result) => getEditorResponseData(result));
        }), VariableController_classPrivateFieldSet(this, _VariableController_editorAPI, editorAPI, "f"), this.number = new NumberVariable(VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f")), this.date = new DateVariable(VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f"));
      }
      makeVariablesBackwardsCompatible(variables) {
        return variables.map((variable) => this.makeVariableBackwardsCompatible(variable));
      }
      makeVariableBackwardsCompatible(variable) {
        return variable.type !== VariableType.list ? variable : this.makeListVariableBackwardsCompatible(variable);
      }
      makeListVariableBackwardsCompatible(listVariable) {
        const updated = listVariable, items = listVariable.items, selected = listVariable.selected, newItems = items.map((item) => item.value);
        return updated.items = newItems, updated.selected = selected == null ? undefined : selected.value, updated;
      }
      applyPrefixSuffixDeltaUpdate(id2, update) {
        return VariableController_awaiter(this, undefined, undefined, function* () {
          const res = yield VariableController_classPrivateFieldGet(this, _VariableController_editorAPI, "f");
          return getEditorResponseData(yield res.updateVariablePrefixSuffixProperties(id2, JSON.stringify(update)));
        });
      }
    }
    _VariableController_editorAPI = new WeakMap, _VariableController_setPlaceholder = new WeakMap, _VariableController_setHelpText = new WeakMap;

    class SubscriberController_SubscriberController {
      constructor(config) {
        this.onVariableListChanged = (variablesJson) => {
          this.config.events.onVariableListChanged.trigger(JSON.parse(variablesJson));
        }, this.onConnectorsChanged = (connectors) => {
          this.config.events.onConnectorsChanged.trigger(JSON.parse(connectors));
        }, this.onPageSizeChanged = (pageSize) => {
          this.config.events.onPageSizeChanged.trigger(JSON.parse(pageSize));
        }, this.config = config;
      }
    }
    var VariableController_VariableController_editorAPI, controllers_VariableController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, controllers_VariableController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, controllers_VariableController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class VariableController_VariableController {
      constructor(editorAPI) {
        VariableController_VariableController_editorAPI.set(this, undefined), this.getAll = () => controllers_VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_VariableController_classPrivateFieldGet(this, VariableController_VariableController_editorAPI, "f")).getVariables().then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => controllers_VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_VariableController_classPrivateFieldGet(this, VariableController_VariableController_editorAPI, "f")).getVariableById(id2).then((result) => getEditorResponseData(result));
        }), this.getByName = (name) => controllers_VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_VariableController_classPrivateFieldGet(this, VariableController_VariableController_editorAPI, "f")).getVariableByName(name).then((result) => getEditorResponseData(result));
        }), this.setListVariable = (id2, items) => controllers_VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_VariableController_classPrivateFieldGet(this, VariableController_VariableController_editorAPI, "f")).setListVariableItems(id2, items.map((item) => JSON.stringify(item))).then((result) => getEditorResponseData(result));
        }), this.setImageVariableConnector = (id2, registration) => controllers_VariableController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_VariableController_classPrivateFieldGet(this, VariableController_VariableController_editorAPI, "f")).setImageVariableConnector(id2, JSON.stringify(registration)).then((result) => getEditorResponseData(result));
        }), controllers_VariableController_classPrivateFieldSet(this, VariableController_VariableController_editorAPI, editorAPI, "f");
      }
    }
    VariableController_VariableController_editorAPI = new WeakMap;
    var ConnectorController_ConnectorController_editorAPI, controllers_ConnectorController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, controllers_ConnectorController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, controllers_ConnectorController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class ConnectorController_ConnectorController {
      constructor(editorAPI) {
        ConnectorController_ConnectorController_editorAPI.set(this, undefined), this.register = (registration) => controllers_ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_ConnectorController_classPrivateFieldGet(this, ConnectorController_ConnectorController_editorAPI, "f")).registerConnector(JSON.stringify(registration)).then((result) => getEditorResponseData(result));
        }), this.getById = (id2) => controllers_ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_ConnectorController_classPrivateFieldGet(this, ConnectorController_ConnectorController_editorAPI, "f")).getConnectorById(id2).then((result) => getEditorResponseData(result));
        }), this.getAllByType = (type) => controllers_ConnectorController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_ConnectorController_classPrivateFieldGet(this, ConnectorController_ConnectorController_editorAPI, "f")).getConnectors(type).then((result) => getEditorResponseData(result));
        }), controllers_ConnectorController_classPrivateFieldSet(this, ConnectorController_ConnectorController_editorAPI, editorAPI, "f");
      }
    }
    ConnectorController_ConnectorController_editorAPI = new WeakMap;
    var PageController_PageController_editorAPI, PageController_PageController_blobAPI, controllers_PageController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, controllers_PageController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, controllers_PageController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class PageController_PageController {
      constructor(editorAPI) {
        PageController_PageController_editorAPI.set(this, undefined), PageController_PageController_blobAPI.set(this, undefined), this.setWidth = (width) => controllers_PageController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_PageController_classPrivateFieldGet(this, PageController_PageController_editorAPI, "f")).setPageWidth(width).then((result) => getEditorResponseData(result));
        }), this.setHeight = (height) => controllers_PageController_awaiter(this, undefined, undefined, function* () {
          return (yield controllers_PageController_classPrivateFieldGet(this, PageController_PageController_editorAPI, "f")).setPageHeight(height).then((result) => getEditorResponseData(result));
        }), controllers_PageController_classPrivateFieldSet(this, PageController_PageController_editorAPI, editorAPI, "f"), controllers_PageController_classPrivateFieldSet(this, PageController_PageController_blobAPI, editorAPI, "f");
      }
    }
    PageController_PageController_editorAPI = new WeakMap, PageController_PageController_blobAPI = new WeakMap;

    class NextInitiator {
      constructor(config, connection2, editorAPI) {
        this.config = config, this.connection = connection2, this.editorAPI = editorAPI, this.subscriber = new SubscriberController_SubscriberController(config), this.variable = new VariableController_VariableController(this.editorAPI), this.connector = new ConnectorController_ConnectorController(this.editorAPI), this.page = new PageController_PageController(this.editorAPI), this.canvas = new CanvasController(this.editorAPI);
      }
    }

    class EngineEventTrigger {
      constructor(logger) {
        this.logger = logger;
      }
      createEventHandlerFn(callbackFn, errorBehavior) {
        return (...args) => {
          try {
            const result = callbackFn(...args);
            return result instanceof Promise ? result.catch((error) => this.handleError(error, errorBehavior, callbackFn.name)) : result;
          } catch (error) {
            this.handleError(error, errorBehavior, callbackFn.name);
          }
        };
      }
      handleError(error, errorBehavior, fnName) {
        var _a;
        if (errorBehavior !== CallbackErrorBehavior.log)
          throw error;
        (_a = this.logger) === null || _a === undefined || _a.call(this, LogLevel.error, LogCategory.event, `Error in callback ${fnName}: ${error}`);
      }
    }

    class EngineCallbackHandler extends EngineEventTrigger {
      constructor(handler, logger) {
        super(logger), this.handler = handler;
      }
      trigger(...args) {
        const handler = this.handler();
        if (handler)
          return this.createEventHandlerFn(handler, CallbackErrorBehavior.throw)(...args);
      }
    }

    class EngineEvent extends EngineEventTrigger {
      constructor(legacyHandler, logger) {
        super(logger), this.legacyHandler = legacyHandler, this.subscriptions = new Set;
      }
      trigger(...args) {
        const handler = this.legacyHandler();
        handler && this.createEventHandlerFn(handler, CallbackErrorBehavior.log)(...args);
        for (const callback of this.subscriptions)
          callback(...args);
      }
      registerCallback(callback, errorBehavior = CallbackErrorBehavior.log) {
        const callbackFn = this.createEventHandlerFn(callback, errorBehavior);
        return this.subscriptions.add(callbackFn), () => {
          this.subscriptions.delete(callbackFn);
        };
      }
    }

    class ConfigHelper {
      static createRuntimeConfig(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
        const clone = Object.assign({}, config);
        return clone.logging = { logLevel: ((_a = config.logging) === null || _a === undefined ? undefined : _a.logLevel) || LogLevel.error, logger: ((_b = config.logging) === null || _b === undefined ? undefined : _b.logger) || ((level, cat, msg) => {
          var _a2, _b2;
          if (ConfigHelper.isLoggingEnabled(level, (_b2 = (_a2 = clone.logging) === null || _a2 === undefined ? undefined : _a2.logLevel) !== null && _b2 !== undefined ? _b2 : LogLevel.error))
            switch (level) {
              case LogLevel.error:
                console.error(`[${cat}] [${level}] ${msg}`);
                break;
              case LogLevel.warn:
                console.warn(`[${cat}] [${level}] ${msg}`);
                break;
              default:
                console.log(`[${cat}] [${level}] ${msg}`);
            }
        }) }, clone.handlers = { onAuthExpired: new EngineCallbackHandler(() => clone.onAuthExpired, (_c = clone.logging) === null || _c === undefined ? undefined : _c.logger), onViewportRequested: new EngineCallbackHandler(() => clone.onViewportRequested, (_d = clone.logging) === null || _d === undefined ? undefined : _d.logger) }, clone.events = { onActionsChanged: new EngineEvent(() => clone.onActionsChanged, (_e = clone.logging) === null || _e === undefined ? undefined : _e.logger), onStateChanged: new EngineEvent(() => clone.onStateChanged, (_f = clone.logging) === null || _f === undefined ? undefined : _f.logger), onDocumentLoaded: new EngineEvent(() => clone.onDocumentLoaded, (_g = clone.logging) === null || _g === undefined ? undefined : _g.logger), onSelectedFramesLayoutChanged: new EngineEvent(() => clone.onSelectedFramesLayoutChanged, (_h = clone.logging) === null || _h === undefined ? undefined : _h.logger), onFramesLayoutChanged: new EngineEvent(() => clone.onFramesLayoutChanged, (_j = clone.logging) === null || _j === undefined ? undefined : _j.logger), onSelectedFramesContentChanged: new EngineEvent(() => clone.onSelectedFramesContentChanged, (_k = clone.logging) === null || _k === undefined ? undefined : _k.logger), onPageSelectionChanged: new EngineEvent(() => clone.onPageSelectionChanged, (_l = clone.logging) === null || _l === undefined ? undefined : _l.logger), onSelectedLayoutPropertiesChanged: new EngineEvent(() => clone.onSelectedLayoutPropertiesChanged, (_m = clone.logging) === null || _m === undefined ? undefined : _m.logger), onSelectedLayoutUnitChanged: new EngineEvent(() => clone.onSelectedLayoutUnitChanged, (_o = clone.logging) === null || _o === undefined ? undefined : _o.logger), onScrubberPositionChanged: new EngineEvent(() => clone.onScrubberPositionChanged, (_p = clone.logging) === null || _p === undefined ? undefined : _p.logger), onFrameAnimationsChanged: new EngineEvent(() => clone.onFrameAnimationsChanged, (_q = clone.logging) === null || _q === undefined ? undefined : _q.logger), onVariableListChanged: new EngineEvent(() => clone.onVariableListChanged, (_r = clone.logging) === null || _r === undefined ? undefined : _r.logger), onSelectedToolChanged: new EngineEvent(() => clone.onSelectedToolChanged, (_s = clone.logging) === null || _s === undefined ? undefined : _s.logger), onUndoStackStateChanged: new EngineEvent(() => clone.onUndoStackStateChanged, (_t = clone.logging) === null || _t === undefined ? undefined : _t.logger), onSelectedLayoutFramesChanged: new EngineEvent(() => clone.onSelectedLayoutFramesChanged, (_u = clone.logging) === null || _u === undefined ? undefined : _u.logger), onSelectedTextStyleChanged: new EngineEvent(() => clone.onSelectedTextStyleChanged, (_v = clone.logging) === null || _v === undefined ? undefined : _v.logger), onColorsChanged: new EngineEvent(() => clone.onColorsChanged, (_w = clone.logging) === null || _w === undefined ? undefined : _w.logger), onParagraphStylesChanged: new EngineEvent(() => clone.onParagraphStylesChanged, (_x = clone.logging) === null || _x === undefined ? undefined : _x.logger), onCharacterStylesChanged: new EngineEvent(() => clone.onCharacterStylesChanged, (_y = clone.logging) === null || _y === undefined ? undefined : _y.logger), onFontFamiliesChanged: new EngineEvent(() => clone.onFontFamiliesChanged, (_z = clone.logging) === null || _z === undefined ? undefined : _z.logger), onSelectedLayoutIdChanged: new EngineEvent(() => clone.onSelectedLayoutIdChanged, (_0 = clone.logging) === null || _0 === undefined ? undefined : _0.logger), onLayoutsChanged: new EngineEvent(() => clone.onLayoutsChanged, (_1 = clone.logging) === null || _1 === undefined ? undefined : _1.logger), onConnectorEvent: new EngineEvent(() => clone.onConnectorEvent, (_2 = clone.logging) === null || _2 === undefined ? undefined : _2.logger), onConnectorsChanged: new EngineEvent(() => clone.onConnectorsChanged, (_3 = clone.logging) === null || _3 === undefined ? undefined : _3.logger), onZoomChanged: new EngineEvent(() => clone.onZoomChanged, (_4 = clone.logging) === null || _4 === undefined ? undefined : _4.logger), onSelectedPageIdChanged: new EngineEvent(() => clone.onSelectedPageIdChanged, clone.logging.logger), onPagesChanged: new EngineEvent(() => clone.onPagesChanged, clone.logging.logger), onPageSnapshotInvalidated: new EngineEvent(() => clone.onPageSnapshotInvalidated, clone.logging.logger), onPageSizeChanged: new EngineEvent(() => clone.onPageSizeChanged, (_5 = clone.logging) === null || _5 === undefined ? undefined : _5.logger), onShapeCornerRadiusChanged: new EngineEvent(() => clone.onShapeCornerRadiusChanged, (_6 = clone.logging) === null || _6 === undefined ? undefined : _6.logger), onCropActiveFrameIdChanged: new EngineEvent(() => clone.onCropActiveFrameIdChanged, (_7 = clone.logging) === null || _7 === undefined ? undefined : _7.logger), onAsyncError: new EngineEvent(() => clone.onAsyncError, (_8 = clone.logging) === null || _8 === undefined ? undefined : _8.logger), onViewModeChanged: new EngineEvent(() => clone.onViewModeChanged, (_9 = clone.logging) === null || _9 === undefined ? undefined : _9.logger), onBarcodeValidationChanged: new EngineEvent(() => clone.onBarcodeValidationChanged, (_10 = clone.logging) === null || _10 === undefined ? undefined : _10.logger), onDataSourceIdChanged: new EngineEvent(() => clone.onDataSourceIdChanged, clone.logging.logger), onDocumentIssueListChanged: new EngineEvent(() => clone.onDocumentIssueListChanged, clone.logging.logger), onCustomUndoDataChanged: new EngineEvent(() => clone.onCustomUndoDataChanged, clone.logging.logger), onEngineEditModeChanged: new EngineEvent(() => clone.onEngineEditModeChanged, clone.logging.logger) }, clone;
      }
      static isLoggingEnabled(level, logLevel) {
        return logLevel == LogLevel.info || (logLevel == LogLevel.warn && (level == LogLevel.warn || level == LogLevel.error) || logLevel == LogLevel.error && level == LogLevel.error);
      }
    }

    class DataItemMappingTools {
      isDatePropertyWrapper(value) {
        return typeof value == "object" && (value == null ? undefined : value.type) === "date";
      }
      isDateObject(value) {
        return value instanceof Date;
      }
      mapEngineToDataItem(dataItem) {
        const parsedItem = {};
        return Object.entries(dataItem).forEach(([key, value]) => {
          parsedItem[key] = this.isDatePropertyWrapper(value) ? new Date(value.value) : value;
        }), parsedItem;
      }
      mapDataItemToEngine(dataItem) {
        const parsedItem = {};
        return Object.entries(dataItem).forEach(([key, value]) => {
          parsedItem[key] = this.isDateObject(value) ? { value: value.getTime(), type: "date" } : value;
        }), parsedItem;
      }
    }
    var _ConfigurationController_editorAPI, ConfigurationController_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, ConfigurationController_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, ConfigurationController_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    _ConfigurationController_editorAPI = new WeakMap;
    var _LocalConfigurationDecorator_localConfig, LocalConfigurationDecorator_awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, LocalConfigurationDecorator_classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, LocalConfigurationDecorator_classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    class LocalConfigurationDecorator extends class {
      constructor(editorAPI) {
        _ConfigurationController_editorAPI.set(this, undefined), ConfigurationController_classPrivateFieldSet(this, _ConfigurationController_editorAPI, editorAPI, "f");
      }
      getValue(key) {
        return ConfigurationController_awaiter(this, undefined, undefined, function* () {
          return (yield ConfigurationController_classPrivateFieldGet(this, _ConfigurationController_editorAPI, "f")).getConfigValue(key).then((result) => getEditorResponseData(result));
        });
      }
      setValue(key, value) {
        return ConfigurationController_awaiter(this, undefined, undefined, function* () {
          return (yield ConfigurationController_classPrivateFieldGet(this, _ConfigurationController_editorAPI, "f")).setConfigValue(key, value).then((result) => getEditorResponseData(result));
        });
      }
      updateStudioOptions(options) {
        return ConfigurationController_awaiter(this, undefined, undefined, function* () {
          return (yield ConfigurationController_classPrivateFieldGet(this, _ConfigurationController_editorAPI, "f")).updateStudioOptions(JSON.stringify(options)).then((result) => getEditorResponseData(result));
        });
      }
      getEngineSessionId() {
        return ConfigurationController_awaiter(this, undefined, undefined, function* () {
          return (yield ConfigurationController_classPrivateFieldGet(this, _ConfigurationController_editorAPI, "f")).getEngineSessionId().then((result) => getEditorResponseData(result));
        });
      }
    } {
      constructor(editorAPI, localConfig) {
        super(editorAPI), _LocalConfigurationDecorator_localConfig.set(this, undefined), LocalConfigurationDecorator_classPrivateFieldSet(this, _LocalConfigurationDecorator_localConfig, localConfig, "f");
      }
      getValue(key) {
        const _super = Object.create(null, { getValue: { get: () => super.getValue } });
        return LocalConfigurationDecorator_awaiter(this, undefined, undefined, function* () {
          const value = LocalConfigurationDecorator_classPrivateFieldGet(this, _LocalConfigurationDecorator_localConfig, "f").get(key);
          return value != null ? getEditorResponseData({ status: 200, success: true, parsedData: value, data: value }, false) : _super.getValue.call(this, key);
        });
      }
      setValue(key, value) {
        const _super = Object.create(null, { setValue: { get: () => super.setValue } });
        return LocalConfigurationDecorator_awaiter(this, undefined, undefined, function* () {
          const res = _super.setValue.call(this, key, value);
          return LocalConfigurationDecorator_classPrivateFieldGet(this, _LocalConfigurationDecorator_localConfig, "f").set(key, value), res;
        });
      }
    }
    let connection;
    _LocalConfigurationDecorator_localConfig = new WeakMap;
    const FIXED_EDITOR_LINK = "https://studio-cdn.chiligrafx.com/editor/" + editor_engine_namespaceObject_V + "/web";

    class SDK {
      constructor(config) {
        this.localConfig = new Map, this.dataItemMappingTools = new DataItemMappingTools, this.loadEditor = () => {
          var _a;
          Connector(this.config.editorLink || FIXED_EDITOR_LINK, { onActionsChanged: this.subscriber.onActionsChanged, onStateChanged: this.subscriber.onStateChanged, onAuthExpired: this.subscriber.onAuthExpired, onViewportRequested: this.subscriber.onViewportRequested, onDocumentLoaded: this.subscriber.onDocumentLoaded, onSelectedFramesContentChanged: this.subscriber.onSelectedFramesContentChanged, onSelectedFramesLayoutChanged: this.subscriber.onSelectedFramesLayoutChanged, onFramesLayoutChanged: this.subscriber.onFramesLayoutChanged, onSelectedLayoutPropertiesChanged: this.subscriber.onSelectedLayoutPropertiesChanged, onSelectedLayoutUnitChanged: this.subscriber.onSelectedLayoutUnitChanged, onPageSelectionChanged: this.subscriber.onPageSelectionChanged, onScrubberPositionChanged: this.subscriber.onAnimationPlaybackChanged, onFrameAnimationsChanged: this.subscriber.onAnimationChanged, onVariableListChanged: (state) => {
            var _a2;
            ((_a2 = this.enabledNextSubscribers) === null || _a2 === undefined ? undefined : _a2.onVariableListChanged) ? this.next.subscriber.onVariableListChanged(state) : this.subscriber.onVariableListChanged(state);
          }, onSelectedToolChanged: this.subscriber.onSelectedToolChanged, onUndoStateChanged: this.subscriber.onUndoStateChanged, onSelectedLayoutFramesChanged: this.subscriber.onSelectedLayoutFramesChanged, onSelectedTextStyleChanged: this.subscriber.onSelectedTextStyleChanged, onColorsChanged: this.subscriber.onColorsChanged, onParagraphStylesChanged: this.subscriber.onParagraphStylesChanged, onCharacterStylesChanged: this.subscriber.onCharacterStylesChanged, onFontFamiliesChanged: this.subscriber.onFontFamiliesChanged, onSelectedLayoutIdChanged: this.subscriber.onSelectedLayoutIdChanged, onLayoutsChanged: this.subscriber.onLayoutsChanged, onConnectorEvent: this.subscriber.onConnectorEvent, onConnectorsChanged: (state) => {
            var _a2;
            ((_a2 = this.enabledNextSubscribers) === null || _a2 === undefined ? undefined : _a2.onConnectorsChanged) ? this.next.subscriber.onConnectorsChanged(state) : this.subscriber.onConnectorsChanged(state);
          }, onZoomChanged: this.subscriber.onZoomChanged, onSelectedPageIdChanged: this.subscriber.onSelectedPageIdChanged, onPagesChanged: this.subscriber.onPagesChanged, onPageSnapshotInvalidated: this.subscriber.onPageSnapshotInvalidated, onPageSizeChanged: (state) => {
            var _a2;
            ((_a2 = this.enabledNextSubscribers) === null || _a2 === undefined ? undefined : _a2.onPageSizeChanged) ? this.next.subscriber.onPageSizeChanged(state) : this.subscriber.onPageSizeChanged(state);
          }, onShapeCornerRadiusChanged: this.subscriber.onShapeCornerRadiusChanged, onCropActiveFrameIdChanged: this.subscriber.onCropActiveFrameIdChanged, onAsyncError: this.subscriber.onAsyncError, onViewModeChanged: this.subscriber.onViewModeChanged, onBarcodeValidationChanged: this.subscriber.onBarcodeValidationChanged, onDataSourceIdChanged: this.subscriber.onDataSourceIdChanged, onDocumentIssueListChanged: this.subscriber.onDocumentIssueListChanged, onCustomUndoDataChanged: this.subscriber.onCustomUndoDataChanged, onEngineEditModeChanged: this.subscriber.onEngineEditModeChanged }, this.setConnection, this.config.editorId, this.config.studioStyling), this.editorAPI = connection == null ? undefined : connection.promise.then((editorAPI) => editorAPI), this.action = new ActionController(this.editorAPI), this.layout = new LayoutController(this.editorAPI), this.frame = new FrameController(this.editorAPI), this.barcode = new BarcodeController(this.editorAPI), this.animation = new AnimationController(this.editorAPI), this.document = new DocumentController(this.editorAPI), this.configuration = new LocalConfigurationDecorator(this.editorAPI, this.localConfig), this.utils = new UtilsController, this.tool = new ToolController(this.editorAPI), this.page = new PageController(this.editorAPI), this.debug = new DebugController(this.editorAPI), this.undoManager = new UndoManagerController(this.editorAPI, this), this.textSelection = new TextStyleController(this.editorAPI), this.colorStyle = new ColorStyleController(this.editorAPI), this.paragraphStyle = new ParagraphStyleController(this.editorAPI), this.characterStyle = new CharacterStyleController(this.editorAPI), this.mediaConnector = new MediaConnectorController(this.editorAPI), this.fontConnector = new FontConnectorController(this.editorAPI), this.dataConnector = new DataConnectorController(this.editorAPI, this.dataItemMappingTools), this.dataSource = new DataSourceController(this.editorAPI, this.dataItemMappingTools), this.connector = new ConnectorController(this.editorAPI, this.localConfig), this.variable = new VariableController(this.editorAPI), this.font = new FontController(this.editorAPI), this.experiment = new ExperimentController(this.editorAPI), this.canvas = new CanvasController(this.editorAPI), this.shape = new ShapeController(this.editorAPI), this.colorConversion = new ColorConversionController(this.editorAPI), this.info = new InfoController, this.clipboard = new ClipboardController(this.editorAPI), this.next = new NextInitiator(this.config, this.connection, this.editorAPI), this.configuration.setValue(WellKnownConfigurationKeys.GraFxStudioSdkVersion, package_namespaceObject_i8), this.configuration.setValue(WellKnownConfigurationKeys.GraFxStudioDocumentType, this.config.documentType || DocumentType.template), this.configuration.updateStudioOptions(this.config.studioOptions || defaultStudioOptions), this.configuration.setValue(WellKnownConfigurationKeys.QueryCallCacheEnabled, ((_a = this.config.enableQueryCallCache) === null || _a === undefined ? undefined : _a.toString()) || "false");
        }, this.setConnection = (newConnection) => {
          connection = newConnection;
        }, this.config = ConfigHelper.createRuntimeConfig(config), this.connection = connection, this.editorAPI = connection == null ? undefined : connection.promise.then((child) => child), this.action = new ActionController(this.editorAPI), this.layout = new LayoutController(this.editorAPI), this.frame = new FrameController(this.editorAPI), this.shape = new ShapeController(this.editorAPI), this.barcode = new BarcodeController(this.editorAPI), this.undoManager = new UndoManagerController(this.editorAPI, this), this.connector = new ConnectorController(this.editorAPI, this.localConfig), this.mediaConnector = new MediaConnectorController(this.editorAPI), this.fontConnector = new FontConnectorController(this.editorAPI), this.dataConnector = new DataConnectorController(this.editorAPI, this.dataItemMappingTools), this.dataSource = new DataSourceController(this.editorAPI, this.dataItemMappingTools), this.animation = new AnimationController(this.editorAPI), this.document = new DocumentController(this.editorAPI), this.configuration = new LocalConfigurationDecorator(this.editorAPI, this.localConfig), this.variable = new VariableController(this.editorAPI), this.utils = new UtilsController, this.subscriber = new SubscriberController(this.config, this.localConfig), this.tool = new ToolController(this.editorAPI), this.page = new PageController(this.editorAPI), this.debug = new DebugController(this.editorAPI), this.textSelection = new TextStyleController(this.editorAPI), this.colorStyle = new ColorStyleController(this.editorAPI), this.paragraphStyle = new ParagraphStyleController(this.editorAPI), this.characterStyle = new CharacterStyleController(this.editorAPI), this.font = new FontController(this.editorAPI), this.experiment = new ExperimentController(this.editorAPI), this.canvas = new CanvasController(this.editorAPI), this.colorConversion = new ColorConversionController(this.editorAPI), this.info = new InfoController, this.clipboard = new ClipboardController(this.editorAPI), this.next = new NextInitiator(this.config, this.connection, this.editorAPI), this.enabledNextSubscribers = this.config.enableNextSubscribers;
      }
    }
    var SlideDirections, ShakeDirections, EaseTypes, TweenTypes, BasicAnimationsEmphasisStyles, ViewMode, FontPreviewFormat, FontWeights, Alignment, TextPosition, Case, Scripting, HorizontalAlign, SelectedTextStyleSections, SelectedTextStyles, ActionEditorEvent, ShapeType, CornerRadiusType, EngineEditModeType;
    (function(SlideDirections2) {
      SlideDirections2.top = "top", SlideDirections2.left = "left", SlideDirections2.right = "right", SlideDirections2.bottom = "bottom", SlideDirections2.topLeft = "topLeft", SlideDirections2.topRight = "topRight", SlideDirections2.bottomLeft = "bottomLeft", SlideDirections2.bottomRight = "bottomRight";
    })(SlideDirections || (SlideDirections = {})), function(ShakeDirections2) {
      ShakeDirections2.horizontal = "horizontal", ShakeDirections2.vertical = "vertical";
    }(ShakeDirections || (ShakeDirections = {})), function(EaseTypes2) {
      EaseTypes2.easeIn = "easeIn", EaseTypes2.easeOut = "easeOut", EaseTypes2.easeInOut = "easeInOut";
    }(EaseTypes || (EaseTypes = {})), function(TweenTypes2) {
      TweenTypes2.quadratic = "Quadratic", TweenTypes2.cubic = "Cubic", TweenTypes2.quartic = "Quartic", TweenTypes2.quintic = "Quintic", TweenTypes2.sine = "Sine", TweenTypes2.exponential = "Exponential", TweenTypes2.circular = "Circular", TweenTypes2.elastic = "Elastic", TweenTypes2.bounce = "Bounce", TweenTypes2.back = "Back";
    }(TweenTypes || (TweenTypes = {})), function(BasicAnimationsEmphasisStyles2) {
      BasicAnimationsEmphasisStyles2.bounce = "bounce", BasicAnimationsEmphasisStyles2.flash = "flash", BasicAnimationsEmphasisStyles2.headshake = "headShake", BasicAnimationsEmphasisStyles2.heartbeat = "heartbeat", BasicAnimationsEmphasisStyles2.pulse = "pulse", BasicAnimationsEmphasisStyles2.rubberBand = "rubberBand", BasicAnimationsEmphasisStyles2.vertical = "vertical", BasicAnimationsEmphasisStyles2.horizontal = "horizontal", BasicAnimationsEmphasisStyles2.swing = "swing", BasicAnimationsEmphasisStyles2.tada = "tada";
    }(BasicAnimationsEmphasisStyles || (BasicAnimationsEmphasisStyles = {})), function(ViewMode2) {
      ViewMode2.preview = "preview", ViewMode2.normal = "normal";
    }(ViewMode || (ViewMode = {})), function(FontPreviewFormat2) {
      FontPreviewFormat2.Square = "square", FontPreviewFormat2.Line = "line";
    }(FontPreviewFormat || (FontPreviewFormat = {})), function(FontWeights2) {
      FontWeights2.BOLD = "Bold", FontWeights2.ITALIC = "Italic", FontWeights2.REGULAR = "Regular";
    }(FontWeights || (FontWeights = {})), function(Alignment2) {
      Alignment2.LEFT = "left", Alignment2.CENTER = "center", Alignment2.RIGHT = "right", Alignment2.JUSTIFY = "justify";
    }(Alignment || (Alignment = {})), function(TextPosition2) {
      TextPosition2.TOP = "top", TextPosition2.CENTER = "center", TextPosition2.BOTTOM = "bottom";
    }(TextPosition || (TextPosition = {})), function(Case2) {
      Case2.TO_LOWER_CASE = "lowercase", Case2.TO_UPPER_CASE = "uppercase", Case2.NORMAL = "normal";
    }(Case || (Case = {})), function(Scripting2) {
      Scripting2.SUPERSCRIPT = "superscript", Scripting2.SUBSCRIPT = "subscript", Scripting2.NORMAL = "normal";
    }(Scripting || (Scripting = {})), function(HorizontalAlign2) {
      HorizontalAlign2.left = "left", HorizontalAlign2.center = "center", HorizontalAlign2.right = "right", HorizontalAlign2.justify = "justify";
    }(HorizontalAlign || (HorizontalAlign = {})), function(SelectedTextStyleSections2) {
      SelectedTextStyleSections2.STYLE = "textStyle", SelectedTextStyleSections2.PROPERTIES = "textProperties", SelectedTextStyleSections2.APPEARANCE = "appearance";
    }(SelectedTextStyleSections || (SelectedTextStyleSections = {})), function(SelectedTextStyles2) {
      SelectedTextStyles2.PARAGRAPH = "paragraphStyleId", SelectedTextStyles2.CHARACTER = "characterStyleId", SelectedTextStyles2.FONT_FAMILY = "fontKey", SelectedTextStyles2.FONT_STYLE = "fontStyle", SelectedTextStyles2.FONT_SIZE = "fontSize", SelectedTextStyles2.LETTER_SPACING = "letterSpacing", SelectedTextStyles2.LINE_HEIGHT = "lineHeight", SelectedTextStyles2.TEXT_ALIGN = "textAlign", SelectedTextStyles2.VERTICAL_ALIGN = "verticalAlign", SelectedTextStyles2.TYPOGRAPHIC_CASE = "typographicCase", SelectedTextStyles2.SUB_SUPER_SCRIPT = "subSuperScript", SelectedTextStyles2.UNDERLINE = "underline", SelectedTextStyles2.LINE_THROUGH = "lineThrough", SelectedTextStyles2.FILL_COLOR = "fillColor", SelectedTextStyles2.COLOR = "color", SelectedTextStyles2.FILL_COLOR_APPLIED = "fillColorApplied", SelectedTextStyles2.STROKE_COLOR = "strokeColor", SelectedTextStyles2.DROP_SHADOW_COLOR = "dropShadowColor", SelectedTextStyles2.BLEND_MODE = "blendMode", SelectedTextStyles2.OPACITY = "opacity", SelectedTextStyles2.TRACKING_RIGHT = "trackingRight", SelectedTextStyles2.BASELINE_SHIFT = "baselineShiftValue";
    }(SelectedTextStyles || (SelectedTextStyles = {})), function(ActionEditorEvent2) {
      ActionEditorEvent2.selectedLayoutChanged = "selectedLayoutChanged", ActionEditorEvent2.frameMoved = "frameMoved", ActionEditorEvent2.pageSizeChanged = "pageSizeChanged", ActionEditorEvent2.documentLoaded = "documentLoaded", ActionEditorEvent2.variableValueChanged = "variableValueChanged";
    }(ActionEditorEvent || (ActionEditorEvent = {})), function(ShapeType2) {
      ShapeType2.ellipse = "ellipse", ShapeType2.rectangle = "rectangle", ShapeType2.polygon = "polygon";
    }(ShapeType || (ShapeType = {})), function(CornerRadiusType2) {
      CornerRadiusType2.all = "all", CornerRadiusType2.only = "only", CornerRadiusType2.none = "none";
    }(CornerRadiusType || (CornerRadiusType = {})), function(EngineEditModeType2) {
      EngineEditModeType2.normal = "normal", EngineEditModeType2.textEdit = "textEdit", EngineEditModeType2.customCrop = "customCrop", EngineEditModeType2.frameSubjectArea = "frameSubjectArea";
    }(EngineEditModeType || (EngineEditModeType = {}));
    const src = SDK;
    return __webpack_exports__;
  })());
});

// src/studio/documentHandler.ts
async function getCurrentDocumentState(studio2) {
  return handleStudioFunc(studio2.document.getCurrentState);
}
async function loadDocumentFromJsonStr(studio2, document2) {
  return handleStudioFunc(studio2.document.load, document2);
}
var init_documentHandler = __esm(() => {
  init_utils();
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS((exports, module) => {
  module.exports = function shallowEqual(objA, objB, compare2, compareContext) {
    var ret = compare2 ? compare2.call(compareContext, objA, objB) : undefined;
    if (ret !== undefined) {
      return !!ret;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    for (var idx = 0;idx < keysA.length; idx++) {
      var key = keysA[idx];
      if (!bHasOwnProperty(key)) {
        return false;
      }
      var valueA = objA[key];
      var valueB = objB[key];
      ret = compare2 ? compare2.call(compareContext, valueA, valueB, key) : undefined;
      if (ret === false || ret === undefined && valueA !== valueB) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/react/cjs/react-jsx-runtime.production.js
var exports_react_jsx_runtime_production = {};
__export(exports_react_jsx_runtime_production, {
  jsxs: () => $jsxs,
  jsx: () => $jsx,
  Fragment: () => $Fragment2
});
function jsxProd(type, config, maybeKey) {
  var key = null;
  maybeKey !== undefined && (key = "" + maybeKey);
  config.key !== undefined && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config)
      propName !== "key" && (maybeKey[propName] = config[propName]);
  } else
    maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE3,
    type,
    key,
    ref: config !== undefined ? config : null,
    props: maybeKey
  };
}
var REACT_ELEMENT_TYPE3, REACT_FRAGMENT_TYPE3, $Fragment2, $jsx, $jsxs;
var init_react_jsx_runtime_production = __esm(() => {
  REACT_ELEMENT_TYPE3 = Symbol.for("react.transitional.element");
  REACT_FRAGMENT_TYPE3 = Symbol.for("react.fragment");
  $Fragment2 = REACT_FRAGMENT_TYPE3;
  $jsx = jsxProd;
  $jsxs = jsxProd;
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  init_react_jsx_runtime_production();
  if (true) {
    module.exports = exports_react_jsx_runtime_production;
  } else {
  }
});

// node_modules/@tabler/icons-react/dist/esm/defaultAttributes.mjs
var defaultAttributes;
var init_defaultAttributes = __esm(() => {
  defaultAttributes = {
    outline: {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    filled: {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      stroke: "none"
    }
  };
});

// node_modules/@tabler/icons-react/dist/esm/createReactComponent.mjs
var import_react246, createReactComponent = (type, iconName, iconNamePascal, iconNode) => {
  const Component2 = import_react246.forwardRef(({ color = "currentColor", size: size4 = 24, stroke = 2, title, className, children, ...rest }, ref) => import_react246.createElement("svg", {
    ref,
    ...defaultAttributes[type],
    width: size4,
    height: size4,
    className: [`tabler-icon`, `tabler-icon-${iconName}`, className].join(" "),
    ...type === "filled" ? {
      fill: color
    } : {
      strokeWidth: stroke,
      stroke: color
    },
    ...rest
  }, [
    title && import_react246.createElement("title", { key: "svg-title" }, title),
    ...iconNode.map(([tag, attrs]) => import_react246.createElement(tag, attrs)),
    ...Array.isArray(children) ? children : [children]
  ]));
  Component2.displayName = `${iconNamePascal}`;
  return Component2;
};
var init_createReactComponent = __esm(() => {
  import_react246 = __toESM(require_react(), 1);
  init_defaultAttributes();
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconAbc.mjs
var IconAbc;
var init_IconAbc = __esm(() => {
  init_createReactComponent();
  IconAbc = createReactComponent("outline", "abc", "IconAbc", [["path", { d: "M3 16v-6a2 2 0 1 1 4 0v6", key: "svg-0" }], ["path", { d: "M3 13h4", key: "svg-1" }], ["path", { d: "M10 8v6a2 2 0 1 0 4 0v-1a2 2 0 1 0 -4 0v1", key: "svg-2" }], ["path", { d: "M20.732 12a2 2 0 0 0 -3.732 1v1a2 2 0 0 0 3.726 1.01", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconAlertCircle.mjs
var IconAlertCircle;
var init_IconAlertCircle = __esm(() => {
  init_createReactComponent();
  IconAlertCircle = createReactComponent("outline", "alert-circle", "IconAlertCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 8v4", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconAlertTriangle.mjs
var IconAlertTriangle;
var init_IconAlertTriangle = __esm(() => {
  init_createReactComponent();
  IconAlertTriangle = createReactComponent("outline", "alert-triangle", "IconAlertTriangle", [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconArrowAutofitDown.mjs
var IconArrowAutofitDown;
var init_IconArrowAutofitDown = __esm(() => {
  init_createReactComponent();
  IconArrowAutofitDown = createReactComponent("outline", "arrow-autofit-down", "IconArrowAutofitDown", [["path", { d: "M12 20h-6a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h8", key: "svg-0" }], ["path", { d: "M18 4v17", key: "svg-1" }], ["path", { d: "M15 18l3 3l3 -3", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconArrowsTransferUpDown.mjs
var IconArrowsTransferUpDown;
var init_IconArrowsTransferUpDown = __esm(() => {
  init_createReactComponent();
  IconArrowsTransferUpDown = createReactComponent("outline", "arrows-transfer-up-down", "IconArrowsTransferUpDown", [["path", { d: "M7 21v-6", key: "svg-0" }], ["path", { d: "M20 6l-3 -3l-3 3", key: "svg-1" }], ["path", { d: "M10 18l-3 3l-3 -3", key: "svg-2" }], ["path", { d: "M7 3v2", key: "svg-3" }], ["path", { d: "M7 9v2", key: "svg-4" }], ["path", { d: "M17 3v6", key: "svg-5" }], ["path", { d: "M17 21v-2", key: "svg-6" }], ["path", { d: "M17 15v-2", key: "svg-7" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconBug.mjs
var IconBug;
var init_IconBug = __esm(() => {
  init_createReactComponent();
  IconBug = createReactComponent("outline", "bug", "IconBug", [["path", { d: "M9 9v-1a3 3 0 0 1 6 0v1", key: "svg-0" }], ["path", { d: "M8 9h8a6 6 0 0 1 1 3v3a5 5 0 0 1 -10 0v-3a6 6 0 0 1 1 -3", key: "svg-1" }], ["path", { d: "M3 13l4 0", key: "svg-2" }], ["path", { d: "M17 13l4 0", key: "svg-3" }], ["path", { d: "M12 20l0 -6", key: "svg-4" }], ["path", { d: "M4 19l3.35 -2", key: "svg-5" }], ["path", { d: "M20 19l-3.35 -2", key: "svg-6" }], ["path", { d: "M4 7l3.75 2.4", key: "svg-7" }], ["path", { d: "M20 7l-3.75 2.4", key: "svg-8" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCameraPlus.mjs
var IconCameraPlus;
var init_IconCameraPlus = __esm(() => {
  init_createReactComponent();
  IconCameraPlus = createReactComponent("outline", "camera-plus", "IconCameraPlus", [["path", { d: "M12 20h-7a2 2 0 0 1 -2 -2v-9a2 2 0 0 1 2 -2h1a2 2 0 0 0 2 -2a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v3.5", key: "svg-0" }], ["path", { d: "M16 19h6", key: "svg-1" }], ["path", { d: "M19 16v6", key: "svg-2" }], ["path", { d: "M9 13a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconChevronDown.mjs
var IconChevronDown;
var init_IconChevronDown = __esm(() => {
  init_createReactComponent();
  IconChevronDown = createReactComponent("outline", "chevron-down", "IconChevronDown", [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconChevronLeft.mjs
var IconChevronLeft;
var init_IconChevronLeft = __esm(() => {
  init_createReactComponent();
  IconChevronLeft = createReactComponent("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconChevronRight.mjs
var IconChevronRight;
var init_IconChevronRight = __esm(() => {
  init_createReactComponent();
  IconChevronRight = createReactComponent("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCircleX.mjs
var IconCircleX;
var init_IconCircleX = __esm(() => {
  init_createReactComponent();
  IconCircleX = createReactComponent("outline", "circle-x", "IconCircleX", [["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-0" }], ["path", { d: "M10 10l4 4m0 -4l-4 4", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCopyPlus.mjs
var IconCopyPlus;
var init_IconCopyPlus = __esm(() => {
  init_createReactComponent();
  IconCopyPlus = createReactComponent("outline", "copy-plus", "IconCopyPlus", [["path", { d: "M7 9.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-1" }], ["path", { d: "M4.012 16.737a2 2 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-2" }], ["path", { d: "M11 14h6", key: "svg-3" }], ["path", { d: "M14 11v6", key: "svg-4" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCopy.mjs
var IconCopy;
var init_IconCopy = __esm(() => {
  init_createReactComponent();
  IconCopy = createReactComponent("outline", "copy", "IconCopy", [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCrop.mjs
var IconCrop;
var init_IconCrop = __esm(() => {
  init_createReactComponent();
  IconCrop = createReactComponent("outline", "crop", "IconCrop", [["path", { d: "M8 5v10a1 1 0 0 0 1 1h10", key: "svg-0" }], ["path", { d: "M5 8h10a1 1 0 0 1 1 1v10", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconDeselect.mjs
var IconDeselect;
var init_IconDeselect = __esm(() => {
  init_createReactComponent();
  IconDeselect = createReactComponent("outline", "deselect", "IconDeselect", [["path", { d: "M12 8h3a1 1 0 0 1 1 1v3", key: "svg-0" }], ["path", { d: "M16 16h-7a1 1 0 0 1 -1 -1v-7", key: "svg-1" }], ["path", { d: "M12 20v.01", key: "svg-2" }], ["path", { d: "M16 20v.01", key: "svg-3" }], ["path", { d: "M8 20v.01", key: "svg-4" }], ["path", { d: "M4 20v.01", key: "svg-5" }], ["path", { d: "M4 16v.01", key: "svg-6" }], ["path", { d: "M4 12v.01", key: "svg-7" }], ["path", { d: "M4 8v.01", key: "svg-8" }], ["path", { d: "M8 4v.01", key: "svg-9" }], ["path", { d: "M12 4v.01", key: "svg-10" }], ["path", { d: "M16 4v.01", key: "svg-11" }], ["path", { d: "M20 4v.01", key: "svg-12" }], ["path", { d: "M20 8v.01", key: "svg-13" }], ["path", { d: "M20 12v.01", key: "svg-14" }], ["path", { d: "M20 16v.01", key: "svg-15" }], ["path", { d: "M3 3l18 18", key: "svg-16" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconDownload.mjs
var IconDownload;
var init_IconDownload = __esm(() => {
  init_createReactComponent();
  IconDownload = createReactComponent("outline", "download", "IconDownload", [["path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2", key: "svg-0" }], ["path", { d: "M7 11l5 5l5 -5", key: "svg-1" }], ["path", { d: "M12 4l0 12", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconExchange.mjs
var IconExchange;
var init_IconExchange = __esm(() => {
  init_createReactComponent();
  IconExchange = createReactComponent("outline", "exchange", "IconExchange", [["path", { d: "M5 18m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M19 6m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M19 8v5a5 5 0 0 1 -5 5h-3l3 -3m0 6l-3 -3", key: "svg-2" }], ["path", { d: "M5 16v-5a5 5 0 0 1 5 -5h3l-3 -3m0 6l3 -3", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconExclamationCircle.mjs
var IconExclamationCircle;
var init_IconExclamationCircle = __esm(() => {
  init_createReactComponent();
  IconExclamationCircle = createReactComponent("outline", "exclamation-circle", "IconExclamationCircle", [["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9v4", key: "svg-1" }], ["path", { d: "M12 16v.01", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconExternalLink.mjs
var IconExternalLink;
var init_IconExternalLink = __esm(() => {
  init_createReactComponent();
  IconExternalLink = createReactComponent("outline", "external-link", "IconExternalLink", [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconEyeCheck.mjs
var IconEyeCheck;
var init_IconEyeCheck = __esm(() => {
  init_createReactComponent();
  IconEyeCheck = createReactComponent("outline", "eye-check", "IconEyeCheck", [["path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-0" }], ["path", { d: "M11.102 17.957c-3.204 -.307 -5.904 -2.294 -8.102 -5.957c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6a19.5 19.5 0 0 1 -.663 1.032", key: "svg-1" }], ["path", { d: "M15 19l2 2l4 -4", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconEyeClosed.mjs
var IconEyeClosed;
var init_IconEyeClosed = __esm(() => {
  init_createReactComponent();
  IconEyeClosed = createReactComponent("outline", "eye-closed", "IconEyeClosed", [["path", { d: "M21 9c-2.4 2.667 -5.4 4 -9 4c-3.6 0 -6.6 -1.333 -9 -4", key: "svg-0" }], ["path", { d: "M3 15l2.5 -3.8", key: "svg-1" }], ["path", { d: "M21 14.976l-2.492 -3.776", key: "svg-2" }], ["path", { d: "M9 17l.5 -4", key: "svg-3" }], ["path", { d: "M15 17l-.5 -4", key: "svg-4" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconFileDownload.mjs
var IconFileDownload;
var init_IconFileDownload = __esm(() => {
  init_createReactComponent();
  IconFileDownload = createReactComponent("outline", "file-download", "IconFileDownload", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M12 17v-6", key: "svg-2" }], ["path", { d: "M9.5 14.5l2.5 2.5l2.5 -2.5", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconFileUpload.mjs
var IconFileUpload;
var init_IconFileUpload = __esm(() => {
  init_createReactComponent();
  IconFileUpload = createReactComponent("outline", "file-upload", "IconFileUpload", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M12 11v6", key: "svg-2" }], ["path", { d: "M9.5 13.5l2.5 -2.5l2.5 2.5", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconFile.mjs
var IconFile;
var init_IconFile = __esm(() => {
  init_createReactComponent();
  IconFile = createReactComponent("outline", "file", "IconFile", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconFilter.mjs
var IconFilter;
var init_IconFilter = __esm(() => {
  init_createReactComponent();
  IconFilter = createReactComponent("outline", "filter", "IconFilter", [["path", { d: "M4 4h16v2.172a2 2 0 0 1 -.586 1.414l-4.414 4.414v7l-6 2v-8.5l-4.48 -4.928a2 2 0 0 1 -.52 -1.345v-2.227z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconFolder.mjs
var IconFolder;
var init_IconFolder = __esm(() => {
  init_createReactComponent();
  IconFolder = createReactComponent("outline", "folder", "IconFolder", [["path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconGripVertical.mjs
var IconGripVertical;
var init_IconGripVertical = __esm(() => {
  init_createReactComponent();
  IconGripVertical = createReactComponent("outline", "grip-vertical", "IconGripVertical", [["path", { d: "M9 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M9 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-1" }], ["path", { d: "M9 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-2" }], ["path", { d: "M15 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-3" }], ["path", { d: "M15 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-4" }], ["path", { d: "M15 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-5" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconInfoCircle.mjs
var IconInfoCircle;
var init_IconInfoCircle = __esm(() => {
  init_createReactComponent();
  IconInfoCircle = createReactComponent("outline", "info-circle", "IconInfoCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconListTree.mjs
var IconListTree;
var init_IconListTree = __esm(() => {
  init_createReactComponent();
  IconListTree = createReactComponent("outline", "list-tree", "IconListTree", [["path", { d: "M9 6h11", key: "svg-0" }], ["path", { d: "M12 12h8", key: "svg-1" }], ["path", { d: "M15 18h5", key: "svg-2" }], ["path", { d: "M5 6v.01", key: "svg-3" }], ["path", { d: "M8 12v.01", key: "svg-4" }], ["path", { d: "M11 18v.01", key: "svg-5" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconList.mjs
var IconList;
var init_IconList = __esm(() => {
  init_createReactComponent();
  IconList = createReactComponent("outline", "list", "IconList", [["path", { d: "M9 6l11 0", key: "svg-0" }], ["path", { d: "M9 12l11 0", key: "svg-1" }], ["path", { d: "M9 18l11 0", key: "svg-2" }], ["path", { d: "M5 6l0 .01", key: "svg-3" }], ["path", { d: "M5 12l0 .01", key: "svg-4" }], ["path", { d: "M5 18l0 .01", key: "svg-5" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconLoader.mjs
var IconLoader;
var init_IconLoader = __esm(() => {
  init_createReactComponent();
  IconLoader = createReactComponent("outline", "loader", "IconLoader", [["path", { d: "M12 6l0 -3", key: "svg-0" }], ["path", { d: "M16.25 7.75l2.15 -2.15", key: "svg-1" }], ["path", { d: "M18 12l3 0", key: "svg-2" }], ["path", { d: "M16.25 16.25l2.15 2.15", key: "svg-3" }], ["path", { d: "M12 18l0 3", key: "svg-4" }], ["path", { d: "M7.75 16.25l-2.15 2.15", key: "svg-5" }], ["path", { d: "M6 12l-3 0", key: "svg-6" }], ["path", { d: "M7.75 7.75l-2.15 -2.15", key: "svg-7" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconMapBolt.mjs
var IconMapBolt;
var init_IconMapBolt = __esm(() => {
  init_createReactComponent();
  IconMapBolt = createReactComponent("outline", "map-bolt", "IconMapBolt", [["path", { d: "M13 19l-4 -2l-6 3v-13l6 -3l6 3l6 -3v8.5", key: "svg-0" }], ["path", { d: "M9 4v13", key: "svg-1" }], ["path", { d: "M15 7v7.5", key: "svg-2" }], ["path", { d: "M19 16l-2 3h4l-2 3", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconPencil.mjs
var IconPencil;
var init_IconPencil = __esm(() => {
  init_createReactComponent();
  IconPencil = createReactComponent("outline", "pencil", "IconPencil", [["path", { d: "M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4", key: "svg-0" }], ["path", { d: "M13.5 6.5l4 4", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconPhotoCog.mjs
var IconPhotoCog;
var init_IconPhotoCog = __esm(() => {
  init_createReactComponent();
  IconPhotoCog = createReactComponent("outline", "photo-cog", "IconPhotoCog", [["path", { d: "M15 8h.01", key: "svg-0" }], ["path", { d: "M12 21h-6a3 3 0 0 1 -3 -3v-12a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v6", key: "svg-1" }], ["path", { d: "M3 16l5 -5c.928 -.893 2.072 -.893 3 0l3 3", key: "svg-2" }], ["path", { d: "M14 14l1 -1c.48 -.461 1.016 -.684 1.551 -.67", key: "svg-3" }], ["path", { d: "M19.001 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-4" }], ["path", { d: "M19.001 15.5v1.5", key: "svg-5" }], ["path", { d: "M19.001 21v1.5", key: "svg-6" }], ["path", { d: "M22.032 17.25l-1.299 .75", key: "svg-7" }], ["path", { d: "M17.27 20l-1.3 .75", key: "svg-8" }], ["path", { d: "M15.97 17.25l1.3 .75", key: "svg-9" }], ["path", { d: "M20.733 20l1.3 .75", key: "svg-10" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconPhotoSearch.mjs
var IconPhotoSearch;
var init_IconPhotoSearch = __esm(() => {
  init_createReactComponent();
  IconPhotoSearch = createReactComponent("outline", "photo-search", "IconPhotoSearch", [["path", { d: "M15 8h.01", key: "svg-0" }], ["path", { d: "M11.5 21h-5.5a3 3 0 0 1 -3 -3v-12a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v5.5", key: "svg-1" }], ["path", { d: "M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-2" }], ["path", { d: "M20.2 20.2l1.8 1.8", key: "svg-3" }], ["path", { d: "M3 16l5 -5c.928 -.893 2.072 -.893 3 0l2 2", key: "svg-4" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconPlaystationSquare.mjs
var IconPlaystationSquare;
var init_IconPlaystationSquare = __esm(() => {
  init_createReactComponent();
  IconPlaystationSquare = createReactComponent("outline", "playstation-square", "IconPlaystationSquare", [["path", { d: "M12 21a9 9 0 0 0 9 -9a9 9 0 0 0 -9 -9a9 9 0 0 0 -9 9a9 9 0 0 0 9 9z", key: "svg-0" }], ["path", { d: "M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconPlug.mjs
var IconPlug;
var init_IconPlug = __esm(() => {
  init_createReactComponent();
  IconPlug = createReactComponent("outline", "plug", "IconPlug", [["path", { d: "M9.785 6l8.215 8.215l-2.054 2.054a5.81 5.81 0 1 1 -8.215 -8.215l2.054 -2.054z", key: "svg-0" }], ["path", { d: "M4 20l3.5 -3.5", key: "svg-1" }], ["path", { d: "M15 4l-3.5 3.5", key: "svg-2" }], ["path", { d: "M20 9l-3.5 3.5", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconPlus.mjs
var IconPlus;
var init_IconPlus = __esm(() => {
  init_createReactComponent();
  IconPlus = createReactComponent("outline", "plus", "IconPlus", [["path", { d: "M12 5l0 14", key: "svg-0" }], ["path", { d: "M5 12l14 0", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconReplace.mjs
var IconReplace;
var init_IconReplace = __esm(() => {
  init_createReactComponent();
  IconReplace = createReactComponent("outline", "replace", "IconReplace", [["path", { d: "M3 3m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-0" }], ["path", { d: "M15 15m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z", key: "svg-1" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-2" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconSearch.mjs
var IconSearch;
var init_IconSearch = __esm(() => {
  init_createReactComponent();
  IconSearch = createReactComponent("outline", "search", "IconSearch", [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconSettings.mjs
var IconSettings;
var init_IconSettings = __esm(() => {
  init_createReactComponent();
  IconSettings = createReactComponent("outline", "settings", "IconSettings", [["path", { d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z", key: "svg-0" }], ["path", { d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconSparkles.mjs
var IconSparkles;
var init_IconSparkles = __esm(() => {
  init_createReactComponent();
  IconSparkles = createReactComponent("outline", "sparkles", "IconSparkles", [["path", { d: "M16 18a2 2 0 0 1 2 2a2 2 0 0 1 2 -2a2 2 0 0 1 -2 -2a2 2 0 0 1 -2 2zm0 -12a2 2 0 0 1 2 2a2 2 0 0 1 2 -2a2 2 0 0 1 -2 -2a2 2 0 0 1 -2 2zm-7 12a6 6 0 0 1 6 -6a6 6 0 0 1 -6 -6a6 6 0 0 1 -6 6a6 6 0 0 1 6 6z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconTrash.mjs
var IconTrash;
var init_IconTrash = __esm(() => {
  init_createReactComponent();
  IconTrash = createReactComponent("outline", "trash", "IconTrash", [["path", { d: "M4 7l16 0", key: "svg-0" }], ["path", { d: "M10 11l0 6", key: "svg-1" }], ["path", { d: "M14 11l0 6", key: "svg-2" }], ["path", { d: "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12", key: "svg-3" }], ["path", { d: "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3", key: "svg-4" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconUpload.mjs
var IconUpload;
var init_IconUpload = __esm(() => {
  init_createReactComponent();
  IconUpload = createReactComponent("outline", "upload", "IconUpload", [["path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2", key: "svg-0" }], ["path", { d: "M7 9l5 -5l5 5", key: "svg-1" }], ["path", { d: "M12 4l0 12", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconWand.mjs
var IconWand;
var init_IconWand = __esm(() => {
  init_createReactComponent();
  IconWand = createReactComponent("outline", "wand", "IconWand", [["path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3", key: "svg-0" }], ["path", { d: "M15 6l3 3", key: "svg-1" }], ["path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2", key: "svg-2" }], ["path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2", key: "svg-3" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconX.mjs
var IconX;
var init_IconX = __esm(() => {
  init_createReactComponent();
  IconX = createReactComponent("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconArrowBigLeftFilled.mjs
var IconArrowBigLeftFilled;
var init_IconArrowBigLeftFilled = __esm(() => {
  init_createReactComponent();
  IconArrowBigLeftFilled = createReactComponent("filled", "arrow-big-left-filled", "IconArrowBigLeftFilled", [["path", { d: "M9.586 4l-6.586 6.586a2 2 0 0 0 0 2.828l6.586 6.586a2 2 0 0 0 2.18 .434l.145 -.068a2 2 0 0 0 1.089 -1.78v-2.586h7a2 2 0 0 0 2 -2v-4l-.005 -.15a2 2 0 0 0 -1.995 -1.85l-7 -.001v-2.585a2 2 0 0 0 -3.414 -1.414z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconBugFilled.mjs
var IconBugFilled;
var init_IconBugFilled = __esm(() => {
  init_createReactComponent();
  IconBugFilled = createReactComponent("filled", "bug-filled", "IconBugFilled", [["path", { d: "M12 4a4 4 0 0 1 3.995 3.8l.005 .2a1 1 0 0 1 .428 .096l3.033 -1.938a1 1 0 1 1 1.078 1.684l-3.015 1.931a7.17 7.17 0 0 1 .476 2.227h3a1 1 0 0 1 0 2h-3v1a6.01 6.01 0 0 1 -.195 1.525l2.708 1.616a1 1 0 1 1 -1.026 1.718l-2.514 -1.501a6.002 6.002 0 0 1 -3.973 2.56v-5.918a1 1 0 0 0 -2 0v5.917a6.002 6.002 0 0 1 -3.973 -2.56l-2.514 1.503a1 1 0 1 1 -1.026 -1.718l2.708 -1.616a6.01 6.01 0 0 1 -.195 -1.526v-1h-3a1 1 0 0 1 0 -2h3.001v-.055a7 7 0 0 1 .474 -2.173l-3.014 -1.93a1 1 0 1 1 1.078 -1.684l3.032 1.939l.024 -.012l.068 -.027l.019 -.005l.016 -.006l.032 -.008l.04 -.013l.034 -.007l.034 -.004l.045 -.008l.015 -.001l.015 -.002l.087 -.004a4 4 0 0 1 4 -4zm0 2a2 2 0 0 0 -2 2h4a2 2 0 0 0 -2 -2z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCaretDownFilled.mjs
var IconCaretDownFilled;
var init_IconCaretDownFilled = __esm(() => {
  init_createReactComponent();
  IconCaretDownFilled = createReactComponent("filled", "caret-down-filled", "IconCaretDownFilled", [["path", { d: "M18 9c.852 0 1.297 .986 .783 1.623l-.076 .084l-6 6a1 1 0 0 1 -1.32 .083l-.094 -.083l-6 -6l-.083 -.094l-.054 -.077l-.054 -.096l-.017 -.036l-.027 -.067l-.032 -.108l-.01 -.053l-.01 -.06l-.004 -.057v-.118l.005 -.058l.009 -.06l.01 -.052l.032 -.108l.027 -.067l.07 -.132l.065 -.09l.073 -.081l.094 -.083l.077 -.054l.096 -.054l.036 -.017l.067 -.027l.108 -.032l.053 -.01l.06 -.01l.057 -.004l12.059 -.002z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCircleCheckFilled.mjs
var IconCircleCheckFilled;
var init_IconCircleCheckFilled = __esm(() => {
  init_createReactComponent();
  IconCircleCheckFilled = createReactComponent("filled", "circle-check-filled", "IconCircleCheckFilled", [["path", { d: "M17 3.34a10 10 0 1 1 -14.995 8.984l-.005 -.324l.005 -.324a10 10 0 0 1 14.995 -8.336zm-1.293 5.953a1 1 0 0 0 -1.32 -.083l-.094 .083l-3.293 3.292l-1.293 -1.292l-.094 -.083a1 1 0 0 0 -1.403 1.403l.083 .094l2 2l.094 .083a1 1 0 0 0 1.226 0l.094 -.083l4 -4l.083 -.094a1 1 0 0 0 -.083 -1.32z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconCircleRectangleFilled.mjs
var IconCircleRectangleFilled;
var init_IconCircleRectangleFilled = __esm(() => {
  init_createReactComponent();
  IconCircleRectangleFilled = createReactComponent("filled", "circle-rectangle-filled", "IconCircleRectangleFilled", [["path", { d: "M17 3.34a10 10 0 1 1 -15 8.66l.005 -.324a10 10 0 0 1 14.995 -8.336m0 5.66h-10a1 1 0 0 0 -1 1v4a1 1 0 0 0 1 1h10a1 1 0 0 0 1 -1v-4a1 1 0 0 0 -1 -1", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconFilterFilled.mjs
var IconFilterFilled;
var init_IconFilterFilled = __esm(() => {
  init_createReactComponent();
  IconFilterFilled = createReactComponent("filled", "filter-filled", "IconFilterFilled", [["path", { d: "M20 3h-16a1 1 0 0 0 -1 1v2.227l.008 .223a3 3 0 0 0 .772 1.795l4.22 4.641v8.114a1 1 0 0 0 1.316 .949l6 -2l.108 -.043a1 1 0 0 0 .576 -.906v-6.586l4.121 -4.12a3 3 0 0 0 .879 -2.123v-2.171a1 1 0 0 0 -1 -1z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconInfoCircleFilled.mjs
var IconInfoCircleFilled;
var init_IconInfoCircleFilled = __esm(() => {
  init_createReactComponent();
  IconInfoCircleFilled = createReactComponent("filled", "info-circle-filled", "IconInfoCircleFilled", [["path", { d: "M12 2c5.523 0 10 4.477 10 10a10 10 0 0 1 -19.995 .324l-.005 -.324l.004 -.28c.148 -5.393 4.566 -9.72 9.996 -9.72zm0 9h-1l-.117 .007a1 1 0 0 0 0 1.986l.117 .007v3l.007 .117a1 1 0 0 0 .876 .876l.117 .007h1l.117 -.007a1 1 0 0 0 .876 -.876l.007 -.117l-.007 -.117a1 1 0 0 0 -.764 -.857l-.112 -.02l-.117 -.006v-3l-.007 -.117a1 1 0 0 0 -.876 -.876l-.117 -.007zm.01 -3l-.127 .007a1 1 0 0 0 0 1.986l.117 .007l.127 -.007a1 1 0 0 0 0 -1.986l-.117 -.007z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconRadioactiveFilled.mjs
var IconRadioactiveFilled;
var init_IconRadioactiveFilled = __esm(() => {
  init_createReactComponent();
  IconRadioactiveFilled = createReactComponent("filled", "radioactive-filled", "IconRadioactiveFilled", [["path", { d: "M21 11a1 1 0 0 1 1 1a10 10 0 0 1 -5 8.656a1 1 0 0 1 -1.302 -.268l-.064 -.098l-3 -5.19a.995 .995 0 0 1 -.133 -.542l.01 -.11l.023 -.106l.034 -.106l.046 -.1l.056 -.094l.067 -.089a.994 .994 0 0 1 .165 -.155l.098 -.064a2 2 0 0 0 .993 -1.57l.007 -.163a1 1 0 0 1 .883 -.994l.117 -.007h6z", key: "svg-0" }], ["path", { d: "M7 3.344a10 10 0 0 1 10 0a1 1 0 0 1 .418 1.262l-.052 .104l-3 5.19l-.064 .098a.994 .994 0 0 1 -.155 .165l-.089 .067a1 1 0 0 1 -.195 .102l-.105 .034l-.107 .022a1.003 1.003 0 0 1 -.547 -.07l-.104 -.052a2 2 0 0 0 -1.842 -.082l-.158 .082a1 1 0 0 1 -1.302 -.268l-.064 -.098l-3 -5.19a1 1 0 0 1 .366 -1.366z", key: "svg-1" }], ["path", { d: "M9 11a1 1 0 0 1 .993 .884l.007 .117a2 2 0 0 0 .861 1.645l.237 .152a.994 .994 0 0 1 .165 .155l.067 .089l.056 .095l.045 .099c.014 .036 .026 .07 .035 .106l.022 .107l.011 .11a.994 .994 0 0 1 -.08 .437l-.053 .104l-3 5.19a1 1 0 0 1 -1.366 .366a10 10 0 0 1 -5 -8.656a1 1 0 0 1 .883 -.993l.117 -.007h6z", key: "svg-2" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconRosetteDiscountCheckFilled.mjs
var IconRosetteDiscountCheckFilled;
var init_IconRosetteDiscountCheckFilled = __esm(() => {
  init_createReactComponent();
  IconRosetteDiscountCheckFilled = createReactComponent("filled", "rosette-discount-check-filled", "IconRosetteDiscountCheckFilled", [["path", { d: "M12.01 2.011a3.2 3.2 0 0 1 2.113 .797l.154 .145l.698 .698a1.2 1.2 0 0 0 .71 .341l.135 .008h1a3.2 3.2 0 0 1 3.195 3.018l.005 .182v1c0 .27 .092 .533 .258 .743l.09 .1l.697 .698a3.2 3.2 0 0 1 .147 4.382l-.145 .154l-.698 .698a1.2 1.2 0 0 0 -.341 .71l-.008 .135v1a3.2 3.2 0 0 1 -3.018 3.195l-.182 .005h-1a1.2 1.2 0 0 0 -.743 .258l-.1 .09l-.698 .697a3.2 3.2 0 0 1 -4.382 .147l-.154 -.145l-.698 -.698a1.2 1.2 0 0 0 -.71 -.341l-.135 -.008h-1a3.2 3.2 0 0 1 -3.195 -3.018l-.005 -.182v-1a1.2 1.2 0 0 0 -.258 -.743l-.09 -.1l-.697 -.698a3.2 3.2 0 0 1 -.147 -4.382l.145 -.154l.698 -.698a1.2 1.2 0 0 0 .341 -.71l.008 -.135v-1l.005 -.182a3.2 3.2 0 0 1 3.013 -3.013l.182 -.005h1a1.2 1.2 0 0 0 .743 -.258l.1 -.09l.698 -.697a3.2 3.2 0 0 1 2.269 -.944zm3.697 7.282a1 1 0 0 0 -1.414 0l-3.293 3.292l-1.293 -1.292l-.094 -.083a1 1 0 0 0 -1.32 1.497l2 2l.094 .083a1 1 0 0 0 1.32 -.083l4 -4l.083 -.094a1 1 0 0 0 -.083 -1.32z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconRosetteFilled.mjs
var IconRosetteFilled;
var init_IconRosetteFilled = __esm(() => {
  init_createReactComponent();
  IconRosetteFilled = createReactComponent("filled", "rosette-filled", "IconRosetteFilled", [["path", { d: "M12.01 2.011a3.2 3.2 0 0 1 2.113 .797l.154 .145l.698 .698a1.2 1.2 0 0 0 .71 .341l.135 .008h1a3.2 3.2 0 0 1 3.195 3.018l.005 .182v1c0 .27 .092 .533 .258 .743l.09 .1l.697 .698a3.2 3.2 0 0 1 .147 4.382l-.145 .154l-.698 .698a1.2 1.2 0 0 0 -.341 .71l-.008 .135v1a3.2 3.2 0 0 1 -3.018 3.195l-.182 .005h-1a1.2 1.2 0 0 0 -.743 .258l-.1 .09l-.698 .697a3.2 3.2 0 0 1 -4.382 .147l-.154 -.145l-.698 -.698a1.2 1.2 0 0 0 -.71 -.341l-.135 -.008h-1a3.2 3.2 0 0 1 -3.195 -3.018l-.005 -.182v-1a1.2 1.2 0 0 0 -.258 -.743l-.09 -.1l-.697 -.698a3.2 3.2 0 0 1 -.147 -4.382l.145 -.154l.698 -.698a1.2 1.2 0 0 0 .341 -.71l.008 -.135v-1l.005 -.182a3.2 3.2 0 0 1 3.013 -3.013l.182 -.005h1a1.2 1.2 0 0 0 .743 -.258l.1 -.09l.698 -.697a3.2 3.2 0 0 1 2.269 -.944z", key: "svg-0" }]]);
});

// node_modules/@tabler/icons-react/dist/esm/icons/IconTrashFilled.mjs
var IconTrashFilled;
var init_IconTrashFilled = __esm(() => {
  init_createReactComponent();
  IconTrashFilled = createReactComponent("filled", "trash-filled", "IconTrashFilled", [["path", { d: "M20 6a1 1 0 0 1 .117 1.993l-.117 .007h-.081l-.919 11a3 3 0 0 1 -2.824 2.995l-.176 .005h-8c-1.598 0 -2.904 -1.249 -2.992 -2.75l-.005 -.167l-.923 -11.083h-.08a1 1 0 0 1 -.117 -1.993l.117 -.007h16z", key: "svg-0" }], ["path", { d: "M14 2a2 2 0 0 1 2 2a1 1 0 0 1 -1.993 .117l-.007 -.117h-4l-.007 .117a1 1 0 0 1 -1.993 -.117a2 2 0 0 1 1.85 -1.995l.15 -.005h4z", key: "svg-1" }]]);
});

// src/studio-adapter/getManualCropsFromDocByConnector.ts
var exports_getManualCropsFromDocByConnector = {};
__export(exports_getManualCropsFromDocByConnector, {
  getManualCropsFromDocByConnector: () => getManualCropsFromDocByConnector
});
async function getManualCropsFromDocByConnector(studio2, connectorId) {
  try {
    const documentStateResult = await getCurrentDocumentState(studio2);
    if (!documentStateResult.isOk()) {
      return Result.error(new Error("Failed to get document state: " + documentStateResult.error?.message));
    }
    const documentState = documentStateResult.value;
    const frameIdToNameMap = new Map;
    if (documentState.pages && Array.isArray(documentState.pages)) {
      for (const page of documentState.pages) {
        if (page.frames && Array.isArray(page.frames)) {
          for (const frame of page.frames) {
            frameIdToNameMap.set(frame.id, frame.name);
          }
        }
      }
    }
    const result = {
      layouts: [],
      connectorId
    };
    if (documentState.layouts && Array.isArray(documentState.layouts)) {
      for (const layout of documentState.layouts) {
        const manualCrops = [];
        if (layout.frameProperties && Array.isArray(layout.frameProperties)) {
          for (const frameProperty of layout.frameProperties) {
            if (frameProperty.perAssetCrop && frameProperty.perAssetCrop[connectorId]) {
              const connectorCrops = frameProperty.perAssetCrop[connectorId];
              for (const [assetPath, cropData] of Object.entries(connectorCrops)) {
                const frameName = frameIdToNameMap.get(frameProperty.id) || frameProperty.id;
                const manualCrop = {
                  frameId: frameProperty.id,
                  frameName,
                  name: assetPath,
                  top: cropData.top,
                  left: cropData.left,
                  width: cropData.width,
                  height: cropData.height,
                  rotationDegrees: cropData.rotationDegrees ?? 0,
                  originalParentWidth: cropData.originalParentWidth ?? 283464,
                  originalParentHeight: cropData.originalParentHeight ?? 283464
                };
                manualCrops.push(manualCrop);
              }
            }
          }
        }
        if (manualCrops.length > 0) {
          const layoutWithCrops = {
            id: layout.id,
            name: layout.name,
            parentId: layout.parentId || "",
            manualCrops
          };
          result.layouts.push(layoutWithCrops);
        }
      }
    }
    return Result.ok(result);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error(String(error40)));
  }
}
var init_getManualCropsFromDocByConnector = __esm(() => {
  init_dist();
  init_documentHandler();
});

// node_modules/json-2-csv/lib/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = undefined;
  exports.errors = {
    optionsRequired: "Options were not passed and are required.",
    json2csv: {
      cannotCallOn: "Cannot call json2csv on",
      dataCheckFailure: "Data provided was not an array of documents.",
      notSameSchema: "Not all documents have the same schema."
    },
    csv2json: {
      cannotCallOn: "Cannot call csv2json on",
      dataCheckFailure: "CSV is not a string."
    }
  };
  exports.defaultJson2CsvOptions = {
    arrayIndexesAsKeys: false,
    checkSchemaDifferences: false,
    delimiter: {
      field: ",",
      wrap: '"',
      eol: `
`
    },
    emptyFieldValue: undefined,
    escapeHeaderNestedDots: true,
    excelBOM: false,
    excludeKeys: [],
    expandNestedObjects: true,
    expandArrayObjects: false,
    prependHeader: true,
    preventCsvInjection: false,
    sortHeader: false,
    trimFieldValues: false,
    trimHeaderFields: false,
    unwindArrays: false,
    useDateIso8601Format: false,
    useLocaleFormat: false,
    wrapBooleans: false
  };
  exports.defaultCsv2JsonOptions = {
    delimiter: {
      field: ",",
      wrap: '"',
      eol: `
`
    },
    excelBOM: false,
    preventCsvInjection: false,
    trimFieldValues: false,
    trimHeaderFields: false
  };
  exports.excelBOM = "\uFEFF";
});

// node_modules/doc-path/lib/path.js
var require_path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setPath = exports.evaluatePath = undefined;
  function evaluatePath(obj, kp) {
    if (!obj) {
      return null;
    }
    const { dotIndex, key, remaining } = state(kp);
    const kpVal = typeof obj === "object" && kp in obj ? obj[kp] : undefined;
    const keyVal = typeof obj === "object" && key in obj ? obj[key] : undefined;
    if (dotIndex >= 0 && typeof obj === "object" && !(kp in obj)) {
      const { key: nextKey } = state(remaining);
      const nextKeyAsInt = parseInt(nextKey);
      if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {
        return keyVal.map((doc2) => evaluatePath(doc2, remaining));
      }
      return evaluatePath(keyVal, remaining);
    } else if (Array.isArray(obj)) {
      const keyAsInt = parseInt(key);
      if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {
        return keyVal;
      }
      return obj.map((doc2) => evaluatePath(doc2, kp));
    } else if (dotIndex >= 0 && kp !== key && typeof obj === "object" && key in obj) {
      return evaluatePath(keyVal, remaining);
    } else if (dotIndex === -1 && typeof obj === "object" && key in obj && !(kp in obj)) {
      return keyVal;
    }
    return kpVal;
  }
  exports.evaluatePath = evaluatePath;
  function setPath(obj, kp, v2) {
    if (!obj) {
      throw new Error("No object was provided.");
    } else if (!kp) {
      throw new Error("No keyPath was provided.");
    }
    return _sp(obj, kp, v2);
  }
  exports.setPath = setPath;
  function _sp(obj, kp, v2) {
    const { dotIndex, key, remaining } = state(kp);
    if (kp.startsWith("__proto__") || kp.startsWith("constructor") || kp.startsWith("prototype")) {
      return obj;
    }
    if (dotIndex >= 0) {
      const keyAsInt = parseInt(key);
      if (typeof obj === "object" && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {
        obj[key] = obj[key] ?? {};
        _sp(obj[key], remaining, v2);
        return obj;
      } else if (typeof obj === "object" && obj !== null && !(key in obj) && Array.isArray(obj)) {
        obj.forEach((doc2) => _sp(doc2, kp, v2));
        return obj;
      } else if (typeof obj === "object" && obj !== null && !(key in obj) && !Array.isArray(obj)) {
        const { key: nextKey } = state(remaining);
        const nextKeyAsInt = parseInt(nextKey);
        if (!isNaN(nextKeyAsInt)) {
          obj[key] = [];
        } else if (remaining === "") {
          obj[kp] = v2;
          return obj;
        } else {
          obj[key] = {};
        }
      }
      _sp(obj[key], remaining, v2);
    } else if (Array.isArray(obj)) {
      const keyAsInt = parseInt(key);
      if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {
        obj[key] = v2;
        return obj;
      }
      obj.forEach((doc2) => _sp(doc2, remaining, v2));
      return obj;
    } else {
      obj[key] = v2;
    }
    return obj;
  }
  function state(kp) {
    const dotIndex = findFirstNonEscapedDotIndex(kp);
    return {
      dotIndex,
      key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\./g, "."),
      remaining: kp.slice(dotIndex + 1)
    };
  }
  function findFirstNonEscapedDotIndex(kp) {
    for (let i2 = 0;i2 < kp.length; i2++) {
      const previousChar = i2 > 0 ? kp[i2 - 1] : "", currentChar = kp[i2];
      if (currentChar === "." && previousChar !== "\\")
        return i2;
    }
    return -1;
  }
});

// node_modules/deeks/lib/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDocumentToRecurOn = exports.flatten = exports.unique = undefined;
  function unique(array2) {
    return [...new Set(array2)];
  }
  exports.unique = unique;
  function flatten(array2) {
    return [].concat(...array2);
  }
  exports.flatten = flatten;
  function isDocumentToRecurOn(val) {
    return typeof val === "object" && val !== null && !Array.isArray(val) && Object.keys(val).length;
  }
  exports.isDocumentToRecurOn = isDocumentToRecurOn;
});

// node_modules/deeks/lib/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/deeks/lib/deeks.js
var require_deeks = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deepKeysFromList = exports.deepKeys = undefined;
  var utils = __importStar(require_utils());
  __exportStar(require_types(), exports);
  function deepKeys(object2, options) {
    const parsedOptions = mergeOptions(options);
    if (typeof object2 === "object" && object2 !== null) {
      return generateDeepKeysList("", object2, parsedOptions);
    }
    return [];
  }
  exports.deepKeys = deepKeys;
  function deepKeysFromList(list, options) {
    const parsedOptions = mergeOptions(options);
    return list.map((document2) => {
      if (typeof document2 === "object" && document2 !== null) {
        return deepKeys(document2, parsedOptions);
      }
      return [];
    });
  }
  exports.deepKeysFromList = deepKeysFromList;
  function generateDeepKeysList(heading, data, options) {
    const keys2 = Object.keys(data).map((currentKey) => {
      const keyName = buildKeyName(heading, escapeNestedDotsIfSpecified(currentKey, options));
      if (options.expandNestedObjects && utils.isDocumentToRecurOn(data[currentKey]) || options.arrayIndexesAsKeys && Array.isArray(data[currentKey]) && data[currentKey].length) {
        return generateDeepKeysList(keyName, data[currentKey], options);
      } else if (options.expandArrayObjects && Array.isArray(data[currentKey])) {
        return processArrayKeys(data[currentKey], keyName, options);
      } else if (options.ignoreEmptyArrays && Array.isArray(data[currentKey]) && !data[currentKey].length) {
        return [];
      }
      return keyName;
    });
    return utils.flatten(keys2);
  }
  function processArrayKeys(subArray, currentKeyPath, options) {
    let subArrayKeys = deepKeysFromList(subArray, options);
    if (!subArray.length) {
      return options.ignoreEmptyArraysWhenExpanding ? [] : [currentKeyPath];
    } else if (subArray.length && utils.flatten(subArrayKeys).length === 0) {
      return [currentKeyPath];
    } else {
      subArrayKeys = subArrayKeys.map((schemaKeys) => {
        if (Array.isArray(schemaKeys) && schemaKeys.length === 0) {
          return [currentKeyPath];
        }
        return schemaKeys.map((subKey) => buildKeyName(currentKeyPath, escapeNestedDotsIfSpecified(subKey, options)));
      });
      return utils.unique(utils.flatten(subArrayKeys));
    }
  }
  function escapeNestedDotsIfSpecified(key, options) {
    if (options.escapeNestedDots) {
      return key.replace(/\./g, "\\.");
    }
    return key;
  }
  function buildKeyName(upperKeyName, currentKeyName) {
    if (upperKeyName) {
      return upperKeyName + "." + currentKeyName;
    }
    return currentKeyName;
  }
  function mergeOptions(options) {
    return {
      arrayIndexesAsKeys: false,
      expandNestedObjects: true,
      expandArrayObjects: false,
      ignoreEmptyArraysWhenExpanding: false,
      escapeNestedDots: false,
      ignoreEmptyArrays: false,
      ...options ?? {}
    };
  }
});

// node_modules/json-2-csv/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = undefined;
  var doc_path_1 = require_path();
  var constants_1 = require_constants();
  var dateStringRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;
  var MAX_ARRAY_LENGTH = 1e5;
  function buildJ2COptions(opts) {
    return {
      ...constants_1.defaultJson2CsvOptions,
      ...opts,
      delimiter: {
        field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,
        wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,
        eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol
      },
      fieldTitleMap: Object.create({})
    };
  }
  exports.buildJ2COptions = buildJ2COptions;
  function buildC2JOptions(opts) {
    return {
      ...constants_1.defaultCsv2JsonOptions,
      ...opts,
      delimiter: {
        field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,
        wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,
        eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol
      }
    };
  }
  exports.buildC2JOptions = buildC2JOptions;
  function validate(data, validationFn, errorMessages) {
    if (!data)
      throw new Error(`${errorMessages.cannotCallOn} ${data}.`);
    if (!validationFn(data))
      throw new Error(errorMessages.dataCheckFailure);
    return true;
  }
  exports.validate = validate;
  function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  exports.deepCopy = deepCopy;
  function isStringRepresentation(fieldValue, options) {
    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];
    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;
  }
  exports.isStringRepresentation = isStringRepresentation;
  function isDateRepresentation(fieldValue) {
    return dateStringRegex.test(fieldValue);
  }
  exports.isDateRepresentation = isDateRepresentation;
  function computeSchemaDifferences(schemaA, schemaB) {
    return arrayDifference(schemaA, schemaB).concat(arrayDifference(schemaB, schemaA));
  }
  exports.computeSchemaDifferences = computeSchemaDifferences;
  function isEmptyField(fieldValue) {
    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === "";
  }
  exports.isEmptyField = isEmptyField;
  function removeEmptyFields(fields) {
    return fields.filter((field) => !isEmptyField(field));
  }
  exports.removeEmptyFields = removeEmptyFields;
  function getNCharacters(str, start, n) {
    return str.substring(start, start + n);
  }
  exports.getNCharacters = getNCharacters;
  function unwindItem(accumulator, item, fieldPath) {
    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);
    let cloned = deepCopy(item);
    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {
      valueToUnwind.forEach((val) => {
        cloned = deepCopy(item);
        accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));
      });
    } else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {
      (0, doc_path_1.setPath)(cloned, fieldPath, "");
      accumulator.push(cloned);
    } else {
      accumulator.push(cloned);
    }
  }
  function unwind(array2, field) {
    const result = [];
    array2.forEach((item) => {
      unwindItem(result, item, field);
    });
    return result;
  }
  exports.unwind = unwind;
  function isNumber(value) {
    return !isNaN(Number(value));
  }
  exports.isNumber = isNumber;
  function isString(value) {
    return typeof value === "string";
  }
  exports.isString = isString;
  function isObject3(value) {
    return typeof value === "object";
  }
  exports.isObject = isObject3;
  function isNull(value) {
    return value === null;
  }
  exports.isNull = isNull;
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  exports.isUndefined = isUndefined;
  function isError(value) {
    return Object.prototype.toString.call(value) === "[object Error]";
  }
  exports.isError = isError;
  function arrayDifference(a2, b) {
    return a2.filter((x2) => !b.includes(x2));
  }
  exports.arrayDifference = arrayDifference;
  function unique(array2) {
    return [...new Set(array2)];
  }
  exports.unique = unique;
  function flatten(array2) {
    if (array2.flat) {
      return array2.flat();
    }
    if (array2.length > MAX_ARRAY_LENGTH) {
      let safeArray = [];
      for (let a2 = 0;a2 < array2.length; a2 += MAX_ARRAY_LENGTH) {
        safeArray = safeArray.concat(...array2.slice(a2, a2 + MAX_ARRAY_LENGTH));
      }
      return safeArray;
    }
    return array2.reduce((accumulator, value) => accumulator.concat(value), []);
  }
  exports.flatten = flatten;
  function isInvalid(parsedJson) {
    return parsedJson === Infinity || parsedJson === -Infinity;
  }
  exports.isInvalid = isInvalid;
});

// node_modules/json-2-csv/lib/json2csv.js
var require_json2csv = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Json2Csv = undefined;
  var doc_path_1 = require_path();
  var deeks_1 = require_deeks();
  var constants_1 = require_constants();
  var utils = __importStar(require_utils2());
  var Json2Csv = function(options) {
    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, "g"), crlfSearchRegex = /\r?\n|\r/, customValueParser = options.parseValue && typeof options.parseValue === "function" ? options.parseValue : null, expandingWithoutUnwinding = options.expandArrayObjects && !options.unwindArrays, deeksOptions = {
      arrayIndexesAsKeys: options.arrayIndexesAsKeys,
      expandNestedObjects: options.expandNestedObjects,
      expandArrayObjects: expandingWithoutUnwinding,
      ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,
      escapeNestedDots: true
    };
    function getFieldNameList(data) {
      return (0, deeks_1.deepKeysFromList)(data, deeksOptions);
    }
    function processSchemas(documentSchemas) {
      if (documentSchemas.length === 0) {
        return [];
      }
      if (options.checkSchemaDifferences) {
        return checkSchemaDifferences(documentSchemas);
      } else {
        const uniqueFieldNames = utils.unique(utils.flatten(documentSchemas));
        return uniqueFieldNames;
      }
    }
    function checkSchemaDifferences(documentSchemas) {
      const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);
      if (schemaDifferences) {
        throw new Error(constants_1.errors.json2csv.notSameSchema);
      }
      return firstDocSchema;
    }
    function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {
      return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {
        const numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;
        return numberOfDifferences > 0 ? schemaDifferences + 1 : schemaDifferences;
      }, 0);
    }
    function filterExcludedKeys(keyPaths) {
      if (options.excludeKeys) {
        return keyPaths.filter((keyPath) => {
          for (const excludedKey of options.excludeKeys) {
            const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);
            if (excludedKey === keyPath || keyPath.match(regex)) {
              return false;
            }
          }
          return true;
        });
      }
      return keyPaths;
    }
    function sortHeaderFields(fieldNames) {
      if (options.sortHeader && typeof options.sortHeader === "function") {
        return fieldNames.sort(options.sortHeader);
      } else if (options.sortHeader) {
        return fieldNames.sort();
      }
      return fieldNames;
    }
    function trimHeaderFields(params) {
      if (options.trimHeaderFields) {
        params.headerFields = params.headerFields.map((field) => field.split(".").map((component) => component.trim()).join("."));
      }
      return params;
    }
    function wrapHeaderFields(params) {
      if (options.prependHeader) {
        params.headerFields = params.headerFields.map(function(headingKey) {
          return wrapFieldValueIfNecessary(headingKey);
        });
      }
      return params;
    }
    function generateCsvHeader(params) {
      const fieldTitleMapKeys = Object.keys(options.fieldTitleMap);
      params.header = params.headerFields.map(function(field) {
        let headerKey = field;
        if (fieldTitleMapKeys.includes(field)) {
          headerKey = options.fieldTitleMap[field];
        } else if (!options.escapeHeaderNestedDots) {
          headerKey = headerKey.replace(/\\\./g, ".");
        }
        return headerKey;
      }).join(options.delimiter.field);
      return params;
    }
    function convertKeysToHeaderFields() {
      if (!options.keys)
        return [];
      return options.keys.map((key) => {
        if (typeof key === "object" && "field" in key) {
          options.fieldTitleMap[key.field] = key.title ?? key.field;
          return key.field;
        }
        return key;
      });
    }
    function extractWildcardMatchKeys() {
      if (!options.keys)
        return [];
      return options.keys.flatMap((item) => {
        if (typeof item === "string") {
          return [];
        } else if (item?.wildcardMatch) {
          return item.field;
        }
        return [];
      });
    }
    function retrieveHeaderFields(data) {
      const wildcardMatchKeys = extractWildcardMatchKeys();
      const keyStrings = convertKeysToHeaderFields();
      const fieldNames = getFieldNameList(data);
      const processed = processSchemas(fieldNames);
      if (options.keys) {
        options.keys = keyStrings;
        const matchedKeys = keyStrings.flatMap((userProvidedKey) => {
          if (!wildcardMatchKeys.includes(userProvidedKey)) {
            return userProvidedKey;
          }
          const matches = [];
          const regex = new RegExp(`^${userProvidedKey}`);
          for (const detectedKey of processed) {
            if (userProvidedKey === detectedKey || detectedKey.match(regex)) {
              matches.push(detectedKey);
            }
          }
          return matches;
        });
        if (!options.unwindArrays) {
          const filtered2 = filterExcludedKeys(matchedKeys);
          return sortHeaderFields(filtered2);
        }
      }
      const filtered = filterExcludedKeys(processed);
      return sortHeaderFields(filtered);
    }
    function stillNeedsUnwind(params) {
      for (const record2 of params.records) {
        for (const field of params.headerFields) {
          const value = (0, doc_path_1.evaluatePath)(record2, field);
          if (Array.isArray(value)) {
            return true;
          }
        }
      }
      return false;
    }
    function unwindRecordsIfNecessary(params, finalPass = false) {
      if (options.unwindArrays) {
        params.headerFields.forEach((headerField) => {
          params.records = utils.unwind(params.records, headerField);
        });
        params.headerFields = retrieveHeaderFields(params.records);
        if (stillNeedsUnwind(params)) {
          return unwindRecordsIfNecessary(params, finalPass);
        }
        if (!finalPass) {
          return unwindRecordsIfNecessary(params, true);
        }
        if (options.keys) {
          const userSelectedFields = convertKeysToHeaderFields();
          params.headerFields = filterExcludedKeys(userSelectedFields);
        }
        return params;
      }
      return params;
    }
    function processRecords(params) {
      params.recordString = params.records.map((record2) => {
        const recordFieldData = retrieveRecordFieldData(record2, params.headerFields), processedRecordData = recordFieldData.map((fieldValue) => {
          fieldValue = trimRecordFieldValue(fieldValue);
          fieldValue = preventCsvInjection(fieldValue);
          let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);
          stringified = wrapFieldValueIfNecessary(stringified);
          return stringified;
        });
        return generateCsvRowFromRecord(processedRecordData);
      }).join(options.delimiter.eol);
      return params;
    }
    function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {
      const filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);
      if (!recordFieldValue.length || !filteredRecordFieldValue.length) {
        return options.emptyFieldValue || "";
      } else if (filteredRecordFieldValue.length === 1) {
        return filteredRecordFieldValue[0];
      }
      return recordFieldValue;
    }
    function retrieveRecordFieldData(record2, fields) {
      const recordValues = [];
      fields.forEach((field) => {
        let recordFieldValue = (0, doc_path_1.evaluatePath)(record2, field);
        if (!utils.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {
          recordFieldValue = options.emptyFieldValue;
        } else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {
          recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);
        }
        recordValues.push(recordFieldValue);
      });
      return recordValues;
    }
    function recordFieldValueToString(fieldValue) {
      const isDate = fieldValue instanceof Date;
      if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === "object" && !isDate) {
        return JSON.stringify(fieldValue);
      } else if (typeof fieldValue === "undefined") {
        return "undefined";
      } else if (isDate && options.useDateIso8601Format) {
        return fieldValue.toISOString();
      } else {
        return !options.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();
      }
    }
    function trimRecordFieldValue(fieldValue) {
      if (options.trimFieldValues) {
        if (Array.isArray(fieldValue)) {
          return fieldValue.map(trimRecordFieldValue);
        } else if (typeof fieldValue === "string") {
          return fieldValue.trim();
        }
        return fieldValue;
      }
      return fieldValue;
    }
    function preventCsvInjection(fieldValue) {
      if (options.preventCsvInjection) {
        if (Array.isArray(fieldValue)) {
          return fieldValue.map(preventCsvInjection);
        } else if (typeof fieldValue === "string" && !utils.isNumber(fieldValue)) {
          return fieldValue.replace(/^[=+\-@\t\r]+/g, "");
        }
        return fieldValue;
      }
      return fieldValue;
    }
    function wrapFieldValueIfNecessary(fieldValue) {
      const wrapDelimiter = options.delimiter.wrap;
      if (fieldValue.includes(options.delimiter.wrap)) {
        fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);
      }
      if (fieldValue.includes(options.delimiter.field) || fieldValue.includes(options.delimiter.wrap) || fieldValue.match(crlfSearchRegex) || options.wrapBooleans && (fieldValue === "true" || fieldValue === "false")) {
        fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;
      }
      return fieldValue;
    }
    function generateCsvRowFromRecord(recordFieldValues) {
      return recordFieldValues.join(options.delimiter.field);
    }
    function generateCsvFromComponents(params) {
      const { header, recordString: records } = params, csv = (options.excelBOM ? constants_1.excelBOM : "") + (options.prependHeader ? header + options.delimiter.eol : "") + records;
      return csv;
    }
    function convert(data) {
      if (!Array.isArray(data)) {
        data = [data];
      }
      const headerFields = {
        headerFields: retrieveHeaderFields(data),
        records: data,
        header: "",
        recordString: ""
      };
      const unwinded = unwindRecordsIfNecessary(headerFields);
      const processed = processRecords(unwinded);
      const wrapped = wrapHeaderFields(processed);
      const trimmed = trimHeaderFields(wrapped);
      const generated = generateCsvHeader(trimmed);
      return generateCsvFromComponents(generated);
    }
    return {
      convert
    };
  };
  exports.Json2Csv = Json2Csv;
});

// node_modules/json-2-csv/lib/csv2json.js
var require_csv2json = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Csv2Json = undefined;
  var doc_path_1 = require_path();
  var constants_1 = require_constants();
  var utils = __importStar(require_utils2());
  var Csv2Json = function(options) {
    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, "g"), excelBOMRegex = new RegExp("^" + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === "function" ? options.parseValue : JSON.parse;
    function processHeaderKey(headerKey) {
      headerKey = removeWrapDelimitersFromValue(headerKey);
      if (options.trimHeaderFields) {
        return headerKey.split(".").map((component) => component.trim()).join(".");
      }
      return headerKey;
    }
    function retrieveHeading(lines) {
      let headerFields = [];
      if (options.headerFields) {
        headerFields = options.headerFields.map((headerField, index4) => ({
          value: processHeaderKey(headerField),
          index: index4
        }));
      } else {
        const headerRow = lines[0];
        headerFields = headerRow.map((headerKey, index4) => ({
          value: processHeaderKey(headerKey),
          index: index4
        }));
        if (options.keys) {
          const keys2 = options.keys;
          headerFields = headerFields.filter((headerKey) => keys2.includes(headerKey.value));
        }
      }
      return {
        lines,
        headerFields,
        recordLines: []
      };
    }
    function stripExcelBOM(csv) {
      if (options.excelBOM) {
        return csv.replace(excelBOMRegex, "");
      }
      return csv;
    }
    function splitLines(csv) {
      const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {
        insideWrapDelimiter: false,
        parsingValue: true,
        justParsedDoubleQuote: false,
        startIndex: 0
      };
      let splitLine = [], character2, charBefore, charAfter, nextNChar, index4 = 0;
      while (index4 < csv.length) {
        character2 = csv[index4];
        charBefore = index4 ? csv[index4 - 1] : "";
        charAfter = index4 < lastCharacterIndex ? csv[index4 + 1] : "";
        nextNChar = utils.getNCharacters(csv, index4, eolDelimiterLength);
        if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter || index4 === lastCharacterIndex) && charBefore === options.delimiter.field) {
          if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index4) {
            splitLine.push("");
          } else if (character2 === options.delimiter.field) {
            splitLine.push("");
          } else {
            splitLine.push(csv.substring(stateVariables.startIndex));
          }
          splitLine.push("");
          lines.push(splitLine);
          splitLine = [];
          stateVariables.startIndex = index4 + eolDelimiterLength;
          stateVariables.parsingValue = true;
          stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;
        } else if (index4 === lastCharacterIndex && character2 === options.delimiter.field) {
          const parsedValue = csv.substring(stateVariables.startIndex, index4);
          splitLine.push(parsedValue);
          splitLine.push("");
          lines.push(splitLine);
        } else if (index4 === lastCharacterIndex || nextNChar === options.delimiter.eol && (!stateVariables.insideWrapDelimiter || stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {
          const toIndex = index4 !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index4 : undefined;
          splitLine.push(csv.substring(stateVariables.startIndex, toIndex));
          lines.push(splitLine);
          splitLine = [];
          stateVariables.startIndex = index4 + eolDelimiterLength;
          stateVariables.parsingValue = true;
          stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;
        } else if (character2 === options.delimiter.wrap && charBefore === options.delimiter.field && !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {
          stateVariables.startIndex = index4;
          stateVariables.insideWrapDelimiter = true;
          stateVariables.parsingValue = true;
          if (utils.getNCharacters(csv, index4 + 1, eolDelimiterLength) === options.delimiter.eol) {
            index4 += options.delimiter.eol.length + 1;
          }
        } else if (charBefore === options.delimiter.field && character2 === options.delimiter.wrap && charAfter === options.delimiter.eol) {
          splitLine.push(csv.substring(stateVariables.startIndex, index4 - 1));
          stateVariables.startIndex = index4;
          stateVariables.parsingValue = true;
          stateVariables.insideWrapDelimiter = true;
          stateVariables.justParsedDoubleQuote = true;
          index4 += 1;
        } else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) && character2 === options.delimiter.wrap && utils.getNCharacters(csv, index4 + 1, eolDelimiterLength) === options.delimiter.eol) {
          stateVariables.insideWrapDelimiter = false;
          stateVariables.parsingValue = false;
        } else if (character2 === options.delimiter.wrap && (index4 === 0 || utils.getNCharacters(csv, index4 - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {
          stateVariables.insideWrapDelimiter = true;
          stateVariables.parsingValue = true;
          stateVariables.startIndex = index4;
        } else if (character2 === options.delimiter.wrap && charAfter === options.delimiter.field && stateVariables.insideWrapDelimiter) {
          splitLine.push(csv.substring(stateVariables.startIndex, index4 + 1));
          stateVariables.startIndex = index4 + 2;
          stateVariables.insideWrapDelimiter = false;
          stateVariables.parsingValue = false;
        } else if (character2 === options.delimiter.wrap && charBefore === options.delimiter.field && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {
          splitLine.push(csv.substring(stateVariables.startIndex, index4 - 1));
          stateVariables.insideWrapDelimiter = true;
          stateVariables.parsingValue = true;
          stateVariables.startIndex = index4;
        } else if (character2 === options.delimiter.wrap && charAfter === options.delimiter.wrap && index4 !== stateVariables.startIndex) {
          index4 += 2;
          stateVariables.justParsedDoubleQuote = true;
          continue;
        } else if (character2 === options.delimiter.field && charBefore !== options.delimiter.wrap && charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {
          splitLine.push(csv.substring(stateVariables.startIndex, index4));
          stateVariables.startIndex = index4 + 1;
        } else if (character2 === options.delimiter.field && charBefore === options.delimiter.wrap && charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {
          stateVariables.insideWrapDelimiter = false;
          stateVariables.parsingValue = true;
          stateVariables.startIndex = index4 + 1;
        }
        index4++;
        stateVariables.justParsedDoubleQuote = false;
      }
      return lines;
    }
    function retrieveRecordLines(params) {
      if (options.headerFields) {
        params.recordLines = params.lines;
      } else {
        params.recordLines = params.lines.splice(1);
      }
      return params;
    }
    function retrieveRecordValueFromLine(headerField, line2) {
      const value = line2[headerField.index];
      return processRecordValue(value);
    }
    function processRecordValue(fieldValue) {
      const parsedJson = parseValue(fieldValue);
      if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {
        return parsedJson;
      } else if (fieldValue === "undefined") {
        return;
      }
      return fieldValue;
    }
    function trimRecordValue(fieldValue) {
      if (options.trimFieldValues && fieldValue !== null) {
        return fieldValue.trim();
      }
      return fieldValue;
    }
    function createDocument(headerFields, line2) {
      return headerFields.reduce((document2, headerField) => {
        const value = retrieveRecordValueFromLine(headerField, line2);
        try {
          return (0, doc_path_1.setPath)(document2, headerField.value, value);
        } catch (error40) {
          return document2;
        }
      }, {});
    }
    function removeWrapDelimitersFromValue(fieldValue) {
      const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];
      if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {
        return fieldValue.length <= 2 ? "" : fieldValue.substring(1, lastIndex);
      }
      return fieldValue;
    }
    function unescapeWrapDelimiterInField(fieldValue) {
      return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);
    }
    function transformRecordLines(params) {
      return params.recordLines.reduce((generatedJsonObjects, line2) => {
        line2 = line2.map((fieldValue) => {
          fieldValue = removeWrapDelimitersFromValue(fieldValue);
          fieldValue = unescapeWrapDelimiterInField(fieldValue);
          fieldValue = trimRecordValue(fieldValue);
          return fieldValue;
        });
        const generatedDocument = createDocument(params.headerFields, line2);
        return generatedJsonObjects.concat(generatedDocument);
      }, []);
    }
    function parseValue(value) {
      try {
        if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {
          return value;
        }
        const parsedJson = valueParserFn(value);
        if (Array.isArray(parsedJson)) {
          return parsedJson.map(trimRecordValue);
        }
        return parsedJson;
      } catch (err) {
        return err;
      }
    }
    function convert(data) {
      const stripped = stripExcelBOM(data);
      const split = splitLines(stripped);
      const heading = retrieveHeading(split);
      const lines = retrieveRecordLines(heading);
      return transformRecordLines(lines);
    }
    return {
      convert
    };
  };
  exports.Csv2Json = Csv2Json;
});

// node_modules/json-2-csv/lib/converter.js
var require_converter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.csv2json = exports.json2csv = undefined;
  var constants_1 = require_constants();
  var json2csv_1 = require_json2csv();
  var csv2json_1 = require_csv2json();
  var utils_1 = require_utils2();
  function json2csv(data, options) {
    const builtOptions = (0, utils_1.buildJ2COptions)(options ?? {});
    (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);
    return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);
  }
  exports.json2csv = json2csv;
  function csv2json(data, options) {
    const builtOptions = (0, utils_1.buildC2JOptions)(options ?? {});
    (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);
    return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);
  }
  exports.csv2json = csv2json;
});

// node:stream
var exports_stream = {};
__export(exports_stream, {
  default: () => Uc
});
var al, tt2, cl, dl, hl, pl, yl = (e, t) => () => (e && (t = e(e = 0)), t), E = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Qr = (e, t) => {
  for (var r3 in t)
    tt2(e, r3, { get: t[r3], enumerable: true });
}, et2 = (e, t, r3, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i2 of dl(t))
      !pl.call(e, i2) && i2 !== r3 && tt2(e, i2, { get: () => t[i2], enumerable: !(n = cl(t, i2)) || n.enumerable });
  return e;
}, ue2 = (e, t, r3) => (et2(e, t, "default"), r3 && et2(r3, t, "default")), rt2 = (e, t, r3) => (r3 = e != null ? al(hl(e)) : {}, et2(t || !e || !e.__esModule ? tt2(r3, "default", { value: e, enumerable: true }) : r3, e)), pe = (e) => et2(tt2({}, "__esModule", { value: true }), e), tn, rn, te2, I2, V2, ut2, C2, He2, ir, k2, Gu, se2, ae2, ce2, di, Se2, Et, xt, At, Pi, Tt, Wi, Gi, Er, Ke2, Cr, Mo, J2, qr, $r, Ut, Jo, Kr, fl, Jr, Ze2, Uc;
var init_stream = __esm(() => {
  al = Object.create;
  tt2 = Object.defineProperty;
  cl = Object.getOwnPropertyDescriptor;
  dl = Object.getOwnPropertyNames;
  hl = Object.getPrototypeOf;
  pl = Object.prototype.hasOwnProperty;
  tn = E((nt) => {
    nt.byteLength = bl;
    nt.toByteArray = _l;
    nt.fromByteArray = ml;
    var G2 = [], P = [], wl = typeof Uint8Array < "u" ? Uint8Array : Array, Wt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ye2 = 0, Zr = Wt.length;ye2 < Zr; ++ye2)
      G2[ye2] = Wt[ye2], P[Wt.charCodeAt(ye2)] = ye2;
    var ye2, Zr;
    P[45] = 62;
    P[95] = 63;
    function en(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r3 = e.indexOf("=");
      r3 === -1 && (r3 = t);
      var n = r3 === t ? 0 : 4 - r3 % 4;
      return [r3, n];
    }
    function bl(e) {
      var t = en(e), r3 = t[0], n = t[1];
      return (r3 + n) * 3 / 4 - n;
    }
    function gl(e, t, r3) {
      return (t + r3) * 3 / 4 - r3;
    }
    function _l(e) {
      var t, r3 = en(e), n = r3[0], i2 = r3[1], o2 = new wl(gl(e, n, i2)), l2 = 0, u2 = i2 > 0 ? n - 4 : n, f2;
      for (f2 = 0;f2 < u2; f2 += 4)
        t = P[e.charCodeAt(f2)] << 18 | P[e.charCodeAt(f2 + 1)] << 12 | P[e.charCodeAt(f2 + 2)] << 6 | P[e.charCodeAt(f2 + 3)], o2[l2++] = t >> 16 & 255, o2[l2++] = t >> 8 & 255, o2[l2++] = t & 255;
      return i2 === 2 && (t = P[e.charCodeAt(f2)] << 2 | P[e.charCodeAt(f2 + 1)] >> 4, o2[l2++] = t & 255), i2 === 1 && (t = P[e.charCodeAt(f2)] << 10 | P[e.charCodeAt(f2 + 1)] << 4 | P[e.charCodeAt(f2 + 2)] >> 2, o2[l2++] = t >> 8 & 255, o2[l2++] = t & 255), o2;
    }
    function El(e) {
      return G2[e >> 18 & 63] + G2[e >> 12 & 63] + G2[e >> 6 & 63] + G2[e & 63];
    }
    function Sl(e, t, r3) {
      for (var n, i2 = [], o2 = t;o2 < r3; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i2.push(El(n));
      return i2.join("");
    }
    function ml(e) {
      for (var t, r3 = e.length, n = r3 % 3, i2 = [], o2 = 16383, l2 = 0, u2 = r3 - n;l2 < u2; l2 += o2)
        i2.push(Sl(e, l2, l2 + o2 > u2 ? u2 : l2 + o2));
      return n === 1 ? (t = e[r3 - 1], i2.push(G2[t >> 2] + G2[t << 4 & 63] + "==")) : n === 2 && (t = (e[r3 - 2] << 8) + e[r3 - 1], i2.push(G2[t >> 10] + G2[t >> 4 & 63] + G2[t << 2 & 63] + "=")), i2.join("");
    }
  });
  rn = E(($t) => {
    $t.read = function(e, t, r3, n, i2) {
      var o2, l2, u2 = i2 * 8 - n - 1, f2 = (1 << u2) - 1, s2 = f2 >> 1, d = -7, c2 = r3 ? i2 - 1 : 0, y2 = r3 ? -1 : 1, h = e[t + c2];
      for (c2 += y2, o2 = h & (1 << -d) - 1, h >>= -d, d += u2;d > 0; o2 = o2 * 256 + e[t + c2], c2 += y2, d -= 8)
        ;
      for (l2 = o2 & (1 << -d) - 1, o2 >>= -d, d += n;d > 0; l2 = l2 * 256 + e[t + c2], c2 += y2, d -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - s2;
      else {
        if (o2 === f2)
          return l2 ? NaN : (h ? -1 : 1) * (1 / 0);
        l2 = l2 + Math.pow(2, n), o2 = o2 - s2;
      }
      return (h ? -1 : 1) * l2 * Math.pow(2, o2 - n);
    };
    $t.write = function(e, t, r3, n, i2, o2) {
      var l2, u2, f2, s2 = o2 * 8 - i2 - 1, d = (1 << s2) - 1, c2 = d >> 1, y2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = n ? 0 : o2 - 1, p2 = n ? 1 : -1, B2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u2 = isNaN(t) ? 1 : 0, l2 = d) : (l2 = Math.floor(Math.log(t) / Math.LN2), t * (f2 = Math.pow(2, -l2)) < 1 && (l2--, f2 *= 2), l2 + c2 >= 1 ? t += y2 / f2 : t += y2 * Math.pow(2, 1 - c2), t * f2 >= 2 && (l2++, f2 /= 2), l2 + c2 >= d ? (u2 = 0, l2 = d) : l2 + c2 >= 1 ? (u2 = (t * f2 - 1) * Math.pow(2, i2), l2 = l2 + c2) : (u2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i2), l2 = 0));i2 >= 8; e[r3 + h] = u2 & 255, h += p2, u2 /= 256, i2 -= 8)
        ;
      for (l2 = l2 << i2 | u2, s2 += i2;s2 > 0; e[r3 + h] = l2 & 255, h += p2, l2 /= 256, s2 -= 8)
        ;
      e[r3 + h - p2] |= B2 * 128;
    };
  });
  te2 = E((Fe2) => {
    var jt = tn(), Le2 = rn(), nn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Fe2.Buffer = a2;
    Fe2.SlowBuffer = Bl;
    Fe2.INSPECT_MAX_BYTES = 50;
    var it2 = 2147483647;
    Fe2.kMaxLength = it2;
    a2.TYPED_ARRAY_SUPPORT = xl();
    !a2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function xl() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a2.prototype, "parent", { enumerable: true, get: function() {
      if (!!a2.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(a2.prototype, "offset", { enumerable: true, get: function() {
      if (!!a2.isBuffer(this))
        return this.byteOffset;
    } });
    function ee2(e) {
      if (e > it2)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, a2.prototype), t;
    }
    function a2(e, t, r3) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Yt(e);
      }
      return fn(e, t, r3);
    }
    a2.poolSize = 8192;
    function fn(e, t, r3) {
      if (typeof e == "string")
        return Al(e, t);
      if (ArrayBuffer.isView(e))
        return Il(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H2(e, ArrayBuffer) || e && H2(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H2(e, SharedArrayBuffer) || e && H2(e.buffer, SharedArrayBuffer)))
        return Ht(e, t, r3);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return a2.from(n, t, r3);
      let i2 = Tl(e);
      if (i2)
        return i2;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return a2.from(e[Symbol.toPrimitive]("string"), t, r3);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    a2.from = function(e, t, r3) {
      return fn(e, t, r3);
    };
    Object.setPrototypeOf(a2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(a2, Uint8Array);
    function sn(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Rl(e, t, r3) {
      return sn(e), e <= 0 ? ee2(e) : t !== undefined ? typeof r3 == "string" ? ee2(e).fill(t, r3) : ee2(e).fill(t) : ee2(e);
    }
    a2.alloc = function(e, t, r3) {
      return Rl(e, t, r3);
    };
    function Yt(e) {
      return sn(e), ee2(e < 0 ? 0 : Kt(e) | 0);
    }
    a2.allocUnsafe = function(e) {
      return Yt(e);
    };
    a2.allocUnsafeSlow = function(e) {
      return Yt(e);
    };
    function Al(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !a2.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r3 = an(e, t) | 0, n = ee2(r3), i2 = n.write(e, t);
      return i2 !== r3 && (n = n.slice(0, i2)), n;
    }
    function Gt(e) {
      let t = e.length < 0 ? 0 : Kt(e.length) | 0, r3 = ee2(t);
      for (let n = 0;n < t; n += 1)
        r3[n] = e[n] & 255;
      return r3;
    }
    function Il(e) {
      if (H2(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Ht(t.buffer, t.byteOffset, t.byteLength);
      }
      return Gt(e);
    }
    function Ht(e, t, r3) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r3 || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r3 === undefined ? n = new Uint8Array(e) : r3 === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r3), Object.setPrototypeOf(n, a2.prototype), n;
    }
    function Tl(e) {
      if (a2.isBuffer(e)) {
        let t = Kt(e.length) | 0, r3 = ee2(t);
        return r3.length === 0 || e.copy(r3, 0, 0, t), r3;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Xt(e.length) ? ee2(0) : Gt(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Gt(e.data);
    }
    function Kt(e) {
      if (e >= it2)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + it2.toString(16) + " bytes");
      return e | 0;
    }
    function Bl(e) {
      return +e != e && (e = 0), a2.alloc(+e);
    }
    a2.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== a2.prototype;
    };
    a2.compare = function(t, r3) {
      if (H2(t, Uint8Array) && (t = a2.from(t, t.offset, t.byteLength)), H2(r3, Uint8Array) && (r3 = a2.from(r3, r3.offset, r3.byteLength)), !a2.isBuffer(t) || !a2.isBuffer(r3))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r3)
        return 0;
      let n = t.length, i2 = r3.length;
      for (let o2 = 0, l2 = Math.min(n, i2);o2 < l2; ++o2)
        if (t[o2] !== r3[o2]) {
          n = t[o2], i2 = r3[o2];
          break;
        }
      return n < i2 ? -1 : i2 < n ? 1 : 0;
    };
    a2.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    a2.concat = function(t, r3) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return a2.alloc(0);
      let n;
      if (r3 === undefined)
        for (r3 = 0, n = 0;n < t.length; ++n)
          r3 += t[n].length;
      let i2 = a2.allocUnsafe(r3), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let l2 = t[n];
        if (H2(l2, Uint8Array))
          o2 + l2.length > i2.length ? (a2.isBuffer(l2) || (l2 = a2.from(l2)), l2.copy(i2, o2)) : Uint8Array.prototype.set.call(i2, l2, o2);
        else if (a2.isBuffer(l2))
          l2.copy(i2, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += l2.length;
      }
      return i2;
    };
    function an(e, t) {
      if (a2.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H2(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r3 = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r3 === 0)
        return 0;
      let i2 = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r3;
          case "utf8":
          case "utf-8":
            return Vt(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r3 * 2;
          case "hex":
            return r3 >>> 1;
          case "base64":
            return _n(e).length;
          default:
            if (i2)
              return n ? -1 : Vt(e).length;
            t = ("" + t).toLowerCase(), i2 = true;
        }
    }
    a2.byteLength = an;
    function Ll(e, t, r3) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r3 === undefined || r3 > this.length) && (r3 = this.length), r3 <= 0) || (r3 >>>= 0, t >>>= 0, r3 <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return vl(this, t, r3);
          case "utf8":
          case "utf-8":
            return dn(this, t, r3);
          case "ascii":
            return kl(this, t, r3);
          case "latin1":
          case "binary":
            return Ul(this, t, r3);
          case "base64":
            return Dl(this, t, r3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ql(this, t, r3);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    a2.prototype._isBuffer = true;
    function we2(e, t, r3) {
      let n = e[t];
      e[t] = e[r3], e[r3] = n;
    }
    a2.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r3 = 0;r3 < t; r3 += 2)
        we2(this, r3, r3 + 1);
      return this;
    };
    a2.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r3 = 0;r3 < t; r3 += 4)
        we2(this, r3, r3 + 3), we2(this, r3 + 1, r3 + 2);
      return this;
    };
    a2.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r3 = 0;r3 < t; r3 += 8)
        we2(this, r3, r3 + 7), we2(this, r3 + 1, r3 + 6), we2(this, r3 + 2, r3 + 5), we2(this, r3 + 3, r3 + 4);
      return this;
    };
    a2.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? dn(this, 0, t) : Ll.apply(this, arguments);
    };
    a2.prototype.toLocaleString = a2.prototype.toString;
    a2.prototype.equals = function(t) {
      if (!a2.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : a2.compare(this, t) === 0;
    };
    a2.prototype.inspect = function() {
      let t = "", r3 = Fe2.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (t += " ... "), "<Buffer " + t + ">";
    };
    nn && (a2.prototype[nn] = a2.prototype.inspect);
    a2.prototype.compare = function(t, r3, n, i2, o2) {
      if (H2(t, Uint8Array) && (t = a2.from(t, t.offset, t.byteLength)), !a2.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r3 === undefined && (r3 = 0), n === undefined && (n = t ? t.length : 0), i2 === undefined && (i2 = 0), o2 === undefined && (o2 = this.length), r3 < 0 || n > t.length || i2 < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i2 >= o2 && r3 >= n)
        return 0;
      if (i2 >= o2)
        return -1;
      if (r3 >= n)
        return 1;
      if (r3 >>>= 0, n >>>= 0, i2 >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let l2 = o2 - i2, u2 = n - r3, f2 = Math.min(l2, u2), s2 = this.slice(i2, o2), d = t.slice(r3, n);
      for (let c2 = 0;c2 < f2; ++c2)
        if (s2[c2] !== d[c2]) {
          l2 = s2[c2], u2 = d[c2];
          break;
        }
      return l2 < u2 ? -1 : u2 < l2 ? 1 : 0;
    };
    function cn(e, t, r3, n, i2) {
      if (e.length === 0)
        return -1;
      if (typeof r3 == "string" ? (n = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), r3 = +r3, Xt(r3) && (r3 = i2 ? 0 : e.length - 1), r3 < 0 && (r3 = e.length + r3), r3 >= e.length) {
        if (i2)
          return -1;
        r3 = e.length - 1;
      } else if (r3 < 0)
        if (i2)
          r3 = 0;
        else
          return -1;
      if (typeof t == "string" && (t = a2.from(t, n)), a2.isBuffer(t))
        return t.length === 0 ? -1 : on(e, t, r3, n, i2);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e, t, r3) : Uint8Array.prototype.lastIndexOf.call(e, t, r3) : on(e, [t], r3, n, i2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function on(e, t, r3, n, i2) {
      let o2 = 1, l2 = e.length, u2 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, l2 /= 2, u2 /= 2, r3 /= 2;
      }
      function f2(d, c2) {
        return o2 === 1 ? d[c2] : d.readUInt16BE(c2 * o2);
      }
      let s2;
      if (i2) {
        let d = -1;
        for (s2 = r3;s2 < l2; s2++)
          if (f2(e, s2) === f2(t, d === -1 ? 0 : s2 - d)) {
            if (d === -1 && (d = s2), s2 - d + 1 === u2)
              return d * o2;
          } else
            d !== -1 && (s2 -= s2 - d), d = -1;
      } else
        for (r3 + u2 > l2 && (r3 = l2 - u2), s2 = r3;s2 >= 0; s2--) {
          let d = true;
          for (let c2 = 0;c2 < u2; c2++)
            if (f2(e, s2 + c2) !== f2(t, c2)) {
              d = false;
              break;
            }
          if (d)
            return s2;
        }
      return -1;
    }
    a2.prototype.includes = function(t, r3, n) {
      return this.indexOf(t, r3, n) !== -1;
    };
    a2.prototype.indexOf = function(t, r3, n) {
      return cn(this, t, r3, n, true);
    };
    a2.prototype.lastIndexOf = function(t, r3, n) {
      return cn(this, t, r3, n, false);
    };
    function Nl(e, t, r3, n) {
      r3 = Number(r3) || 0;
      let i2 = e.length - r3;
      n ? (n = Number(n), n > i2 && (n = i2)) : n = i2;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let l2;
      for (l2 = 0;l2 < n; ++l2) {
        let u2 = parseInt(t.substr(l2 * 2, 2), 16);
        if (Xt(u2))
          return l2;
        e[r3 + l2] = u2;
      }
      return l2;
    }
    function Fl(e, t, r3, n) {
      return ot(Vt(t, e.length - r3), e, r3, n);
    }
    function Ml(e, t, r3, n) {
      return ot(Gl(t), e, r3, n);
    }
    function Cl(e, t, r3, n) {
      return ot(_n(t), e, r3, n);
    }
    function Ol(e, t, r3, n) {
      return ot(Hl(t, e.length - r3), e, r3, n);
    }
    a2.prototype.write = function(t, r3, n, i2) {
      if (r3 === undefined)
        i2 = "utf8", n = this.length, r3 = 0;
      else if (n === undefined && typeof r3 == "string")
        i2 = r3, n = this.length, r3 = 0;
      else if (isFinite(r3))
        r3 = r3 >>> 0, isFinite(n) ? (n = n >>> 0, i2 === undefined && (i2 = "utf8")) : (i2 = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r3;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r3 < 0) || r3 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i2 || (i2 = "utf8");
      let l2 = false;
      for (;; )
        switch (i2) {
          case "hex":
            return Nl(this, t, r3, n);
          case "utf8":
          case "utf-8":
            return Fl(this, t, r3, n);
          case "ascii":
          case "latin1":
          case "binary":
            return Ml(this, t, r3, n);
          case "base64":
            return Cl(this, t, r3, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ol(this, t, r3, n);
          default:
            if (l2)
              throw new TypeError("Unknown encoding: " + i2);
            i2 = ("" + i2).toLowerCase(), l2 = true;
        }
    };
    a2.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Dl(e, t, r3) {
      return t === 0 && r3 === e.length ? jt.fromByteArray(e) : jt.fromByteArray(e.slice(t, r3));
    }
    function dn(e, t, r3) {
      r3 = Math.min(e.length, r3);
      let n = [], i2 = t;
      for (;i2 < r3; ) {
        let o2 = e[i2], l2 = null, u2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i2 + u2 <= r3) {
          let f2, s2, d, c2;
          switch (u2) {
            case 1:
              o2 < 128 && (l2 = o2);
              break;
            case 2:
              f2 = e[i2 + 1], (f2 & 192) === 128 && (c2 = (o2 & 31) << 6 | f2 & 63, c2 > 127 && (l2 = c2));
              break;
            case 3:
              f2 = e[i2 + 1], s2 = e[i2 + 2], (f2 & 192) === 128 && (s2 & 192) === 128 && (c2 = (o2 & 15) << 12 | (f2 & 63) << 6 | s2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (l2 = c2));
              break;
            case 4:
              f2 = e[i2 + 1], s2 = e[i2 + 2], d = e[i2 + 3], (f2 & 192) === 128 && (s2 & 192) === 128 && (d & 192) === 128 && (c2 = (o2 & 15) << 18 | (f2 & 63) << 12 | (s2 & 63) << 6 | d & 63, c2 > 65535 && c2 < 1114112 && (l2 = c2));
          }
        }
        l2 === null ? (l2 = 65533, u2 = 1) : l2 > 65535 && (l2 -= 65536, n.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | l2 & 1023), n.push(l2), i2 += u2;
      }
      return Pl(n);
    }
    var ln = 4096;
    function Pl(e) {
      let t = e.length;
      if (t <= ln)
        return String.fromCharCode.apply(String, e);
      let r3 = "", n = 0;
      for (;n < t; )
        r3 += String.fromCharCode.apply(String, e.slice(n, n += ln));
      return r3;
    }
    function kl(e, t, r3) {
      let n = "";
      r3 = Math.min(e.length, r3);
      for (let i2 = t;i2 < r3; ++i2)
        n += String.fromCharCode(e[i2] & 127);
      return n;
    }
    function Ul(e, t, r3) {
      let n = "";
      r3 = Math.min(e.length, r3);
      for (let i2 = t;i2 < r3; ++i2)
        n += String.fromCharCode(e[i2]);
      return n;
    }
    function vl(e, t, r3) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r3 || r3 < 0 || r3 > n) && (r3 = n);
      let i2 = "";
      for (let o2 = t;o2 < r3; ++o2)
        i2 += Vl[e[o2]];
      return i2;
    }
    function ql(e, t, r3) {
      let n = e.slice(t, r3), i2 = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i2 += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i2;
    }
    a2.prototype.slice = function(t, r3) {
      let n = this.length;
      t = ~~t, r3 = r3 === undefined ? n : ~~r3, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r3 < 0 ? (r3 += n, r3 < 0 && (r3 = 0)) : r3 > n && (r3 = n), r3 < t && (r3 = t);
      let i2 = this.subarray(t, r3);
      return Object.setPrototypeOf(i2, a2.prototype), i2;
    };
    function F2(e, t, r3) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r3)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a2.prototype.readUintLE = a2.prototype.readUIntLE = function(t, r3, n) {
      t = t >>> 0, r3 = r3 >>> 0, n || F2(t, r3, this.length);
      let i2 = this[t], o2 = 1, l2 = 0;
      for (;++l2 < r3 && (o2 *= 256); )
        i2 += this[t + l2] * o2;
      return i2;
    };
    a2.prototype.readUintBE = a2.prototype.readUIntBE = function(t, r3, n) {
      t = t >>> 0, r3 = r3 >>> 0, n || F2(t, r3, this.length);
      let i2 = this[t + --r3], o2 = 1;
      for (;r3 > 0 && (o2 *= 256); )
        i2 += this[t + --r3] * o2;
      return i2;
    };
    a2.prototype.readUint8 = a2.prototype.readUInt8 = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 1, this.length), this[t];
    };
    a2.prototype.readUint16LE = a2.prototype.readUInt16LE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    a2.prototype.readUint16BE = a2.prototype.readUInt16BE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    a2.prototype.readUint32LE = a2.prototype.readUInt32LE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    a2.prototype.readUint32BE = a2.prototype.readUInt32BE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    a2.prototype.readBigUInt64LE = fe2(function(t) {
      t = t >>> 0, Ne2(t, "offset");
      let r3 = this[t], n = this[t + 7];
      (r3 === undefined || n === undefined) && Ge2(t, this.length - 8);
      let i2 = r3 + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i2) + (BigInt(o2) << BigInt(32));
    });
    a2.prototype.readBigUInt64BE = fe2(function(t) {
      t = t >>> 0, Ne2(t, "offset");
      let r3 = this[t], n = this[t + 7];
      (r3 === undefined || n === undefined) && Ge2(t, this.length - 8);
      let i2 = r3 * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i2) << BigInt(32)) + BigInt(o2);
    });
    a2.prototype.readIntLE = function(t, r3, n) {
      t = t >>> 0, r3 = r3 >>> 0, n || F2(t, r3, this.length);
      let i2 = this[t], o2 = 1, l2 = 0;
      for (;++l2 < r3 && (o2 *= 256); )
        i2 += this[t + l2] * o2;
      return o2 *= 128, i2 >= o2 && (i2 -= Math.pow(2, 8 * r3)), i2;
    };
    a2.prototype.readIntBE = function(t, r3, n) {
      t = t >>> 0, r3 = r3 >>> 0, n || F2(t, r3, this.length);
      let i2 = r3, o2 = 1, l2 = this[t + --i2];
      for (;i2 > 0 && (o2 *= 256); )
        l2 += this[t + --i2] * o2;
      return o2 *= 128, l2 >= o2 && (l2 -= Math.pow(2, 8 * r3)), l2;
    };
    a2.prototype.readInt8 = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    a2.prototype.readInt16LE = function(t, r3) {
      t = t >>> 0, r3 || F2(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a2.prototype.readInt16BE = function(t, r3) {
      t = t >>> 0, r3 || F2(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a2.prototype.readInt32LE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    a2.prototype.readInt32BE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    a2.prototype.readBigInt64LE = fe2(function(t) {
      t = t >>> 0, Ne2(t, "offset");
      let r3 = this[t], n = this[t + 7];
      (r3 === undefined || n === undefined) && Ge2(t, this.length - 8);
      let i2 = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i2) << BigInt(32)) + BigInt(r3 + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    a2.prototype.readBigInt64BE = fe2(function(t) {
      t = t >>> 0, Ne2(t, "offset");
      let r3 = this[t], n = this[t + 7];
      (r3 === undefined || n === undefined) && Ge2(t, this.length - 8);
      let i2 = (r3 << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i2) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    a2.prototype.readFloatLE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 4, this.length), Le2.read(this, t, true, 23, 4);
    };
    a2.prototype.readFloatBE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 4, this.length), Le2.read(this, t, false, 23, 4);
    };
    a2.prototype.readDoubleLE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 8, this.length), Le2.read(this, t, true, 52, 8);
    };
    a2.prototype.readDoubleBE = function(t, r3) {
      return t = t >>> 0, r3 || F2(t, 8, this.length), Le2.read(this, t, false, 52, 8);
    };
    function O2(e, t, r3, n, i2, o2) {
      if (!a2.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i2 || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r3 + n > e.length)
        throw new RangeError("Index out of range");
    }
    a2.prototype.writeUintLE = a2.prototype.writeUIntLE = function(t, r3, n, i2) {
      if (t = +t, r3 = r3 >>> 0, n = n >>> 0, !i2) {
        let u2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r3, n, u2, 0);
      }
      let o2 = 1, l2 = 0;
      for (this[r3] = t & 255;++l2 < n && (o2 *= 256); )
        this[r3 + l2] = t / o2 & 255;
      return r3 + n;
    };
    a2.prototype.writeUintBE = a2.prototype.writeUIntBE = function(t, r3, n, i2) {
      if (t = +t, r3 = r3 >>> 0, n = n >>> 0, !i2) {
        let u2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r3, n, u2, 0);
      }
      let o2 = n - 1, l2 = 1;
      for (this[r3 + o2] = t & 255;--o2 >= 0 && (l2 *= 256); )
        this[r3 + o2] = t / l2 & 255;
      return r3 + n;
    };
    a2.prototype.writeUint8 = a2.prototype.writeUInt8 = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 1, 255, 0), this[r3] = t & 255, r3 + 1;
    };
    a2.prototype.writeUint16LE = a2.prototype.writeUInt16LE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 2, 65535, 0), this[r3] = t & 255, this[r3 + 1] = t >>> 8, r3 + 2;
    };
    a2.prototype.writeUint16BE = a2.prototype.writeUInt16BE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 2, 65535, 0), this[r3] = t >>> 8, this[r3 + 1] = t & 255, r3 + 2;
    };
    a2.prototype.writeUint32LE = a2.prototype.writeUInt32LE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 4, 4294967295, 0), this[r3 + 3] = t >>> 24, this[r3 + 2] = t >>> 16, this[r3 + 1] = t >>> 8, this[r3] = t & 255, r3 + 4;
    };
    a2.prototype.writeUint32BE = a2.prototype.writeUInt32BE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 4, 4294967295, 0), this[r3] = t >>> 24, this[r3 + 1] = t >>> 16, this[r3 + 2] = t >>> 8, this[r3 + 3] = t & 255, r3 + 4;
    };
    function hn(e, t, r3, n, i2) {
      gn(t, n, i2, e, r3, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r3++] = o2, o2 = o2 >> 8, e[r3++] = o2, o2 = o2 >> 8, e[r3++] = o2, o2 = o2 >> 8, e[r3++] = o2;
      let l2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r3++] = l2, l2 = l2 >> 8, e[r3++] = l2, l2 = l2 >> 8, e[r3++] = l2, l2 = l2 >> 8, e[r3++] = l2, r3;
    }
    function pn(e, t, r3, n, i2) {
      gn(t, n, i2, e, r3, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r3 + 7] = o2, o2 = o2 >> 8, e[r3 + 6] = o2, o2 = o2 >> 8, e[r3 + 5] = o2, o2 = o2 >> 8, e[r3 + 4] = o2;
      let l2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r3 + 3] = l2, l2 = l2 >> 8, e[r3 + 2] = l2, l2 = l2 >> 8, e[r3 + 1] = l2, l2 = l2 >> 8, e[r3] = l2, r3 + 8;
    }
    a2.prototype.writeBigUInt64LE = fe2(function(t, r3 = 0) {
      return hn(this, t, r3, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a2.prototype.writeBigUInt64BE = fe2(function(t, r3 = 0) {
      return pn(this, t, r3, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a2.prototype.writeIntLE = function(t, r3, n, i2) {
      if (t = +t, r3 = r3 >>> 0, !i2) {
        let f2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r3, n, f2 - 1, -f2);
      }
      let o2 = 0, l2 = 1, u2 = 0;
      for (this[r3] = t & 255;++o2 < n && (l2 *= 256); )
        t < 0 && u2 === 0 && this[r3 + o2 - 1] !== 0 && (u2 = 1), this[r3 + o2] = (t / l2 >> 0) - u2 & 255;
      return r3 + n;
    };
    a2.prototype.writeIntBE = function(t, r3, n, i2) {
      if (t = +t, r3 = r3 >>> 0, !i2) {
        let f2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r3, n, f2 - 1, -f2);
      }
      let o2 = n - 1, l2 = 1, u2 = 0;
      for (this[r3 + o2] = t & 255;--o2 >= 0 && (l2 *= 256); )
        t < 0 && u2 === 0 && this[r3 + o2 + 1] !== 0 && (u2 = 1), this[r3 + o2] = (t / l2 >> 0) - u2 & 255;
      return r3 + n;
    };
    a2.prototype.writeInt8 = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r3] = t & 255, r3 + 1;
    };
    a2.prototype.writeInt16LE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 2, 32767, -32768), this[r3] = t & 255, this[r3 + 1] = t >>> 8, r3 + 2;
    };
    a2.prototype.writeInt16BE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 2, 32767, -32768), this[r3] = t >>> 8, this[r3 + 1] = t & 255, r3 + 2;
    };
    a2.prototype.writeInt32LE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 4, 2147483647, -2147483648), this[r3] = t & 255, this[r3 + 1] = t >>> 8, this[r3 + 2] = t >>> 16, this[r3 + 3] = t >>> 24, r3 + 4;
    };
    a2.prototype.writeInt32BE = function(t, r3, n) {
      return t = +t, r3 = r3 >>> 0, n || O2(this, t, r3, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r3] = t >>> 24, this[r3 + 1] = t >>> 16, this[r3 + 2] = t >>> 8, this[r3 + 3] = t & 255, r3 + 4;
    };
    a2.prototype.writeBigInt64LE = fe2(function(t, r3 = 0) {
      return hn(this, t, r3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    a2.prototype.writeBigInt64BE = fe2(function(t, r3 = 0) {
      return pn(this, t, r3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function yn(e, t, r3, n, i2, o2) {
      if (r3 + n > e.length)
        throw new RangeError("Index out of range");
      if (r3 < 0)
        throw new RangeError("Index out of range");
    }
    function wn(e, t, r3, n, i2) {
      return t = +t, r3 = r3 >>> 0, i2 || yn(e, t, r3, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Le2.write(e, t, r3, n, 23, 4), r3 + 4;
    }
    a2.prototype.writeFloatLE = function(t, r3, n) {
      return wn(this, t, r3, true, n);
    };
    a2.prototype.writeFloatBE = function(t, r3, n) {
      return wn(this, t, r3, false, n);
    };
    function bn(e, t, r3, n, i2) {
      return t = +t, r3 = r3 >>> 0, i2 || yn(e, t, r3, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Le2.write(e, t, r3, n, 52, 8), r3 + 8;
    }
    a2.prototype.writeDoubleLE = function(t, r3, n) {
      return bn(this, t, r3, true, n);
    };
    a2.prototype.writeDoubleBE = function(t, r3, n) {
      return bn(this, t, r3, false, n);
    };
    a2.prototype.copy = function(t, r3, n, i2) {
      if (!a2.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i2 && i2 !== 0 && (i2 = this.length), r3 >= t.length && (r3 = t.length), r3 || (r3 = 0), i2 > 0 && i2 < n && (i2 = n), i2 === n || t.length === 0 || this.length === 0)
        return 0;
      if (r3 < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      i2 > this.length && (i2 = this.length), t.length - r3 < i2 - n && (i2 = t.length - r3 + n);
      let o2 = i2 - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r3, n, i2) : Uint8Array.prototype.set.call(t, this.subarray(n, i2), r3), o2;
    };
    a2.prototype.fill = function(t, r3, n, i2) {
      if (typeof t == "string") {
        if (typeof r3 == "string" ? (i2 = r3, r3 = 0, n = this.length) : typeof n == "string" && (i2 = n, n = this.length), i2 !== undefined && typeof i2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i2 == "string" && !a2.isEncoding(i2))
          throw new TypeError("Unknown encoding: " + i2);
        if (t.length === 1) {
          let l2 = t.charCodeAt(0);
          (i2 === "utf8" && l2 < 128 || i2 === "latin1") && (t = l2);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r3 < 0 || this.length < r3 || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r3)
        return this;
      r3 = r3 >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r3;o2 < n; ++o2)
          this[o2] = t;
      else {
        let l2 = a2.isBuffer(t) ? t : a2.from(t, i2), u2 = l2.length;
        if (u2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r3; ++o2)
          this[o2 + r3] = l2[o2 % u2];
      }
      return this;
    };
    var Be2 = {};
    function zt(e, t, r3) {
      Be2[e] = class extends r3 {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i2) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i2, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    zt("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    zt("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", function(e, t, r3) {
      let n = `The value of "${e}" is out of range.`, i2 = r3;
      return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i2 = un(String(r3)) : typeof r3 == "bigint" && (i2 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i2 = un(i2)), i2 += "n"), n += ` It must be ${t}. Received ${i2}`, n;
    }, RangeError);
    function un(e) {
      let t = "", r3 = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r3 >= n + 4; r3 -= 3)
        t = `_${e.slice(r3 - 3, r3)}${t}`;
      return `${e.slice(0, r3)}${t}`;
    }
    function Wl(e, t, r3) {
      Ne2(t, "offset"), (e[t] === undefined || e[t + r3] === undefined) && Ge2(t, e.length - (r3 + 1));
    }
    function gn(e, t, r3, n, i2, o2) {
      if (e > r3 || e < t) {
        let l2 = typeof t == "bigint" ? "n" : "", u2;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? u2 = `>= 0${l2} and < 2${l2} ** ${(o2 + 1) * 8}${l2}` : u2 = `>= -(2${l2} ** ${(o2 + 1) * 8 - 1}${l2}) and < 2 ** ${(o2 + 1) * 8 - 1}${l2}` : u2 = `>= ${t}${l2} and <= ${r3}${l2}`, new Be2.ERR_OUT_OF_RANGE("value", u2, e);
      }
      Wl(n, i2, o2);
    }
    function Ne2(e, t) {
      if (typeof e != "number")
        throw new Be2.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ge2(e, t, r3) {
      throw Math.floor(e) !== e ? (Ne2(e, r3), new Be2.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e)) : t < 0 ? new Be2.ERR_BUFFER_OUT_OF_BOUNDS : new Be2.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t}`, e);
    }
    var $l = /[^+/0-9A-Za-z-_]/g;
    function jl(e) {
      if (e = e.split("=")[0], e = e.trim().replace($l, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Vt(e, t) {
      t = t || 1 / 0;
      let r3, n = e.length, i2 = null, o2 = [];
      for (let l2 = 0;l2 < n; ++l2) {
        if (r3 = e.charCodeAt(l2), r3 > 55295 && r3 < 57344) {
          if (!i2) {
            if (r3 > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (l2 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i2 = r3;
            continue;
          }
          if (r3 < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i2 = r3;
            continue;
          }
          r3 = (i2 - 55296 << 10 | r3 - 56320) + 65536;
        } else
          i2 && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i2 = null, r3 < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r3);
        } else if (r3 < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r3 >> 6 | 192, r3 & 63 | 128);
        } else if (r3 < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, r3 & 63 | 128);
        } else if (r3 < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, r3 & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function Gl(e) {
      let t = [];
      for (let r3 = 0;r3 < e.length; ++r3)
        t.push(e.charCodeAt(r3) & 255);
      return t;
    }
    function Hl(e, t) {
      let r3, n, i2, o2 = [];
      for (let l2 = 0;l2 < e.length && !((t -= 2) < 0); ++l2)
        r3 = e.charCodeAt(l2), n = r3 >> 8, i2 = r3 % 256, o2.push(i2), o2.push(n);
      return o2;
    }
    function _n(e) {
      return jt.toByteArray(jl(e));
    }
    function ot(e, t, r3, n) {
      let i2;
      for (i2 = 0;i2 < n && !(i2 + r3 >= t.length || i2 >= e.length); ++i2)
        t[i2 + r3] = e[i2];
      return i2;
    }
    function H2(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Xt(e) {
      return e !== e;
    }
    var Vl = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r3 = 0;r3 < 16; ++r3) {
        let n = r3 * 16;
        for (let i2 = 0;i2 < 16; ++i2)
          t[n + i2] = e[r3] + e[i2];
      }
      return t;
    }();
    function fe2(e) {
      return typeof BigInt > "u" ? Yl : e;
    }
    function Yl() {
      throw new Error("BigInt not supported");
    }
  });
  I2 = E((Gc, En) => {
    En.exports = { ArrayIsArray(e) {
      return Array.isArray(e);
    }, ArrayPrototypeIncludes(e, t) {
      return e.includes(t);
    }, ArrayPrototypeIndexOf(e, t) {
      return e.indexOf(t);
    }, ArrayPrototypeJoin(e, t) {
      return e.join(t);
    }, ArrayPrototypeMap(e, t) {
      return e.map(t);
    }, ArrayPrototypePop(e, t) {
      return e.pop(t);
    }, ArrayPrototypePush(e, t) {
      return e.push(t);
    }, ArrayPrototypeSlice(e, t, r3) {
      return e.slice(t, r3);
    }, Error, FunctionPrototypeCall(e, t, ...r3) {
      return e.call(t, ...r3);
    }, FunctionPrototypeSymbolHasInstance(e, t) {
      return Function.prototype[Symbol.hasInstance].call(e, t);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(e, t) {
      return Object.defineProperties(e, t);
    }, ObjectDefineProperty(e, t, r3) {
      return Object.defineProperty(e, t, r3);
    }, ObjectGetOwnPropertyDescriptor(e, t) {
      return Object.getOwnPropertyDescriptor(e, t);
    }, ObjectKeys(e) {
      return Object.keys(e);
    }, ObjectSetPrototypeOf(e, t) {
      return Object.setPrototypeOf(e, t);
    }, Promise, PromisePrototypeCatch(e, t) {
      return e.catch(t);
    }, PromisePrototypeThen(e, t, r3) {
      return e.then(t, r3);
    }, PromiseReject(e) {
      return Promise.reject(e);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(e, t) {
      return e.test(t);
    }, SafeSet: Set, String, StringPrototypeSlice(e, t, r3) {
      return e.slice(t, r3);
    }, StringPrototypeToLowerCase(e) {
      return e.toLowerCase();
    }, StringPrototypeToUpperCase(e) {
      return e.toUpperCase();
    }, StringPrototypeTrim(e) {
      return e.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(e, t, r3) {
      return e.set(t, r3);
    }, Uint8Array };
  });
  V2 = E((Hc, Qt) => {
    var Kl = te2(), zl = Object.getPrototypeOf(async function() {
    }).constructor, Sn = globalThis.Blob || Kl.Blob, Xl = typeof Sn < "u" ? function(t) {
      return t instanceof Sn;
    } : function(t) {
      return false;
    }, Jt = class extends Error {
      constructor(t) {
        if (!Array.isArray(t))
          throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
        let r3 = "";
        for (let n = 0;n < t.length; n++)
          r3 += `    ${t[n].stack}
`;
        super(r3), this.name = "AggregateError", this.errors = t;
      }
    };
    Qt.exports = { AggregateError: Jt, kEmptyObject: Object.freeze({}), once(e) {
      let t = false;
      return function(...r3) {
        t || (t = true, e.apply(this, r3));
      };
    }, createDeferredPromise: function() {
      let e, t;
      return { promise: new Promise((n, i2) => {
        e = n, t = i2;
      }), resolve: e, reject: t };
    }, promisify(e) {
      return new Promise((t, r3) => {
        e((n, ...i2) => n ? r3(n) : t(...i2));
      });
    }, debuglog() {
      return function() {
      };
    }, format(e, ...t) {
      return e.replace(/%([sdifj])/g, function(...[r3, n]) {
        let i2 = t.shift();
        return n === "f" ? i2.toFixed(6) : n === "j" ? JSON.stringify(i2) : n === "s" && typeof i2 == "object" ? `${i2.constructor !== Object ? i2.constructor.name : ""} {}`.trim() : i2.toString();
      });
    }, inspect(e) {
      switch (typeof e) {
        case "string":
          if (e.includes("'"))
            if (e.includes('"')) {
              if (!e.includes("`") && !e.includes("${"))
                return `\`${e}\``;
            } else
              return `"${e}"`;
          return `'${e}'`;
        case "number":
          return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
        case "bigint":
          return `${String(e)}n`;
        case "boolean":
        case "undefined":
          return String(e);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(e) {
      return e instanceof zl;
    }, isArrayBufferView(e) {
      return ArrayBuffer.isView(e);
    } }, isBlob: Xl };
    Qt.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  ut2 = E((Vc, lt2) => {
    var { AbortController: mn, AbortSignal: Jl } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    lt2.exports = mn;
    lt2.exports.AbortSignal = Jl;
    lt2.exports.default = mn;
  });
  C2 = E((Yc, An) => {
    var { format: Ql, inspect: ft, AggregateError: Zl } = V2(), eu = globalThis.AggregateError || Zl, tu = Symbol("kIsNodeError"), ru = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], nu = /^([A-Z][a-z0-9]*)+$/, iu = "__node_internal_", st2 = {};
    function be2(e, t) {
      if (!e)
        throw new st2.ERR_INTERNAL_ASSERTION(t);
    }
    function xn(e) {
      let t = "", r3 = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r3 >= n + 4; r3 -= 3)
        t = `_${e.slice(r3 - 3, r3)}${t}`;
      return `${e.slice(0, r3)}${t}`;
    }
    function ou(e, t, r3) {
      if (typeof t == "function")
        return be2(t.length <= r3.length, `Code: ${e}; The provided arguments length (${r3.length}) does not match the required ones (${t.length}).`), t(...r3);
      let n = (t.match(/%[dfijoOs]/g) || []).length;
      return be2(n === r3.length, `Code: ${e}; The provided arguments length (${r3.length}) does not match the required ones (${n}).`), r3.length === 0 ? t : Ql(t, ...r3);
    }
    function M2(e, t, r3) {
      r3 || (r3 = Error);

      class n extends r3 {
        constructor(...o2) {
          super(ou(e, t, o2));
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      }
      Object.defineProperties(n.prototype, { name: { value: r3.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${e}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), n.prototype.code = e, n.prototype[tu] = true, st2[e] = n;
    }
    function Rn(e) {
      let t = iu + e.name;
      return Object.defineProperty(e, "name", { value: t }), e;
    }
    function lu(e, t) {
      if (e && t && e !== t) {
        if (Array.isArray(t.errors))
          return t.errors.push(e), t;
        let r3 = new eu([t, e], t.message);
        return r3.code = t.code, r3;
      }
      return e || t;
    }
    var Zt = class extends Error {
      constructor(t = "The operation was aborted", r3 = undefined) {
        if (r3 !== undefined && typeof r3 != "object")
          throw new st2.ERR_INVALID_ARG_TYPE("options", "Object", r3);
        super(t, r3), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    M2("ERR_ASSERTION", "%s", Error);
    M2("ERR_INVALID_ARG_TYPE", (e, t, r3) => {
      be2(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
      let n = "The ";
      e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
      let i2 = [], o2 = [], l2 = [];
      for (let f2 of t)
        be2(typeof f2 == "string", "All expected entries have to be of type string"), ru.includes(f2) ? i2.push(f2.toLowerCase()) : nu.test(f2) ? o2.push(f2) : (be2(f2 !== "object", 'The value "object" should be written as "Object"'), l2.push(f2));
      if (o2.length > 0) {
        let f2 = i2.indexOf("object");
        f2 !== -1 && (i2.splice(i2, f2, 1), o2.push("Object"));
      }
      if (i2.length > 0) {
        switch (i2.length) {
          case 1:
            n += `of type ${i2[0]}`;
            break;
          case 2:
            n += `one of type ${i2[0]} or ${i2[1]}`;
            break;
          default: {
            let f2 = i2.pop();
            n += `one of type ${i2.join(", ")}, or ${f2}`;
          }
        }
        (o2.length > 0 || l2.length > 0) && (n += " or ");
      }
      if (o2.length > 0) {
        switch (o2.length) {
          case 1:
            n += `an instance of ${o2[0]}`;
            break;
          case 2:
            n += `an instance of ${o2[0]} or ${o2[1]}`;
            break;
          default: {
            let f2 = o2.pop();
            n += `an instance of ${o2.join(", ")}, or ${f2}`;
          }
        }
        l2.length > 0 && (n += " or ");
      }
      switch (l2.length) {
        case 0:
          break;
        case 1:
          l2[0].toLowerCase() !== l2[0] && (n += "an "), n += `${l2[0]}`;
          break;
        case 2:
          n += `one of ${l2[0]} or ${l2[1]}`;
          break;
        default: {
          let f2 = l2.pop();
          n += `one of ${l2.join(", ")}, or ${f2}`;
        }
      }
      if (r3 == null)
        n += `. Received ${r3}`;
      else if (typeof r3 == "function" && r3.name)
        n += `. Received function ${r3.name}`;
      else if (typeof r3 == "object") {
        var u2;
        (u2 = r3.constructor) !== null && u2 !== undefined && u2.name ? n += `. Received an instance of ${r3.constructor.name}` : n += `. Received ${ft(r3, { depth: -1 })}`;
      } else {
        let f2 = ft(r3, { colors: false });
        f2.length > 25 && (f2 = `${f2.slice(0, 25)}...`), n += `. Received type ${typeof r3} (${f2})`;
      }
      return n;
    }, TypeError);
    M2("ERR_INVALID_ARG_VALUE", (e, t, r3 = "is invalid") => {
      let n = ft(t);
      return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r3}. Received ${n}`;
    }, TypeError);
    M2("ERR_INVALID_RETURN_VALUE", (e, t, r3) => {
      var n;
      let i2 = r3 != null && (n = r3.constructor) !== null && n !== undefined && n.name ? `instance of ${r3.constructor.name}` : `type ${typeof r3}`;
      return `Expected ${e} to be returned from the "${t}" function but got ${i2}.`;
    }, TypeError);
    M2("ERR_MISSING_ARGS", (...e) => {
      be2(e.length > 0, "At least one arg needs to be specified");
      let t, r3 = e.length;
      switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r3) {
        case 1:
          t += `The ${e[0]} argument`;
          break;
        case 2:
          t += `The ${e[0]} and ${e[1]} arguments`;
          break;
        default:
          {
            let n = e.pop();
            t += `The ${e.join(", ")}, and ${n} arguments`;
          }
          break;
      }
      return `${t} must be specified`;
    }, TypeError);
    M2("ERR_OUT_OF_RANGE", (e, t, r3) => {
      be2(t, 'Missing "range" argument');
      let n;
      return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? n = xn(String(r3)) : typeof r3 == "bigint" ? (n = String(r3), (r3 > 2n ** 32n || r3 < -(2n ** 32n)) && (n = xn(n)), n += "n") : n = ft(r3), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
    }, RangeError);
    M2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    M2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    M2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    M2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    M2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    M2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    M2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    M2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    M2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    M2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    M2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    An.exports = { AbortError: Zt, aggregateTwoErrors: Rn(lu), hideStackFrames: Rn, codes: st2 };
  });
  He2 = E((Kc, Cn) => {
    var { ArrayIsArray: Bn, ArrayPrototypeIncludes: Ln, ArrayPrototypeJoin: Nn, ArrayPrototypeMap: uu, NumberIsInteger: tr, NumberIsNaN: fu, NumberMAX_SAFE_INTEGER: su, NumberMIN_SAFE_INTEGER: au, NumberParseInt: cu, ObjectPrototypeHasOwnProperty: du, RegExpPrototypeExec: hu, String: pu, StringPrototypeToUpperCase: yu, StringPrototypeTrim: wu } = I2(), { hideStackFrames: W2, codes: { ERR_SOCKET_BAD_PORT: bu, ERR_INVALID_ARG_TYPE: D2, ERR_INVALID_ARG_VALUE: at2, ERR_OUT_OF_RANGE: ge2, ERR_UNKNOWN_SIGNAL: In } } = C2(), { normalizeEncoding: gu } = V2(), { isAsyncFunction: _u, isArrayBufferView: Eu } = V2().types, Tn = {};
    function Su(e) {
      return e === (e | 0);
    }
    function mu(e) {
      return e === e >>> 0;
    }
    var xu = /^[0-7]+$/, Ru = "must be a 32-bit unsigned integer or an octal string";
    function Au(e, t, r3) {
      if (typeof e > "u" && (e = r3), typeof e == "string") {
        if (hu(xu, e) === null)
          throw new at2(t, e, Ru);
        e = cu(e, 8);
      }
      return Fn(e, t), e;
    }
    var Iu = W2((e, t, r3 = au, n = su) => {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (!tr(e))
        throw new ge2(t, "an integer", e);
      if (e < r3 || e > n)
        throw new ge2(t, `>= ${r3} && <= ${n}`, e);
    }), Tu = W2((e, t, r3 = -2147483648, n = 2147483647) => {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (!tr(e))
        throw new ge2(t, "an integer", e);
      if (e < r3 || e > n)
        throw new ge2(t, `>= ${r3} && <= ${n}`, e);
    }), Fn = W2((e, t, r3 = false) => {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (!tr(e))
        throw new ge2(t, "an integer", e);
      let n = r3 ? 1 : 0, i2 = 4294967295;
      if (e < n || e > i2)
        throw new ge2(t, `>= ${n} && <= ${i2}`, e);
    });
    function Mn(e, t) {
      if (typeof e != "string")
        throw new D2(t, "string", e);
    }
    function Bu(e, t, r3 = undefined, n) {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (r3 != null && e < r3 || n != null && e > n || (r3 != null || n != null) && fu(e))
        throw new ge2(t, `${r3 != null ? `>= ${r3}` : ""}${r3 != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`, e);
    }
    var Lu = W2((e, t, r3) => {
      if (!Ln(r3, e)) {
        let n = Nn(uu(r3, (o2) => typeof o2 == "string" ? `'${o2}'` : pu(o2)), ", "), i2 = "must be one of: " + n;
        throw new at2(t, e, i2);
      }
    });
    function Nu(e, t) {
      if (typeof e != "boolean")
        throw new D2(t, "boolean", e);
    }
    function er(e, t, r3) {
      return e == null || !du(e, t) ? r3 : e[t];
    }
    var Fu = W2((e, t, r3 = null) => {
      let n = er(r3, "allowArray", false), i2 = er(r3, "allowFunction", false);
      if (!er(r3, "nullable", false) && e === null || !n && Bn(e) || typeof e != "object" && (!i2 || typeof e != "function"))
        throw new D2(t, "Object", e);
    }), Mu = W2((e, t, r3 = 0) => {
      if (!Bn(e))
        throw new D2(t, "Array", e);
      if (e.length < r3) {
        let n = `must be longer than ${r3}`;
        throw new at2(t, e, n);
      }
    });
    function Cu(e, t = "signal") {
      if (Mn(e, t), Tn[e] === undefined)
        throw Tn[yu(e)] !== undefined ? new In(e + " (signals must use all capital letters)") : new In(e);
    }
    var Ou = W2((e, t = "buffer") => {
      if (!Eu(e))
        throw new D2(t, ["Buffer", "TypedArray", "DataView"], e);
    });
    function Du(e, t) {
      let r3 = gu(t), n = e.length;
      if (r3 === "hex" && n % 2 !== 0)
        throw new at2("encoding", t, `is invalid for data of length ${n}`);
    }
    function Pu(e, t = "Port", r3 = true) {
      if (typeof e != "number" && typeof e != "string" || typeof e == "string" && wu(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r3)
        throw new bu(t, e, r3);
      return e | 0;
    }
    var ku = W2((e, t) => {
      if (e !== undefined && (e === null || typeof e != "object" || !("aborted" in e)))
        throw new D2(t, "AbortSignal", e);
    }), Uu = W2((e, t) => {
      if (typeof e != "function")
        throw new D2(t, "Function", e);
    }), vu = W2((e, t) => {
      if (typeof e != "function" || _u(e))
        throw new D2(t, "Function", e);
    }), qu = W2((e, t) => {
      if (e !== undefined)
        throw new D2(t, "undefined", e);
    });
    function Wu(e, t, r3) {
      if (!Ln(r3, e))
        throw new D2(t, `('${Nn(r3, "|")}')`, e);
    }
    Cn.exports = { isInt32: Su, isUint32: mu, parseFileMode: Au, validateArray: Mu, validateBoolean: Nu, validateBuffer: Ou, validateEncoding: Du, validateFunction: Uu, validateInt32: Tu, validateInteger: Iu, validateNumber: Bu, validateObject: Fu, validateOneOf: Lu, validatePlainFunction: vu, validatePort: Pu, validateSignalName: Cu, validateString: Mn, validateUint32: Fn, validateUndefined: qu, validateUnion: Wu, validateAbortSignal: ku };
  });
  ir = E((zc, kn) => {
    var x2 = kn.exports = {}, Y2, K2;
    function rr() {
      throw new Error("setTimeout has not been defined");
    }
    function nr() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Y2 = setTimeout : Y2 = rr;
      } catch {
        Y2 = rr;
      }
      try {
        typeof clearTimeout == "function" ? K2 = clearTimeout : K2 = nr;
      } catch {
        K2 = nr;
      }
    })();
    function On(e) {
      if (Y2 === setTimeout)
        return setTimeout(e, 0);
      if ((Y2 === rr || !Y2) && setTimeout)
        return Y2 = setTimeout, setTimeout(e, 0);
      try {
        return Y2(e, 0);
      } catch {
        try {
          return Y2.call(null, e, 0);
        } catch {
          return Y2.call(this, e, 0);
        }
      }
    }
    function $u(e) {
      if (K2 === clearTimeout)
        return clearTimeout(e);
      if ((K2 === nr || !K2) && clearTimeout)
        return K2 = clearTimeout, clearTimeout(e);
      try {
        return K2(e);
      } catch {
        try {
          return K2.call(null, e);
        } catch {
          return K2.call(this, e);
        }
      }
    }
    var re2 = [], Me2 = false, _e2, ct2 = -1;
    function ju() {
      !Me2 || !_e2 || (Me2 = false, _e2.length ? re2 = _e2.concat(re2) : ct2 = -1, re2.length && Dn());
    }
    function Dn() {
      if (!Me2) {
        var e = On(ju);
        Me2 = true;
        for (var t = re2.length;t; ) {
          for (_e2 = re2, re2 = [];++ct2 < t; )
            _e2 && _e2[ct2].run();
          ct2 = -1, t = re2.length;
        }
        _e2 = null, Me2 = false, $u(e);
      }
    }
    x2.nextTick = function(e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r3 = 1;r3 < arguments.length; r3++)
          t[r3 - 1] = arguments[r3];
      re2.push(new Pn(e, t)), re2.length === 1 && !Me2 && On(Dn);
    };
    function Pn(e, t) {
      this.fun = e, this.array = t;
    }
    Pn.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    x2.title = "browser";
    x2.browser = true;
    x2.env = {};
    x2.argv = [];
    x2.version = "";
    x2.versions = {};
    function ne2() {
    }
    x2.on = ne2;
    x2.addListener = ne2;
    x2.once = ne2;
    x2.off = ne2;
    x2.removeListener = ne2;
    x2.removeAllListeners = ne2;
    x2.emit = ne2;
    x2.prependListener = ne2;
    x2.prependOnceListener = ne2;
    x2.listeners = function(e) {
      return [];
    };
    x2.binding = function(e) {
      throw new Error("process.binding is not supported");
    };
    x2.cwd = function() {
      return "/";
    };
    x2.chdir = function(e) {
      throw new Error("process.chdir is not supported");
    };
    x2.umask = function() {
      return 0;
    };
  });
  k2 = {};
  Qr(k2, { default: () => Gu });
  se2 = yl(() => {
    ue2(k2, rt2(ir()));
    Gu = rt2(ir());
  });
  ae2 = E((Jc, zn) => {
    var { Symbol: dt2, SymbolAsyncIterator: Un, SymbolIterator: vn } = I2(), qn = dt2("kDestroyed"), Wn = dt2("kIsErrored"), or = dt2("kIsReadable"), $n = dt2("kIsDisturbed");
    function ht2(e, t = false) {
      var r3;
      return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r3 = e._readableState) === null || r3 === undefined ? undefined : r3.readable) !== false) && (!e._writableState || e._readableState));
    }
    function pt2(e) {
      var t;
      return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === undefined ? undefined : t.writable) !== false));
    }
    function Hu(e) {
      return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Ee2(e) {
      return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function Vu(e, t) {
      return e == null ? false : t === true ? typeof e[Un] == "function" : t === false ? typeof e[vn] == "function" : typeof e[Un] == "function" || typeof e[vn] == "function";
    }
    function yt(e) {
      if (!Ee2(e))
        return null;
      let { _writableState: t, _readableState: r3 } = e, n = t || r3;
      return !!(e.destroyed || e[qn] || n != null && n.destroyed);
    }
    function jn(e) {
      if (!pt2(e))
        return null;
      if (e.writableEnded === true)
        return true;
      let t = e._writableState;
      return t != null && t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Yu(e, t) {
      if (!pt2(e))
        return null;
      if (e.writableFinished === true)
        return true;
      let r3 = e._writableState;
      return r3 != null && r3.errored ? false : typeof r3?.finished != "boolean" ? null : !!(r3.finished || t === false && r3.ended === true && r3.length === 0);
    }
    function Ku(e) {
      if (!ht2(e))
        return null;
      if (e.readableEnded === true)
        return true;
      let t = e._readableState;
      return !t || t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Gn(e, t) {
      if (!ht2(e))
        return null;
      let r3 = e._readableState;
      return r3 != null && r3.errored ? false : typeof r3?.endEmitted != "boolean" ? null : !!(r3.endEmitted || t === false && r3.ended === true && r3.length === 0);
    }
    function Hn(e) {
      return e && e[or] != null ? e[or] : typeof e?.readable != "boolean" ? null : yt(e) ? false : ht2(e) && e.readable && !Gn(e);
    }
    function Vn(e) {
      return typeof e?.writable != "boolean" ? null : yt(e) ? false : pt2(e) && e.writable && !jn(e);
    }
    function zu(e, t) {
      return Ee2(e) ? yt(e) ? true : !(t?.readable !== false && Hn(e) || t?.writable !== false && Vn(e)) : null;
    }
    function Xu(e) {
      var t, r3;
      return Ee2(e) ? e.writableErrored ? e.writableErrored : (t = (r3 = e._writableState) === null || r3 === undefined ? undefined : r3.errored) !== null && t !== undefined ? t : null : null;
    }
    function Ju(e) {
      var t, r3;
      return Ee2(e) ? e.readableErrored ? e.readableErrored : (t = (r3 = e._readableState) === null || r3 === undefined ? undefined : r3.errored) !== null && t !== undefined ? t : null : null;
    }
    function Qu(e) {
      if (!Ee2(e))
        return null;
      if (typeof e.closed == "boolean")
        return e.closed;
      let { _writableState: t, _readableState: r3 } = e;
      return typeof t?.closed == "boolean" || typeof r3?.closed == "boolean" ? t?.closed || r3?.closed : typeof e._closed == "boolean" && Yn(e) ? e._closed : null;
    }
    function Yn(e) {
      return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function Kn(e) {
      return typeof e._sent100 == "boolean" && Yn(e);
    }
    function Zu(e) {
      var t;
      return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === undefined ? undefined : t.upgradeOrConnect) === undefined;
    }
    function ef(e) {
      if (!Ee2(e))
        return null;
      let { _writableState: t, _readableState: r3 } = e, n = t || r3;
      return !n && Kn(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === false);
    }
    function tf(e) {
      var t;
      return !!(e && ((t = e[$n]) !== null && t !== undefined ? t : e.readableDidRead || e.readableAborted));
    }
    function rf(e) {
      var t, r3, n, i2, o2, l2, u2, f2, s2, d;
      return !!(e && ((t = (r3 = (n = (i2 = (o2 = (l2 = e[Wn]) !== null && l2 !== undefined ? l2 : e.readableErrored) !== null && o2 !== undefined ? o2 : e.writableErrored) !== null && i2 !== undefined ? i2 : (u2 = e._readableState) === null || u2 === undefined ? undefined : u2.errorEmitted) !== null && n !== undefined ? n : (f2 = e._writableState) === null || f2 === undefined ? undefined : f2.errorEmitted) !== null && r3 !== undefined ? r3 : (s2 = e._readableState) === null || s2 === undefined ? undefined : s2.errored) !== null && t !== undefined ? t : (d = e._writableState) === null || d === undefined ? undefined : d.errored));
    }
    zn.exports = { kDestroyed: qn, isDisturbed: tf, kIsDisturbed: $n, isErrored: rf, kIsErrored: Wn, isReadable: Hn, kIsReadable: or, isClosed: Qu, isDestroyed: yt, isDuplexNodeStream: Hu, isFinished: zu, isIterable: Vu, isReadableNodeStream: ht2, isReadableEnded: Ku, isReadableFinished: Gn, isReadableErrored: Ju, isNodeStream: Ee2, isWritable: Vn, isWritableNodeStream: pt2, isWritableEnded: jn, isWritableFinished: Yu, isWritableErrored: Xu, isServerRequest: Zu, isServerResponse: Kn, willEmitClose: ef };
  });
  ce2 = E((Qc, ur) => {
    var Ce2 = (se2(), pe(k2)), { AbortError: nf, codes: of } = C2(), { ERR_INVALID_ARG_TYPE: lf, ERR_STREAM_PREMATURE_CLOSE: Xn } = of, { kEmptyObject: Jn, once: Qn } = V2(), { validateAbortSignal: uf, validateFunction: ff, validateObject: sf } = He2(), { Promise: af } = I2(), { isClosed: cf, isReadable: Zn, isReadableNodeStream: lr, isReadableFinished: ei, isReadableErrored: df, isWritable: ti, isWritableNodeStream: ri, isWritableFinished: ni, isWritableErrored: hf, isNodeStream: pf, willEmitClose: yf } = ae2();
    function wf(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    var bf = () => {
    };
    function ii(e, t, r3) {
      var n, i2;
      arguments.length === 2 ? (r3 = t, t = Jn) : t == null ? t = Jn : sf(t, "options"), ff(r3, "callback"), uf(t.signal, "options.signal"), r3 = Qn(r3);
      let o2 = (n = t.readable) !== null && n !== undefined ? n : lr(e), l2 = (i2 = t.writable) !== null && i2 !== undefined ? i2 : ri(e);
      if (!pf(e))
        throw new lf("stream", "Stream", e);
      let { _writableState: u2, _readableState: f2 } = e, s2 = () => {
        e.writable || y2();
      }, d = yf(e) && lr(e) === o2 && ri(e) === l2, c2 = ni(e, false), y2 = () => {
        c2 = true, e.destroyed && (d = false), !(d && (!e.readable || o2)) && (!o2 || h) && r3.call(e);
      }, h = ei(e, false), p2 = () => {
        h = true, e.destroyed && (d = false), !(d && (!e.writable || l2)) && (!l2 || c2) && r3.call(e);
      }, B2 = (N2) => {
        r3.call(e, N2);
      }, v2 = cf(e), w2 = () => {
        v2 = true;
        let N2 = hf(e) || df(e);
        if (N2 && typeof N2 != "boolean")
          return r3.call(e, N2);
        if (o2 && !h && lr(e, true) && !ei(e, false))
          return r3.call(e, new Xn);
        if (l2 && !c2 && !ni(e, false))
          return r3.call(e, new Xn);
        r3.call(e);
      }, b = () => {
        e.req.on("finish", y2);
      };
      wf(e) ? (e.on("complete", y2), d || e.on("abort", w2), e.req ? b() : e.on("request", b)) : l2 && !u2 && (e.on("end", s2), e.on("close", s2)), !d && typeof e.aborted == "boolean" && e.on("aborted", w2), e.on("end", p2), e.on("finish", y2), t.error !== false && e.on("error", B2), e.on("close", w2), v2 ? Ce2.nextTick(w2) : u2 != null && u2.errorEmitted || f2 != null && f2.errorEmitted ? d || Ce2.nextTick(w2) : (!o2 && (!d || Zn(e)) && (c2 || ti(e) === false) || !l2 && (!d || ti(e)) && (h || Zn(e) === false) || f2 && e.req && e.aborted) && Ce2.nextTick(w2);
      let L2 = () => {
        r3 = bf, e.removeListener("aborted", w2), e.removeListener("complete", y2), e.removeListener("abort", w2), e.removeListener("request", b), e.req && e.req.removeListener("finish", y2), e.removeListener("end", s2), e.removeListener("close", s2), e.removeListener("finish", y2), e.removeListener("end", p2), e.removeListener("error", B2), e.removeListener("close", w2);
      };
      if (t.signal && !v2) {
        let N2 = () => {
          let Q2 = r3;
          L2(), Q2.call(e, new nf(undefined, { cause: t.signal.reason }));
        };
        if (t.signal.aborted)
          Ce2.nextTick(N2);
        else {
          let Q2 = r3;
          r3 = Qn((...Ie2) => {
            t.signal.removeEventListener("abort", N2), Q2.apply(e, Ie2);
          }), t.signal.addEventListener("abort", N2);
        }
      }
      return L2;
    }
    function gf(e, t) {
      return new af((r3, n) => {
        ii(e, t, (i2) => {
          i2 ? n(i2) : r3();
        });
      });
    }
    ur.exports = ii;
    ur.exports.finished = gf;
  });
  di = E((Zc, ar) => {
    var fi = globalThis.AbortController || ut2().AbortController, { codes: { ERR_INVALID_ARG_TYPE: Ve2, ERR_MISSING_ARGS: _f, ERR_OUT_OF_RANGE: Ef }, AbortError: z2 } = C2(), { validateAbortSignal: Oe2, validateInteger: Sf, validateObject: De2 } = He2(), mf = I2().Symbol("kWeak"), { finished: xf } = ce2(), { ArrayPrototypePush: Rf, MathFloor: Af, Number: If, NumberIsNaN: Tf, Promise: oi, PromiseReject: li, PromisePrototypeThen: Bf, Symbol: si } = I2(), wt = si("kEmpty"), ui = si("kEof");
    function bt(e, t) {
      if (typeof e != "function")
        throw new Ve2("fn", ["Function", "AsyncFunction"], e);
      t != null && De2(t, "options"), t?.signal != null && Oe2(t.signal, "options.signal");
      let r3 = 1;
      return t?.concurrency != null && (r3 = Af(t.concurrency)), Sf(r3, "concurrency", 1), async function* () {
        var i2, o2;
        let l2 = new fi, u2 = this, f2 = [], s2 = l2.signal, d = { signal: s2 }, c2 = () => l2.abort();
        t != null && (i2 = t.signal) !== null && i2 !== undefined && i2.aborted && c2(), t == null || (o2 = t.signal) === null || o2 === undefined || o2.addEventListener("abort", c2);
        let y2, h, p2 = false;
        function B2() {
          p2 = true;
        }
        async function v2() {
          try {
            for await (let L2 of u2) {
              var w2;
              if (p2)
                return;
              if (s2.aborted)
                throw new z2;
              try {
                L2 = e(L2, d);
              } catch (N2) {
                L2 = li(N2);
              }
              L2 !== wt && (typeof ((w2 = L2) === null || w2 === undefined ? undefined : w2.catch) == "function" && L2.catch(B2), f2.push(L2), y2 && (y2(), y2 = null), !p2 && f2.length && f2.length >= r3 && await new oi((N2) => {
                h = N2;
              }));
            }
            f2.push(ui);
          } catch (L2) {
            let N2 = li(L2);
            Bf(N2, undefined, B2), f2.push(N2);
          } finally {
            var b;
            p2 = true, y2 && (y2(), y2 = null), t == null || (b = t.signal) === null || b === undefined || b.removeEventListener("abort", c2);
          }
        }
        v2();
        try {
          for (;; ) {
            for (;f2.length > 0; ) {
              let w2 = await f2[0];
              if (w2 === ui)
                return;
              if (s2.aborted)
                throw new z2;
              w2 !== wt && (yield w2), f2.shift(), h && (h(), h = null);
            }
            await new oi((w2) => {
              y2 = w2;
            });
          }
        } finally {
          l2.abort(), p2 = true, h && (h(), h = null);
        }
      }.call(this);
    }
    function Lf(e = undefined) {
      return e != null && De2(e, "options"), e?.signal != null && Oe2(e.signal, "options.signal"), async function* () {
        let r3 = 0;
        for await (let i2 of this) {
          var n;
          if (e != null && (n = e.signal) !== null && n !== undefined && n.aborted)
            throw new z2({ cause: e.signal.reason });
          yield [r3++, i2];
        }
      }.call(this);
    }
    async function ai(e, t = undefined) {
      for await (let r3 of sr.call(this, e, t))
        return true;
      return false;
    }
    async function Nf(e, t = undefined) {
      if (typeof e != "function")
        throw new Ve2("fn", ["Function", "AsyncFunction"], e);
      return !await ai.call(this, async (...r3) => !await e(...r3), t);
    }
    async function Ff(e, t) {
      for await (let r3 of sr.call(this, e, t))
        return r3;
    }
    async function Mf(e, t) {
      if (typeof e != "function")
        throw new Ve2("fn", ["Function", "AsyncFunction"], e);
      async function r3(n, i2) {
        return await e(n, i2), wt;
      }
      for await (let n of bt.call(this, r3, t))
        ;
    }
    function sr(e, t) {
      if (typeof e != "function")
        throw new Ve2("fn", ["Function", "AsyncFunction"], e);
      async function r3(n, i2) {
        return await e(n, i2) ? n : wt;
      }
      return bt.call(this, r3, t);
    }
    var fr = class extends _f {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function Cf(e, t, r3) {
      var n;
      if (typeof e != "function")
        throw new Ve2("reducer", ["Function", "AsyncFunction"], e);
      r3 != null && De2(r3, "options"), r3?.signal != null && Oe2(r3.signal, "options.signal");
      let i2 = arguments.length > 1;
      if (r3 != null && (n = r3.signal) !== null && n !== undefined && n.aborted) {
        let s2 = new z2(undefined, { cause: r3.signal.reason });
        throw this.once("error", () => {
        }), await xf(this.destroy(s2)), s2;
      }
      let o2 = new fi, l2 = o2.signal;
      if (r3 != null && r3.signal) {
        let s2 = { once: true, [mf]: this };
        r3.signal.addEventListener("abort", () => o2.abort(), s2);
      }
      let u2 = false;
      try {
        for await (let s2 of this) {
          var f2;
          if (u2 = true, r3 != null && (f2 = r3.signal) !== null && f2 !== undefined && f2.aborted)
            throw new z2;
          i2 ? t = await e(t, s2, { signal: l2 }) : (t = s2, i2 = true);
        }
        if (!u2 && !i2)
          throw new fr;
      } finally {
        o2.abort();
      }
      return t;
    }
    async function Of(e) {
      e != null && De2(e, "options"), e?.signal != null && Oe2(e.signal, "options.signal");
      let t = [];
      for await (let n of this) {
        var r3;
        if (e != null && (r3 = e.signal) !== null && r3 !== undefined && r3.aborted)
          throw new z2(undefined, { cause: e.signal.reason });
        Rf(t, n);
      }
      return t;
    }
    function Df(e, t) {
      let r3 = bt.call(this, e, t);
      return async function* () {
        for await (let i2 of r3)
          yield* i2;
      }.call(this);
    }
    function ci(e) {
      if (e = If(e), Tf(e))
        return 0;
      if (e < 0)
        throw new Ef("number", ">= 0", e);
      return e;
    }
    function Pf(e, t = undefined) {
      return t != null && De2(t, "options"), t?.signal != null && Oe2(t.signal, "options.signal"), e = ci(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z2;
        for await (let o2 of this) {
          var i2;
          if (t != null && (i2 = t.signal) !== null && i2 !== undefined && i2.aborted)
            throw new z2;
          e-- <= 0 && (yield o2);
        }
      }.call(this);
    }
    function kf(e, t = undefined) {
      return t != null && De2(t, "options"), t?.signal != null && Oe2(t.signal, "options.signal"), e = ci(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z2;
        for await (let o2 of this) {
          var i2;
          if (t != null && (i2 = t.signal) !== null && i2 !== undefined && i2.aborted)
            throw new z2;
          if (e-- > 0)
            yield o2;
          else
            return;
        }
      }.call(this);
    }
    ar.exports.streamReturningOperators = { asIndexedPairs: Lf, drop: Pf, filter: sr, flatMap: Df, map: bt, take: kf };
    ar.exports.promiseReturningOperators = { every: Nf, forEach: Mf, reduce: Cf, toArray: Of, some: ai, find: Ff };
  });
  Se2 = E((ed, Ei) => {
    var de = (se2(), pe(k2)), { aggregateTwoErrors: Uf, codes: { ERR_MULTIPLE_CALLBACK: vf }, AbortError: qf } = C2(), { Symbol: yi } = I2(), { kDestroyed: Wf, isDestroyed: $f, isFinished: jf, isServerRequest: Gf } = ae2(), wi = yi("kDestroy"), cr = yi("kConstruct");
    function bi(e, t, r3) {
      e && (e.stack, t && !t.errored && (t.errored = e), r3 && !r3.errored && (r3.errored = e));
    }
    function Hf(e, t) {
      let r3 = this._readableState, n = this._writableState, i2 = n || r3;
      return n && n.destroyed || r3 && r3.destroyed ? (typeof t == "function" && t(), this) : (bi(e, n, r3), n && (n.destroyed = true), r3 && (r3.destroyed = true), i2.constructed ? hi(this, e, t) : this.once(wi, function(o2) {
        hi(this, Uf(o2, e), t);
      }), this);
    }
    function hi(e, t, r3) {
      let n = false;
      function i2(o2) {
        if (n)
          return;
        n = true;
        let { _readableState: l2, _writableState: u2 } = e;
        bi(o2, u2, l2), u2 && (u2.closed = true), l2 && (l2.closed = true), typeof r3 == "function" && r3(o2), o2 ? de.nextTick(Vf, e, o2) : de.nextTick(gi, e);
      }
      try {
        e._destroy(t || null, i2);
      } catch (o2) {
        i2(o2);
      }
    }
    function Vf(e, t) {
      dr(e, t), gi(e);
    }
    function gi(e) {
      let { _readableState: t, _writableState: r3 } = e;
      r3 && (r3.closeEmitted = true), t && (t.closeEmitted = true), (r3 && r3.emitClose || t && t.emitClose) && e.emit("close");
    }
    function dr(e, t) {
      let { _readableState: r3, _writableState: n } = e;
      n && n.errorEmitted || r3 && r3.errorEmitted || (n && (n.errorEmitted = true), r3 && (r3.errorEmitted = true), e.emit("error", t));
    }
    function Yf() {
      let e = this._readableState, t = this._writableState;
      e && (e.constructed = true, e.closed = false, e.closeEmitted = false, e.destroyed = false, e.errored = null, e.errorEmitted = false, e.reading = false, e.ended = e.readable === false, e.endEmitted = e.readable === false), t && (t.constructed = true, t.destroyed = false, t.closed = false, t.closeEmitted = false, t.errored = null, t.errorEmitted = false, t.finalCalled = false, t.prefinished = false, t.ended = t.writable === false, t.ending = t.writable === false, t.finished = t.writable === false);
    }
    function hr(e, t, r3) {
      let { _readableState: n, _writableState: i2 } = e;
      if (i2 && i2.destroyed || n && n.destroyed)
        return this;
      n && n.autoDestroy || i2 && i2.autoDestroy ? e.destroy(t) : t && (t.stack, i2 && !i2.errored && (i2.errored = t), n && !n.errored && (n.errored = t), r3 ? de.nextTick(dr, e, t) : dr(e, t));
    }
    function Kf(e, t) {
      if (typeof e._construct != "function")
        return;
      let { _readableState: r3, _writableState: n } = e;
      r3 && (r3.constructed = false), n && (n.constructed = false), e.once(cr, t), !(e.listenerCount(cr) > 1) && de.nextTick(zf, e);
    }
    function zf(e) {
      let t = false;
      function r3(n) {
        if (t) {
          hr(e, n ?? new vf);
          return;
        }
        t = true;
        let { _readableState: i2, _writableState: o2 } = e, l2 = o2 || i2;
        i2 && (i2.constructed = true), o2 && (o2.constructed = true), l2.destroyed ? e.emit(wi, n) : n ? hr(e, n, true) : de.nextTick(Xf, e);
      }
      try {
        e._construct(r3);
      } catch (n) {
        r3(n);
      }
    }
    function Xf(e) {
      e.emit(cr);
    }
    function pi(e) {
      return e && e.setHeader && typeof e.abort == "function";
    }
    function _i(e) {
      e.emit("close");
    }
    function Jf(e, t) {
      e.emit("error", t), de.nextTick(_i, e);
    }
    function Qf(e, t) {
      !e || $f(e) || (!t && !jf(e) && (t = new qf), Gf(e) ? (e.socket = null, e.destroy(t)) : pi(e) ? e.abort() : pi(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? de.nextTick(Jf, e, t) : de.nextTick(_i, e), e.destroyed || (e[Wf] = true));
    }
    Ei.exports = { construct: Kf, destroyer: Qf, destroy: Hf, undestroy: Yf, errorOrDestroy: hr };
  });
  Et = E((td, pr) => {
    var Pe2 = typeof Reflect == "object" ? Reflect : null, Si = Pe2 && typeof Pe2.apply == "function" ? Pe2.apply : function(t, r3, n) {
      return Function.prototype.apply.call(t, r3, n);
    }, gt;
    Pe2 && typeof Pe2.ownKeys == "function" ? gt = Pe2.ownKeys : Object.getOwnPropertySymbols ? gt = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : gt = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function Zf(e) {
      console && console.warn && console.warn(e);
    }
    var xi = Number.isNaN || function(t) {
      return t !== t;
    };
    function S2() {
      S2.init.call(this);
    }
    pr.exports = S2;
    pr.exports.once = ns;
    S2.EventEmitter = S2;
    S2.prototype._events = undefined;
    S2.prototype._eventsCount = 0;
    S2.prototype._maxListeners = undefined;
    var mi = 10;
    function _t(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(S2, "defaultMaxListeners", { enumerable: true, get: function() {
      return mi;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || xi(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      mi = e;
    } });
    S2.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    S2.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || xi(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Ri(e) {
      return e._maxListeners === undefined ? S2.defaultMaxListeners : e._maxListeners;
    }
    S2.prototype.getMaxListeners = function() {
      return Ri(this);
    };
    S2.prototype.emit = function(t) {
      for (var r3 = [], n = 1;n < arguments.length; n++)
        r3.push(arguments[n]);
      var i2 = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i2 = i2 && o2.error === undefined;
      else if (!i2)
        return false;
      if (i2) {
        var l2;
        if (r3.length > 0 && (l2 = r3[0]), l2 instanceof Error)
          throw l2;
        var u2 = new Error("Unhandled error." + (l2 ? " (" + l2.message + ")" : ""));
        throw u2.context = l2, u2;
      }
      var f2 = o2[t];
      if (f2 === undefined)
        return false;
      if (typeof f2 == "function")
        Si(f2, this, r3);
      else
        for (var s2 = f2.length, d = Li(f2, s2), n = 0;n < s2; ++n)
          Si(d[n], this, r3);
      return true;
    };
    function Ai(e, t, r3, n) {
      var i2, o2, l2;
      if (_t(r3), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r3.listener ? r3.listener : r3), o2 = e._events), l2 = o2[t]), l2 === undefined)
        l2 = o2[t] = r3, ++e._eventsCount;
      else if (typeof l2 == "function" ? l2 = o2[t] = n ? [r3, l2] : [l2, r3] : n ? l2.unshift(r3) : l2.push(r3), i2 = Ri(e), i2 > 0 && l2.length > i2 && !l2.warned) {
        l2.warned = true;
        var u2 = new Error("Possible EventEmitter memory leak detected. " + l2.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        u2.name = "MaxListenersExceededWarning", u2.emitter = e, u2.type = t, u2.count = l2.length, Zf(u2);
      }
      return e;
    }
    S2.prototype.addListener = function(t, r3) {
      return Ai(this, t, r3, false);
    };
    S2.prototype.on = S2.prototype.addListener;
    S2.prototype.prependListener = function(t, r3) {
      return Ai(this, t, r3, true);
    };
    function es() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ii(e, t, r3) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r3 }, i2 = es.bind(n);
      return i2.listener = r3, n.wrapFn = i2, i2;
    }
    S2.prototype.once = function(t, r3) {
      return _t(r3), this.on(t, Ii(this, t, r3)), this;
    };
    S2.prototype.prependOnceListener = function(t, r3) {
      return _t(r3), this.prependListener(t, Ii(this, t, r3)), this;
    };
    S2.prototype.removeListener = function(t, r3) {
      var n, i2, o2, l2, u2;
      if (_t(r3), i2 = this._events, i2 === undefined)
        return this;
      if (n = i2[t], n === undefined)
        return this;
      if (n === r3 || n.listener === r3)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i2[t], i2.removeListener && this.emit("removeListener", t, n.listener || r3));
      else if (typeof n != "function") {
        for (o2 = -1, l2 = n.length - 1;l2 >= 0; l2--)
          if (n[l2] === r3 || n[l2].listener === r3) {
            u2 = n[l2].listener, o2 = l2;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : ts(n, o2), n.length === 1 && (i2[t] = n[0]), i2.removeListener !== undefined && this.emit("removeListener", t, u2 || r3);
      }
      return this;
    };
    S2.prototype.off = S2.prototype.removeListener;
    S2.prototype.removeAllListeners = function(t) {
      var r3, n, i2;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), l2;
        for (i2 = 0;i2 < o2.length; ++i2)
          l2 = o2[i2], l2 !== "removeListener" && this.removeAllListeners(l2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r3 = n[t], typeof r3 == "function")
        this.removeListener(t, r3);
      else if (r3 !== undefined)
        for (i2 = r3.length - 1;i2 >= 0; i2--)
          this.removeListener(t, r3[i2]);
      return this;
    };
    function Ti(e, t, r3) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i2 = n[t];
      return i2 === undefined ? [] : typeof i2 == "function" ? r3 ? [i2.listener || i2] : [i2] : r3 ? rs(i2) : Li(i2, i2.length);
    }
    S2.prototype.listeners = function(t) {
      return Ti(this, t, true);
    };
    S2.prototype.rawListeners = function(t) {
      return Ti(this, t, false);
    };
    S2.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Bi.call(e, t);
    };
    S2.prototype.listenerCount = Bi;
    function Bi(e) {
      var t = this._events;
      if (t !== undefined) {
        var r3 = t[e];
        if (typeof r3 == "function")
          return 1;
        if (r3 !== undefined)
          return r3.length;
      }
      return 0;
    }
    S2.prototype.eventNames = function() {
      return this._eventsCount > 0 ? gt(this._events) : [];
    };
    function Li(e, t) {
      for (var r3 = new Array(t), n = 0;n < t; ++n)
        r3[n] = e[n];
      return r3;
    }
    function ts(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function rs(e) {
      for (var t = new Array(e.length), r3 = 0;r3 < t.length; ++r3)
        t[r3] = e[r3].listener || e[r3];
      return t;
    }
    function ns(e, t) {
      return new Promise(function(r3, n) {
        function i2(l2) {
          e.removeListener(t, o2), n(l2);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i2), r3([].slice.call(arguments));
        }
        Ni(e, t, o2, { once: true }), t !== "error" && is3(e, i2, { once: true });
      });
    }
    function is3(e, t, r3) {
      typeof e.on == "function" && Ni(e, "error", t, r3);
    }
    function Ni(e, t, r3, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r3) : e.on(t, r3);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r3(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  xt = E((rd, Mi) => {
    var { ArrayIsArray: os, ObjectSetPrototypeOf: Fi } = I2(), { EventEmitter: St2 } = Et();
    function mt(e) {
      St2.call(this, e);
    }
    Fi(mt.prototype, St2.prototype);
    Fi(mt, St2);
    mt.prototype.pipe = function(e, t) {
      let r3 = this;
      function n(d) {
        e.writable && e.write(d) === false && r3.pause && r3.pause();
      }
      r3.on("data", n);
      function i2() {
        r3.readable && r3.resume && r3.resume();
      }
      e.on("drain", i2), !e._isStdio && (!t || t.end !== false) && (r3.on("end", l2), r3.on("close", u2));
      let o2 = false;
      function l2() {
        o2 || (o2 = true, e.end());
      }
      function u2() {
        o2 || (o2 = true, typeof e.destroy == "function" && e.destroy());
      }
      function f2(d) {
        s2(), St2.listenerCount(this, "error") === 0 && this.emit("error", d);
      }
      yr(r3, "error", f2), yr(e, "error", f2);
      function s2() {
        r3.removeListener("data", n), e.removeListener("drain", i2), r3.removeListener("end", l2), r3.removeListener("close", u2), r3.removeListener("error", f2), e.removeListener("error", f2), r3.removeListener("end", s2), r3.removeListener("close", s2), e.removeListener("close", s2);
      }
      return r3.on("end", s2), r3.on("close", s2), e.on("close", s2), e.emit("pipe", r3), e;
    };
    function yr(e, t, r3) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r3);
      !e._events || !e._events[t] ? e.on(t, r3) : os(e._events[t]) ? e._events[t].unshift(r3) : e._events[t] = [r3, e._events[t]];
    }
    Mi.exports = { Stream: mt, prependListener: yr };
  });
  At = E((nd, Rt) => {
    var { AbortError: ls, codes: us } = C2(), fs = ce2(), { ERR_INVALID_ARG_TYPE: Ci } = us, ss = (e, t) => {
      if (typeof e != "object" || !("aborted" in e))
        throw new Ci(t, "AbortSignal", e);
    };
    function as(e) {
      return !!(e && typeof e.pipe == "function");
    }
    Rt.exports.addAbortSignal = function(t, r3) {
      if (ss(t, "signal"), !as(r3))
        throw new Ci("stream", "stream.Stream", r3);
      return Rt.exports.addAbortSignalNoValidate(t, r3);
    };
    Rt.exports.addAbortSignalNoValidate = function(e, t) {
      if (typeof e != "object" || !("aborted" in e))
        return t;
      let r3 = () => {
        t.destroy(new ls(undefined, { cause: e.reason }));
      };
      return e.aborted ? r3() : (e.addEventListener("abort", r3), fs(t, () => e.removeEventListener("abort", r3))), t;
    };
  });
  Pi = E((od, Di) => {
    var { StringPrototypeSlice: Oi, SymbolIterator: cs, TypedArrayPrototypeSet: It, Uint8Array: ds } = I2(), { Buffer: wr } = te2(), { inspect: hs } = V2();
    Di.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(t) {
        let r3 = { data: t, next: null };
        this.length > 0 ? this.tail.next = r3 : this.head = r3, this.tail = r3, ++this.length;
      }
      unshift(t) {
        let r3 = { data: t, next: this.head };
        this.length === 0 && (this.tail = r3), this.head = r3, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let t = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(t) {
        if (this.length === 0)
          return "";
        let r3 = this.head, n = "" + r3.data;
        for (;(r3 = r3.next) !== null; )
          n += t + r3.data;
        return n;
      }
      concat(t) {
        if (this.length === 0)
          return wr.alloc(0);
        let r3 = wr.allocUnsafe(t >>> 0), n = this.head, i2 = 0;
        for (;n; )
          It(r3, n.data, i2), i2 += n.data.length, n = n.next;
        return r3;
      }
      consume(t, r3) {
        let n = this.head.data;
        if (t < n.length) {
          let i2 = n.slice(0, t);
          return this.head.data = n.slice(t), i2;
        }
        return t === n.length ? this.shift() : r3 ? this._getString(t) : this._getBuffer(t);
      }
      first() {
        return this.head.data;
      }
      *[cs]() {
        for (let t = this.head;t; t = t.next)
          yield t.data;
      }
      _getString(t) {
        let r3 = "", n = this.head, i2 = 0;
        do {
          let o2 = n.data;
          if (t > o2.length)
            r3 += o2, t -= o2.length;
          else {
            t === o2.length ? (r3 += o2, ++i2, n.next ? this.head = n.next : this.head = this.tail = null) : (r3 += Oi(o2, 0, t), this.head = n, n.data = Oi(o2, t));
            break;
          }
          ++i2;
        } while ((n = n.next) !== null);
        return this.length -= i2, r3;
      }
      _getBuffer(t) {
        let r3 = wr.allocUnsafe(t), n = t, i2 = this.head, o2 = 0;
        do {
          let l2 = i2.data;
          if (t > l2.length)
            It(r3, l2, n - t), t -= l2.length;
          else {
            t === l2.length ? (It(r3, l2, n - t), ++o2, i2.next ? this.head = i2.next : this.head = this.tail = null) : (It(r3, new ds(l2.buffer, l2.byteOffset, t), n - t), this.head = i2, i2.data = l2.slice(t));
            break;
          }
          ++o2;
        } while ((i2 = i2.next) !== null);
        return this.length -= o2, r3;
      }
      [Symbol.for("nodejs.util.inspect.custom")](t, r3) {
        return hs(this, { ...r3, depth: 0, customInspect: false });
      }
    };
  });
  Tt = E((ld, Ui) => {
    var { MathFloor: ps, NumberIsInteger: ys } = I2(), { ERR_INVALID_ARG_VALUE: ws } = C2().codes;
    function bs(e, t, r3) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r3] : null;
    }
    function ki(e) {
      return e ? 16 : 16 * 1024;
    }
    function gs(e, t, r3, n) {
      let i2 = bs(t, n, r3);
      if (i2 != null) {
        if (!ys(i2) || i2 < 0) {
          let o2 = n ? `options.${r3}` : "options.highWaterMark";
          throw new ws(o2, i2);
        }
        return ps(i2);
      }
      return ki(e.objectMode);
    }
    Ui.exports = { getHighWaterMark: gs, getDefaultHighWaterMark: ki };
  });
  Wi = E((br, qi) => {
    var Bt = te2(), X2 = Bt.Buffer;
    function vi(e, t) {
      for (var r3 in e)
        t[r3] = e[r3];
    }
    X2.from && X2.alloc && X2.allocUnsafe && X2.allocUnsafeSlow ? qi.exports = Bt : (vi(Bt, br), br.Buffer = me2);
    function me2(e, t, r3) {
      return X2(e, t, r3);
    }
    me2.prototype = Object.create(X2.prototype);
    vi(X2, me2);
    me2.from = function(e, t, r3) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return X2(e, t, r3);
    };
    me2.alloc = function(e, t, r3) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = X2(e);
      return t !== undefined ? typeof r3 == "string" ? n.fill(t, r3) : n.fill(t) : n.fill(0), n;
    };
    me2.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return X2(e);
    };
    me2.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Bt.SlowBuffer(e);
    };
  });
  Gi = E((ji) => {
    var _r = Wi().Buffer, $i = _r.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _s(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function Es(e) {
      var t = _s(e);
      if (typeof t != "string" && (_r.isEncoding === $i || !$i(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    ji.StringDecoder = Ye2;
    function Ye2(e) {
      this.encoding = Es(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Is, this.end = Ts, t = 4;
          break;
        case "utf8":
          this.fillLast = xs, t = 4;
          break;
        case "base64":
          this.text = Bs, this.end = Ls, t = 3;
          break;
        default:
          this.write = Ns, this.end = Fs;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = _r.allocUnsafe(t);
    }
    Ye2.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r3;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r3 = this.lastNeed, this.lastNeed = 0;
      } else
        r3 = 0;
      return r3 < e.length ? t ? t + this.text(e, r3) : this.text(e, r3) : t || "";
    };
    Ye2.prototype.end = As;
    Ye2.prototype.text = Rs;
    Ye2.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function gr(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ss(e, t, r3) {
      var n = t.length - 1;
      if (n < r3)
        return 0;
      var i2 = gr(t[n]);
      return i2 >= 0 ? (i2 > 0 && (e.lastNeed = i2 - 1), i2) : --n < r3 || i2 === -2 ? 0 : (i2 = gr(t[n]), i2 >= 0 ? (i2 > 0 && (e.lastNeed = i2 - 2), i2) : --n < r3 || i2 === -2 ? 0 : (i2 = gr(t[n]), i2 >= 0 ? (i2 > 0 && (i2 === 2 ? i2 = 0 : e.lastNeed = i2 - 3), i2) : 0));
    }
    function ms(e, t, r3) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function xs(e) {
      var t = this.lastTotal - this.lastNeed, r3 = ms(this, e, t);
      if (r3 !== undefined)
        return r3;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Rs(e, t) {
      var r3 = Ss(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r3;
      var n = e.length - (r3 - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function As(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function Is(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r3 = e.toString("utf16le", t);
        if (r3) {
          var n = r3.charCodeAt(r3.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r3.slice(0, -1);
        }
        return r3;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ts(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r3 = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r3);
      }
      return t;
    }
    function Bs(e, t) {
      var r3 = (e.length - t) % 3;
      return r3 === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r3, this.lastTotal = 3, r3 === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r3));
    }
    function Ls(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ns(e) {
      return e.toString(this.encoding);
    }
    function Fs(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Er = E((fd, Ki) => {
    var Hi = (se2(), pe(k2)), { PromisePrototypeThen: Ms, SymbolAsyncIterator: Vi, SymbolIterator: Yi } = I2(), { Buffer: Cs } = te2(), { ERR_INVALID_ARG_TYPE: Os, ERR_STREAM_NULL_VALUES: Ds } = C2().codes;
    function Ps(e, t, r3) {
      let n;
      if (typeof t == "string" || t instanceof Cs)
        return new e({ objectMode: true, ...r3, read() {
          this.push(t), this.push(null);
        } });
      let i2;
      if (t && t[Vi])
        i2 = true, n = t[Vi]();
      else if (t && t[Yi])
        i2 = false, n = t[Yi]();
      else
        throw new Os("iterable", ["Iterable"], t);
      let o2 = new e({ objectMode: true, highWaterMark: 1, ...r3 }), l2 = false;
      o2._read = function() {
        l2 || (l2 = true, f2());
      }, o2._destroy = function(s2, d) {
        Ms(u2(s2), () => Hi.nextTick(d, s2), (c2) => Hi.nextTick(d, c2 || s2));
      };
      async function u2(s2) {
        let d = s2 != null, c2 = typeof n.throw == "function";
        if (d && c2) {
          let { value: y2, done: h } = await n.throw(s2);
          if (await y2, h)
            return;
        }
        if (typeof n.return == "function") {
          let { value: y2 } = await n.return();
          await y2;
        }
      }
      async function f2() {
        for (;; ) {
          try {
            let { value: s2, done: d } = i2 ? await n.next() : n.next();
            if (d)
              o2.push(null);
            else {
              let c2 = s2 && typeof s2.then == "function" ? await s2 : s2;
              if (c2 === null)
                throw l2 = false, new Ds;
              if (o2.push(c2))
                continue;
              l2 = false;
            }
          } catch (s2) {
            o2.destroy(s2);
          }
          break;
        }
      }
      return o2;
    }
    Ki.exports = Ps;
  });
  Ke2 = E((sd, uo) => {
    var $2 = (se2(), pe(k2)), { ArrayPrototypeIndexOf: ks, NumberIsInteger: Us, NumberIsNaN: vs, NumberParseInt: qs, ObjectDefineProperties: Ji, ObjectKeys: Ws, ObjectSetPrototypeOf: Qi, Promise: $s, SafeSet: js, SymbolAsyncIterator: Gs, Symbol: Hs } = I2();
    uo.exports = g2;
    g2.ReadableState = Ir;
    var { EventEmitter: Vs } = Et(), { Stream: he2, prependListener: Ys } = xt(), { Buffer: Sr } = te2(), { addAbortSignal: Ks } = At(), zs = ce2(), _2 = V2().debuglog("stream", (e) => {
      _2 = e;
    }), Xs = Pi(), Ue2 = Se2(), { getHighWaterMark: Js, getDefaultHighWaterMark: Qs } = Tt(), { aggregateTwoErrors: zi, codes: { ERR_INVALID_ARG_TYPE: Zs, ERR_METHOD_NOT_IMPLEMENTED: ea, ERR_OUT_OF_RANGE: ta, ERR_STREAM_PUSH_AFTER_EOF: ra, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: na } } = C2(), { validateObject: ia } = He2(), xe2 = Hs("kPaused"), { StringDecoder: Zi } = Gi(), oa = Er();
    Qi(g2.prototype, he2.prototype);
    Qi(g2, he2);
    var mr = () => {
    }, { errorOrDestroy: ke2 } = Ue2;
    function Ir(e, t, r3) {
      typeof r3 != "boolean" && (r3 = t instanceof J2()), this.objectMode = !!(e && e.objectMode), r3 && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? Js(this, e, "readableHighWaterMark", r3) : Qs(false), this.buffer = new Xs, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[xe2] = null, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new Zi(e.encoding), this.encoding = e.encoding);
    }
    function g2(e) {
      if (!(this instanceof g2))
        return new g2(e);
      let t = this instanceof J2();
      this._readableState = new Ir(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && Ks(e.signal, this)), he2.call(this, e), Ue2.construct(this, () => {
        this._readableState.needReadable && Lt(this, this._readableState);
      });
    }
    g2.prototype.destroy = Ue2.destroy;
    g2.prototype._undestroy = Ue2.undestroy;
    g2.prototype._destroy = function(e, t) {
      t(e);
    };
    g2.prototype[Vs.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    g2.prototype.push = function(e, t) {
      return eo(this, e, t, false);
    };
    g2.prototype.unshift = function(e, t) {
      return eo(this, e, t, true);
    };
    function eo(e, t, r3, n) {
      _2("readableAddChunk", t);
      let i2 = e._readableState, o2;
      if (i2.objectMode || (typeof t == "string" ? (r3 = r3 || i2.defaultEncoding, i2.encoding !== r3 && (n && i2.encoding ? t = Sr.from(t, r3).toString(i2.encoding) : (t = Sr.from(t, r3), r3 = ""))) : t instanceof Sr ? r3 = "" : he2._isUint8Array(t) ? (t = he2._uint8ArrayToBuffer(t), r3 = "") : t != null && (o2 = new Zs("chunk", ["string", "Buffer", "Uint8Array"], t))), o2)
        ke2(e, o2);
      else if (t === null)
        i2.reading = false, fa(e, i2);
      else if (i2.objectMode || t && t.length > 0)
        if (n)
          if (i2.endEmitted)
            ke2(e, new na);
          else {
            if (i2.destroyed || i2.errored)
              return false;
            xr(e, i2, t, true);
          }
        else if (i2.ended)
          ke2(e, new ra);
        else {
          if (i2.destroyed || i2.errored)
            return false;
          i2.reading = false, i2.decoder && !r3 ? (t = i2.decoder.write(t), i2.objectMode || t.length !== 0 ? xr(e, i2, t, false) : Lt(e, i2)) : xr(e, i2, t, false);
        }
      else
        n || (i2.reading = false, Lt(e, i2));
      return !i2.ended && (i2.length < i2.highWaterMark || i2.length === 0);
    }
    function xr(e, t, r3, n) {
      t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = true, e.emit("data", r3)) : (t.length += t.objectMode ? 1 : r3.length, n ? t.buffer.unshift(r3) : t.buffer.push(r3), t.needReadable && Nt(e)), Lt(e, t);
    }
    g2.prototype.isPaused = function() {
      let e = this._readableState;
      return e[xe2] === true || e.flowing === false;
    };
    g2.prototype.setEncoding = function(e) {
      let t = new Zi(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      let r3 = this._readableState.buffer, n = "";
      for (let i2 of r3)
        n += t.write(i2);
      return r3.clear(), n !== "" && r3.push(n), this._readableState.length = n.length, this;
    };
    var la = 1073741824;
    function ua(e) {
      if (e > la)
        throw new ta("size", "<= 1GiB", e);
      return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function Xi(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : vs(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    g2.prototype.read = function(e) {
      _2("read", e), e === undefined ? e = NaN : Us(e) || (e = qs(e, 10));
      let t = this._readableState, r3 = e;
      if (e > t.highWaterMark && (t.highWaterMark = ua(e)), e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return _2("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Rr(this) : Nt(this), null;
      if (e = Xi(e, t), e === 0 && t.ended)
        return t.length === 0 && Rr(this), null;
      let n = t.needReadable;
      if (_2("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, _2("length less than watermark", n)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
        n = false, _2("reading, ended or constructing", n);
      else if (n) {
        _2("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true);
        try {
          this._read(t.highWaterMark);
        } catch (o2) {
          ke2(this, o2);
        }
        t.sync = false, t.reading || (e = Xi(r3, t));
      }
      let i2;
      return e > 0 ? i2 = oo(e, t) : i2 = null, i2 === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = true), r3 !== e && t.ended && Rr(this)), i2 !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = true, this.emit("data", i2)), i2;
    };
    function fa(e, t) {
      if (_2("onEofChunk"), !t.ended) {
        if (t.decoder) {
          let r3 = t.decoder.end();
          r3 && r3.length && (t.buffer.push(r3), t.length += t.objectMode ? 1 : r3.length);
        }
        t.ended = true, t.sync ? Nt(e) : (t.needReadable = false, t.emittedReadable = true, to(e));
      }
    }
    function Nt(e) {
      let t = e._readableState;
      _2("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (_2("emitReadable", t.flowing), t.emittedReadable = true, $2.nextTick(to, e));
    }
    function to(e) {
      let t = e._readableState;
      _2("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, no(e);
    }
    function Lt(e, t) {
      !t.readingMore && t.constructed && (t.readingMore = true, $2.nextTick(sa, e, t));
    }
    function sa(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        let r3 = t.length;
        if (_2("maybeReadMore read 0"), e.read(0), r3 === t.length)
          break;
      }
      t.readingMore = false;
    }
    g2.prototype._read = function(e) {
      throw new ea("_read()");
    };
    g2.prototype.pipe = function(e, t) {
      let r3 = this, n = this._readableState;
      n.pipes.length === 1 && (n.multiAwaitDrain || (n.multiAwaitDrain = true, n.awaitDrainWriters = new js(n.awaitDrainWriters ? [n.awaitDrainWriters] : []))), n.pipes.push(e), _2("pipe count=%d opts=%j", n.pipes.length, t);
      let o2 = (!t || t.end !== false) && e !== $2.stdout && e !== $2.stderr ? u2 : v2;
      n.endEmitted ? $2.nextTick(o2) : r3.once("end", o2), e.on("unpipe", l2);
      function l2(w2, b) {
        _2("onunpipe"), w2 === r3 && b && b.hasUnpiped === false && (b.hasUnpiped = true, d());
      }
      function u2() {
        _2("onend"), e.end();
      }
      let f2, s2 = false;
      function d() {
        _2("cleanup"), e.removeListener("close", p2), e.removeListener("finish", B2), f2 && e.removeListener("drain", f2), e.removeListener("error", h), e.removeListener("unpipe", l2), r3.removeListener("end", u2), r3.removeListener("end", v2), r3.removeListener("data", y2), s2 = true, f2 && n.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f2();
      }
      function c2() {
        s2 || (n.pipes.length === 1 && n.pipes[0] === e ? (_2("false write response, pause", 0), n.awaitDrainWriters = e, n.multiAwaitDrain = false) : n.pipes.length > 1 && n.pipes.includes(e) && (_2("false write response, pause", n.awaitDrainWriters.size), n.awaitDrainWriters.add(e)), r3.pause()), f2 || (f2 = aa(r3, e), e.on("drain", f2));
      }
      r3.on("data", y2);
      function y2(w2) {
        _2("ondata");
        let b = e.write(w2);
        _2("dest.write", b), b === false && c2();
      }
      function h(w2) {
        if (_2("onerror", w2), v2(), e.removeListener("error", h), e.listenerCount("error") === 0) {
          let b = e._writableState || e._readableState;
          b && !b.errorEmitted ? ke2(e, w2) : e.emit("error", w2);
        }
      }
      Ys(e, "error", h);
      function p2() {
        e.removeListener("finish", B2), v2();
      }
      e.once("close", p2);
      function B2() {
        _2("onfinish"), e.removeListener("close", p2), v2();
      }
      e.once("finish", B2);
      function v2() {
        _2("unpipe"), r3.unpipe(e);
      }
      return e.emit("pipe", r3), e.writableNeedDrain === true ? n.flowing && c2() : n.flowing || (_2("pipe resume"), r3.resume()), e;
    };
    function aa(e, t) {
      return function() {
        let n = e._readableState;
        n.awaitDrainWriters === t ? (_2("pipeOnDrain", 1), n.awaitDrainWriters = null) : n.multiAwaitDrain && (_2("pipeOnDrain", n.awaitDrainWriters.size), n.awaitDrainWriters.delete(t)), (!n.awaitDrainWriters || n.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
      };
    }
    g2.prototype.unpipe = function(e) {
      let t = this._readableState, r3 = { hasUnpiped: false };
      if (t.pipes.length === 0)
        return this;
      if (!e) {
        let i2 = t.pipes;
        t.pipes = [], this.pause();
        for (let o2 = 0;o2 < i2.length; o2++)
          i2[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let n = ks(t.pipes, e);
      return n === -1 ? this : (t.pipes.splice(n, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, r3), this);
    };
    g2.prototype.on = function(e, t) {
      let r3 = he2.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, _2("on readable", n.length, n.reading), n.length ? Nt(this) : n.reading || $2.nextTick(ca, this)), r3;
    };
    g2.prototype.addListener = g2.prototype.on;
    g2.prototype.removeListener = function(e, t) {
      let r3 = he2.prototype.removeListener.call(this, e, t);
      return e === "readable" && $2.nextTick(ro, this), r3;
    };
    g2.prototype.off = g2.prototype.removeListener;
    g2.prototype.removeAllListeners = function(e) {
      let t = he2.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && $2.nextTick(ro, this), t;
    };
    function ro(e) {
      let t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[xe2] === false ? t.flowing = true : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function ca(e) {
      _2("readable nexttick read 0"), e.read(0);
    }
    g2.prototype.resume = function() {
      let e = this._readableState;
      return e.flowing || (_2("resume"), e.flowing = !e.readableListening, da(this, e)), e[xe2] = false, this;
    };
    function da(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, $2.nextTick(ha, e, t));
    }
    function ha(e, t) {
      _2("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), no(e), t.flowing && !t.reading && e.read(0);
    }
    g2.prototype.pause = function() {
      return _2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (_2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[xe2] = true, this;
    };
    function no(e) {
      let t = e._readableState;
      for (_2("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    g2.prototype.wrap = function(e) {
      let t = false;
      e.on("data", (n) => {
        !this.push(n) && e.pause && (t = true, e.pause());
      }), e.on("end", () => {
        this.push(null);
      }), e.on("error", (n) => {
        ke2(this, n);
      }), e.on("close", () => {
        this.destroy();
      }), e.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        t && e.resume && (t = false, e.resume());
      };
      let r3 = Ws(e);
      for (let n = 1;n < r3.length; n++) {
        let i2 = r3[n];
        this[i2] === undefined && typeof e[i2] == "function" && (this[i2] = e[i2].bind(e));
      }
      return this;
    };
    g2.prototype[Gs] = function() {
      return io(this);
    };
    g2.prototype.iterator = function(e) {
      return e !== undefined && ia(e, "options"), io(this, e);
    };
    function io(e, t) {
      typeof e.read != "function" && (e = g2.wrap(e, { objectMode: true }));
      let r3 = pa(e, t);
      return r3.stream = e, r3;
    }
    async function* pa(e, t) {
      let r3 = mr;
      function n(l2) {
        this === e ? (r3(), r3 = mr) : r3 = l2;
      }
      e.on("readable", n);
      let i2, o2 = zs(e, { writable: false }, (l2) => {
        i2 = l2 ? zi(i2, l2) : null, r3(), r3 = mr;
      });
      try {
        for (;; ) {
          let l2 = e.destroyed ? null : e.read();
          if (l2 !== null)
            yield l2;
          else {
            if (i2)
              throw i2;
            if (i2 === null)
              return;
            await new $s(n);
          }
        }
      } catch (l2) {
        throw i2 = zi(i2, l2), i2;
      } finally {
        (i2 || t?.destroyOnReturn !== false) && (i2 === undefined || e._readableState.autoDestroy) ? Ue2.destroyer(e, null) : (e.off("readable", n), o2());
      }
    }
    Ji(g2.prototype, { readable: { __proto__: null, get() {
      let e = this._readableState;
      return !!e && e.readable !== false && !e.destroyed && !e.errorEmitted && !e.endEmitted;
    }, set(e) {
      this._readableState && (this._readableState.readable = !!e);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    Ji(Ir.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[xe2] !== false;
    }, set(e) {
      this[xe2] = !!e;
    } } });
    g2._fromList = oo;
    function oo(e, t) {
      if (t.length === 0)
        return null;
      let r3;
      return t.objectMode ? r3 = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r3 = t.buffer.join("") : t.buffer.length === 1 ? r3 = t.buffer.first() : r3 = t.buffer.concat(t.length), t.buffer.clear()) : r3 = t.buffer.consume(e, t.decoder), r3;
    }
    function Rr(e) {
      let t = e._readableState;
      _2("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, $2.nextTick(ya, t, e));
    }
    function ya(e, t) {
      if (_2("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
        if (e.endEmitted = true, t.emit("end"), t.writable && t.allowHalfOpen === false)
          $2.nextTick(wa, t);
        else if (e.autoDestroy) {
          let r3 = t._writableState;
          (!r3 || r3.autoDestroy && (r3.finished || r3.writable === false)) && t.destroy();
        }
      }
    }
    function wa(e) {
      e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    g2.from = function(e, t) {
      return oa(g2, e, t);
    };
    var Ar;
    function lo() {
      return Ar === undefined && (Ar = {}), Ar;
    }
    g2.fromWeb = function(e, t) {
      return lo().newStreamReadableFromReadableStream(e, t);
    };
    g2.toWeb = function(e, t) {
      return lo().newReadableStreamFromStreamReadable(e, t);
    };
    g2.wrap = function(e, t) {
      var r3, n;
      return new g2({ objectMode: (r3 = (n = e.readableObjectMode) !== null && n !== undefined ? n : e.objectMode) !== null && r3 !== undefined ? r3 : true, ...t, destroy(i2, o2) {
        Ue2.destroyer(e, i2), o2(i2);
      } }).wrap(e);
    };
  });
  Cr = E((ad, Eo) => {
    var Re2 = (se2(), pe(k2)), { ArrayPrototypeSlice: ao, Error: ba, FunctionPrototypeSymbolHasInstance: co, ObjectDefineProperty: ho, ObjectDefineProperties: ga, ObjectSetPrototypeOf: po, StringPrototypeToLowerCase: _a, Symbol: Ea, SymbolHasInstance: Sa } = I2();
    Eo.exports = m2;
    m2.WritableState = Je2;
    var { EventEmitter: ma } = Et(), ze2 = xt().Stream, { Buffer: Ft } = te2(), Ot = Se2(), { addAbortSignal: xa } = At(), { getHighWaterMark: Ra, getDefaultHighWaterMark: Aa } = Tt(), { ERR_INVALID_ARG_TYPE: Ia, ERR_METHOD_NOT_IMPLEMENTED: Ta, ERR_MULTIPLE_CALLBACK: yo, ERR_STREAM_CANNOT_PIPE: Ba, ERR_STREAM_DESTROYED: Xe2, ERR_STREAM_ALREADY_FINISHED: La, ERR_STREAM_NULL_VALUES: Na, ERR_STREAM_WRITE_AFTER_END: Fa, ERR_UNKNOWN_ENCODING: wo } = C2().codes, { errorOrDestroy: ve2 } = Ot;
    po(m2.prototype, ze2.prototype);
    po(m2, ze2);
    function Lr() {
    }
    var qe2 = Ea("kOnFinished");
    function Je2(e, t, r3) {
      typeof r3 != "boolean" && (r3 = t instanceof J2()), this.objectMode = !!(e && e.objectMode), r3 && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Ra(this, e, "writableHighWaterMark", r3) : Aa(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let n = !!(e && e.decodeStrings === false);
      this.decodeStrings = !n, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = Ca.bind(undefined, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ct(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[qe2] = [];
    }
    function Ct(e) {
      e.buffered = [], e.bufferedIndex = 0, e.allBuffers = true, e.allNoop = true;
    }
    Je2.prototype.getBuffer = function() {
      return ao(this.buffered, this.bufferedIndex);
    };
    ho(Je2.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function m2(e) {
      let t = this instanceof J2();
      if (!t && !co(m2, this))
        return new m2(e);
      this._writableState = new Je2(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && xa(e.signal, this)), ze2.call(this, e), Ot.construct(this, () => {
        let r3 = this._writableState;
        r3.writing || Fr(this, r3), Mr(this, r3);
      });
    }
    ho(m2, Sa, { __proto__: null, value: function(e) {
      return co(this, e) ? true : this !== m2 ? false : e && e._writableState instanceof Je2;
    } });
    m2.prototype.pipe = function() {
      ve2(this, new Ba);
    };
    function bo(e, t, r3, n) {
      let i2 = e._writableState;
      if (typeof r3 == "function")
        n = r3, r3 = i2.defaultEncoding;
      else {
        if (!r3)
          r3 = i2.defaultEncoding;
        else if (r3 !== "buffer" && !Ft.isEncoding(r3))
          throw new wo(r3);
        typeof n != "function" && (n = Lr);
      }
      if (t === null)
        throw new Na;
      if (!i2.objectMode)
        if (typeof t == "string")
          i2.decodeStrings !== false && (t = Ft.from(t, r3), r3 = "buffer");
        else if (t instanceof Ft)
          r3 = "buffer";
        else if (ze2._isUint8Array(t))
          t = ze2._uint8ArrayToBuffer(t), r3 = "buffer";
        else
          throw new Ia("chunk", ["string", "Buffer", "Uint8Array"], t);
      let o2;
      return i2.ending ? o2 = new Fa : i2.destroyed && (o2 = new Xe2("write")), o2 ? (Re2.nextTick(n, o2), ve2(e, o2, true), o2) : (i2.pendingcb++, Ma(e, i2, t, r3, n));
    }
    m2.prototype.write = function(e, t, r3) {
      return bo(this, e, t, r3) === true;
    };
    m2.prototype.cork = function() {
      this._writableState.corked++;
    };
    m2.prototype.uncork = function() {
      let e = this._writableState;
      e.corked && (e.corked--, e.writing || Fr(this, e));
    };
    m2.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = _a(t)), !Ft.isEncoding(t))
        throw new wo(t);
      return this._writableState.defaultEncoding = t, this;
    };
    function Ma(e, t, r3, n, i2) {
      let o2 = t.objectMode ? 1 : r3.length;
      t.length += o2;
      let l2 = t.length < t.highWaterMark;
      return l2 || (t.needDrain = true), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({ chunk: r3, encoding: n, callback: i2 }), t.allBuffers && n !== "buffer" && (t.allBuffers = false), t.allNoop && i2 !== Lr && (t.allNoop = false)) : (t.writelen = o2, t.writecb = i2, t.writing = true, t.sync = true, e._write(r3, n, t.onwrite), t.sync = false), l2 && !t.errored && !t.destroyed;
    }
    function fo(e, t, r3, n, i2, o2, l2) {
      t.writelen = n, t.writecb = l2, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new Xe2("write")) : r3 ? e._writev(i2, t.onwrite) : e._write(i2, o2, t.onwrite), t.sync = false;
    }
    function so(e, t, r3, n) {
      --t.pendingcb, n(r3), Nr(t), ve2(e, r3);
    }
    function Ca(e, t) {
      let r3 = e._writableState, n = r3.sync, i2 = r3.writecb;
      if (typeof i2 != "function") {
        ve2(e, new yo);
        return;
      }
      r3.writing = false, r3.writecb = null, r3.length -= r3.writelen, r3.writelen = 0, t ? (t.stack, r3.errored || (r3.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), n ? Re2.nextTick(so, e, r3, t, i2) : so(e, r3, t, i2)) : (r3.buffered.length > r3.bufferedIndex && Fr(e, r3), n ? r3.afterWriteTickInfo !== null && r3.afterWriteTickInfo.cb === i2 ? r3.afterWriteTickInfo.count++ : (r3.afterWriteTickInfo = { count: 1, cb: i2, stream: e, state: r3 }, Re2.nextTick(Oa, r3.afterWriteTickInfo)) : go(e, r3, 1, i2));
    }
    function Oa({ stream: e, state: t, count: r3, cb: n }) {
      return t.afterWriteTickInfo = null, go(e, t, r3, n);
    }
    function go(e, t, r3, n) {
      for (!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));r3-- > 0; )
        t.pendingcb--, n();
      t.destroyed && Nr(t), Mr(e, t);
    }
    function Nr(e) {
      if (e.writing)
        return;
      for (let i2 = e.bufferedIndex;i2 < e.buffered.length; ++i2) {
        var t;
        let { chunk: o2, callback: l2 } = e.buffered[i2], u2 = e.objectMode ? 1 : o2.length;
        e.length -= u2, l2((t = e.errored) !== null && t !== undefined ? t : new Xe2("write"));
      }
      let r3 = e[qe2].splice(0);
      for (let i2 = 0;i2 < r3.length; i2++) {
        var n;
        r3[i2]((n = e.errored) !== null && n !== undefined ? n : new Xe2("end"));
      }
      Ct(e);
    }
    function Fr(e, t) {
      if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
        return;
      let { buffered: r3, bufferedIndex: n, objectMode: i2 } = t, o2 = r3.length - n;
      if (!o2)
        return;
      let l2 = n;
      if (t.bufferProcessing = true, o2 > 1 && e._writev) {
        t.pendingcb -= o2 - 1;
        let u2 = t.allNoop ? Lr : (s2) => {
          for (let d = l2;d < r3.length; ++d)
            r3[d].callback(s2);
        }, f2 = t.allNoop && l2 === 0 ? r3 : ao(r3, l2);
        f2.allBuffers = t.allBuffers, fo(e, t, true, t.length, f2, "", u2), Ct(t);
      } else {
        do {
          let { chunk: u2, encoding: f2, callback: s2 } = r3[l2];
          r3[l2++] = null;
          let d = i2 ? 1 : u2.length;
          fo(e, t, false, d, u2, f2, s2);
        } while (l2 < r3.length && !t.writing);
        l2 === r3.length ? Ct(t) : l2 > 256 ? (r3.splice(0, l2), t.bufferedIndex = 0) : t.bufferedIndex = l2;
      }
      t.bufferProcessing = false;
    }
    m2.prototype._write = function(e, t, r3) {
      if (this._writev)
        this._writev([{ chunk: e, encoding: t }], r3);
      else
        throw new Ta("_write()");
    };
    m2.prototype._writev = null;
    m2.prototype.end = function(e, t, r3) {
      let n = this._writableState;
      typeof e == "function" ? (r3 = e, e = null, t = null) : typeof t == "function" && (r3 = t, t = null);
      let i2;
      if (e != null) {
        let o2 = bo(this, e, t);
        o2 instanceof ba && (i2 = o2);
      }
      return n.corked && (n.corked = 1, this.uncork()), i2 || (!n.errored && !n.ending ? (n.ending = true, Mr(this, n, true), n.ended = true) : n.finished ? i2 = new La("end") : n.destroyed && (i2 = new Xe2("end"))), typeof r3 == "function" && (i2 || n.finished ? Re2.nextTick(r3, i2) : n[qe2].push(r3)), this;
    };
    function Mt(e) {
      return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Da(e, t) {
      let r3 = false;
      function n(i2) {
        if (r3) {
          ve2(e, i2 ?? yo());
          return;
        }
        if (r3 = true, t.pendingcb--, i2) {
          let o2 = t[qe2].splice(0);
          for (let l2 = 0;l2 < o2.length; l2++)
            o2[l2](i2);
          ve2(e, i2, t.sync);
        } else
          Mt(t) && (t.prefinished = true, e.emit("prefinish"), t.pendingcb++, Re2.nextTick(Br, e, t));
      }
      t.sync = true, t.pendingcb++;
      try {
        e._final(n);
      } catch (i2) {
        n(i2);
      }
      t.sync = false;
    }
    function Pa(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = true, Da(e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Mr(e, t, r3) {
      Mt(t) && (Pa(e, t), t.pendingcb === 0 && (r3 ? (t.pendingcb++, Re2.nextTick((n, i2) => {
        Mt(i2) ? Br(n, i2) : i2.pendingcb--;
      }, e, t)) : Mt(t) && (t.pendingcb++, Br(e, t))));
    }
    function Br(e, t) {
      t.pendingcb--, t.finished = true;
      let r3 = t[qe2].splice(0);
      for (let n = 0;n < r3.length; n++)
        r3[n]();
      if (e.emit("finish"), t.autoDestroy) {
        let n = e._readableState;
        (!n || n.autoDestroy && (n.endEmitted || n.readable === false)) && e.destroy();
      }
    }
    ga(m2.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(e) {
      this._writableState && (this._writableState.destroyed = e);
    } }, writable: { __proto__: null, get() {
      let e = this._writableState;
      return !!e && e.writable !== false && !e.destroyed && !e.errored && !e.ending && !e.ended;
    }, set(e) {
      this._writableState && (this._writableState.writable = !!e);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let e = this._writableState;
      return e ? !e.destroyed && !e.ending && e.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var ka = Ot.destroy;
    m2.prototype.destroy = function(e, t) {
      let r3 = this._writableState;
      return !r3.destroyed && (r3.bufferedIndex < r3.buffered.length || r3[qe2].length) && Re2.nextTick(Nr, r3), ka.call(this, e, t), this;
    };
    m2.prototype._undestroy = Ot.undestroy;
    m2.prototype._destroy = function(e, t) {
      t(e);
    };
    m2.prototype[ma.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    var Tr;
    function _o() {
      return Tr === undefined && (Tr = {}), Tr;
    }
    m2.fromWeb = function(e, t) {
      return _o().newStreamWritableFromWritableStream(e, t);
    };
    m2.toWeb = function(e) {
      return _o().newWritableStreamFromStreamWritable(e);
    };
  });
  Mo = E((cd, Fo) => {
    var Or = (se2(), pe(k2)), Ua = te2(), { isReadable: va, isWritable: qa, isIterable: So, isNodeStream: Wa, isReadableNodeStream: mo, isWritableNodeStream: xo, isDuplexNodeStream: $a } = ae2(), Ro = ce2(), { AbortError: No, codes: { ERR_INVALID_ARG_TYPE: ja, ERR_INVALID_RETURN_VALUE: Ao } } = C2(), { destroyer: We2 } = Se2(), Ga = J2(), Ha = Ke2(), { createDeferredPromise: Io } = V2(), To = Er(), Bo = globalThis.Blob || Ua.Blob, Va = typeof Bo < "u" ? function(t) {
      return t instanceof Bo;
    } : function(t) {
      return false;
    }, Ya = globalThis.AbortController || ut2().AbortController, { FunctionPrototypeCall: Lo } = I2(), Ae2 = class extends Ga {
      constructor(t) {
        super(t), t?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Fo.exports = function e(t, r3) {
      if ($a(t))
        return t;
      if (mo(t))
        return Dt({ readable: t });
      if (xo(t))
        return Dt({ writable: t });
      if (Wa(t))
        return Dt({ writable: false, readable: false });
      if (typeof t == "function") {
        let { value: i2, write: o2, final: l2, destroy: u2 } = Ka(t);
        if (So(i2))
          return To(Ae2, i2, { objectMode: true, write: o2, final: l2, destroy: u2 });
        let f2 = i2?.then;
        if (typeof f2 == "function") {
          let s2, d = Lo(f2, i2, (c2) => {
            if (c2 != null)
              throw new Ao("nully", "body", c2);
          }, (c2) => {
            We2(s2, c2);
          });
          return s2 = new Ae2({ objectMode: true, readable: false, write: o2, final(c2) {
            l2(async () => {
              try {
                await d, Or.nextTick(c2, null);
              } catch (y2) {
                Or.nextTick(c2, y2);
              }
            });
          }, destroy: u2 });
        }
        throw new Ao("Iterable, AsyncIterable or AsyncFunction", r3, i2);
      }
      if (Va(t))
        return e(t.arrayBuffer());
      if (So(t))
        return To(Ae2, t, { objectMode: true, writable: false });
      if (typeof t?.writable == "object" || typeof t?.readable == "object") {
        let i2 = t != null && t.readable ? mo(t?.readable) ? t?.readable : e(t.readable) : undefined, o2 = t != null && t.writable ? xo(t?.writable) ? t?.writable : e(t.writable) : undefined;
        return Dt({ readable: i2, writable: o2 });
      }
      let n = t?.then;
      if (typeof n == "function") {
        let i2;
        return Lo(n, t, (o2) => {
          o2 != null && i2.push(o2), i2.push(null);
        }, (o2) => {
          We2(i2, o2);
        }), i2 = new Ae2({ objectMode: true, writable: false, read() {
        } });
      }
      throw new ja(r3, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t);
    };
    function Ka(e) {
      let { promise: t, resolve: r3 } = Io(), n = new Ya, i2 = n.signal;
      return { value: e(async function* () {
        for (;; ) {
          let l2 = t;
          t = null;
          let { chunk: u2, done: f2, cb: s2 } = await l2;
          if (Or.nextTick(s2), f2)
            return;
          if (i2.aborted)
            throw new No(undefined, { cause: i2.reason });
          ({ promise: t, resolve: r3 } = Io()), yield u2;
        }
      }(), { signal: i2 }), write(l2, u2, f2) {
        let s2 = r3;
        r3 = null, s2({ chunk: l2, done: false, cb: f2 });
      }, final(l2) {
        let u2 = r3;
        r3 = null, u2({ done: true, cb: l2 });
      }, destroy(l2, u2) {
        n.abort(), u2(l2);
      } };
    }
    function Dt(e) {
      let t = e.readable && typeof e.readable.read != "function" ? Ha.wrap(e.readable) : e.readable, r3 = e.writable, n = !!va(t), i2 = !!qa(r3), o2, l2, u2, f2, s2;
      function d(c2) {
        let y2 = f2;
        f2 = null, y2 ? y2(c2) : c2 ? s2.destroy(c2) : !n && !i2 && s2.destroy();
      }
      return s2 = new Ae2({ readableObjectMode: !!(t != null && t.readableObjectMode), writableObjectMode: !!(r3 != null && r3.writableObjectMode), readable: n, writable: i2 }), i2 && (Ro(r3, (c2) => {
        i2 = false, c2 && We2(t, c2), d(c2);
      }), s2._write = function(c2, y2, h) {
        r3.write(c2, y2) ? h() : o2 = h;
      }, s2._final = function(c2) {
        r3.end(), l2 = c2;
      }, r3.on("drain", function() {
        if (o2) {
          let c2 = o2;
          o2 = null, c2();
        }
      }), r3.on("finish", function() {
        if (l2) {
          let c2 = l2;
          l2 = null, c2();
        }
      })), n && (Ro(t, (c2) => {
        n = false, c2 && We2(t, c2), d(c2);
      }), t.on("readable", function() {
        if (u2) {
          let c2 = u2;
          u2 = null, c2();
        }
      }), t.on("end", function() {
        s2.push(null);
      }), s2._read = function() {
        for (;; ) {
          let c2 = t.read();
          if (c2 === null) {
            u2 = s2._read;
            return;
          }
          if (!s2.push(c2))
            return;
        }
      }), s2._destroy = function(c2, y2) {
        !c2 && f2 !== null && (c2 = new No), u2 = null, o2 = null, l2 = null, f2 === null ? y2(c2) : (f2 = y2, We2(r3, c2), We2(t, c2));
      }, s2;
    }
  });
  J2 = E((dd, Do) => {
    var { ObjectDefineProperties: za, ObjectGetOwnPropertyDescriptor: ie2, ObjectKeys: Xa, ObjectSetPrototypeOf: Co } = I2();
    Do.exports = j2;
    var kr = Ke2(), U2 = Cr();
    Co(j2.prototype, kr.prototype);
    Co(j2, kr);
    {
      let e = Xa(U2.prototype);
      for (let t = 0;t < e.length; t++) {
        let r3 = e[t];
        j2.prototype[r3] || (j2.prototype[r3] = U2.prototype[r3]);
      }
    }
    function j2(e) {
      if (!(this instanceof j2))
        return new j2(e);
      kr.call(this, e), U2.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== false, e.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    za(j2.prototype, { writable: { __proto__: null, ...ie2(U2.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ie2(U2.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ie2(U2.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ie2(U2.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ie2(U2.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ie2(U2.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ie2(U2.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ie2(U2.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ie2(U2.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(e) {
      this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } } });
    var Dr;
    function Oo() {
      return Dr === undefined && (Dr = {}), Dr;
    }
    j2.fromWeb = function(e, t) {
      return Oo().newStreamDuplexFromReadableWritablePair(e, t);
    };
    j2.toWeb = function(e) {
      return Oo().newReadableWritablePairFromDuplex(e);
    };
    var Pr;
    j2.from = function(e) {
      return Pr || (Pr = Mo()), Pr(e, "body");
    };
  });
  qr = E((hd, ko) => {
    var { ObjectSetPrototypeOf: Po, Symbol: Ja } = I2();
    ko.exports = oe2;
    var { ERR_METHOD_NOT_IMPLEMENTED: Qa } = C2().codes, vr = J2(), { getHighWaterMark: Za } = Tt();
    Po(oe2.prototype, vr.prototype);
    Po(oe2, vr);
    var Qe2 = Ja("kCallback");
    function oe2(e) {
      if (!(this instanceof oe2))
        return new oe2(e);
      let t = e ? Za(this, e, "readableHighWaterMark", true) : null;
      t === 0 && (e = { ...e, highWaterMark: null, readableHighWaterMark: t, writableHighWaterMark: e.writableHighWaterMark || 0 }), vr.call(this, e), this._readableState.sync = false, this[Qe2] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ec);
    }
    function Ur(e) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((t, r3) => {
        if (t) {
          e ? e(t) : this.destroy(t);
          return;
        }
        r3 != null && this.push(r3), this.push(null), e && e();
      }) : (this.push(null), e && e());
    }
    function ec() {
      this._final !== Ur && Ur.call(this);
    }
    oe2.prototype._final = Ur;
    oe2.prototype._transform = function(e, t, r3) {
      throw new Qa("_transform()");
    };
    oe2.prototype._write = function(e, t, r3) {
      let n = this._readableState, i2 = this._writableState, o2 = n.length;
      this._transform(e, t, (l2, u2) => {
        if (l2) {
          r3(l2);
          return;
        }
        u2 != null && this.push(u2), i2.ended || o2 === n.length || n.length < n.highWaterMark ? r3() : this[Qe2] = r3;
      });
    };
    oe2.prototype._read = function() {
      if (this[Qe2]) {
        let e = this[Qe2];
        this[Qe2] = null, e();
      }
    };
  });
  $r = E((pd, vo) => {
    var { ObjectSetPrototypeOf: Uo } = I2();
    vo.exports = $e2;
    var Wr = qr();
    Uo($e2.prototype, Wr.prototype);
    Uo($e2, Wr);
    function $e2(e) {
      if (!(this instanceof $e2))
        return new $e2(e);
      Wr.call(this, e);
    }
    $e2.prototype._transform = function(e, t, r3) {
      r3(null, e);
    };
  });
  Ut = E((yd, Vo) => {
    var Pt = (se2(), pe(k2)), { ArrayIsArray: tc, Promise: rc, SymbolAsyncIterator: nc } = I2(), kt = ce2(), { once: ic } = V2(), oc = Se2(), qo = J2(), { aggregateTwoErrors: lc, codes: { ERR_INVALID_ARG_TYPE: Go, ERR_INVALID_RETURN_VALUE: jr, ERR_MISSING_ARGS: uc, ERR_STREAM_DESTROYED: fc, ERR_STREAM_PREMATURE_CLOSE: sc }, AbortError: ac } = C2(), { validateFunction: cc, validateAbortSignal: dc } = He2(), { isIterable: je2, isReadable: Gr, isReadableNodeStream: Yr, isNodeStream: Wo } = ae2(), hc = globalThis.AbortController || ut2().AbortController, Hr, Vr;
    function $o(e, t, r3) {
      let n = false;
      e.on("close", () => {
        n = true;
      });
      let i2 = kt(e, { readable: t, writable: r3 }, (o2) => {
        n = !o2;
      });
      return { destroy: (o2) => {
        n || (n = true, oc.destroyer(e, o2 || new fc("pipe")));
      }, cleanup: i2 };
    }
    function pc(e) {
      return cc(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function yc(e) {
      if (je2(e))
        return e;
      if (Yr(e))
        return wc(e);
      throw new Go("val", ["Readable", "Iterable", "AsyncIterable"], e);
    }
    async function* wc(e) {
      Vr || (Vr = Ke2()), yield* Vr.prototype[nc].call(e);
    }
    async function jo(e, t, r3, { end: n }) {
      let i2, o2 = null, l2 = (s2) => {
        if (s2 && (i2 = s2), o2) {
          let d = o2;
          o2 = null, d();
        }
      }, u2 = () => new rc((s2, d) => {
        i2 ? d(i2) : o2 = () => {
          i2 ? d(i2) : s2();
        };
      });
      t.on("drain", l2);
      let f2 = kt(t, { readable: false }, l2);
      try {
        t.writableNeedDrain && await u2();
        for await (let s2 of e)
          t.write(s2) || await u2();
        n && t.end(), await u2(), r3();
      } catch (s2) {
        r3(i2 !== s2 ? lc(i2, s2) : s2);
      } finally {
        f2(), t.off("drain", l2);
      }
    }
    function bc(...e) {
      return Ho(e, ic(pc(e)));
    }
    function Ho(e, t, r3) {
      if (e.length === 1 && tc(e[0]) && (e = e[0]), e.length < 2)
        throw new uc("streams");
      let n = new hc, i2 = n.signal, o2 = r3?.signal, l2 = [];
      dc(o2, "options.signal");
      function u2() {
        h(new ac);
      }
      o2?.addEventListener("abort", u2);
      let f2, s2, d = [], c2 = 0;
      function y2(w2) {
        h(w2, --c2 === 0);
      }
      function h(w2, b) {
        if (w2 && (!f2 || f2.code === "ERR_STREAM_PREMATURE_CLOSE") && (f2 = w2), !(!f2 && !b)) {
          for (;d.length; )
            d.shift()(f2);
          o2?.removeEventListener("abort", u2), n.abort(), b && (f2 || l2.forEach((L2) => L2()), Pt.nextTick(t, f2, s2));
        }
      }
      let p2;
      for (let w2 = 0;w2 < e.length; w2++) {
        let b = e[w2], L2 = w2 < e.length - 1, N2 = w2 > 0, Q2 = L2 || r3?.end !== false, Ie2 = w2 === e.length - 1;
        if (Wo(b)) {
          let q2 = function(Z2) {
            Z2 && Z2.name !== "AbortError" && Z2.code !== "ERR_STREAM_PREMATURE_CLOSE" && y2(Z2);
          };
          var v2 = q2;
          if (Q2) {
            let { destroy: Z2, cleanup: qt } = $o(b, L2, N2);
            d.push(Z2), Gr(b) && Ie2 && l2.push(qt);
          }
          b.on("error", q2), Gr(b) && Ie2 && l2.push(() => {
            b.removeListener("error", q2);
          });
        }
        if (w2 === 0)
          if (typeof b == "function") {
            if (p2 = b({ signal: i2 }), !je2(p2))
              throw new jr("Iterable, AsyncIterable or Stream", "source", p2);
          } else
            je2(b) || Yr(b) ? p2 = b : p2 = qo.from(b);
        else if (typeof b == "function")
          if (p2 = yc(p2), p2 = b(p2, { signal: i2 }), L2) {
            if (!je2(p2, true))
              throw new jr("AsyncIterable", `transform[${w2 - 1}]`, p2);
          } else {
            var B2;
            Hr || (Hr = $r());
            let q2 = new Hr({ objectMode: true }), Z2 = (B2 = p2) === null || B2 === undefined ? undefined : B2.then;
            if (typeof Z2 == "function")
              c2++, Z2.call(p2, (Te2) => {
                s2 = Te2, Te2 != null && q2.write(Te2), Q2 && q2.end(), Pt.nextTick(y2);
              }, (Te2) => {
                q2.destroy(Te2), Pt.nextTick(y2, Te2);
              });
            else if (je2(p2, true))
              c2++, jo(p2, q2, y2, { end: Q2 });
            else
              throw new jr("AsyncIterable or Promise", "destination", p2);
            p2 = q2;
            let { destroy: qt, cleanup: sl } = $o(p2, false, true);
            d.push(qt), Ie2 && l2.push(sl);
          }
        else if (Wo(b)) {
          if (Yr(p2)) {
            c2 += 2;
            let q2 = gc(p2, b, y2, { end: Q2 });
            Gr(b) && Ie2 && l2.push(q2);
          } else if (je2(p2))
            c2++, jo(p2, b, y2, { end: Q2 });
          else
            throw new Go("val", ["Readable", "Iterable", "AsyncIterable"], p2);
          p2 = b;
        } else
          p2 = qo.from(b);
      }
      return (i2 != null && i2.aborted || o2 != null && o2.aborted) && Pt.nextTick(u2), p2;
    }
    function gc(e, t, r3, { end: n }) {
      let i2 = false;
      return t.on("close", () => {
        i2 || r3(new sc);
      }), e.pipe(t, { end: n }), n ? e.once("end", () => {
        i2 = true, t.end();
      }) : r3(), kt(e, { readable: true, writable: false }, (o2) => {
        let l2 = e._readableState;
        o2 && o2.code === "ERR_STREAM_PREMATURE_CLOSE" && l2 && l2.ended && !l2.errored && !l2.errorEmitted ? e.once("end", r3).once("error", r3) : r3(o2);
      }), kt(t, { readable: false, writable: true }, r3);
    }
    Vo.exports = { pipelineImpl: Ho, pipeline: bc };
  });
  Jo = E((wd, Xo) => {
    var { pipeline: _c } = Ut(), vt2 = J2(), { destroyer: Ec } = Se2(), { isNodeStream: Sc, isReadable: Yo, isWritable: Ko } = ae2(), { AbortError: mc, codes: { ERR_INVALID_ARG_VALUE: zo, ERR_MISSING_ARGS: xc } } = C2();
    Xo.exports = function(...t) {
      if (t.length === 0)
        throw new xc("streams");
      if (t.length === 1)
        return vt2.from(t[0]);
      let r3 = [...t];
      if (typeof t[0] == "function" && (t[0] = vt2.from(t[0])), typeof t[t.length - 1] == "function") {
        let h = t.length - 1;
        t[h] = vt2.from(t[h]);
      }
      for (let h = 0;h < t.length; ++h)
        if (!!Sc(t[h])) {
          if (h < t.length - 1 && !Yo(t[h]))
            throw new zo(`streams[${h}]`, r3[h], "must be readable");
          if (h > 0 && !Ko(t[h]))
            throw new zo(`streams[${h}]`, r3[h], "must be writable");
        }
      let n, i2, o2, l2, u2;
      function f2(h) {
        let p2 = l2;
        l2 = null, p2 ? p2(h) : h ? u2.destroy(h) : !y2 && !c2 && u2.destroy();
      }
      let s2 = t[0], d = _c(t, f2), c2 = !!Ko(s2), y2 = !!Yo(d);
      return u2 = new vt2({ writableObjectMode: !!(s2 != null && s2.writableObjectMode), readableObjectMode: !!(d != null && d.writableObjectMode), writable: c2, readable: y2 }), c2 && (u2._write = function(h, p2, B2) {
        s2.write(h, p2) ? B2() : n = B2;
      }, u2._final = function(h) {
        s2.end(), i2 = h;
      }, s2.on("drain", function() {
        if (n) {
          let h = n;
          n = null, h();
        }
      }), d.on("finish", function() {
        if (i2) {
          let h = i2;
          i2 = null, h();
        }
      })), y2 && (d.on("readable", function() {
        if (o2) {
          let h = o2;
          o2 = null, h();
        }
      }), d.on("end", function() {
        u2.push(null);
      }), u2._read = function() {
        for (;; ) {
          let h = d.read();
          if (h === null) {
            o2 = u2._read;
            return;
          }
          if (!u2.push(h))
            return;
        }
      }), u2._destroy = function(h, p2) {
        !h && l2 !== null && (h = new mc), o2 = null, n = null, i2 = null, l2 === null ? p2(h) : (l2 = p2, Ec(d, h));
      }, u2;
    };
  });
  Kr = E((bd, Qo) => {
    var { ArrayPrototypePop: Rc, Promise: Ac } = I2(), { isIterable: Ic, isNodeStream: Tc } = ae2(), { pipelineImpl: Bc } = Ut(), { finished: Lc } = ce2();
    function Nc(...e) {
      return new Ac((t, r3) => {
        let n, i2, o2 = e[e.length - 1];
        if (o2 && typeof o2 == "object" && !Tc(o2) && !Ic(o2)) {
          let l2 = Rc(e);
          n = l2.signal, i2 = l2.end;
        }
        Bc(e, (l2, u2) => {
          l2 ? r3(l2) : t(u2);
        }, { signal: n, end: i2 });
      });
    }
    Qo.exports = { finished: Lc, pipeline: Nc };
  });
  fl = E((gd, ul) => {
    var { Buffer: Fc } = te2(), { ObjectDefineProperty: le2, ObjectKeys: tl, ReflectApply: rl } = I2(), { promisify: { custom: nl } } = V2(), { streamReturningOperators: Zo, promiseReturningOperators: el } = di(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: il } } = C2(), Mc = Jo(), { pipeline: ol } = Ut(), { destroyer: Cc } = Se2(), ll = ce2(), zr = Kr(), Xr = ae2(), R2 = ul.exports = xt().Stream;
    R2.isDisturbed = Xr.isDisturbed;
    R2.isErrored = Xr.isErrored;
    R2.isReadable = Xr.isReadable;
    R2.Readable = Ke2();
    for (let e of tl(Zo)) {
      let r3 = function(...n) {
        if (new.target)
          throw il();
        return R2.Readable.from(rl(t, this, n));
      };
      Dc = r3;
      let t = Zo[e];
      le2(r3, "name", { __proto__: null, value: t.name }), le2(r3, "length", { __proto__: null, value: t.length }), le2(R2.Readable.prototype, e, { __proto__: null, value: r3, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    for (let e of tl(el)) {
      let r3 = function(...i2) {
        if (new.target)
          throw il();
        return rl(t, this, i2);
      };
      Dc = r3;
      let t = el[e];
      le2(r3, "name", { __proto__: null, value: t.name }), le2(r3, "length", { __proto__: null, value: t.length }), le2(R2.Readable.prototype, e, { __proto__: null, value: r3, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    R2.Writable = Cr();
    R2.Duplex = J2();
    R2.Transform = qr();
    R2.PassThrough = $r();
    R2.pipeline = ol;
    var { addAbortSignal: Oc } = At();
    R2.addAbortSignal = Oc;
    R2.finished = ll;
    R2.destroy = Cc;
    R2.compose = Mc;
    le2(R2, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return zr;
    } });
    le2(ol, nl, { __proto__: null, enumerable: true, get() {
      return zr.pipeline;
    } });
    le2(ll, nl, { __proto__: null, enumerable: true, get() {
      return zr.finished;
    } });
    R2.Stream = R2;
    R2._isUint8Array = function(t) {
      return t instanceof Uint8Array;
    };
    R2._uint8ArrayToBuffer = function(t) {
      return Fc.from(t.buffer, t.byteOffset, t.byteLength);
    };
  });
  Jr = E((_d, A2) => {
    var T2 = fl(), Pc = Kr(), kc = T2.Readable.destroy;
    A2.exports = T2.Readable;
    A2.exports._uint8ArrayToBuffer = T2._uint8ArrayToBuffer;
    A2.exports._isUint8Array = T2._isUint8Array;
    A2.exports.isDisturbed = T2.isDisturbed;
    A2.exports.isErrored = T2.isErrored;
    A2.exports.isReadable = T2.isReadable;
    A2.exports.Readable = T2.Readable;
    A2.exports.Writable = T2.Writable;
    A2.exports.Duplex = T2.Duplex;
    A2.exports.Transform = T2.Transform;
    A2.exports.PassThrough = T2.PassThrough;
    A2.exports.addAbortSignal = T2.addAbortSignal;
    A2.exports.finished = T2.finished;
    A2.exports.destroy = T2.destroy;
    A2.exports.destroy = kc;
    A2.exports.pipeline = T2.pipeline;
    A2.exports.compose = T2.compose;
    Object.defineProperty(T2, "promises", { configurable: true, enumerable: true, get() {
      return Pc;
    } });
    A2.exports.Stream = T2.Stream;
    A2.exports.default = A2.exports;
  });
  Ze2 = {};
  Qr(Ze2, { default: () => Uc });
  ue2(Ze2, rt2(Jr()));
  Uc = rt2(Jr());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS((exports) => {
  exports.base64 = true;
  exports.array = true;
  exports.string = true;
  exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  exports.nodebuffer = typeof Buffer !== "undefined";
  exports.uint8array = typeof Uint8Array !== "undefined";
  if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
  } else {
    buffer = new ArrayBuffer(0);
    try {
      exports.blob = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      try {
        Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        builder = new Builder;
        builder.append(buffer);
        exports.blob = builder.getBlob("application/zip").size === 0;
      } catch (e2) {
        exports.blob = false;
      }
    }
  }
  var buffer;
  var Builder;
  var builder;
  try {
    exports.nodestream = !!(init_stream(), __toCommonJS(exports_stream)).Readable;
  } catch (e) {
    exports.nodestream = false;
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var utils = require_utils3();
  var support = require_support();
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i2 = 0, len = input.length, remainingBytes = len;
    var isArray = utils.getTypeOf(input) !== "string";
    while (i2 < input.length) {
      remainingBytes = len - i2;
      if (!isArray) {
        chr1 = input.charCodeAt(i2++);
        chr2 = i2 < len ? input.charCodeAt(i2++) : 0;
        chr3 = i2 < len ? input.charCodeAt(i2++) : 0;
      } else {
        chr1 = input[i2++];
        chr2 = i2 < len ? input[i2++] : 0;
        chr3 = i2 < len ? input[i2++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i2 = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i2 < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i2++));
      enc2 = _keyStr.indexOf(input.charAt(i2++));
      enc3 = _keyStr.indexOf(input.charAt(i2++));
      enc4 = _keyStr.indexOf(input.charAt(i2++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS((exports, module) => {
  module.exports = {
    isNode: typeof Buffer !== "undefined",
    newBufferFrom: function(data, encoding) {
      if (Buffer.from && Buffer.from !== Uint8Array.from) {
        return Buffer.from(data, encoding);
      } else {
        if (typeof data === "number") {
          throw new Error('The "data" argument must not be a number');
        }
        return new Buffer(data, encoding);
      }
    },
    allocBuffer: function(size5) {
      if (Buffer.alloc) {
        return Buffer.alloc(size5);
      } else {
        var buf = new Buffer(size5);
        buf.fill(0);
        return buf;
      }
    },
    isBuffer: function(b) {
      return Buffer.isBuffer(b);
    },
    isStream: function(obj) {
      return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
  };
});

// node_modules/immediate/lib/browser.js
var require_browser = __commonJS((exports, module) => {
  var Mutation = global.MutationObserver || global.WebKitMutationObserver;
  var scheduleDrain;
  {
    if (Mutation) {
      called = 0;
      observer = new Mutation(nextTick);
      element = global.document.createTextNode("");
      observer.observe(element, {
        characterData: true
      });
      scheduleDrain = function() {
        element.data = called = ++called % 2;
      };
    } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
      channel = new global.MessageChannel;
      channel.port1.onmessage = nextTick;
      scheduleDrain = function() {
        channel.port2.postMessage(0);
      };
    } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
      scheduleDrain = function() {
        var scriptEl = global.document.createElement("script");
        scriptEl.onreadystatechange = function() {
          nextTick();
          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        global.document.documentElement.appendChild(scriptEl);
      };
    } else {
      scheduleDrain = function() {
        setTimeout(nextTick, 0);
      };
    }
  }
  var called;
  var observer;
  var element;
  var channel;
  var draining;
  var queue = [];
  function nextTick() {
    draining = true;
    var i2, oldQueue;
    var len = queue.length;
    while (len) {
      oldQueue = queue;
      queue = [];
      i2 = -1;
      while (++i2 < len) {
        oldQueue[i2]();
      }
      len = queue.length;
    }
    draining = false;
  }
  module.exports = immediate;
  function immediate(task) {
    if (queue.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
});

// node_modules/lie/lib/browser.js
var require_browser2 = __commonJS((exports, module) => {
  var immediate = require_browser();
  function INTERNAL() {
  }
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  module.exports = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = undefined;
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype["finally"] = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p2 = this.constructor;
    return this.then(resolve2, reject2);
    function resolve2(value) {
      function yes() {
        return value;
      }
      return p2.resolve(callback()).then(yes);
    }
    function reject2(reason) {
      function no() {
        throw reason;
      }
      return p2.resolve(callback()).then(no);
    }
  };
  Promise2.prototype["catch"] = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise2 = new this.constructor(INTERNAL);
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise2, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise2, onFulfilled, onRejected));
    }
    return promise2;
  };
  function QueueItem(promise2, onFulfilled, onRejected) {
    this.promise = promise2;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise2, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise2, e);
      }
      if (returnValue === promise2) {
        handlers.reject(promise2, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise2, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i2 = -1;
      var len = self2.queue.length;
      while (++i2 < len) {
        self2.queue[i2].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error40) {
    self2.state = REJECTED;
    self2.outcome = error40;
    var i2 = -1;
    var len = self2.queue.length;
    while (++i2 < len) {
      self2.queue[i2].callRejected(error40);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = "success";
    } catch (e) {
      out.status = "error";
      out.value = e;
    }
    return out;
  }
  Promise2.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }
  Promise2.reject = reject;
  function reject(reason) {
    var promise2 = new this(INTERNAL);
    return handlers.reject(promise2, reason);
  }
  Promise2.all = all;
  function all(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var values2 = new Array(len);
    var resolved = 0;
    var i2 = -1;
    var promise2 = new this(INTERNAL);
    while (++i2 < len) {
      allResolver(iterable[i2], i2);
    }
    return promise2;
    function allResolver(value, i3) {
      self2.resolve(value).then(resolveFromAll, function(error40) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error40);
        }
      });
      function resolveFromAll(outValue) {
        values2[i3] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise2, values2);
        }
      }
    }
  }
  Promise2.race = race;
  function race(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var i2 = -1;
    var promise2 = new this(INTERNAL);
    while (++i2 < len) {
      resolver(iterable[i2]);
    }
    return promise2;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise2, response);
        }
      }, function(error40) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error40);
        }
      });
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS((exports, module) => {
  var ES6Promise = null;
  if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
  } else {
    ES6Promise = require_browser2();
  }
  module.exports = {
    Promise: ES6Promise
  };
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc2 = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i2 = 0;i2 < args.length; i2++) {
        args[i2] = arguments[i2 + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc2.documentElement;
      registerImmediate = function(handle) {
        var script = doc2.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc2 && "onreadystatechange" in doc2.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/jszip/lib/utils.js
var require_utils3 = __commonJS((exports) => {
  var support = require_support();
  var base643 = require_base64();
  var nodejsUtils = require_nodejsUtils();
  var external2 = require_external();
  require_setImmediate();
  function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
  }
  exports.newBlob = function(part, type) {
    exports.checkSupport("blob");
    try {
      return new Blob([part], {
        type
      });
    } catch (e) {
      try {
        var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        var builder = new Builder;
        builder.append(part);
        return builder.getBlob(type);
      } catch (e2) {
        throw new Error("Bug : can't construct the Blob.");
      }
    }
  };
  function identity3(input) {
    return input;
  }
  function stringToArrayLike(str, array2) {
    for (var i2 = 0;i2 < str.length; ++i2) {
      array2[i2] = str.charCodeAt(i2) & 255;
    }
    return array2;
  }
  var arrayToStringHelper = {
    stringifyByChunk: function(array2, type, chunk) {
      var result = [], k3 = 0, len = array2.length;
      if (len <= chunk) {
        return String.fromCharCode.apply(null, array2);
      }
      while (k3 < len) {
        if (type === "array" || type === "nodebuffer") {
          result.push(String.fromCharCode.apply(null, array2.slice(k3, Math.min(k3 + chunk, len))));
        } else {
          result.push(String.fromCharCode.apply(null, array2.subarray(k3, Math.min(k3 + chunk, len))));
        }
        k3 += chunk;
      }
      return result.join("");
    },
    stringifyByChar: function(array2) {
      var resultStr = "";
      for (var i2 = 0;i2 < array2.length; i2++) {
        resultStr += String.fromCharCode(array2[i2]);
      }
      return resultStr;
    },
    applyCanBeUsed: {
      uint8array: function() {
        try {
          return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (e) {
          return false;
        }
      }(),
      nodebuffer: function() {
        try {
          return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
        } catch (e) {
          return false;
        }
      }()
    }
  };
  function arrayLikeToString(array2) {
    var chunk = 65536, type = exports.getTypeOf(array2), canUseApply = true;
    if (type === "uint8array") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }
    if (canUseApply) {
      while (chunk > 1) {
        try {
          return arrayToStringHelper.stringifyByChunk(array2, type, chunk);
        } catch (e) {
          chunk = Math.floor(chunk / 2);
        }
      }
    }
    return arrayToStringHelper.stringifyByChar(array2);
  }
  exports.applyFromCharCode = arrayLikeToString;
  function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i2 = 0;i2 < arrayFrom.length; i2++) {
      arrayTo[i2] = arrayFrom[i2];
    }
    return arrayTo;
  }
  var transform2 = {};
  transform2["string"] = {
    string: identity3,
    array: function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform2["string"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: function(input) {
      return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
  };
  transform2["array"] = {
    string: arrayLikeToString,
    array: identity3,
    arraybuffer: function(input) {
      return new Uint8Array(input).buffer;
    },
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform2["arraybuffer"] = {
    string: function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    array: function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    arraybuffer: identity3,
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
  };
  transform2["uint8array"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return input.buffer;
    },
    uint8array: identity3,
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform2["nodebuffer"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform2["nodebuffer"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: identity3
  };
  exports.transformTo = function(outputType, input) {
    if (!input) {
      input = "";
    }
    if (!outputType) {
      return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform2[inputType][outputType](input);
    return result;
  };
  exports.resolve = function(path) {
    var parts = path.split("/");
    var result = [];
    for (var index4 = 0;index4 < parts.length; index4++) {
      var part = parts[index4];
      if (part === "." || part === "" && index4 !== 0 && index4 !== parts.length - 1) {
        continue;
      } else if (part === "..") {
        result.pop();
      } else {
        result.push(part);
      }
    }
    return result.join("/");
  };
  exports.getTypeOf = function(input) {
    if (typeof input === "string") {
      return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
      return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
      return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
      return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
      return "arraybuffer";
    }
  };
  exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
      throw new Error(type + " is not supported by this platform");
    }
  };
  exports.MAX_VALUE_16BITS = 65535;
  exports.MAX_VALUE_32BITS = -1;
  exports.pretty = function(str) {
    var res = "", code, i2;
    for (i2 = 0;i2 < (str || "").length; i2++) {
      code = str.charCodeAt(i2);
      res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
  };
  exports.delay = function(callback, args, self2) {
    setImmediate(function() {
      callback.apply(self2 || null, args || []);
    });
  };
  exports.inherits = function(ctor, superCtor) {
    var Obj = function() {
    };
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj;
  };
  exports.extend = function() {
    var result = {}, i2, attr;
    for (i2 = 0;i2 < arguments.length; i2++) {
      for (attr in arguments[i2]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i2], attr) && typeof result[attr] === "undefined") {
          result[attr] = arguments[i2][attr];
        }
      }
    }
    return result;
  };
  exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
    var promise2 = external2.Promise.resolve(inputData).then(function(data) {
      var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
      if (isBlob && typeof FileReader !== "undefined") {
        return new external2.Promise(function(resolve, reject) {
          var reader = new FileReader;
          reader.onload = function(e) {
            resolve(e.target.result);
          };
          reader.onerror = function(e) {
            reject(e.target.error);
          };
          reader.readAsArrayBuffer(data);
        });
      } else {
        return data;
      }
    });
    return promise2.then(function(data) {
      var dataType = exports.getTypeOf(data);
      if (!dataType) {
        return external2.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
      }
      if (dataType === "arraybuffer") {
        data = exports.transformTo("uint8array", data);
      } else if (dataType === "string") {
        if (isBase64) {
          data = base643.decode(data);
        } else if (isBinary) {
          if (isOptimizedBinaryString !== true) {
            data = string2binary(data);
          }
        }
      }
      return data;
    });
  };
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS((exports, module) => {
  function GenericWorker(name) {
    this.name = name || "default";
    this.streamInfo = {};
    this.generatedError = null;
    this.extraStreamInfo = {};
    this.isPaused = true;
    this.isFinished = false;
    this.isLocked = false;
    this._listeners = {
      data: [],
      end: [],
      error: []
    };
    this.previous = null;
  }
  GenericWorker.prototype = {
    push: function(chunk) {
      this.emit("data", chunk);
    },
    end: function() {
      if (this.isFinished) {
        return false;
      }
      this.flush();
      try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
      } catch (e) {
        this.emit("error", e);
      }
      return true;
    },
    error: function(e) {
      if (this.isFinished) {
        return false;
      }
      if (this.isPaused) {
        this.generatedError = e;
      } else {
        this.isFinished = true;
        this.emit("error", e);
        if (this.previous) {
          this.previous.error(e);
        }
        this.cleanUp();
      }
      return true;
    },
    on: function(name, listener) {
      this._listeners[name].push(listener);
      return this;
    },
    cleanUp: function() {
      this.streamInfo = this.generatedError = this.extraStreamInfo = null;
      this._listeners = [];
    },
    emit: function(name, arg) {
      if (this._listeners[name]) {
        for (var i2 = 0;i2 < this._listeners[name].length; i2++) {
          this._listeners[name][i2].call(this, arg);
        }
      }
    },
    pipe: function(next2) {
      return next2.registerPrevious(this);
    },
    registerPrevious: function(previous) {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.streamInfo = previous.streamInfo;
      this.mergeStreamInfo();
      this.previous = previous;
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.end();
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    },
    pause: function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = true;
      if (this.previous) {
        this.previous.pause();
      }
      return true;
    },
    resume: function() {
      if (!this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = false;
      var withError = false;
      if (this.generatedError) {
        this.error(this.generatedError);
        withError = true;
      }
      if (this.previous) {
        this.previous.resume();
      }
      return !withError;
    },
    flush: function() {
    },
    processChunk: function(chunk) {
      this.push(chunk);
    },
    withStreamInfo: function(key, value) {
      this.extraStreamInfo[key] = value;
      this.mergeStreamInfo();
      return this;
    },
    mergeStreamInfo: function() {
      for (var key in this.extraStreamInfo) {
        if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
          continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
      }
    },
    lock: function() {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.isLocked = true;
      if (this.previous) {
        this.previous.lock();
      }
    },
    toString: function() {
      var me2 = "Worker " + this.name;
      if (this.previous) {
        return this.previous + " -> " + me2;
      } else {
        return me2;
      }
    }
  };
  module.exports = GenericWorker;
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS((exports) => {
  var utils = require_utils3();
  var support = require_support();
  var nodejsUtils = require_nodejsUtils();
  var GenericWorker = require_GenericWorker();
  var _utf8len = new Array(256);
  for (i2 = 0;i2 < 256; i2++) {
    _utf8len[i2] = i2 >= 252 ? 6 : i2 >= 248 ? 5 : i2 >= 240 ? 4 : i2 >= 224 ? 3 : i2 >= 192 ? 2 : 1;
  }
  var i2;
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = function(str) {
    var buf, c2, c22, m_pos, i3, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    if (support.uint8array) {
      buf = new Uint8Array(buf_len);
    } else {
      buf = new Array(buf_len);
    }
    for (i3 = 0, m_pos = 0;i3 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i3++] = c2;
      } else if (c2 < 2048) {
        buf[i3++] = 192 | c2 >>> 6;
        buf[i3++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i3++] = 224 | c2 >>> 12;
        buf[i3++] = 128 | c2 >>> 6 & 63;
        buf[i3++] = 128 | c2 & 63;
      } else {
        buf[i3++] = 240 | c2 >>> 18;
        buf[i3++] = 128 | c2 >>> 12 & 63;
        buf[i3++] = 128 | c2 >>> 6 & 63;
        buf[i3++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  var utf8border = function(buf, max2) {
    var pos;
    max2 = max2 || buf.length;
    if (max2 > buf.length) {
      max2 = buf.length;
    }
    pos = max2 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max2;
    }
    if (pos === 0) {
      return max2;
    }
    return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
  };
  var buf2string = function(buf) {
    var i3, out, c2, c_len;
    var len = buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i3 = 0;i3 < len; ) {
      c2 = buf[i3++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i3 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i3 < len) {
        c2 = c2 << 6 | buf[i3++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    if (utf16buf.length !== out) {
      if (utf16buf.subarray) {
        utf16buf = utf16buf.subarray(0, out);
      } else {
        utf16buf.length = out;
      }
    }
    return utils.applyFromCharCode(utf16buf);
  };
  exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
      return nodejsUtils.newBufferFrom(str, "utf-8");
    }
    return string2buf(str);
  };
  exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
      return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }
    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
    return buf2string(buf);
  };
  function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  utils.inherits(Utf8DecodeWorker, GenericWorker);
  Utf8DecodeWorker.prototype.processChunk = function(chunk) {
    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: exports.utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker.prototype.flush = function() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: exports.utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  exports.Utf8DecodeWorker = Utf8DecodeWorker;
  function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
  }
  utils.inherits(Utf8EncodeWorker, GenericWorker);
  Utf8EncodeWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: exports.utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  exports.Utf8EncodeWorker = Utf8EncodeWorker;
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var utils = require_utils3();
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: utils.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  module.exports = ConvertWorker;
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS((exports, module) => {
  var Readable = (init_stream(), __toCommonJS(exports_stream)).Readable;
  var utils = require_utils3();
  utils.inherits(NodejsStreamOutputAdapter, Readable);
  function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data, meta) {
      if (!self2.push(data)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e) {
      self2.emit("error", e);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
  };
  module.exports = NodejsStreamOutputAdapter;
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS((exports, module) => {
  var utils = require_utils3();
  var ConvertWorker = require_ConvertWorker();
  var GenericWorker = require_GenericWorker();
  var base643 = require_base64();
  var support = require_support();
  var external2 = require_external();
  var NodejsStreamOutputAdapter = null;
  if (support.nodestream) {
    try {
      NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
    } catch (e) {
    }
  }
  function transformZipOutput(type, content, mimeType) {
    switch (type) {
      case "blob":
        return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
      case "base64":
        return base643.encode(content);
      default:
        return utils.transformTo(type, content);
    }
  }
  function concat(type, dataArray) {
    var i2, index4 = 0, res = null, totalLength = 0;
    for (i2 = 0;i2 < dataArray.length; i2++) {
      totalLength += dataArray[i2].length;
    }
    switch (type) {
      case "string":
        return dataArray.join("");
      case "array":
        return Array.prototype.concat.apply([], dataArray);
      case "uint8array":
        res = new Uint8Array(totalLength);
        for (i2 = 0;i2 < dataArray.length; i2++) {
          res.set(dataArray[i2], index4);
          index4 += dataArray[i2].length;
        }
        return res;
      case "nodebuffer":
        return Buffer.concat(dataArray);
      default:
        throw new Error("concat : unsupported type '" + type + "'");
    }
  }
  function accumulate(helper, updateCallback2) {
    return new external2.Promise(function(resolve, reject) {
      var dataArray = [];
      var { _internalType: chunkType, _outputType: resultType, _mimeType: mimeType } = helper;
      helper.on("data", function(data, meta) {
        dataArray.push(data);
        if (updateCallback2) {
          updateCallback2(meta);
        }
      }).on("error", function(err) {
        dataArray = [];
        reject(err);
      }).on("end", function() {
        try {
          var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
          resolve(result);
        } catch (e) {
          reject(e);
        }
        dataArray = [];
      }).resume();
    });
  }
  function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
      case "blob":
      case "arraybuffer":
        internalType = "uint8array";
        break;
      case "base64":
        internalType = "string";
        break;
    }
    try {
      this._internalType = internalType;
      this._outputType = outputType;
      this._mimeType = mimeType;
      utils.checkSupport(internalType);
      this._worker = worker.pipe(new ConvertWorker(internalType));
      worker.lock();
    } catch (e) {
      this._worker = new GenericWorker("error");
      this._worker.error(e);
    }
  }
  StreamHelper.prototype = {
    accumulate: function(updateCb) {
      return accumulate(this, updateCb);
    },
    on: function(evt, fn) {
      var self2 = this;
      if (evt === "data") {
        this._worker.on(evt, function(chunk) {
          fn.call(self2, chunk.data, chunk.meta);
        });
      } else {
        this._worker.on(evt, function() {
          utils.delay(fn, arguments, self2);
        });
      }
      return this;
    },
    resume: function() {
      utils.delay(this._worker.resume, [], this._worker);
      return this;
    },
    pause: function() {
      this._worker.pause();
      return this;
    },
    toNodejsStream: function(updateCb) {
      utils.checkSupport("nodestream");
      if (this._outputType !== "nodebuffer") {
        throw new Error(this._outputType + " is not supported by this method");
      }
      return new NodejsStreamOutputAdapter(this, {
        objectMode: this._outputType !== "nodebuffer"
      }, updateCb);
    }
  };
  module.exports = StreamHelper;
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS((exports) => {
  exports.base64 = false;
  exports.binary = false;
  exports.dir = false;
  exports.createFolders = true;
  exports.date = null;
  exports.compression = null;
  exports.compressionOptions = null;
  exports.comment = null;
  exports.unixPermissions = null;
  exports.dosPermissions = null;
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS((exports, module) => {
  var utils = require_utils3();
  var GenericWorker = require_GenericWorker();
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self2 = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self2.dataIsReady = true;
      self2.data = data;
      self2.max = data && data.length || 0;
      self2.type = utils.getTypeOf(data);
      if (!self2.isPaused) {
        self2._tickAndRepeat();
      }
    }, function(e) {
      self2.error(e);
    });
  }
  utils.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size5 = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size5);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  module.exports = DataWorker;
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  var utils = require_utils3();
  function makeTable() {
    var c2, table = [];
    for (var n = 0;n < 256; n++) {
      c2 = n;
      for (var k3 = 0;k3 < 8; k3++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n] = c2;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i2 = pos;i2 < end; i2++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i2 = pos;i2 < end; i2++) {
      crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i2)) & 255];
    }
    return crc ^ -1;
  }
  module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray = utils.getTypeOf(input) !== "string";
    if (isArray) {
      return crc32(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var crc32 = require_crc32();
  var utils = require_utils3();
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function(chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  module.exports = Crc32Probe;
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS((exports, module) => {
  var utils = require_utils3();
  var GenericWorker = require_GenericWorker();
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function(chunk) {
    if (chunk) {
      var length2 = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length2 + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  module.exports = DataLengthProbe;
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS((exports, module) => {
  var external2 = require_external();
  var DataWorker = require_DataWorker();
  var Crc32Probe = require_Crc32Probe();
  var DataLengthProbe = require_DataLengthProbe();
  function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
  }
  CompressedObject.prototype = {
    getContentWorker: function() {
      var worker = new DataWorker(external2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
      var that = this;
      worker.on("end", function() {
        if (this.streamInfo["data_length"] !== that.uncompressedSize) {
          throw new Error("Bug : uncompressed data size mismatch");
        }
      });
      return worker;
    },
    getCompressedWorker: function() {
      return new DataWorker(external2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
  };
  CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
  };
  module.exports = CompressedObject;
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS((exports, module) => {
  var StreamHelper = require_StreamHelper();
  var DataWorker = require_DataWorker();
  var utf8 = require_utf8();
  var CompressedObject = require_compressedObject();
  var GenericWorker = require_GenericWorker();
  var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;
    this._data = data;
    this._dataBinary = options.binary;
    this.options = {
      compression: options.compression,
      compressionOptions: options.compressionOptions
    };
  };
  ZipObject.prototype = {
    internalStream: function(type) {
      var result = null, outputType = "string";
      try {
        if (!type) {
          throw new Error("No output type specified.");
        }
        outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf8.Utf8DecodeWorker);
        }
      } catch (e) {
        result = new GenericWorker("error");
        result.error(e);
      }
      return new StreamHelper(result, outputType, "");
    },
    async: function(type, onUpdate) {
      return this.internalStream(type).accumulate(onUpdate);
    },
    nodeStream: function(type, onUpdate) {
      return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },
    _compressWorker: function(compression, compressionOptions) {
      if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
        return this._data.getCompressedWorker();
      } else {
        var result = this._decompressWorker();
        if (!this._dataBinary) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
      }
    },
    _decompressWorker: function() {
      if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
      } else if (this._data instanceof GenericWorker) {
        return this._data;
      } else {
        return new DataWorker(this._data);
      }
    }
  };
  var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
  var removedFn = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  };
  for (i2 = 0;i2 < removedMethods.length; i2++) {
    ZipObject.prototype[removedMethods[i2]] = removedFn;
  }
  var i2;
  module.exports = ZipObject;
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS((exports) => {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p2 in source) {
        if (_has(source, p2)) {
          obj[p2] = source[p2];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size5) {
    if (buf.length === size5) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size5);
    }
    buf.length = size5;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i2 = 0;i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    },
    flattenChunks: function(chunks) {
      var i2, l2, len, pos, chunk, result;
      len = 0;
      for (i2 = 0, l2 = chunks.length;i2 < l2; i2++) {
        len += chunks[i2].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i2 = 0, l2 = chunks.length;i2 < l2; i2++) {
        chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i2 = 0;i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports) => {
  var utils = require_common();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s2, w2) {
    s2.pending_buf[s2.pending++] = w2 & 255;
    s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
  }
  function send_bits(s2, value, length2) {
    if (s2.bi_valid > Buf_size - length2) {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      put_short(s2, s2.bi_buf);
      s2.bi_buf = value >> Buf_size - s2.bi_valid;
      s2.bi_valid += length2 - Buf_size;
    } else {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      s2.bi_valid += length2;
    }
  }
  function send_code(s2, c2, tree) {
    send_bits(s2, tree[c2 * 2], tree[c2 * 2 + 1]);
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s2) {
    if (s2.bi_valid === 16) {
      put_short(s2, s2.bi_buf);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    } else if (s2.bi_valid >= 8) {
      s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
      s2.bi_buf >>= 8;
      s2.bi_valid -= 8;
    }
  }
  function gen_bitlen(s2, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m2;
    var bits;
    var xbits;
    var f2;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s2.bl_count[bits] = 0;
    }
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h = s2.heap_max + 1;h < HEAP_SIZE; h++) {
      n = s2.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s2.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f2 = tree[n * 2];
      s2.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s2.static_len += f2 * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0) {
        bits--;
      }
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n = s2.bl_count[bits];
      while (n !== 0) {
        m2 = s2.heap[--h];
        if (m2 > max_code) {
          continue;
        }
        if (tree[m2 * 2 + 1] !== bits) {
          s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
          tree[m2 * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0;n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length2;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length2 = 0;
    for (code = 0;code < LENGTH_CODES - 1; code++) {
      base_length[code] = length2;
      for (n = 0;n < 1 << extra_lbits[code]; n++) {
        _length_code[length2++] = code;
      }
    }
    _length_code[length2 - 1] = code;
    dist = 0;
    for (code = 0;code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0;n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (;code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0;n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0;n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s2) {
    var n;
    for (n = 0;n < L_CODES; n++) {
      s2.dyn_ltree[n * 2] = 0;
    }
    for (n = 0;n < D_CODES; n++) {
      s2.dyn_dtree[n * 2] = 0;
    }
    for (n = 0;n < BL_CODES; n++) {
      s2.bl_tree[n * 2] = 0;
    }
    s2.dyn_ltree[END_BLOCK * 2] = 1;
    s2.opt_len = s2.static_len = 0;
    s2.last_lit = s2.matches = 0;
  }
  function bi_windup(s2) {
    if (s2.bi_valid > 8) {
      put_short(s2, s2.bi_buf);
    } else if (s2.bi_valid > 0) {
      s2.pending_buf[s2.pending++] = s2.bi_buf;
    }
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  }
  function copy_block(s2, buf, len, header) {
    bi_windup(s2);
    if (header) {
      put_short(s2, len);
      put_short(s2, ~len);
    }
    utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
    s2.pending += len;
  }
  function smaller(tree, n, m2, depth) {
    var _n2 = n * 2;
    var _m2 = m2 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
  }
  function pqdownheap(s2, tree, k3) {
    var v2 = s2.heap[k3];
    var j2 = k3 << 1;
    while (j2 <= s2.heap_len) {
      if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
        j2++;
      }
      if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
        break;
      }
      s2.heap[k3] = s2.heap[j2];
      k3 = j2;
      j2 <<= 1;
    }
    s2.heap[k3] = v2;
  }
  function compress_block(s2, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s2.last_lit !== 0) {
      do {
        dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
        lc = s2.pending_buf[s2.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s2, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s2, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s2, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s2, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s2, dist, extra);
          }
        }
      } while (lx < s2.last_lit);
    }
    send_code(s2, END_BLOCK, ltree);
  }
  function build_tree(s2, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m2;
    var max_code = -1;
    var node2;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE;
    for (n = 0;n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n;
        s2.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node2 * 2] = 1;
      s2.depth[node2] = 0;
      s2.opt_len--;
      if (has_stree) {
        s2.static_len -= stree[node2 * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s2.heap_len >> 1;n >= 1; n--) {
      pqdownheap(s2, tree, n);
    }
    node2 = elems;
    do {
      n = s2.heap[1];
      s2.heap[1] = s2.heap[s2.heap_len--];
      pqdownheap(s2, tree, 1);
      m2 = s2.heap[1];
      s2.heap[--s2.heap_max] = n;
      s2.heap[--s2.heap_max] = m2;
      tree[node2 * 2] = tree[n * 2] + tree[m2 * 2];
      s2.depth[node2] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
      tree[n * 2 + 1] = tree[m2 * 2 + 1] = node2;
      s2.heap[1] = node2++;
      pqdownheap(s2, tree, 1);
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[1];
    gen_bitlen(s2, desc);
    gen_codes(tree, max_code, s2.bl_count);
  }
  function scan_tree(s2, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count2 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count2 < max_count && curlen === nextlen) {
        continue;
      } else if (count2 < min_count) {
        s2.bl_tree[curlen * 2] += count2;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s2.bl_tree[curlen * 2]++;
        }
        s2.bl_tree[REP_3_6 * 2]++;
      } else if (count2 <= 10) {
        s2.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s2.bl_tree[REPZ_11_138 * 2]++;
      }
      count2 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s2, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count2 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count2 < max_count && curlen === nextlen) {
        continue;
      } else if (count2 < min_count) {
        do {
          send_code(s2, curlen, s2.bl_tree);
        } while (--count2 !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s2, curlen, s2.bl_tree);
          count2--;
        }
        send_code(s2, REP_3_6, s2.bl_tree);
        send_bits(s2, count2 - 3, 2);
      } else if (count2 <= 10) {
        send_code(s2, REPZ_3_10, s2.bl_tree);
        send_bits(s2, count2 - 3, 3);
      } else {
        send_code(s2, REPZ_11_138, s2.bl_tree);
        send_bits(s2, count2 - 11, 7);
      }
      count2 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s2) {
    var max_blindex;
    scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
    scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
    build_tree(s2, s2.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s2, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s2, lcodes - 257, 5);
    send_bits(s2, dcodes - 1, 5);
    send_bits(s2, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s2, s2.dyn_ltree, lcodes - 1);
    send_tree(s2, s2.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s2) {
    var black_mask = 4093624447;
    var n;
    for (n = 0;n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32;n < LITERALS; n++) {
      if (s2.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s2) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
    s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
    s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
    init_block(s2);
  }
  function _tr_stored_block(s2, buf, stored_len, last) {
    send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s2, buf, stored_len, true);
  }
  function _tr_align(s2) {
    send_bits(s2, STATIC_TREES << 1, 3);
    send_code(s2, END_BLOCK, static_ltree);
    bi_flush(s2);
  }
  function _tr_flush_block(s2, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s2.level > 0) {
      if (s2.strm.data_type === Z_UNKNOWN) {
        s2.strm.data_type = detect_data_type(s2);
      }
      build_tree(s2, s2.l_desc);
      build_tree(s2, s2.d_desc);
      max_blindex = build_bl_tree(s2);
      opt_lenb = s2.opt_len + 3 + 7 >>> 3;
      static_lenb = s2.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s2, buf, stored_len, last);
    } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s2, static_ltree, static_dtree);
    } else {
      send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
    }
    init_block(s2);
    if (last) {
      bi_windup(s2);
    }
  }
  function _tr_tally(s2, dist, lc) {
    s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
    s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
    s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
    s2.last_lit++;
    if (dist === 0) {
      s2.dyn_ltree[lc * 2]++;
    } else {
      s2.matches++;
      dist--;
      s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s2.dyn_dtree[d_code(dist) * 2]++;
    }
    return s2.last_lit === s2.lit_bufsize - 1;
  }
  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports, module) => {
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  module.exports = adler32;
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS((exports, module) => {
  function makeTable() {
    var c2, table = [];
    for (var n = 0;n < 256; n++) {
      c2 = n;
      for (var k3 = 0;k3 < 8; k3++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n] = c2;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i2 = pos;i2 < end; i2++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  }
  module.exports = crc32;
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports, module) => {
  module.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports) => {
  var utils = require_common();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f2) {
    return (f2 << 1) - (f2 > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s2 = strm.state;
    var len = s2.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
    strm.next_out += len;
    s2.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s2.pending -= len;
    if (s2.pending === 0) {
      s2.pending_out = 0;
    }
  }
  function flush_block_only(s2, last) {
    trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
    s2.block_start = s2.strstart;
    flush_pending(s2.strm);
  }
  function put_byte(s2, b) {
    s2.pending_buf[s2.pending++] = b;
  }
  function putShortMSB(s2, b) {
    s2.pending_buf[s2.pending++] = b >>> 8 & 255;
    s2.pending_buf[s2.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size5) {
    var len = strm.avail_in;
    if (len > size5) {
      len = size5;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s2, cur_match) {
    var chain_length = s2.max_chain_length;
    var scan = s2.strstart;
    var match2;
    var len;
    var best_len = s2.prev_length;
    var nice_match = s2.nice_match;
    var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s2.window;
    var wmask = s2.w_mask;
    var prev2 = s2.prev;
    var strend = s2.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s2.prev_length >= s2.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s2.lookahead) {
      nice_match = s2.lookahead;
    }
    do {
      match2 = cur_match;
      if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match2++;
      do {
      } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s2.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s2.lookahead) {
      return best_len;
    }
    return s2.lookahead;
  }
  function fill_window(s2) {
    var _w_size = s2.w_size;
    var p2, n, m2, more, str;
    do {
      more = s2.window_size - s2.lookahead - s2.strstart;
      if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
        s2.match_start -= _w_size;
        s2.strstart -= _w_size;
        s2.block_start -= _w_size;
        n = s2.hash_size;
        p2 = n;
        do {
          m2 = s2.head[--p2];
          s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
        } while (--n);
        n = _w_size;
        p2 = n;
        do {
          m2 = s2.prev[--p2];
          s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s2.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
      s2.lookahead += n;
      if (s2.lookahead + s2.insert >= MIN_MATCH) {
        str = s2.strstart - s2.insert;
        s2.ins_h = s2.window[str];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
        while (s2.insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
          s2.insert--;
          if (s2.lookahead + s2.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
  }
  function deflate_stored(s2, flush) {
    var max_block_size = 65535;
    if (max_block_size > s2.pending_buf_size - 5) {
      max_block_size = s2.pending_buf_size - 5;
    }
    for (;; ) {
      if (s2.lookahead <= 1) {
        fill_window(s2);
        if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.strstart += s2.lookahead;
      s2.lookahead = 0;
      var max_start = s2.block_start + max_block_size;
      if (s2.strstart === 0 || s2.strstart >= max_start) {
        s2.lookahead = s2.strstart - max_start;
        s2.strstart = max_start;
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.strstart > s2.block_start) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s2, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
          s2.match_length--;
          do {
            s2.strstart++;
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          } while (--s2.match_length !== 0);
          s2.strstart++;
        } else {
          s2.strstart += s2.match_length;
          s2.match_length = 0;
          s2.ins_h = s2.window[s2.strstart];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s2, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      s2.prev_length = s2.match_length;
      s2.prev_match = s2.match_start;
      s2.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
        if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
          s2.match_length = MIN_MATCH - 1;
        }
      }
      if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
        max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
        s2.lookahead -= s2.prev_length - 1;
        s2.prev_length -= 2;
        do {
          if (++s2.strstart <= max_insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
        } while (--s2.prev_length !== 0);
        s2.match_available = 0;
        s2.match_length = MIN_MATCH - 1;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        if (bflush) {
          flush_block_only(s2, false);
        }
        s2.strstart++;
        s2.lookahead--;
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s2.match_available = 1;
        s2.strstart++;
        s2.lookahead--;
      }
    }
    if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      s2.match_available = 0;
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s2, flush) {
    var bflush;
    var prev2;
    var scan, strend;
    var _win = s2.window;
    for (;; ) {
      if (s2.lookahead <= MAX_MATCH) {
        fill_window(s2);
        if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.match_length = 0;
      if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
        scan = s2.strstart - 1;
        prev2 = _win[scan];
        if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
          strend = s2.strstart + MAX_MATCH;
          do {
          } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
          s2.match_length = MAX_MATCH - (strend - scan);
          if (s2.match_length > s2.lookahead) {
            s2.match_length = s2.lookahead;
          }
        }
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        s2.strstart += s2.match_length;
        s2.match_length = 0;
      } else {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s2, flush) {
    var bflush;
    for (;; ) {
      if (s2.lookahead === 0) {
        fill_window(s2);
        if (s2.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s2.match_length = 0;
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  function lm_init(s2) {
    s2.window_size = 2 * s2.w_size;
    zero(s2.head);
    s2.max_lazy_match = configuration_table[s2.level].max_lazy;
    s2.good_match = configuration_table[s2.level].good_length;
    s2.nice_match = configuration_table[s2.level].nice_length;
    s2.max_chain_length = configuration_table[s2.level].max_chain;
    s2.strstart = 0;
    s2.block_start = 0;
    s2.lookahead = 0;
    s2.insert = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    s2.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s2;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s2 = strm.state;
    s2.pending = 0;
    s2.pending_out = 0;
    if (s2.wrap < 0) {
      s2.wrap = -s2.wrap;
    }
    s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s2.wrap === 2 ? 0 : 1;
    s2.last_flush = Z_NO_FLUSH;
    trees._tr_init(s2);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s2 = new DeflateState;
    strm.state = s2;
    s2.strm = strm;
    s2.wrap = wrap;
    s2.gzhead = null;
    s2.w_bits = windowBits;
    s2.w_size = 1 << s2.w_bits;
    s2.w_mask = s2.w_size - 1;
    s2.hash_bits = memLevel + 7;
    s2.hash_size = 1 << s2.hash_bits;
    s2.hash_mask = s2.hash_size - 1;
    s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s2.window = new utils.Buf8(s2.w_size * 2);
    s2.head = new utils.Buf16(s2.hash_size);
    s2.prev = new utils.Buf16(s2.w_size);
    s2.lit_bufsize = 1 << memLevel + 6;
    s2.pending_buf_size = s2.lit_bufsize * 4;
    s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
    s2.d_buf = 1 * s2.lit_bufsize;
    s2.l_buf = (1 + 2) * s2.lit_bufsize;
    s2.level = level;
    s2.strategy = strategy;
    s2.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate(strm, flush) {
    var old_flush, s2;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s2 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s2.strm = strm;
    old_flush = s2.last_flush;
    s2.last_flush = flush;
    if (s2.status === INIT_STATE) {
      if (s2.wrap === 2) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
        } else {
          put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s2.status = BUSY_STATE;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s2.status === EXTRA_STATE) {
      if (s2.gzhead.extra) {
        beg = s2.pending;
        while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              break;
            }
          }
          put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
          s2.gzindex++;
        }
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (s2.gzindex === s2.gzhead.extra.length) {
          s2.gzindex = 0;
          s2.status = NAME_STATE;
        }
      } else {
        s2.status = NAME_STATE;
      }
    }
    if (s2.status === NAME_STATE) {
      if (s2.gzhead.name) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.name.length) {
            val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.gzindex = 0;
          s2.status = COMMENT_STATE;
        }
      } else {
        s2.status = COMMENT_STATE;
      }
    }
    if (s2.status === COMMENT_STATE) {
      if (s2.gzhead.comment) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.comment.length) {
            val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.status = HCRC_STATE;
        }
      } else {
        s2.status = HCRC_STATE;
      }
    }
    if (s2.status === HCRC_STATE) {
      if (s2.gzhead.hcrc) {
        if (s2.pending + 2 > s2.pending_buf_size) {
          flush_pending(strm);
        }
        if (s2.pending + 2 <= s2.pending_buf_size) {
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
          s2.status = BUSY_STATE;
        }
      } else {
        s2.status = BUSY_STATE;
      }
    }
    if (s2.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
      var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s2.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s2);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s2, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s2.head);
            if (s2.lookahead === 0) {
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s2.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s2.wrap === 2) {
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      put_byte(s2, strm.adler >> 16 & 255);
      put_byte(s2, strm.adler >> 24 & 255);
      put_byte(s2, strm.total_in & 255);
      put_byte(s2, strm.total_in >> 8 & 255);
      put_byte(s2, strm.total_in >> 16 & 255);
      put_byte(s2, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s2.wrap > 0) {
      s2.wrap = -s2.wrap;
    }
    return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s2;
    var str, n;
    var wrap;
    var avail;
    var next2;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s2 = strm.state;
    wrap = s2.wrap;
    if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s2.wrap = 0;
    if (dictLength >= s2.w_size) {
      if (wrap === 0) {
        zero(s2.head);
        s2.strstart = 0;
        s2.block_start = 0;
        s2.insert = 0;
      }
      tmpDict = new utils.Buf8(s2.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
      dictionary = tmpDict;
      dictLength = s2.w_size;
    }
    avail = strm.avail_in;
    next2 = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s2);
    while (s2.lookahead >= MIN_MATCH) {
      str = s2.strstart;
      n = s2.lookahead - (MIN_MATCH - 1);
      do {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
      } while (--n);
      s2.strstart = str;
      s2.lookahead = MIN_MATCH - 1;
      fill_window(s2);
    }
    s2.strstart += s2.lookahead;
    s2.block_start = s2.strstart;
    s2.insert = s2.lookahead;
    s2.lookahead = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    strm.next_in = next2;
    strm.input = input;
    strm.avail_in = avail;
    s2.wrap = wrap;
    return Z_OK;
  }
  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = "pako deflate (from Nodeca project)";
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports) => {
  var utils = require_common();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (q2 = 0;q2 < 256; q2++) {
    _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
  }
  var q2;
  _utf8len[254] = _utf8len[254] = 1;
  exports.string2buf = function(str) {
    var buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i2 = 0, m_pos = 0;i2 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i2++] = c2;
      } else if (c2 < 2048) {
        buf[i2++] = 192 | c2 >>> 6;
        buf[i2++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i2++] = 224 | c2 >>> 12;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      } else {
        buf[i2++] = 240 | c2 >>> 18;
        buf[i2++] = 128 | c2 >>> 12 & 63;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i2 = 0;i2 < len; i2++) {
      result += String.fromCharCode(buf[i2]);
    }
    return result;
  }
  exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i2 = 0, len = buf.length;i2 < len; i2++) {
      buf[i2] = str.charCodeAt(i2);
    }
    return buf;
  };
  exports.buf2string = function(buf, max2) {
    var i2, out, c2, c_len;
    var len = max2 || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0;i2 < len; ) {
      c2 = buf[i2++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c2 = c2 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports.utf8border = function(buf, max2) {
    var pos;
    max2 = max2 || buf.length;
    if (max2 > buf.length) {
      max2 = buf.length;
    }
    pos = max2 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max2;
    }
    if (pos === 0) {
      return max2;
    }
    return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
  };
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports, module) => {
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports) => {
  var zlib_deflate = require_deflate();
  var utils = require_common();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports, module) => {
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from2;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from2 = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from2 += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from2 += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from2 += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from2++];
                        if (len > 1) {
                          output[_out++] = from_source[from2++];
                        }
                      }
                    } else {
                      from2 = _out - dist;
                      do {
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from2++];
                        if (len > 1) {
                          output[_out++] = output[from2++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports, module) => {
  var utils = require_common();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min2 = 0, max2 = 0;
    var root2 = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next2;
    var base = null;
    var base_index = 0;
    var end;
    var count2 = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0;len <= MAXBITS; len++) {
      count2[len] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count2[lens[lens_index + sym]]++;
    }
    root2 = bits;
    for (max2 = MAXBITS;max2 >= 1; max2--) {
      if (count2[max2] !== 0) {
        break;
      }
    }
    if (root2 > max2) {
      root2 = max2;
    }
    if (max2 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min2 = 1;min2 < max2; min2++) {
      if (count2[min2] !== 0) {
        break;
      }
    }
    if (root2 < min2) {
      root2 = min2;
    }
    left = 1;
    for (len = 1;len <= MAXBITS; len++) {
      left <<= 1;
      left -= count2[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max2 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1;len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count2[len];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min2;
    next2 = table_index;
    curr = root2;
    drop = 0;
    low = -1;
    used = 1 << root2;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (;; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min2 = fill;
      do {
        fill -= incr;
        table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count2[len] === 0) {
        if (len === max2) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root2 && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root2;
        }
        next2 += min2;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max2) {
          left -= count2[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root2 << 24 | curr << 16 | next2 - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root2;
    return 0;
  };
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports) => {
  var utils = require_common();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT2 = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q2) {
    return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix;
  var distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy2) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy2 >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy2) {
        dist = copy2;
      }
      utils.arraySet(state.window, src, end - copy2, dist, state.wnext);
      copy2 -= dist;
      if (copy2) {
        utils.arraySet(state.window, src, end - copy2, copy2, 0);
        state.wnext = copy2;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate(strm, flush) {
    var state;
    var input, output;
    var next2;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy2;
    var from2;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next2 = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy2 = state.length;
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next2, copy2, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next2);
                }
                have -= copy2;
                next2 += copy2;
                state.length -= copy2;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next2 + copy2++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next2);
              }
              have -= copy2;
              next2 += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT2;
          case COMMENT2:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next2 + copy2++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next2);
              }
              have -= copy2;
              next2 += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next2;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy2 = state.length;
            if (copy2) {
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              if (copy2 === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next2, copy2, put);
              have -= copy2;
              next2 += copy2;
              left -= copy2;
              put += copy2;
              state.length -= copy2;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy2 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy2 > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy2--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next2;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next2 = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy2 = _out - left;
            if (state.offset > copy2) {
              copy2 = state.offset - copy2;
              if (copy2 > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy2 > state.wnext) {
                copy2 -= state.wnext;
                from2 = state.wsize - copy2;
              } else {
                from2 = state.wnext - copy2;
              }
              if (copy2 > state.length) {
                copy2 = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from2 = put - state.offset;
              copy2 = state.length;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            left -= copy2;
            state.length -= copy2;
            do {
              output[put++] = from_source[from2++];
            } while (--copy2);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next2++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next2;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = "pako inflate (from Nodeca project)";
});

// node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports, module) => {
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports) => {
  var zlib_inflate = require_inflate();
  var utils = require_common();
  var strings = require_strings();
  var c2 = require_constants2();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c2.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c2.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
      if (status === c2.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c2.Z_BUF_ERROR && allowBufError === true) {
        status = c2.Z_OK;
        allowBufError = false;
      }
      if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
    if (status === c2.Z_STREAM_END) {
      _mode = c2.Z_FINISH;
    }
    if (_mode === c2.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c2.Z_OK;
    }
    if (_mode === c2.Z_SYNC_FLUSH) {
      this.onEnd(c2.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c2.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }
  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
});

// node_modules/pako/index.js
var require_pako = __commonJS((exports, module) => {
  var assign4 = require_common().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants = require_constants2();
  var pako = {};
  assign4(pako, deflate, inflate, constants);
  module.exports = pako;
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS((exports) => {
  var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var pako = require_pako();
  var utils = require_utils3();
  var GenericWorker = require_GenericWorker();
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  exports.magic = "\b\x00";
  function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  utils.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function() {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker.prototype._createPako = function() {
    this._pako = new pako[this._pakoAction]({
      raw: true,
      level: this._pakoOptions.level || -1
    });
    var self2 = this;
    this._pako.onData = function(data) {
      self2.push({
        data,
        meta: self2.meta
      });
    };
  };
  exports.compressWorker = function(compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  exports.uncompressWorker = function() {
    return new FlateWorker("Inflate", {});
  };
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS((exports) => {
  var GenericWorker = require_GenericWorker();
  exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function() {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function() {
      return new GenericWorker("STORE decompression");
    }
  };
  exports.DEFLATE = require_flate();
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS((exports) => {
  exports.LOCAL_FILE_HEADER = "PK\x03\x04";
  exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
  exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
  exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
  exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
  exports.DATA_DESCRIPTOR = "PK\x07\b";
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS((exports, module) => {
  var utils = require_utils3();
  var GenericWorker = require_GenericWorker();
  var utf8 = require_utf8();
  var crc32 = require_crc32();
  var signature = require_signature();
  var decToHex = function(dec, bytes) {
    var hex = "", i2;
    for (i2 = 0;i2 < bytes; i2++) {
      hex += String.fromCharCode(dec & 255);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 16893 : 33204;
    }
    return (result & 65535) << 16;
  };
  var generateDosExternalFileAttr = function(dosPermissions) {
    return (dosPermissions || 0) & 63;
  };
  var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset4, platform2, encodeFileName) {
    var file2 = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file2.name)), comment2 = file2.comment, encodedComment = utils.transformTo("string", encodeFileName(comment2)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment2)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment2.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file2.dir, date5 = file2.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo["crc32"];
      dataInfo.compressedSize = streamInfo["compressedSize"];
      dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 8;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 2048;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
      extFileAttr |= 16;
    }
    if (platform2 === "UNIX") {
      versionMadeBy = 798;
      extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir);
    } else {
      versionMadeBy = 20;
      extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions, dir);
    }
    dosTime = date5.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date5.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date5.getUTCSeconds() / 2;
    dosDate = date5.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date5.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date5.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
      extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
      extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
    }
    var header = "";
    header += `
\x00`;
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset4, 4) + encodedFileName + extraFields + encodedComment;
    return {
      fileRecord,
      dirRecord
    };
  };
  var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment2, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment2));
    dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment2, platform2, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment2;
    this.zipPlatform = platform2;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record2 = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record2.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record2 = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record2.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record2.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function() {
    var localDirLength = this.bytesWritten;
    for (var i2 = 0;i2 < this.dirRecords.length; i2++) {
      this.push({
        data: this.dirRecords[i2],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function(previous) {
    this._sources.push(previous);
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.closedSource(self2.previous.streamInfo);
      if (self2._sources.length) {
        self2.prepareNextSource();
      } else {
        self2.end();
      }
    });
    previous.on("error", function(e) {
      self2.error(e);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function(e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
      return false;
    }
    for (var i2 = 0;i2 < sources.length; i2++) {
      try {
        sources[i2].error(e);
      } catch (e2) {
      }
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function() {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i2 = 0;i2 < sources.length; i2++) {
      sources[i2].lock();
    }
  };
  module.exports = ZipFileWorker;
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS((exports) => {
  var compressions = require_compressions();
  var ZipFileWorker = require_ZipFileWorker();
  var getCompression = function(fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  exports.generateWorker = function(zip, options, comment2) {
    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment2, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {
      zip.forEach(function(relativePath, file2) {
        entriesCount++;
        var compression = getCompression(file2.options.compression, options.compression);
        var compressionOptions = file2.options.compressionOptions || options.compressionOptions || {};
        var { dir, date: date5 } = file2;
        file2._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir,
          date: date5,
          comment: file2.comment || "",
          unixPermissions: file2.unixPermissions,
          dosPermissions: file2.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
      zipFileWorker.error(e);
    }
    return zipFileWorker;
  };
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS((exports, module) => {
  var utils = require_utils3();
  var GenericWorker = require_GenericWorker();
  function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
  }
  utils.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
    var self2 = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function(chunk) {
      self2.push({
        data: chunk,
        meta: {
          percent: 0
        }
      });
    }).on("error", function(e) {
      if (self2.isPaused) {
        this.generatedError = e;
      } else {
        self2.error(e);
      }
    }).on("end", function() {
      if (self2.isPaused) {
        self2._upstreamEnded = true;
      } else {
        self2.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function() {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  module.exports = NodejsStreamInputAdapter;
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS((exports, module) => {
  var utf8 = require_utf8();
  var utils = require_utils3();
  var GenericWorker = require_GenericWorker();
  var StreamHelper = require_StreamHelper();
  var defaults = require_defaults();
  var CompressedObject = require_compressedObject();
  var ZipObject = require_zipObject();
  var generate = require_generate();
  var nodejsUtils = require_nodejsUtils();
  var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
  var fileAdd = function(name, data, originalOptions) {
    var dataType = utils.getTypeOf(data), parent;
    var o2 = utils.extend(originalOptions || {}, defaults);
    o2.date = o2.date || new Date;
    if (o2.compression !== null) {
      o2.compression = o2.compression.toUpperCase();
    }
    if (typeof o2.unixPermissions === "string") {
      o2.unixPermissions = parseInt(o2.unixPermissions, 8);
    }
    if (o2.unixPermissions && o2.unixPermissions & 16384) {
      o2.dir = true;
    }
    if (o2.dosPermissions && o2.dosPermissions & 16) {
      o2.dir = true;
    }
    if (o2.dir) {
      name = forceTrailingSlash(name);
    }
    if (o2.createFolders && (parent = parentFolder(name))) {
      folderAdd.call(this, parent, true);
    }
    var isUnicodeString = dataType === "string" && o2.binary === false && o2.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
      o2.binary = !isUnicodeString;
    }
    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
    if (isCompressedEmpty || o2.dir || !data || data.length === 0) {
      o2.base64 = false;
      o2.binary = true;
      data = "";
      o2.compression = "STORE";
      dataType = "string";
    }
    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
      zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
      zipObjectContent = utils.prepareContent(name, data, o2.binary, o2.optimizedBinaryString, o2.base64);
    }
    var object2 = new ZipObject(name, zipObjectContent, o2);
    this.files[name] = object2;
  };
  var parentFolder = function(path) {
    if (path.slice(-1) === "/") {
      path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf("/");
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
  };
  var forceTrailingSlash = function(path) {
    if (path.slice(-1) !== "/") {
      path += "/";
    }
    return path;
  };
  var folderAdd = function(name, createFolders) {
    createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
    name = forceTrailingSlash(name);
    if (!this.files[name]) {
      fileAdd.call(this, name, null, {
        dir: true,
        createFolders
      });
    }
    return this.files[name];
  };
  function isRegExp(object2) {
    return Object.prototype.toString.call(object2) === "[object RegExp]";
  }
  var out = {
    load: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    forEach: function(cb) {
      var filename, relativePath, file2;
      for (filename in this.files) {
        file2 = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath && filename.slice(0, this.root.length) === this.root) {
          cb(relativePath, file2);
        }
      }
    },
    filter: function(search) {
      var result = [];
      this.forEach(function(relativePath, entry) {
        if (search(relativePath, entry)) {
          result.push(entry);
        }
      });
      return result;
    },
    file: function(name, data, o2) {
      if (arguments.length === 1) {
        if (isRegExp(name)) {
          var regexp = name;
          return this.filter(function(relativePath, file2) {
            return !file2.dir && regexp.test(relativePath);
          });
        } else {
          var obj = this.files[this.root + name];
          if (obj && !obj.dir) {
            return obj;
          } else {
            return null;
          }
        }
      } else {
        name = this.root + name;
        fileAdd.call(this, name, data, o2);
      }
      return this;
    },
    folder: function(arg) {
      if (!arg) {
        return this;
      }
      if (isRegExp(arg)) {
        return this.filter(function(relativePath, file2) {
          return file2.dir && arg.test(relativePath);
        });
      }
      var name = this.root + arg;
      var newFolder = folderAdd.call(this, name);
      var ret = this.clone();
      ret.root = newFolder.name;
      return ret;
    },
    remove: function(name) {
      name = this.root + name;
      var file2 = this.files[name];
      if (!file2) {
        if (name.slice(-1) !== "/") {
          name += "/";
        }
        file2 = this.files[name];
      }
      if (file2 && !file2.dir) {
        delete this.files[name];
      } else {
        var kids = this.filter(function(relativePath, file3) {
          return file3.name.slice(0, name.length) === name;
        });
        for (var i2 = 0;i2 < kids.length; i2++) {
          delete this.files[kids[i2].name];
        }
      }
      return this;
    },
    generate: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
        opts = utils.extend(options || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions: null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf8.utf8encode
        });
        opts.type = opts.type.toLowerCase();
        opts.compression = opts.compression.toUpperCase();
        if (opts.type === "binarystring") {
          opts.type = "string";
        }
        if (!opts.type) {
          throw new Error("No output type specified.");
        }
        utils.checkSupport(opts.type);
        if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
          opts.platform = "UNIX";
        }
        if (opts.platform === "win32") {
          opts.platform = "DOS";
        }
        var comment2 = opts.comment || this.comment || "";
        worker = generate.generateWorker(this, opts, comment2);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    generateAsync: function(options, onUpdate) {
      return this.generateInternalStream(options).accumulate(onUpdate);
    },
    generateNodeStream: function(options, onUpdate) {
      options = options || {};
      if (!options.type) {
        options.type = "nodebuffer";
      }
      return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
  };
  module.exports = out;
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS((exports, module) => {
  var utils = require_utils3();
  function DataReader(data) {
    this.data = data;
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    checkOffset: function(offset4) {
      this.checkIndex(this.index + offset4);
    },
    checkIndex: function(newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    setIndex: function(newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    skip: function(n) {
      this.setIndex(this.index + n);
    },
    byteAt: function() {
    },
    readInt: function(size5) {
      var result = 0, i2;
      this.checkOffset(size5);
      for (i2 = this.index + size5 - 1;i2 >= this.index; i2--) {
        result = (result << 8) + this.byteAt(i2);
      }
      this.index += size5;
      return result;
    },
    readString: function(size5) {
      return utils.transformTo("string", this.readData(size5));
    },
    readData: function() {
    },
    lastIndexOfSignature: function() {
    },
    readAndCheckSignature: function() {
    },
    readDate: function() {
      var dostime = this.readInt(4);
      return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));
    }
  };
  module.exports = DataReader;
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils3();
  function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i2 = 0;i2 < this.data.length; i2++) {
      data[i2] = data[i2] & 255;
    }
  }
  utils.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function(i2) {
    return this.data[this.zero + i2];
  };
  ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i2 = this.length - 4;i2 >= 0; --i2) {
      if (this.data[i2] === sig0 && this.data[i2 + 1] === sig1 && this.data[i2 + 2] === sig2 && this.data[i2 + 3] === sig3) {
        return i2 - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader.prototype.readData = function(size5) {
    this.checkOffset(size5);
    if (size5 === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size5);
    this.index += size5;
    return result;
  };
  module.exports = ArrayReader;
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils3();
  function StringReader(data) {
    DataReader.call(this, data);
  }
  utils.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function(i2) {
    return this.data.charCodeAt(this.zero + i2);
  };
  StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader.prototype.readData = function(size5) {
    this.checkOffset(size5);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size5);
    this.index += size5;
    return result;
  };
  module.exports = StringReader;
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS((exports, module) => {
  var ArrayReader = require_ArrayReader();
  var utils = require_utils3();
  function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
  }
  utils.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function(size5) {
    this.checkOffset(size5);
    if (size5 === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size5);
    this.index += size5;
    return result;
  };
  module.exports = Uint8ArrayReader;
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS((exports, module) => {
  var Uint8ArrayReader = require_Uint8ArrayReader();
  var utils = require_utils3();
  function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
  }
  utils.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function(size5) {
    this.checkOffset(size5);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size5);
    this.index += size5;
    return result;
  };
  module.exports = NodeBufferReader;
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS((exports, module) => {
  var utils = require_utils3();
  var support = require_support();
  var ArrayReader = require_ArrayReader();
  var StringReader = require_StringReader();
  var NodeBufferReader = require_NodeBufferReader();
  var Uint8ArrayReader = require_Uint8ArrayReader();
  module.exports = function(data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
      return new StringReader(data);
    }
    if (type === "nodebuffer") {
      return new NodeBufferReader(data);
    }
    if (support.uint8array) {
      return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
  };
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils3();
  var CompressedObject = require_compressedObject();
  var crc32fn = require_crc32();
  var utf8 = require_utf8();
  var compressions = require_compressions();
  var support = require_support();
  var MADE_BY_DOS = 0;
  var MADE_BY_UNIX = 3;
  var findCompression = function(compressionMethod) {
    for (var method in compressions) {
      if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
        continue;
      }
      if (compressions[method].magic === compressionMethod) {
        return compressions[method];
      }
    }
    return null;
  };
  function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
  }
  ZipEntry.prototype = {
    isEncrypted: function() {
      return (this.bitFlag & 1) === 1;
    },
    useUTF8: function() {
      return (this.bitFlag & 2048) === 2048;
    },
    readLocalPart: function(reader) {
      var compression, localExtraFieldsLength;
      reader.skip(22);
      this.fileNameLength = reader.readInt(2);
      localExtraFieldsLength = reader.readInt(2);
      this.fileName = reader.readData(this.fileNameLength);
      reader.skip(localExtraFieldsLength);
      if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough information from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
      }
      compression = findCompression(this.compressionMethod);
      if (compression === null) {
        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
      }
      this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },
    readCentralPart: function(reader) {
      this.versionMadeBy = reader.readInt(2);
      reader.skip(2);
      this.bitFlag = reader.readInt(2);
      this.compressionMethod = reader.readString(2);
      this.date = reader.readDate();
      this.crc32 = reader.readInt(4);
      this.compressedSize = reader.readInt(4);
      this.uncompressedSize = reader.readInt(4);
      var fileNameLength = reader.readInt(2);
      this.extraFieldsLength = reader.readInt(2);
      this.fileCommentLength = reader.readInt(2);
      this.diskNumberStart = reader.readInt(2);
      this.internalFileAttributes = reader.readInt(2);
      this.externalFileAttributes = reader.readInt(4);
      this.localHeaderOffset = reader.readInt(4);
      if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
      }
      reader.skip(fileNameLength);
      this.readExtraFields(reader);
      this.parseZIP64ExtraField(reader);
      this.fileComment = reader.readData(this.fileCommentLength);
    },
    processAttributes: function() {
      this.unixPermissions = null;
      this.dosPermissions = null;
      var madeBy = this.versionMadeBy >> 8;
      this.dir = this.externalFileAttributes & 16 ? true : false;
      if (madeBy === MADE_BY_DOS) {
        this.dosPermissions = this.externalFileAttributes & 63;
      }
      if (madeBy === MADE_BY_UNIX) {
        this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
      }
      if (!this.dir && this.fileNameStr.slice(-1) === "/") {
        this.dir = true;
      }
    },
    parseZIP64ExtraField: function() {
      if (!this.extraFields[1]) {
        return;
      }
      var extraReader = readerFor(this.extraFields[1].value);
      if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
      }
      if (this.compressedSize === utils.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
      }
      if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
      }
      if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
      }
    },
    readExtraFields: function(reader) {
      var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
      if (!this.extraFields) {
        this.extraFields = {};
      }
      while (reader.index + 4 < end) {
        extraFieldId = reader.readInt(2);
        extraFieldLength = reader.readInt(2);
        extraFieldValue = reader.readData(extraFieldLength);
        this.extraFields[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
      reader.setIndex(end);
    },
    handleUTF8: function() {
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
      } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
          this.fileNameStr = upath;
        } else {
          var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
          this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
          this.fileCommentStr = ucomment;
        } else {
          var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
          this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
      }
    },
    findExtraFieldUnicodePath: function() {
      var upathField = this.extraFields[28789];
      if (upathField) {
        var extraReader = readerFor(upathField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
      }
      return null;
    },
    findExtraFieldUnicodeComment: function() {
      var ucommentField = this.extraFields[25461];
      if (ucommentField) {
        var extraReader = readerFor(ucommentField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
      }
      return null;
    }
  };
  module.exports = ZipEntry;
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils3();
  var sig = require_signature();
  var ZipEntry = require_zipEntry();
  var support = require_support();
  function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
  }
  ZipEntries.prototype = {
    checkSignature: function(expectedSignature) {
      if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
      }
    },
    isSignature: function(askedIndex, expectedSignature) {
      var currentIndex = this.reader.index;
      this.reader.setIndex(askedIndex);
      var signature = this.reader.readString(4);
      var result = signature === expectedSignature;
      this.reader.setIndex(currentIndex);
      return result;
    },
    readBlockEndOfCentral: function() {
      this.diskNumber = this.reader.readInt(2);
      this.diskWithCentralDirStart = this.reader.readInt(2);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
      this.centralDirRecords = this.reader.readInt(2);
      this.centralDirSize = this.reader.readInt(4);
      this.centralDirOffset = this.reader.readInt(4);
      this.zipCommentLength = this.reader.readInt(2);
      var zipComment = this.reader.readData(this.zipCommentLength);
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      var decodeContent = utils.transformTo(decodeParamType, zipComment);
      this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    readBlockZip64EndOfCentral: function() {
      this.zip64EndOfCentralSize = this.reader.readInt(8);
      this.reader.skip(4);
      this.diskNumber = this.reader.readInt(4);
      this.diskWithCentralDirStart = this.reader.readInt(4);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
      this.centralDirRecords = this.reader.readInt(8);
      this.centralDirSize = this.reader.readInt(8);
      this.centralDirOffset = this.reader.readInt(8);
      this.zip64ExtensibleData = {};
      var extraDataSize = this.zip64EndOfCentralSize - 44, index4 = 0, extraFieldId, extraFieldLength, extraFieldValue;
      while (index4 < extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
    },
    readBlockZip64EndOfCentralLocator: function() {
      this.diskWithZip64CentralDirStart = this.reader.readInt(4);
      this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
      this.disksCount = this.reader.readInt(4);
      if (this.disksCount > 1) {
        throw new Error("Multi-volumes zip are not supported");
      }
    },
    readLocalFiles: function() {
      var i2, file2;
      for (i2 = 0;i2 < this.files.length; i2++) {
        file2 = this.files[i2];
        this.reader.setIndex(file2.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file2.readLocalPart(this.reader);
        file2.handleUTF8();
        file2.processAttributes();
      }
    },
    readCentralDir: function() {
      var file2;
      this.reader.setIndex(this.centralDirOffset);
      while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file2 = new ZipEntry({
          zip64: this.zip64
        }, this.loadOptions);
        file2.readCentralPart(this.reader);
        this.files.push(file2);
      }
      if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 && this.files.length === 0) {
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        } else {
        }
      }
    },
    readEndOfCentral: function() {
      var offset4 = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
      if (offset4 < 0) {
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
        if (isGarbage) {
          throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
          throw new Error("Corrupted zip: can't find end of central directory");
        }
      }
      this.reader.setIndex(offset4);
      var endOfCentralDirOffset = offset4;
      this.checkSignature(sig.CENTRAL_DIRECTORY_END);
      this.readBlockEndOfCentral();
      if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
        this.zip64 = true;
        offset4 = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset4 < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset4);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
          this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          if (this.relativeOffsetEndOfZip64CentralDir < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
      }
      var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
      if (this.zip64) {
        expectedEndOfCentralDirOffset += 20;
        expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
      }
      var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
      if (extraBytes > 0) {
        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
        } else {
          this.reader.zero = extraBytes;
        }
      } else if (extraBytes < 0) {
        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
      }
    },
    prepareReader: function(data) {
      this.reader = readerFor(data);
    },
    load: function(data) {
      this.prepareReader(data);
      this.readEndOfCentral();
      this.readCentralDir();
      this.readLocalFiles();
    }
  };
  module.exports = ZipEntries;
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS((exports, module) => {
  var utils = require_utils3();
  var external2 = require_external();
  var utf8 = require_utf8();
  var ZipEntries = require_zipEntries();
  var Crc32Probe = require_Crc32Probe();
  var nodejsUtils = require_nodejsUtils();
  function checkEntryCRC32(zipEntry) {
    return new external2.Promise(function(resolve, reject) {
      var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe);
      worker.on("error", function(e) {
        reject(e);
      }).on("end", function() {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
          reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf8.utf8decode
    });
    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      return external2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
      var zipEntries = new ZipEntries(options);
      zipEntries.load(data2);
      return zipEntries;
    }).then(function checkCRC32(zipEntries) {
      var promises = [external2.Promise.resolve(zipEntries)];
      var files = zipEntries.files;
      if (options.checkCRC32) {
        for (var i2 = 0;i2 < files.length; i2++) {
          promises.push(checkEntryCRC32(files[i2]));
        }
      }
      return external2.Promise.all(promises);
    }).then(function addFiles(results) {
      var zipEntries = results.shift();
      var files = zipEntries.files;
      for (var i2 = 0;i2 < files.length; i2++) {
        var input = files[i2];
        var unsafeName = input.fileNameStr;
        var safeName = utils.resolve(input.fileNameStr);
        zip.file(safeName, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
        if (!input.dir) {
          zip.file(safeName).unsafeOriginalName = unsafeName;
        }
      }
      if (zipEntries.zipComment.length) {
        zip.comment = zipEntries.zipComment;
      }
      return zip;
    });
  };
});

// node_modules/jszip/lib/index.js
var require_lib = __commonJS((exports, module) => {
  function JSZip() {
    if (!(this instanceof JSZip)) {
      return new JSZip;
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = Object.create(null);
    this.comment = null;
    this.root = "";
    this.clone = function() {
      var newObj = new JSZip;
      for (var i2 in this) {
        if (typeof this[i2] !== "function") {
          newObj[i2] = this[i2];
        }
      }
      return newObj;
    };
  }
  JSZip.prototype = require_object();
  JSZip.prototype.loadAsync = require_load();
  JSZip.support = require_support();
  JSZip.defaults = require_defaults();
  JSZip.version = "3.10.1";
  JSZip.loadAsync = function(content, options) {
    return new JSZip().loadAsync(content, options);
  };
  JSZip.external = require_external();
  module.exports = JSZip;
});

// src/index.tsx
var import_react286 = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set;
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/zustand/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react.default.useSyncExternalStore(api.subscribe, () => selector(api.getState()), () => selector(api.getInitialState()));
  import_react.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
function die(error, ...args) {
  if (false) {
  }
  throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index2) => iter(index2, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is2(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== undefined && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : undefined;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path));
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(resultEach, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (false)
    ;
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && !has(parentState.assigned_, prop) ? rootPath.concat(prop) : undefined;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    scope_: parent ? parent.scope_ : getCurrentScope(),
    modified_: false,
    finalized_: false,
    assigned_: {},
    parent_: parent,
    base_: base,
    draft_: null,
    copy_: null,
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek2(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek2(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is2(value, current2) && (value !== undefined || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && (value !== undefined || (prop in state.copy_)) || Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek2(state.base_, prop) !== undefined || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (false)
    ;
  return arrayTraps.set.call(this, state, prop, undefined);
};
arrayTraps.set = function(state, prop, value) {
  if (false)
    ;
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek2(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : desc.get?.call(state.draft_) : undefined;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== undefined && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, undefined);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === undefined)
          result = base;
        if (result === NOTHING)
          result = undefined;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, undefined);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(undefined, scope);
  }
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1;i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(base, (draft) => applyPatchesImpl(draft, patches));
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2;
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(immer);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);

// node_modules/zustand/esm/middleware/immer.mjs
var immerImpl = (initializer) => (set2, get, store) => {
  store.setState = (updater, replace, ...args) => {
    const nextState = typeof updater === "function" ? produce(updater) : updater;
    return set2(nextState, replace, ...args);
  };
  return initializer(store.setState, get, store);
};
var immer2 = immerImpl;

// src/modalStore.ts
var saveLayoutConfigToJSON = (config) => {
  console.log("Saving config:", config);
};
var useAppStore = () => appStore();
var unloadedDoc = { layouts: [], variables: [] };
var appStore = create()(immer2((set2, get) => ({
  state: {
    modal: {
      isAddImageVariableMappingModalOpen: false,
      currentAddImageMappingSelectedVariables: [],
      isSwapImageVariableModalOpen: false,
      currentSwapImageVariableSelected: "",
      currentSwapImageVariableId: null,
      isModalVisible: false,
      currentSelectedMapId: null,
      dependentModal: {
        isOpen: false,
        currentImageVariableId: null,
        currentSelectedVariables: [],
        currentGroupIndex: null
      }
    },
    studio: {
      isLayoutConfigLoaded: false,
      isDocumentLoaded: false,
      document: unloadedDoc,
      layoutImageMapping: []
    },
    isToolbarVisible: false,
    isToolbarEnabled: true
  },
  alerts: [],
  effects: {
    modal: {
      showModal: () => set2((store) => {
        store.state.modal.isModalVisible = true;
        store.state.isToolbarVisible = false;
      }),
      hideModal: () => set2((store) => {
        store.state.modal.isModalVisible = false;
      }),
      setIsImageVariableMappingModalOpen: (value) => set2((store) => {
        store.state.modal.isAddImageVariableMappingModalOpen = value;
      }),
      setCurrentAddImageMappingSelectedVariables: (value) => set2((store) => {
        store.state.modal.currentAddImageMappingSelectedVariables = value;
      }),
      setCurrentSelectedMapId: (value) => {
        set2((store) => {
          store.state.modal.currentSelectedMapId = value;
        });
      },
      setIsSwapImageVariableModalOpen: (value) => {
        set2((store) => {
          store.state.modal.isSwapImageVariableModalOpen = value;
        });
      },
      setCurrentSwapImageVariableSelected: (value) => {
        set2((store) => {
          store.state.modal.currentSwapImageVariableSelected = value;
        });
      },
      setCurrentSwapImageVariableId: (value) => {
        set2((store) => {
          store.state.modal.currentSwapImageVariableId = value;
        });
      },
      dependentModal: {
        setIsOpen: (value, mapId) => {
          set2((store) => {
            store.state.modal.dependentModal.isOpen = value;
            if (value === true) {
              if (!mapId) {
                raiseError(store, new Error("Cannot open dependent modal without mapId"));
                store.state.modal.dependentModal.isOpen = false;
                return;
              }
              store.state.modal.currentSelectedMapId = mapId;
            }
          });
        },
        setCurrentImageVariableId: (id) => {
          set2((store) => {
            store.state.modal.dependentModal.currentImageVariableId = id;
          });
        },
        setCurrentSelectedVariables: (value) => {
          set2((store) => {
            store.state.modal.dependentModal.currentSelectedVariables = value;
          });
        },
        setCurrentGroupIndex: (value) => {
          set2((store) => {
            store.state.modal.dependentModal.currentGroupIndex = value;
          });
        }
      }
    },
    studio: {
      document: {
        load: (doc) => set2((store) => {
          store.state.studio.isDocumentLoaded = true;
          store.state.studio.document = doc;
        }),
        unload: () => set2((store) => {
          store.state.studio.document = unloadedDoc;
          store.state.studio.isDocumentLoaded = false;
        })
      },
      layoutImageMapping: {
        addLayoutMap: () => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const randomId = Math.random().toString(36).substring(2, 10);
            const newLayoutMap = {
              id: randomId,
              layoutIds: [],
              variables: []
            };
            store.state.studio.layoutImageMapping.push(newLayoutMap);
          } else {
            raiseError(store, new Error("For addLayoutMap layout config is not loaded"));
          }
        }),
        addLayoutMapFromCopy: (mapId) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const sourceLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id === mapId);
            if (sourceLayoutMap) {
              const randomId = Math.random().toString(36).substring(2, 10);
              const newLayoutMap = {
                id: randomId,
                layoutIds: [],
                variables: JSON.parse(JSON.stringify(sourceLayoutMap.variables))
              };
              store.state.studio.layoutImageMapping.push(newLayoutMap);
            } else {
              raiseError(store, new Error("For addLayoutMapFromCopy source layout map not found"));
            }
          } else {
            raiseError(store, new Error("For addLayoutMapFromCopy layout config is not loaded"));
          }
        }),
        deleteLayoutMap: (mapId) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const mapIndex = store.state.studio.layoutImageMapping.findIndex((map) => map.id === mapId);
            if (mapIndex !== -1) {
              store.state.studio.layoutImageMapping.splice(mapIndex, 1);
            } else {
              raiseError(store, new Error("For deleteLayoutMap layout map not found"));
            }
          } else {
            raiseError(store, new Error("For deleteLayoutMap layout config is not loaded"));
          }
        }),
        setLayoutIds: ({ mapId: configId, layoutIds }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((layout) => layout.id == configId);
            if (targetLayoutMap) {
              targetLayoutMap.layoutIds = layoutIds;
            } else {
              raiseError(store, new Error("For setLayoutIds targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For setLayoutIds layout config is not loaded"));
          }
        }),
        addImageVariable: ({ mapId, imageVariable }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMapMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMapMap) {
              const imageVariableIndex = targetLayoutMapMap.variables.findIndex((imgVar) => imgVar.id == imageVariable.id);
              if (imageVariableIndex == -1) {
                targetLayoutMapMap.variables.push(imageVariable);
              } else {
                targetLayoutMapMap.variables[imageVariableIndex] = imageVariable;
              }
            } else {
              raiseError(store, new Error("For addImageVariable targetLayoutMapMap not found"));
            }
          } else {
            raiseError(store, new Error("For addImageVariable layout config is not loaded"));
          }
        }),
        updateDependent: ({
          mapId,
          imageVariableId,
          dependentGroupIndex,
          dependent
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((layout) => layout.id == mapId);
            if (!targetLayoutMap) {
              raiseError(store, new Error("For updateDependent targetLayoutMap not found"));
              return;
            }
            const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
            if (!imageVariable) {
              raiseError(store, new Error("For updateDependent imageVariable not found"));
              return;
            }
            const dependentGroup = imageVariable.dependentGroup[dependentGroupIndex];
            if (dependentGroup == undefined) {
              raiseError(store, new Error("For updateDependent dependentGroup not found"));
              return;
            }
            const dependentIndex = dependentGroup.dependents.findIndex((dep) => dep.variableId == dependent.variableId);
            if (dependentIndex == -1) {
              dependentGroup.dependents.push(dependent);
            } else {
              dependentGroup.dependents[dependentIndex] = dependent;
            }
          } else {
            raiseError(store, new Error("For updateDependent layout config is not loaded"));
          }
        }),
        removeDependent: ({
          mapId,
          imageVariableId,
          dependentGroupIndex,
          dependent
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((layout) => layout.id == mapId);
            if (!targetLayoutMap) {
              raiseError(store, new Error("For removeDependent targetLayoutMap not found"));
              return;
            }
            const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
            if (!imageVariable) {
              raiseError(store, new Error("For removeDependent imageVariable not found"));
              return;
            }
            const dependentGroup = imageVariable.dependentGroup[dependentGroupIndex];
            if (dependentGroup == undefined) {
              raiseError(store, new Error("For removeDependent dependentGroup not found"));
              return;
            }
            const dependentIndex = dependentGroup.dependents.findIndex((dep) => dep.variableId == dependent.variableId);
            if (dependentIndex == -1) {
              raiseError(store, new Error("For removeDependent dependent not found"));
              return;
            }
            dependentGroup.dependents.splice(dependentIndex, 1);
          } else {
            raiseError(store, new Error("For removeDependent layout config is not loaded"));
          }
        }),
        load: (configs) => set2((store) => {
          if (!store.state.studio.isLayoutConfigLoaded) {
            store.state.studio.isLayoutConfigLoaded = true;
            store.state.studio.layoutImageMapping = configs;
          } else {
            raiseError(store, new Error("For load layout config is already loaded"));
          }
        }),
        unload: () => set2((store) => {
          store.state.studio.layoutImageMapping = [];
          store.state.studio.isLayoutConfigLoaded = false;
        }),
        save: () => {
          const store = get();
          if (store.state.studio.isLayoutConfigLoaded) {
            saveLayoutConfigToJSON(store.state.studio.layoutImageMapping);
          } else {
            raiseError(store, new Error("For save layout config is not loaded"));
          }
        },
        addDependentGroup: ({ mapId, imageVariableId, dependents }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                imageVariable.dependentGroup.push({
                  dependents,
                  variableValue: []
                });
              } else {
                raiseError(store, new Error("For addDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For addDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For addDependentGroup layout config is not loaded"));
          }
        }),
        copyDependentGroup: ({ mapId, imageVariableId, groupIndex }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                const dependentGroup = imageVariable.dependentGroup[groupIndex];
                if (dependentGroup == undefined) {
                  raiseError(store, new Error("For copyDependentGroup dependentGroup not found"));
                  return;
                }
                const newDependentGroup = JSON.parse(JSON.stringify(dependentGroup));
                imageVariable.dependentGroup.push(newDependentGroup);
              } else {
                raiseError(store, new Error("For copyDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For copyDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For copyDependentGroup layout config is not loaded"));
          }
        }),
        removeImageVariable: ({ mapId, imageVariableId }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariableIndex = targetLayoutMap.variables.findIndex((imgVar) => imgVar.id == imageVariableId);
              if (imageVariableIndex !== -1) {
                targetLayoutMap.variables.splice(imageVariableIndex, 1);
              } else {
                raiseError(store, new Error("For removeImageVariable imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For removeImageVariable targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For removeImageVariable layout config is not loaded"));
          }
        }),
        swapImageVariable: ({
          mapId,
          oldImageVariableId,
          newImageVariableId
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const oldImageVariableIndex = targetLayoutMap.variables.findIndex((imgVar) => imgVar.id == oldImageVariableId);
              if (oldImageVariableIndex !== -1) {
                const oldImageVariable = targetLayoutMap.variables[oldImageVariableIndex];
                const newImageVariable = {
                  id: newImageVariableId,
                  dependentGroup: [...oldImageVariable.dependentGroup]
                };
                targetLayoutMap.variables[oldImageVariableIndex] = newImageVariable;
              } else {
                raiseError(store, new Error("For swapImageVariable oldImageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For swapImageVariable targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For swapImageVariable layout config is not loaded"));
          }
        }),
        removeDependentGroup: ({ mapId, imageVariableId, groupIndex }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                imageVariable.dependentGroup.splice(groupIndex, 1);
              } else {
                raiseError(store, new Error("For removeDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For removeDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For removeDependentGroup layout config is not loaded"));
          }
        }),
        addVarValueToDependentGroup: ({
          mapId,
          imageVariableId,
          groupIndex,
          variableValue
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                const dependentGroup = imageVariable.dependentGroup[groupIndex];
                if (dependentGroup == undefined) {
                  raiseError(store, new Error("For addVarValueToDependentGroup dependentGroup not found"));
                  return;
                }
                dependentGroup.variableValue.push(variableValue);
              } else {
                raiseError(store, new Error("For addVarValueToDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For addVarValueToDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For addVarValueToDependentGroup layout config is not loaded"));
          }
        }),
        removeVarValueFromDependentGroup: ({
          mapId,
          imageVariableId,
          groupIndex,
          variableValueIndex
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                const dependentGroup = imageVariable.dependentGroup[groupIndex];
                if (dependentGroup == undefined) {
                  raiseError(store, new Error("For removeVarValueFromDependentGroup dependentGroup not found"));
                  return;
                }
                if (variableValueIndex < 0 || variableValueIndex >= dependentGroup.variableValue.length) {
                  raiseError(store, new Error("For removeVarValueFromDependentGroup invalid variableValueIndex"));
                  return;
                }
                dependentGroup.variableValue.splice(variableValueIndex, 1);
              } else {
                raiseError(store, new Error("For removeVarValueFromDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For removeVarValueFromDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For removeVarValueFromDependentGroup layout config is not loaded"));
          }
        }),
        updateVarValueFromDependentGroup: ({
          mapId,
          imageVariableId,
          groupIndex,
          variableValueIndex,
          variableValue
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                const dependentGroup = imageVariable.dependentGroup[groupIndex];
                if (dependentGroup == undefined) {
                  raiseError(store, new Error("For updateVarValueFromDependentGroup dependentGroup not found"));
                  return;
                }
                if (variableValueIndex < 0 || variableValueIndex >= dependentGroup.variableValue.length) {
                  raiseError(store, new Error("For updateVarValueFromDependentGroup invalid variableValueIndex"));
                  return;
                }
                dependentGroup.variableValue[variableValueIndex] = variableValue;
              } else {
                raiseError(store, new Error("For updateVarValueFromDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For updateVarValueFromDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For updateVarValueFromDependentGroup layout config is not loaded"));
          }
        }),
        setIndexOfVarValueFromDependentGroup: ({
          mapId,
          imageVariableId,
          groupIndex,
          oldVariableValueIndex,
          newVariableValueIndex
        }) => set2((store) => {
          if (store.state.studio.isLayoutConfigLoaded) {
            const targetLayoutMap = store.state.studio.layoutImageMapping.find((map) => map.id == mapId);
            if (targetLayoutMap) {
              const imageVariable = targetLayoutMap.variables.find((imgVar) => imgVar.id == imageVariableId);
              if (imageVariable) {
                const dependentGroup = imageVariable.dependentGroup[groupIndex];
                if (dependentGroup == undefined) {
                  raiseError(store, new Error("For setIndexOfVarValueFromDependentGroup dependentGroup not found"));
                  return;
                }
                if (oldVariableValueIndex < 0 || oldVariableValueIndex >= dependentGroup.variableValue.length) {
                  raiseError(store, new Error("For setIndexOfVarValueFromDependentGroup invalid oldVariableValueIndex"));
                  return;
                }
                let adjustedNewIndex = newVariableValueIndex;
                if (adjustedNewIndex < 0) {
                  adjustedNewIndex = 0;
                }
                if (adjustedNewIndex >= dependentGroup.variableValue.length) {
                  adjustedNewIndex = dependentGroup.variableValue.length - 1;
                }
                const [movedItem] = dependentGroup.variableValue.splice(oldVariableValueIndex, 1);
                dependentGroup.variableValue.splice(adjustedNewIndex, 0, movedItem);
              } else {
                raiseError(store, new Error("For setIndexOfVarValueFromDependentGroup imageVariable not found"));
              }
            } else {
              raiseError(store, new Error("For setIndexOfVarValueFromDependentGroup targetLayoutMap not found"));
            }
          } else {
            raiseError(store, new Error("For setIndexOfVarValueFromDependentGroup layout config is not loaded"));
          }
        })
      }
    }
  },
  errors: [],
  showToolbar: () => set2((state) => {
    state.state.isToolbarVisible = true;
  }),
  hideToolbar: () => set2((state) => {
    state.state.isToolbarVisible = false;
  }),
  enableToolbar: () => set2((state) => {
    console.log("ENABLE TOOLBAR");
    state.state.isToolbarEnabled = true;
  }),
  disableToolbar: () => set2((state) => {
    console.log("DISABLE TOOLBAR");
    state.state.isToolbarEnabled = false;
  }),
  raiseError: (error) => {
    if (error.isResult != null) {
      error.onFailure((error2) => set2((state) => raiseError(state, error2)));
    } else {
      set2((state) => raiseError(state, error));
    }
  },
  dismissAlert: (id) => set2((state) => {
    state.alerts = state.alerts.filter((alert) => alert.id !== id);
  })
})));
appStore.subscribe((state, oldState) => console.log("state", state, "oldState", oldState));
function raiseError(store, error) {
  const alertId = Math.random().toString(36).substring(2, 15);
  const alert = {
    id: alertId,
    message: error.message
  };
  store.alerts.push(alert);
  store.errors.push({ error, state: store });
  console.error(error);
}

// src/studio/studioAdapter.ts
init_dist();

// src/studio/layoutHandler.ts
init_dist();
init_utils();
async function getPrivateData({ studio: studio2, id }) {
  const result = await handleStudioFunc(studio2.layout.getPrivateData, id);
  console.log(result);
  if (result.isError())
    return result;
  return Result.try(() => result.value);
}
async function setPrivateData({
  studio: studio2,
  id,
  privateData
}) {
  return await handleStudioFunc(studio2.layout.setPrivateData, id, privateData);
}
async function getAllLayouts(studio2) {
  return await handleStudioFunc(studio2.layout.getAll);
}
async function getLayoutById(studio2, id) {
  return await handleStudioFunc(studio2.layout.getById, id);
}
async function setLayoutAvailable(studio2, id, available) {
  return await handleStudioFunc(studio2.layout.setAvailableForUser, id, available);
}
async function getSelected(studio2) {
  return await handleStudioFunc(studio2.layout.getSelected);
}
async function updateLayoutResizable(studio2, id, update) {
  return await handleStudioFunc(studio2.layout.setResizableByUser, id, update);
}

// src/studio/variableHandler.ts
init_dist();
init_utils();
var import_studio_sdk = __toESM(require_main(), 1);
async function getAllVariables(studio2) {
  return handleStudioFunc(studio2.next.variable.getAll);
}
async function setVariableValue2({
  studio: studio2,
  id,
  value
}) {
  return handleStudioFunc(studio2.variable.setValue, id, value);
}
async function setVariableVisblity({
  studio: studio2,
  id,
  visible
}) {
  return handleStudioFunc(studio2.variable.setVariableVisibility, id, visible);
}
async function setVariableVisblityWithName({
  studio: studio2,
  name,
  visible
}) {
  const allVariablesResult = await getAllVariables(studio2);
  return allVariablesResult.map(async (variables) => {
    const existingVariable = variables.find((variable) => variable.name === name);
    if (existingVariable) {
      return await setVariableVisblity({
        studio: studio2,
        id: existingVariable.id,
        visible
      });
    } else {
      return Result.error(new Error(`Variable with name ${name} not found`));
    }
  });
}
async function createVariable({
  studio: studio2,
  variableType,
  name
}) {
  const createResult = await handleStudioFunc(studio2.variable.create, "", variableType);
  return createResult.map(async (id) => {
    const result = await handleStudioFunc(studio2.variable.rename, id, name);
    if (result.isOk())
      return id;
    return Result.error(result.value);
  });
}
async function groupVariables({
  studio: studio2,
  name,
  variableIds
}) {
  return handleStudioFunc(studio2.variable.groupVariables, name, variableIds);
}
async function moveVariable({
  studio: studio2,
  id,
  order = 0,
  newParentId
}) {
  return handleStudioFunc(studio2.variable.move, order, id, newParentId);
}
async function setVariableType({
  studio: studio2,
  id,
  variableType
}) {
  return handleStudioFunc(studio2.variable.setType, id, variableType);
}
async function setListVariableItems({
  studio: studio2,
  id,
  items
}) {
  return handleStudioFunc(studio2.variable.setListVariable, id, items);
}
async function deleteVariables(studio2, ids) {
  return handleStudioFunc(studio2.variable.remove, ids);
}
async function setOrCreateVariableValue({
  studio: studio2,
  name,
  value,
  variableType
}) {
  const allVariablesResult = await getAllVariables(studio2);
  return allVariablesResult.map(async (variables) => {
    const existingVariable = variables.find((variable) => variable.name === name);
    if (existingVariable) {
      if (existingVariable.type !== variableType) {
        await setVariableType({
          studio: studio2,
          id: existingVariable.id,
          variableType
        });
      }
      if (variableType === import_studio_sdk.VariableType.list) {
        return await setListVariableItems({
          studio: studio2,
          id: existingVariable.id,
          items: value
        });
      }
      return await setVariableValue2({
        studio: studio2,
        id: existingVariable.id,
        value
      });
    } else {
      const createResult = await createVariable({
        studio: studio2,
        variableType,
        name
      });
      return createResult.map(async (id) => {
        if (variableType === import_studio_sdk.VariableType.list) {
          return await setListVariableItems({ studio: studio2, id, items: value });
        }
        return await setVariableValue2({
          studio: studio2,
          id,
          value
        });
      });
    }
  });
}
async function getById(studio2, id) {
  return handleStudioFunc(studio2.next.variable.getById, id);
}
function getByName(studio2, name) {
  return handleStudioFunc(studio2.next.variable.getByName, name);
}

// src/studio/studioAdapter.ts
var import_studio_sdk2 = __toESM(require_main(), 1);

// src/types/toolbarEnvelope.ts
function createEmptyEnvelope() {
  return {
    layoutMaps: [],
    frameMaps: [],
    layoutSizes: {},
    defaultDownloadSettings: {
      includeFonts: true,
      includeGrafxMedia: false,
      includeSmartCrops: false,
      removeToolbarData: false,
      removeUnusedConnectors: false,
      useOriginalFontFileNames: false,
      addTimestamp: true
    }
  };
}

// src/studio/actionHandler.ts
init_dist();
init_utils();

class ActionNotFoundError extends Error {
  _tag = "ActionNotFoundError";
}
async function getAction({
  studio: studio2,
  name
}) {
  const actionsResult = await handleStudioFunc(studio2.action.getAll);
  return actionsResult.map((actions) => {
    const sgAction = actions.find((a) => a.name == name);
    if (sgAction == null) {
      return Result.error(new ActionNotFoundError("Action not found, null"));
    }
    return sgAction;
  });
}
async function createAction(studio2) {
  return handleStudioFunc(studio2.action.create);
}
async function updateAction(actionData, update) {
  const { studio: studio2 } = actionData;
  const actionResult = await getAction(actionData);
  return actionResult.recover(async (error) => {
    if (error instanceof ActionNotFoundError) {
      return createAction(actionData.studio);
    } else {
      return Result.error(error);
    }
  }).map((value) => {
    return handleStudioFunc(studio2.action.update, typeof value == "string" ? value : value.id, update);
  });
}
function setEnableActions(studio2, value) {
  if (value) {
    studio2.action.enable();
  } else {
    studio2.action.disable();
  }
}

// src/studio/actions/imageSelection.js
function imageSelectionScript(debug) {
  const version2 = "0.4";
  const imageSelectionData = "%DATA%";
  const errorCollection = [];
  const debugData = {};
  try {
    let replaceVariables = function(input, allTransforms) {
      return input.replace(/\${(.*?)}/g, (_, name) => {
        const variableValue = getVariableValue(name);
        const currentTransforms = allTransforms[name];
        return currentTransforms.reduce((previousValue, transform) => {
          if (transform.replaceAll) {
            return previousValue.replaceAll(transform.find, transform.replace);
          }
          return previousValue.replace(transform.find, transform.replace);
        }, variableValue);
      });
    }, getCompositeKeyFromVariables = function(dependencies) {
      return dependencies.map((dep) => {
        const variableRawValue = getVariableValue(dep);
        return `${variableRawValue}`;
      }).join("|");
    };
    const vars = studio.variables.all();
    const imageVars = vars.filter((f) => f.type == "image");
    const layoutName = getSelectedLayoutName();
    const layoutImageMapping = imageSelectionData[layoutName];
    if (debug) {
      debugData.imageVars = imageVars;
      debugData.layoutImageMapping = layoutImageMapping;
    }
    if (!layoutImageMapping) {
      errorCollection.push(Error(`No image mapping found for layout ${layoutName}`));
      return { debugData, errorCollection };
    }
    for (const imageVar of imageVars) {
      const imageVariableDependentGroups = layoutImageMapping[imageVar.name];
      if (debug) {
        debugData[imageVar.name] = {
          imageVariableDependentGroups: layoutImageMapping[imageVar.name]
        };
      }
      if (!imageVariableDependentGroups) {
        errorCollection.push(Error(`No  dependent groups found for image variable: ${imageVar.name}`));
        continue;
      }
      const dependancies = Object.keys(imageVariableDependentGroups);
      if (debug) {
        debugData[imageVar.name].dependancies = dependancies;
      }
      if (dependancies.length == 0) {
        errorCollection.push(Error(`Something went wrong no dependancies for: ${imageVar.name}`));
        continue;
      }
      const variableMatch = dependancies.reduce((variableMatch2, d) => {
        if (variableMatch2 != null) {
          return variableMatch2;
        }
        const compositeKey = getCompositeKeyFromVariables(d.split("|"));
        variableMatch2 = imageVariableDependentGroups[d][compositeKey];
        if (debug) {
          debugData[imageVar.name].compositeKeys = !debugData[imageVar.name].compositeKeys ? [compositeKey] : [...debugData[imageVar.name].compositeKeys, compositeKey];
          debugData[imageVar.name].variableMatches = !debugData[imageVar.name].variableMatches ? [variableMatch2] : [...debugData[imageVar.name].variableMatches, variableMatch2];
        }
        return variableMatch2;
      }, null);
      if (debug) {
        debugData[imageVar.name].variableMatch = variableMatch;
      }
      if (!variableMatch) {
        errorCollection.push(Error(`Something went wrong no match found for: ${imageVar.name}`));
        continue;
      }
      const variableValue = replaceVariables(variableMatch.value, variableMatch.transforms);
      setVariableValue(imageVar.name, variableValue);
      if (debug) {
        debugData[imageVar.name].variableValue = variableValue;
      }
    }
  } catch (e) {
    errorCollection.push(e);
  }
  return { debugData, errorCollection };
}

// src/studio/actions/imageSizing.js
function imageSizingScript(debug) {
  const version2 = 1;
  const imageSizingData = "%DATA1%";
  const layoutSizingData = "%DATA2%";
  const errorCollection = [];
  const vars = studio.variables.all();
  const imageVars = vars.filter((f) => f.type == "image");
  const layoutName = getSelectedLayoutName();
  const layoutImageSizingData = imageSizingData[layoutName];
  const layoutSizeData = layoutSizingData[layoutName];
  if (layoutSizeData == null) {
    errorCollection.push(Error(`No layout sizing data found for ${layoutName}}`));
    return;
  }
  if (layoutImageSizingData == null) {
    errorCollection.push(Error(`No layout image sizing data found for ${layoutName}}`));
    return;
  }
  for (const imageVar of imageVars) {
    const imageSizeData = layoutImageSizingData[imageVar.value];
    if (imageSizeData == null) {
      errorCollection.push(Error(`No image size data found for ${imageVar.value} for variable ${imageVar.name}`));
      continue;
    }
    const newFramePos = calculateUpdatedFrame(imageSizeData, layoutSizeData, {
      width: getPageWidth(),
      height: getPageHeight()
    });
    const frameName = imageSizeData.frameName;
    setFrameX(frameName, newFramePos.x);
    setFrameY(frameName, newFramePos.y);
    setFrameWidth(frameName, newFramePos.width);
    setFrameHeight(frameName, newFramePos.height);
  }
  function calculateUpdatedFrame(initialFrame, initialPage, currentPage) {
    if (initialPage.width <= 0 || initialPage.height <= 0) {
      return initialFrame;
    }
    const relativeInitialX = initialFrame.x;
    const relativeInitialY = initialFrame.y;
    const widthRatio = initialFrame.width / initialPage.width;
    const heightRatio = initialFrame.height / initialPage.height;
    const xPosRatio = relativeInitialX / initialPage.width;
    const yPosRatio = relativeInitialY / initialPage.height;
    const updatedWidth = currentPage.width * widthRatio;
    const updatedHeight = currentPage.height * heightRatio;
    const updatedRelativeX = currentPage.width * xPosRatio;
    const updatedRelativeY = currentPage.height * yPosRatio;
    const updatedX = updatedRelativeX;
    const updatedY = updatedRelativeY;
    return {
      x: updatedX,
      y: updatedY,
      width: updatedWidth,
      height: updatedHeight
    };
  }
}

// src/studio/layoutMappingToActionMap.ts
function layoutMappingToActionMap(layoutMaps, doc) {
  const actionMap = {};
  layoutMaps.forEach((layoutMap) => {
    layoutMap.layoutIds.forEach((layoutId) => {
      const layout = doc.layouts.find((l) => l.id === layoutId);
      if (layout) {
        const layoutName = layout.name;
        if (!actionMap[layoutName]) {
          actionMap[layoutName] = {};
        }
        layoutMap.variables.forEach((imageVar) => {
          const docVariable = doc.variables.find((v) => v.id === imageVar.id);
          if (docVariable) {
            actionMap[layoutName][docVariable.name] = {};
            imageVar.dependentGroup.forEach((group) => {
              const dependentNames = [];
              const variableNamesById = {};
              group.dependents.forEach((dependent) => {
                const dependentVar = doc.variables.find((v) => v.id === dependent.variableId);
                if (dependentVar) {
                  dependentNames.push(dependentVar.name);
                  variableNamesById[dependent.variableId] = dependentVar.name;
                }
              });
              if (dependentNames.length === 0)
                return;
              const dependentKey = dependentNames.join("|");
              if (!actionMap[layoutName][docVariable.name][dependentKey]) {
                actionMap[layoutName][docVariable.name][dependentKey] = {};
              }
              const allPossibleValues = group.dependents.map((dependent) => {
                return dependent.values;
              });
              const generateCombinations = (arrays, current2 = [], index2 = 0) => {
                if (index2 === arrays.length) {
                  return [current2];
                }
                const result = [];
                for (const value of arrays[index2]) {
                  result.push(...generateCombinations(arrays, [...current2, value], index2 + 1));
                }
                return result;
              };
              const valueCombinations = generateCombinations(allPossibleValues);
              valueCombinations.forEach((combination) => {
                const valueKey = combination.join("|");
                if (!actionMap[layoutName][docVariable.name][dependentKey][valueKey]) {
                  actionMap[layoutName][docVariable.name][dependentKey][valueKey] = { value: "" };
                }
                const valueString = group.variableValue.map((varValue) => {
                  if (typeof varValue === "string") {
                    return varValue;
                  } else if (varValue.id) {
                    const valueVar = doc.variables.find((v) => v.id === varValue.id);
                    if (valueVar) {
                      return `\${${valueVar.name}}`;
                    }
                  }
                  return "";
                }).join("");
                console.log("VALUES", group.variableValue);
                const transforms = group.variableValue.filter((varValue) => typeof varValue != "string").reduce((obj, varValue) => {
                  if (varValue.id) {
                    const valueVar = doc.variables.find((v) => v.id === varValue.id);
                    if (valueVar) {
                      obj[valueVar.name] = varValue.transform;
                    }
                  }
                  return obj;
                }, {});
                actionMap[layoutName][docVariable.name][dependentKey][valueKey].value = valueString;
                actionMap[layoutName][docVariable.name][dependentKey][valueKey].transforms = transforms;
              });
            });
          }
        });
      }
    });
  });
  return actionMap;
}

// src/studio-adapter/frameLayoutMappingToLookup.ts
init_dist();

// src/studio/frameHandler.ts
init_utils();
async function getSelected2(studio2) {
  return handleStudioFunc(studio2.frame.getSelected);
}
async function getById2(studio2, id) {
  return handleStudioFunc(studio2.frame.getById, id);
}
async function getAll(studio2) {
  return handleStudioFunc(studio2.frame.getAll);
}
async function getPropertiesOnSelectedLayout(studio2) {
  return handleStudioFunc(studio2.frame.getPropertiesOnSelectedLayout);
}
async function getPropertiesOnLayout(studio2, layoutId) {
  return handleStudioFunc(studio2.frame.getAllLayoutProperties, layoutId);
}

// src/studio-adapter/frameLayoutMappingToLookup.ts
async function frameLayoutMappingToLookup(frameMaps, studio2) {
  try {
    const result = {};
    const layoutsResult = await getAllLayouts(studio2);
    if (layoutsResult.isError()) {
      throw layoutsResult.error;
    }
    const layouts = layoutsResult.value;
    if (!layouts) {
      throw new Error("Failed to get layouts");
    }
    const framesResult = await getAll(studio2);
    if (framesResult.isError()) {
      throw framesResult.error;
    }
    const frames = framesResult.value;
    if (!frames) {
      throw new Error("Failed to get frames");
    }
    const layoutIdToNameMap = new Map;
    const frameIdToNameMap = new Map;
    for (const layout of layouts) {
      layoutIdToNameMap.set(layout.id, layout.name);
    }
    for (const frame of frames) {
      frameIdToNameMap.set(frame.id, frame.name);
    }
    for (const frameMap of frameMaps) {
      const { layoutId, frameSnapshots } = frameMap;
      const layoutName = layoutIdToNameMap.get(layoutId) || layoutId;
      if (!result[layoutName]) {
        result[layoutName] = {};
      }
      for (const snapshot of frameSnapshots) {
        const { imageName, ...rest } = snapshot;
        const frameName = frameIdToNameMap.get(snapshot.frameId);
        if (!frameName) {
          throw new Error(`No frame name for frame with ID: ${snapshot.frameId}`);
        }
        const newRest = { ...rest, frameName };
        result[layoutName][imageName] = newRest;
      }
    }
    return Result.ok(result);
  } catch (error) {
    return Result.error(error instanceof Error ? error : new Error(String(error)));
  }
}

// src/studio-adapter/layoutManagerToLookup.ts
init_dist();
async function layoutManagerToLookup(studio2) {
  const layoutsResult = await getAllLayouts(studio2);
  if (layoutsResult.isError()) {
    console.error("Failed to get layouts:", layoutsResult.error);
    return layoutsResult;
  }
  const layouts = layoutsResult.value;
  if (!layouts) {
    return Result.error(new Error("Layouts are null or undefined"));
  }
  return Result.try(() => {
    const layoutSizes = {};
    for (const layout of layouts) {
      const widthValue = typeof layout.width === "object" && layout.width !== null ? layout.width.value : layout.width;
      const heightValue = typeof layout.height === "object" && layout.height !== null ? layout.height.value : layout.height;
      const aspectRatio = heightValue > 0 ? widthValue / heightValue : 0;
      layoutSizes[layout.name] = {
        width: widthValue,
        height: heightValue,
        aspectRatio
      };
    }
    return layoutSizes;
  });
}

// src/studio/actions/layoutSizing.js
function layoutSizingScript(debug = false) {
  const version2 = 2;
  let debugObj = {};
  const selectedLayoutName = getSelectedLayoutName();
  const data = JSON.parse(getTextVariableValue("AUTO_GEN_TOOLBAR_LAYOUTS"));
  if (selectedLayoutName == null) {
    return;
  }
  const { width, height, aspectRatio: layoutRatio } = data[selectedLayoutName];
  if (debug) {
    debugObj = JSON.parse(JSON.stringify({
      selectedLayoutName,
      data,
      layoutRatio,
      width,
      height
    }));
  }
  if (layoutRatio != null && width != null && height != null) {
    const originalAspectRatio = layoutRatio;
    const minAllowedRatio = originalAspectRatio * 0.8;
    const maxAllowedRatio = originalAspectRatio * 1.2;
    const pageWidth = getPageWidth();
    const pageHeight = getPageHeight();
    const currentAspectRatio = pageWidth / pageHeight;
    if (debug) {
      debugObj = {
        currentAspectRatio,
        minAllowedRatio,
        maxAllowedRatio,
        pageWidth,
        pageHeight,
        ...debugObj
      };
    }
    if (currentAspectRatio < minAllowedRatio || currentAspectRatio > maxAllowedRatio) {
      const distToMin = Math.abs(currentAspectRatio - minAllowedRatio);
      const distToMax = Math.abs(currentAspectRatio - maxAllowedRatio);
      const targetRatio = distToMin <= distToMax ? minAllowedRatio : maxAllowedRatio;
      if (Math.round(width) == Math.round(pageWidth)) {
        let newWidth = pageHeight * targetRatio;
        data[selectedLayoutName].width = newWidth;
        data[selectedLayoutName].height = pageHeight;
        setPageSize(newWidth, pageHeight);
      } else if (Math.round(height) == Math.round(pageHeight)) {
        let newHeight = pageWidth / targetRatio;
        data[selectedLayoutName].height = newHeight;
        data[selectedLayoutName].width = pageWidth;
        setPageSize(pageWidth, newHeight);
      } else {
        data[selectedLayoutName].height = pageHeight;
        data[selectedLayoutName].width = pageHeight * targetRatio;
        setPageSize(data[selectedLayoutName].width, pageHeight);
      }
    } else {
      data[selectedLayoutName].height = pageHeight;
      data[selectedLayoutName].width = pageWidth;
    }
    setVariableValue("AUTO_GEN_TOOLBAR_LAYOUTS", JSON.stringify(data, null, 0));
  }
  if (debug) {
    console.log(debugObj);
  }
}

// src/studio/studioAdapter.ts
init_documentHandler();

// src/studio/connectorAdapter.ts
init_utils();

// node_modules/@chili-publish/studio-sdk/lib/src/next/types/ConnectorTypes.js
var ConnectorRegistrationSource;
(function(ConnectorRegistrationSource2) {
  ConnectorRegistrationSource2["url"] = "url";
  ConnectorRegistrationSource2["grafx"] = "grafx";
  ConnectorRegistrationSource2["local"] = "local";
})(ConnectorRegistrationSource || (ConnectorRegistrationSource = {}));
var ConnectorType;
(function(ConnectorType2) {
  ConnectorType2["media"] = "media";
  ConnectorType2["fonts"] = "fonts";
  ConnectorType2["data"] = "data";
})(ConnectorType || (ConnectorType = {}));
// src/studio/connectorAdapter.ts
async function getConnectorsByType(studio2, type) {
  return handleStudioFunc(studio2.connector.getAllByType, type);
}
async function registerConnector(studio2, id) {
  return handleStudioFunc(studio2.next.connector.register, {
    id,
    source: ConnectorRegistrationSource.grafx
  });
}
async function unregisterConnector(studio2, connectorId) {
  return handleStudioFunc(studio2.connector.unregister, connectorId);
}

// src/studio/studioAdapter.ts
async function getStudio() {
  if (window.SDK == null)
    return Result.error(new Error("Studio SDK does not exist on the window"));
  return Result.ok(window.SDK);
}
async function tryAddingToolbarToData(data) {
  const newData = {
    ...data,
    toolbar: JSON.stringify(createEmptyEnvelope(), null, 0)
  };
  return setPrivateData({
    studio: window.SDK,
    id: "0",
    privateData: newData
  });
}
async function loadLayoutImageMapFromDoc() {
  const result = await loadToolbarDataFromDoc();
  if (await result.isOk()) {
    return Result.ok(result.value?.layoutMaps ?? []);
  }
  return result;
}
async function loadFrameLayoutMapsFromDoc() {
  const result = await loadToolbarDataFromDoc();
  if (await result.isOk()) {
    return Result.ok(result.value?.frameMaps ?? []);
  }
  return result;
}
async function loadToolbarDataFromDoc() {
  const dataResult = await getPrivateData({
    id: "0",
    studio: window.SDK
  });
  if (dataResult.isOk()) {
    const data = dataResult.value;
    if (data.toolbar != null) {
      const toolbarResult = await Result.try(() => JSON.parse(data.toolbar));
      if (toolbarResult.isOk()) {
        return Result.ok(toolbarResult.value);
      }
      return toolbarResult;
    } else {
      const setDataResult = await tryAddingToolbarToData(data);
      if (setDataResult.isOk()) {
        return Result.ok(createEmptyEnvelope());
      }
      return setDataResult;
    }
  }
  return dataResult;
}
function saveLayoutImageMapToDoc(layoutMaps) {
  return saveToolbarDataToDoc("layoutMaps", layoutMaps);
}
function saveFrameLayoutMapsToDoc(frameMaps) {
  return saveToolbarDataToDoc("frameMaps", frameMaps);
}
async function saveToolbarDataToDoc(key, value) {
  const dataResult = await getPrivateData({
    id: "0",
    studio: window.SDK
  });
  if (dataResult.isOk()) {
    let data = dataResult.value;
    if (data.toolbar == null) {
      const setDataResult = await tryAddingToolbarToData(data);
      if (setDataResult.isOk()) {
        const dataResult2 = await getPrivateData({
          id: "0",
          studio: window.SDK
        });
        if (dataResult2.isOk()) {
          data = dataResult2.value;
        }
        return dataResult2;
      } else {
        return setDataResult;
      }
    }
    if (data.toolbar != null) {
      const toolbarResult = await Result.try(() => JSON.parse(data.toolbar));
      if (toolbarResult.isOk()) {
        const toolbar = toolbarResult.value;
        toolbar[key] = value;
        const stringifyResult = Result.try(() => JSON.stringify(toolbar, null, 0));
        if (stringifyResult.isOk()) {
          data.toolbar = stringifyResult.value;
          const setDataResult = await setPrivateData({
            studio: window.SDK,
            id: "0",
            privateData: data
          });
          if (setDataResult.isOk()) {
            return Result.ok();
          }
          return setDataResult;
        }
        return stringifyResult;
      }
      return toolbarResult;
    }
    return Result.error(new Error("data.toolbar is null even after we tried to fix it"));
  }
  return dataResult;
}
async function loadDocFromDoc() {
  const layoutsResult = await getAllLayouts(window.SDK);
  if (!layoutsResult.isOk()) {
    return layoutsResult;
  }
  const variablesResult = await getAllVariables(window.SDK);
  if (!variablesResult.isOk()) {
    return variablesResult;
  }
  const layouts = layoutsResult.value.map((layout) => ({
    name: layout.name || "",
    id: layout.id || "",
    parentId: layout.parentId
  }));
  const variables = variablesResult.value.map((variable) => {
    const baseVariable = {
      id: variable.id || "",
      name: variable.name || "",
      isVisiblie: variable.isVisible ?? false
    };
    switch (variable.type) {
      case "image":
      case "shortText":
        return {
          ...baseVariable,
          type: variable.type,
          value: String(variable.value || "")
        };
      case "list":
        return {
          ...baseVariable,
          type: "list",
          value: String(variable.value || ""),
          items: Array.isArray(variable.items) ? variable.items.map((item) => ({
            value: String(item.value || ""),
            displayValue: item.displayValue
          })) : []
        };
      case "boolean":
        return {
          ...baseVariable,
          type: "boolean",
          value: Boolean(variable.value)
        };
      default:
        return {
          ...baseVariable,
          type: "shortText",
          value: String(variable.value || "")
        };
    }
  });
  return Result.ok({
    layouts,
    variables
  });
}
async function saveLayoutMappingToAction(layoutMaps, doc) {
  const actionMap = layoutMappingToActionMap(layoutMaps, doc);
  const script = imageSelectionScript.toString().replace('"%DATA%"', JSON.stringify(actionMap)) + `
console.log(imageSelectionScript(false))`;
  const updateResult = await updateAction({
    name: "AUTO_GEN_TOOLBAR",
    studio: window.SDK
  }, {
    name: "AUTO_GEN_TOOLBAR",
    triggers: [
      { event: import_studio_sdk2.ActionEditorEvent.selectedLayoutChanged },
      { event: import_studio_sdk2.ActionEditorEvent.variableValueChanged }
    ],
    script
  });
  return updateResult;
}
async function saveImageSizingMappingToAction(frameMaps) {
  const imageResizingMapResult = await frameLayoutMappingToLookup(frameMaps, window.SDK);
  const layoutSizingMapResult = await layoutManagerToLookup(window.SDK);
  const results = Result.all(imageResizingMapResult, layoutSizingMapResult);
  if (results.isError() || results.value == null) {
    return results;
  }
  const [imageResizingData, layoutSizingData] = results.value;
  const script = imageSizingScript.toString().replace('"%DATA1%"', JSON.stringify(imageResizingData)).replace('"%DATA2%"', JSON.stringify(layoutSizingData)) + `
console.log(imageSizingScript(false))`;
  const updateResult = await updateAction({
    name: "AUTO_GEN_TOOLBAR_IR",
    studio: window.SDK
  }, {
    name: "AUTO_GEN_TOOLBAR_IR",
    triggers: [
      { event: import_studio_sdk2.ActionEditorEvent.selectedLayoutChanged },
      { event: import_studio_sdk2.ActionEditorEvent.variableValueChanged }
    ],
    script
  });
  return updateResult;
}
async function saveLayoutSizingToAction(on) {
  if (on) {
    const layoutSizingMapResult = await layoutManagerToLookup(window.SDK);
    if (layoutSizingMapResult.isError() || layoutSizingMapResult.value == null) {
      return layoutSizingMapResult;
    }
    const script = layoutSizingScript.toString() + `
console.log(layoutSizingScript(false))`;
    const updateResult = await updateAction({
      name: "AUTO_GEN_TOOLBAR_LAYOUTS",
      studio: window.SDK
    }, {
      name: "AUTO_GEN_TOOLBAR_LAYOUTS",
      triggers: [{ event: import_studio_sdk2.ActionEditorEvent.pageSizeChanged }],
      script
    });
    if (updateResult.isError()) {
      return updateResult;
    }
    const variableResult = await setOrCreateVariableValue({
      studio: window.SDK,
      name: "AUTO_GEN_TOOLBAR_LAYOUTS",
      variableType: import_studio_sdk2.VariableType.shortText,
      value: JSON.stringify(layoutSizingMapResult.value, null, 0)
    });
    if (variableResult.isError()) {
      return variableResult;
    }
    return setVariableVisblityWithName({
      studio: window.SDK,
      name: "AUTO_GEN_TOOLBAR_LAYOUTS",
      visible: { type: import_studio_sdk2.VariableVisibilityType.invisible }
    });
  } else {
    const variableResult = await setOrCreateVariableValue({
      studio: window.SDK,
      name: "AUTO_GEN_TOOLBAR_LAYOUTS",
      variableType: import_studio_sdk2.VariableType.shortText,
      value: JSON.stringify({}, null, 0)
    });
    if (variableResult.isError()) {
      return variableResult;
    }
    return setVariableVisblityWithName({
      studio: window.SDK,
      name: "AUTO_GEN_TOOLBAR_LAYOUTS",
      visible: { type: import_studio_sdk2.VariableVisibilityType.invisible }
    });
  }
}
async function updateFrameLayoutMaps(frameSnapshot) {
  try {
    const studioResult = await getStudio();
    if (!studioResult.isOk()) {
      return Result.error(studioResult.error);
    }
    const studio2 = studioResult.value;
    const selectedLayoutResult = await getSelected(studio2);
    if (!selectedLayoutResult.isOk()) {
      return Result.error(new Error("Failed to get selected layout: " + selectedLayoutResult.error?.message));
    }
    const selectedLayout = selectedLayoutResult.value;
    if (!selectedLayout || !selectedLayout.id) {
      return Result.error(new Error("No layout is currently selected"));
    }
    const layoutId = selectedLayout.id;
    const frameLayoutMapsResult = await loadFrameLayoutMapsFromDoc();
    if (!frameLayoutMapsResult.isOk()) {
      return Result.error(new Error("Failed to load frame layout maps: " + frameLayoutMapsResult.error?.message));
    }
    const frameLayoutMaps = frameLayoutMapsResult.value;
    let frameLayoutMap = frameLayoutMaps.find((map) => map.layoutId === layoutId);
    if (!frameLayoutMap) {
      frameLayoutMap = {
        layoutId,
        frameSnapshots: []
      };
      frameLayoutMaps.push(frameLayoutMap);
    }
    const frameSnapshotIndex = frameLayoutMap.frameSnapshots.findIndex((snapshot) => snapshot.frameId === frameSnapshot.frameId && snapshot.imageName == frameSnapshot.assetId);
    const newFrameSnapshot = {
      imageName: frameSnapshot.assetId,
      frameId: frameSnapshot.frameId,
      x: frameSnapshot.x,
      y: frameSnapshot.y,
      width: frameSnapshot.width,
      height: frameSnapshot.height
    };
    if (frameSnapshotIndex >= 0) {
      frameLayoutMap.frameSnapshots[frameSnapshotIndex] = newFrameSnapshot;
    } else {
      frameLayoutMap.frameSnapshots.push(newFrameSnapshot);
    }
    const saveResult = await saveFrameLayoutMapsToDoc(frameLayoutMaps);
    if (!saveResult.isOk()) {
      return Result.error(new Error("Failed to save frame layout maps: " + saveResult.error?.message));
    }
    return Result.ok(undefined);
  } catch (error) {
    return Result.error(error instanceof Error ? error : new Error(String(error)));
  }
}
async function getCurrentConnectors(studio2) {
  try {
    const connectorsResult = await getConnectorsByType(studio2, import_studio_sdk2.ConnectorType.media);
    if (!connectorsResult.isOk()) {
      return Result.error(new Error("Failed to get connectors: " + connectorsResult.error?.message));
    }
    const connectorInstances = connectorsResult.value;
    console.log("connectorInstances", connectorInstances);
    const documentStateResult = await getCurrentDocumentState(studio2);
    if (!documentStateResult.isOk()) {
      return Result.error(new Error("Failed to get document state: " + documentStateResult.error?.message));
    }
    const documentState = documentStateResult.value;
    const documentConnectors = documentState.connectors || [];
    console.log("documentConnectors", documentConnectors);
    const grafxConnectors = documentConnectors.filter((docConnector) => docConnector.source.source === "grafx" && connectorInstances.some((instance) => instance.id === docConnector.id));
    const result = [];
    for (const connector of grafxConnectors) {
      const sourceId = connector.source["id"];
      if (sourceId == null) {
        return Result.error(new Error(`Connector source ID is null for connector with id: ${connector.id}`));
      }
      const usage = {
        id: connector.id,
        sourceId,
        name: connector.name,
        type: "media",
        usesInTemplate: {
          images: [],
          variables: []
        }
      };
      if (documentState.pages && Array.isArray(documentState.pages)) {
        for (const page of documentState.pages) {
          if (page.frames && Array.isArray(page.frames)) {
            for (const frame of page.frames) {
              if (frame.type === "image" && frame.src && frame.src.id === connector.id) {
                usage.usesInTemplate.images.push({
                  id: frame.id,
                  name: frame.name || frame.id
                });
              }
            }
          }
        }
      }
      if (documentState.variables && Array.isArray(documentState.variables)) {
        for (const variable of documentState.variables) {
          if (variable.type === "image" && variable.value && typeof variable.value === "object" && variable.value.connectorId === connector.id) {
            usage.usesInTemplate.variables.push({
              id: variable.id,
              name: variable.name || variable.id
            });
          }
        }
      }
      result.push(usage);
    }
    return Result.ok(result);
  } catch (error) {
    return Result.error(error instanceof Error ? error : new Error(String(error)));
  }
}
async function mergeConnectors(studio2, targetConnectorId, selectedConnectorIds) {
  try {
    const connectorsToUnregister = selectedConnectorIds.filter((id) => id !== targetConnectorId);
    for (const connectorId of connectorsToUnregister) {
      const unregisterResult = await unregisterConnector(studio2, connectorId);
      if (!unregisterResult.isOk()) {
        return Result.error(new Error(`Failed to unregister connector ${connectorId}: ${unregisterResult.error?.message}`));
      }
    }
    const documentStateResult = await getCurrentDocumentState(studio2);
    if (!documentStateResult.isOk()) {
      return Result.error(new Error(`Failed to get document state: ${documentStateResult.error?.message}`));
    }
    let documentJson = JSON.stringify(documentStateResult.value);
    for (const connectorId of connectorsToUnregister) {
      const regex = new RegExp(connectorId, "g");
      documentJson = documentJson.replace(regex, targetConnectorId);
    }
    const loadResult = await loadDocumentFromJsonStr(studio2, documentJson);
    if (!loadResult.isOk()) {
      return Result.error(new Error(`Failed to load updated document: ${loadResult.error?.message}`));
    }
    return Result.ok(undefined);
  } catch (error) {
    return Result.error(error instanceof Error ? error : new Error(String(error)));
  }
}

// src/components/LayoutMappingModal/LayoutModal.tsx
var import_react257 = __toESM(require_react(), 1);

// node_modules/styled-components/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_react2 = __toESM(require_react(), 1);
var import_shallowequal = __toESM(require_shallowequal(), 1);

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign3 = Object.assign;
function hash(value, length) {
  return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position) {
  return value.indexOf(search, position);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2, siblings) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root2, props) {
  return assign3(node("", null, null, "", null, null, 0, root2.siblings), root2, { length: -root2.length }, props);
}
function lift(root2) {
  while (root2.root)
    root2 = copy(root2.root, { children: [root2] });
  append(root2, root2.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek3() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek3())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek3() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek3() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek3()))
    next();
  return slice(index2, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek3()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek3() === 45)
              characters2 += delimit(next());
            atrule = peek3(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type, props, children, length2, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0;i < index2; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value;x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root2, parent, offset === 0 ? RULESET : type, props, children, length2, siblings);
}
function comment(value, root2, parent, siblings) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root2, parent, length2, siblings) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}

// node_modules/stylis/src/Prefixer.js
function prefix2(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1" + "$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/))
        return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index2) {
        return length2 = index2, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3" + "$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix2(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_, a, b, c, d, e, f) {
        return MS + a + ":" + b + f + (c ? MS + a + "-span:" + (d ? e : +e - +b) + f : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3" + "$1" + WEBKIT + "$2$3" + "$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i = 0;i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(",")))
        return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0;i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix2(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign3(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign3(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/styled-components/dist/styled-components.browser.esm.js
var f = typeof process != "undefined" && process.env !== undefined && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var m = "active";
var y = "data-styled-version";
var v = "6.1.18";
var g = `/*!sc*/
`;
var S = typeof window != "undefined" && typeof document != "undefined";
var w = Boolean(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process != "undefined" && process.env !== undefined && process.env.REACT_APP_SC_DISABLE_SPEEDY !== undefined && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process != "undefined" && process.env !== undefined && process.env.SC_DISABLE_SPEEDY !== undefined && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : false);
var N = new Set;
var _ = Object.freeze([]);
var C = Object.freeze({});
function I(e, t, n) {
  return n === undefined && (n = C), e.theme !== n.theme && e.theme || t || n.theme;
}
var A = new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
var O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var D = /(^-|-$)/g;
function R(e) {
  return e.replace(O, "-").replace(D, "");
}
var T = /(a)(d)/gi;
var k = 52;
var j = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function x(e) {
  var t, n = "";
  for (t = Math.abs(e);t > k; t = t / k | 0)
    n = j(t % k) + n;
  return (j(t % k) + n).replace(T, "$1-$2");
}
var V;
var F = 5381;
var M = function(e, t) {
  for (var n = t.length;n; )
    e = 33 * e ^ t.charCodeAt(--n);
  return e;
};
var z = function(e) {
  return M(F, e);
};
function $(e) {
  return x(z(e) >>> 0);
}
function B(e) {
  return e.displayName || e.name || "Component";
}
function L(e) {
  return typeof e == "string" && true;
}
var G = typeof Symbol == "function" && Symbol.for;
var Y = G ? Symbol.for("react.memo") : 60115;
var W = G ? Symbol.for("react.forward_ref") : 60112;
var q = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
var H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
var U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
var J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
function X(e) {
  return (("type" in (t = e)) && t.type.$$typeof) === Y ? U : ("$$typeof" in e) ? J[e.$$typeof] : q;
  var t;
}
var Z = Object.defineProperty;
var K = Object.getOwnPropertyNames;
var Q = Object.getOwnPropertySymbols;
var ee = Object.getOwnPropertyDescriptor;
var te = Object.getPrototypeOf;
var ne = Object.prototype;
function oe(e, t, n) {
  if (typeof t != "string") {
    if (ne) {
      var o2 = te(t);
      o2 && o2 !== ne && oe(e, o2, n);
    }
    var r2 = K(t);
    Q && (r2 = r2.concat(Q(t)));
    for (var s2 = X(e), i2 = X(t), a2 = 0;a2 < r2.length; ++a2) {
      var c2 = r2[a2];
      if (!((c2 in H) || n && n[c2] || i2 && (c2 in i2) || s2 && (c2 in s2))) {
        var l2 = ee(t, c2);
        try {
          Z(e, c2, l2);
        } catch (e2) {
        }
      }
    }
  }
  return e;
}
function re(e) {
  return typeof e == "function";
}
function se(e) {
  return typeof e == "object" && "styledComponentId" in e;
}
function ie(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function ae(e, t) {
  if (e.length === 0)
    return "";
  for (var n = e[0], o2 = 1;o2 < e.length; o2++)
    n += t ? t + e[o2] : e[o2];
  return n;
}
function ce(e) {
  return e !== null && typeof e == "object" && e.constructor.name === Object.name && !(("props" in e) && e.$$typeof);
}
function le(e, t, n) {
  if (n === undefined && (n = false), !n && !ce(e) && !Array.isArray(e))
    return t;
  if (Array.isArray(t))
    for (var o2 = 0;o2 < t.length; o2++)
      e[o2] = le(e[o2], t[o2]);
  else if (ce(t))
    for (var o2 in t)
      e[o2] = le(e[o2], t[o2]);
  return e;
}
function ue(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
function he(t) {
  for (var n = [], o2 = 1;o2 < arguments.length; o2++)
    n[o2 - 1] = arguments[o2];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : ""));
}
var fe = function() {
  function e(e2) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e2;
  }
  return e.prototype.indexOfGroup = function(e2) {
    for (var t = 0, n = 0;n < e2; n++)
      t += this.groupSizes[n];
    return t;
  }, e.prototype.insertRules = function(e2, t) {
    if (e2 >= this.groupSizes.length) {
      for (var n = this.groupSizes, o2 = n.length, r2 = o2;e2 >= r2; )
        if ((r2 <<= 1) < 0)
          throw he(16, "".concat(e2));
      this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n), this.length = r2;
      for (var s2 = o2;s2 < r2; s2++)
        this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e2 + 1), a2 = (s2 = 0, t.length);s2 < a2; s2++)
      this.tag.insertRule(i2, t[s2]) && (this.groupSizes[e2]++, i2++);
  }, e.prototype.clearGroup = function(e2) {
    if (e2 < this.length) {
      var t = this.groupSizes[e2], n = this.indexOfGroup(e2), o2 = n + t;
      this.groupSizes[e2] = 0;
      for (var r2 = n;r2 < o2; r2++)
        this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(e2) {
    var t = "";
    if (e2 >= this.length || this.groupSizes[e2] === 0)
      return t;
    for (var n = this.groupSizes[e2], o2 = this.indexOfGroup(e2), r2 = o2 + n, s2 = o2;s2 < r2; s2++)
      t += "".concat(this.tag.getRule(s2)).concat(g);
    return t;
  }, e;
}();
var me = 1 << 30;
var ye = new Map;
var ve = new Map;
var ge = 1;
var Se = function(e) {
  if (ye.has(e))
    return ye.get(e);
  for (;ve.has(ge); )
    ge++;
  var t = ge++;
  if (false)
    ;
  return ye.set(e, t), ve.set(t, e), t;
};
var we = function(e, t) {
  ge = t + 1, ye.set(e, t), ve.set(t, e);
};
var be = "style[".concat(f, "][").concat(y, '="').concat(v, '"]');
var Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
var Ne = function(e, t, n) {
  for (var o2, r2 = n.split(","), s2 = 0, i2 = r2.length;s2 < i2; s2++)
    (o2 = r2[s2]) && e.registerName(t, o2);
};
var Pe = function(e, t) {
  for (var n, o2 = ((n = t.textContent) !== null && n !== undefined ? n : "").split(g), r2 = [], s2 = 0, i2 = o2.length;s2 < i2; s2++) {
    var a2 = o2[s2].trim();
    if (a2) {
      var c2 = a2.match(Ee);
      if (c2) {
        var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
        l2 !== 0 && (we(u2, l2), Ne(e, u2, c2[3]), e.getTag().insertRules(l2, r2)), r2.length = 0;
      } else
        r2.push(a2);
    }
  }
};
var _e = function(e) {
  for (var t = document.querySelectorAll(be), n = 0, o2 = t.length;n < o2; n++) {
    var r2 = t[n];
    r2 && r2.getAttribute(f) !== m && (Pe(e, r2), r2.parentNode && r2.parentNode.removeChild(r2));
  }
};
function Ce() {
  return typeof __webpack_nonce__ != "undefined" ? __webpack_nonce__ : null;
}
var Ie = function(e) {
  var t = document.head, n = e || t, o2 = document.createElement("style"), r2 = function(e2) {
    var t2 = Array.from(e2.querySelectorAll("style[".concat(f, "]")));
    return t2[t2.length - 1];
  }(n), s2 = r2 !== undefined ? r2.nextSibling : null;
  o2.setAttribute(f, m), o2.setAttribute(y, v);
  var i2 = Ce();
  return i2 && o2.setAttribute("nonce", i2), n.insertBefore(o2, s2), o2;
};
var Ae = function() {
  function e(e2) {
    this.element = Ie(e2), this.element.appendChild(document.createTextNode("")), this.sheet = function(e3) {
      if (e3.sheet)
        return e3.sheet;
      for (var t = document.styleSheets, n = 0, o2 = t.length;n < o2; n++) {
        var r2 = t[n];
        if (r2.ownerNode === e3)
          return r2;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    try {
      return this.sheet.insertRule(t, e2), this.length++, true;
    } catch (e3) {
      return false;
    }
  }, e.prototype.deleteRule = function(e2) {
    this.sheet.deleteRule(e2), this.length--;
  }, e.prototype.getRule = function(e2) {
    var t = this.sheet.cssRules[e2];
    return t && t.cssText ? t.cssText : "";
  }, e;
}();
var Oe = function() {
  function e(e2) {
    this.element = Ie(e2), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    if (e2 <= this.length && e2 >= 0) {
      var n = document.createTextNode(t);
      return this.element.insertBefore(n, this.nodes[e2] || null), this.length++, true;
    }
    return false;
  }, e.prototype.deleteRule = function(e2) {
    this.element.removeChild(this.nodes[e2]), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.nodes[e2].textContent : "";
  }, e;
}();
var De = function() {
  function e(e2) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    return e2 <= this.length && (this.rules.splice(e2, 0, t), this.length++, true);
  }, e.prototype.deleteRule = function(e2) {
    this.rules.splice(e2, 1), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.rules[e2] : "";
  }, e;
}();
var Re = S;
var Te = { isServer: !S, useCSSOMInjection: !w };
var ke = function() {
  function e(e2, n, o2) {
    e2 === undefined && (e2 = C), n === undefined && (n = {});
    var r2 = this;
    this.options = __assign(__assign({}, Te), e2), this.gs = n, this.names = new Map(o2), this.server = !!e2.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function() {
      return function(e3) {
        for (var t = e3.getTag(), n2 = t.length, o3 = "", r3 = function(n3) {
          var r4 = function(e4) {
            return ve.get(e4);
          }(n3);
          if (r4 === undefined)
            return "continue";
          var s3 = e3.names.get(r4), i2 = t.getGroup(n3);
          if (s3 === undefined || !s3.size || i2.length === 0)
            return "continue";
          var a2 = "".concat(f, ".g").concat(n3, '[id="').concat(r4, '"]'), c2 = "";
          s3 !== undefined && s3.forEach(function(e4) {
            e4.length > 0 && (c2 += "".concat(e4, ","));
          }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat(g);
        }, s2 = 0;s2 < n2; s2++)
          r3(s2);
        return o3;
      }(r2);
    });
  }
  return e.registerId = function(e2) {
    return Se(e2);
  }, e.prototype.rehydrate = function() {
    !this.server && S && _e(this);
  }, e.prototype.reconstructWithOptions = function(n, o2) {
    return o2 === undefined && (o2 = true), new e(__assign(__assign({}, this.options), n), this.gs, o2 && this.names || undefined);
  }, e.prototype.allocateGSInstance = function(e2) {
    return this.gs[e2] = (this.gs[e2] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (e2 = function(e3) {
      var { useCSSOMInjection: t, target: n } = e3;
      return e3.isServer ? new De(n) : t ? new Ae(n) : new Oe(n);
    }(this.options), new fe(e2)));
    var e2;
  }, e.prototype.hasNameForId = function(e2, t) {
    return this.names.has(e2) && this.names.get(e2).has(t);
  }, e.prototype.registerName = function(e2, t) {
    if (Se(e2), this.names.has(e2))
      this.names.get(e2).add(t);
    else {
      var n = new Set;
      n.add(t), this.names.set(e2, n);
    }
  }, e.prototype.insertRules = function(e2, t, n) {
    this.registerName(e2, t), this.getTag().insertRules(Se(e2), n);
  }, e.prototype.clearNames = function(e2) {
    this.names.has(e2) && this.names.get(e2).clear();
  }, e.prototype.clearRules = function(e2) {
    this.getTag().clearGroup(Se(e2)), this.clearNames(e2);
  }, e.prototype.clearTag = function() {
    this.tag = undefined;
  }, e;
}();
var je = /&/g;
var xe = /^\s*\/\/.*$/gm;
function Ve(e, t) {
  return e.map(function(e2) {
    return e2.type === "rule" && (e2.value = "".concat(t, " ").concat(e2.value), e2.value = e2.value.replaceAll(",", ",".concat(t, " ")), e2.props = e2.props.map(function(e3) {
      return "".concat(t, " ").concat(e3);
    })), Array.isArray(e2.children) && e2.type !== "@keyframes" && (e2.children = Ve(e2.children, t)), e2;
  });
}
function Fe(e) {
  var t, n, o2, r2 = e === undefined ? C : e, s2 = r2.options, i2 = s2 === undefined ? C : s2, a2 = r2.plugins, c2 = a2 === undefined ? _ : a2, l2 = function(e2, o3, r3) {
    return r3.startsWith(n) && r3.endsWith(n) && r3.replaceAll(n, "").length > 0 ? ".".concat(t) : e2;
  }, u2 = c2.slice();
  u2.push(function(e2) {
    e2.type === RULESET && e2.value.includes("&") && (e2.props[0] = e2.props[0].replace(je, n).replace(o2, l2));
  }), i2.prefix && u2.push(prefixer), u2.push(stringify);
  var p2 = function(e2, r3, s3, a3) {
    r3 === undefined && (r3 = ""), s3 === undefined && (s3 = ""), a3 === undefined && (a3 = "&"), t = a3, n = r3, o2 = new RegExp("\\".concat(n, "\\b"), "g");
    var c3 = e2.replace(xe, ""), l3 = compile(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
    i2.namespace && (l3 = Ve(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u2.concat(rulesheet(function(e3) {
      return p3.push(e3);
    })))), p3;
  };
  return p2.hash = c2.length ? c2.reduce(function(e2, t2) {
    return t2.name || he(15), M(e2, t2.name);
  }, F).toString() : "", p2;
}
var Me = new ke;
var ze = Fe();
var $e = import_react2.default.createContext({ shouldForwardProp: undefined, styleSheet: Me, stylis: ze });
var Be = $e.Consumer;
var Le = import_react2.default.createContext(undefined);
function Ge() {
  return import_react2.useContext($e);
}
function Ye(e) {
  var t = import_react2.useState(e.stylisPlugins), n = t[0], r2 = t[1], c2 = Ge().styleSheet, l2 = import_react2.useMemo(function() {
    var t2 = c2;
    return e.sheet ? t2 = e.sheet : e.target && (t2 = t2.reconstructWithOptions({ target: e.target }, false)), e.disableCSSOMInjection && (t2 = t2.reconstructWithOptions({ useCSSOMInjection: false })), t2;
  }, [e.disableCSSOMInjection, e.sheet, e.target, c2]), u2 = import_react2.useMemo(function() {
    return Fe({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: n });
  }, [e.enableVendorPrefixes, e.namespace, n]);
  import_react2.useEffect(function() {
    import_shallowequal.default(n, e.stylisPlugins) || r2(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var d = import_react2.useMemo(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: l2, stylis: u2 };
  }, [e.shouldForwardProp, l2, u2]);
  return import_react2.default.createElement($e.Provider, { value: d }, import_react2.default.createElement(Le.Provider, { value: u2 }, e.children));
}
var We = function() {
  function e(e2, t) {
    var n = this;
    this.inject = function(e3, t2) {
      t2 === undefined && (t2 = ze);
      var o2 = n.name + t2.hash;
      e3.hasNameForId(n.id, o2) || e3.insertRules(n.id, o2, t2(n.rules, o2, "@keyframes"));
    }, this.name = e2, this.id = "sc-keyframes-".concat(e2), this.rules = t, ue(this, function() {
      throw he(12, String(n.name));
    });
  }
  return e.prototype.getName = function(e2) {
    return e2 === undefined && (e2 = ze), this.name + e2.hash;
  }, e;
}();
var qe = function(e) {
  return e >= "A" && e <= "Z";
};
function He(e) {
  for (var t = "", n = 0;n < e.length; n++) {
    var o2 = e[n];
    if (n === 1 && o2 === "-" && e[0] === "-")
      return e;
    qe(o2) ? t += "-" + o2.toLowerCase() : t += o2;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var Ue = function(e) {
  return e == null || e === false || e === "";
};
var Je = function(t) {
  var n, o2, r2 = [];
  for (var s2 in t) {
    var i2 = t[s2];
    t.hasOwnProperty(s2) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r2.push("".concat(He(s2), ":"), i2, ";") : ce(i2) ? r2.push.apply(r2, __spreadArray(__spreadArray(["".concat(s2, " {")], Je(i2), false), ["}"], false)) : r2.push("".concat(He(s2), ": ").concat((n = s2, (o2 = i2) == null || typeof o2 == "boolean" || o2 === "" ? "" : typeof o2 != "number" || o2 === 0 || (n in unitlessKeys) || n.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
  }
  return r2;
};
function Xe(e, t, n, o2) {
  if (Ue(e))
    return [];
  if (se(e))
    return [".".concat(e.styledComponentId)];
  if (re(e)) {
    if (!re(s2 = e) || s2.prototype && s2.prototype.isReactComponent || !t)
      return [e];
    var r2 = e(t);
    return true, Xe(r2, t, n, o2);
  }
  var s2;
  return e instanceof We ? n ? (e.inject(n, o2), [e.getName(o2)]) : [e] : ce(e) ? Je(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e2) {
    return Xe(e2, t, n, o2);
  })) : [e.toString()];
}
function Ze(e) {
  for (var t = 0;t < e.length; t += 1) {
    var n = e[t];
    if (re(n) && !se(n))
      return false;
  }
  return true;
}
var Ke = z(v);
var Qe = function() {
  function e(e2, t, n) {
    this.rules = e2, this.staticRulesId = "", this.isStatic = (n === undefined || n.isStatic) && Ze(e2), this.componentId = t, this.baseHash = M(Ke, t), this.baseStyle = n, ke.registerId(t);
  }
  return e.prototype.generateAndInjectStyles = function(e2, t, n) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e2, t, n) : "";
    if (this.isStatic && !n.hash)
      if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId))
        o2 = ie(o2, this.staticRulesId);
      else {
        var r2 = ae(Xe(this.rules, e2, t, n)), s2 = x(M(this.baseHash, r2) >>> 0);
        if (!t.hasNameForId(this.componentId, s2)) {
          var i2 = n(r2, ".".concat(s2), undefined, this.componentId);
          t.insertRules(this.componentId, s2, i2);
        }
        o2 = ie(o2, s2), this.staticRulesId = s2;
      }
    else {
      for (var a2 = M(this.baseHash, n.hash), c2 = "", l2 = 0;l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if (typeof u2 == "string")
          c2 += u2;
        else if (u2) {
          var p2 = ae(Xe(u2, e2, t, n));
          a2 = M(a2, p2 + l2), c2 += p2;
        }
      }
      if (c2) {
        var d = x(a2 >>> 0);
        t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c2, ".".concat(d), undefined, this.componentId)), o2 = ie(o2, d);
      }
    }
    return o2;
  }, e;
}();
var et = import_react2.default.createContext(undefined);
var tt = et.Consumer;
var rt = {};
var st = new Set;
function it(e, r2, s2) {
  var i2 = se(e), a2 = e, c2 = !L(e), p2 = r2.attrs, d = p2 === undefined ? _ : p2, h = r2.componentId, f2 = h === undefined ? function(e2, t) {
    var n = typeof e2 != "string" ? "sc" : R(e2);
    rt[n] = (rt[n] || 0) + 1;
    var o2 = "".concat(n, "-").concat($(v + n + rt[n]));
    return t ? "".concat(t, "-").concat(o2) : o2;
  }(r2.displayName, r2.parentComponentId) : h, m2 = r2.displayName, y2 = m2 === undefined ? function(e2) {
    return L(e2) ? "styled.".concat(e2) : "Styled(".concat(B(e2), ")");
  }(e) : m2, g2 = r2.displayName && r2.componentId ? "".concat(R(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, S2 = i2 && a2.attrs ? a2.attrs.concat(d).filter(Boolean) : d, w2 = r2.shouldForwardProp;
  if (i2 && a2.shouldForwardProp) {
    var b = a2.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var E = r2.shouldForwardProp;
      w2 = function(e2, t) {
        return b(e2, t) && E(e2, t);
      };
    } else
      w2 = b;
  }
  var N2 = new Qe(s2, g2, i2 ? a2.componentStyle : undefined);
  function O2(e2, r3) {
    return function(e3, r4, s3) {
      var { attrs: i3, componentStyle: a3, defaultProps: c3, foldedComponentIds: p3, styledComponentId: d2, target: h2 } = e3, f3 = import_react2.default.useContext(et), m3 = Ge(), y3 = e3.shouldForwardProp || m3.shouldForwardProp;
      var v2 = I(r4, f3, c3) || C, g3 = function(e4, n, o2) {
        for (var r5, s4 = __assign(__assign({}, n), { className: undefined, theme: o2 }), i4 = 0;i4 < e4.length; i4 += 1) {
          var a4 = re(r5 = e4[i4]) ? r5(s4) : r5;
          for (var c4 in a4)
            s4[c4] = c4 === "className" ? ie(s4[c4], a4[c4]) : c4 === "style" ? __assign(__assign({}, s4[c4]), a4[c4]) : a4[c4];
        }
        return n.className && (s4.className = ie(s4.className, n.className)), s4;
      }(i3, r4, v2), S3 = g3.as || h2, w3 = {};
      for (var b2 in g3)
        g3[b2] === undefined || b2[0] === "$" || b2 === "as" || b2 === "theme" && g3.theme === v2 || (b2 === "forwardedAs" ? w3.as = g3.forwardedAs : y3 && !y3(b2, S3) || (w3[b2] = g3[b2]));
      var E2 = function(e4, t) {
        var n = Ge(), o2 = e4.generateAndInjectStyles(t, n.styleSheet, n.stylis);
        return false, o2;
      }(a3, g3);
      var N3 = ie(p3, d2);
      return E2 && (N3 += " " + E2), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, s3 && (w3.ref = s3), import_react2.createElement(S3, w3);
    }(D2, e2, r3);
  }
  O2.displayName = y2;
  var D2 = import_react2.default.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a2.target : e, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e2) {
    this._foldedDefaultProps = i2 ? function(e3) {
      for (var t = [], n = 1;n < arguments.length; n++)
        t[n - 1] = arguments[n];
      for (var o2 = 0, r3 = t;o2 < r3.length; o2++)
        le(e3, r3[o2], true);
      return e3;
    }({}, a2.defaultProps, e2) : e2;
  } }), false, ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c2 && oe(D2, e, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function at(e, t) {
  for (var n = [e[0]], o2 = 0, r2 = t.length;o2 < r2; o2 += 1)
    n.push(t[o2], e[o2 + 1]);
  return n;
}
var ct = function(e) {
  return Object.assign(e, { isCss: true });
};
function lt(t) {
  for (var n = [], o2 = 1;o2 < arguments.length; o2++)
    n[o2 - 1] = arguments[o2];
  if (re(t) || ce(t))
    return ct(Xe(at(_, __spreadArray([t], n, true))));
  var r2 = t;
  return n.length === 0 && r2.length === 1 && typeof r2[0] == "string" ? Xe(r2) : ct(Xe(at(r2, n)));
}
function ut(n, o2, r2) {
  if (r2 === undefined && (r2 = C), !o2)
    throw he(1, o2);
  var s2 = function(t) {
    for (var s3 = [], i2 = 1;i2 < arguments.length; i2++)
      s3[i2 - 1] = arguments[i2];
    return n(o2, r2, lt.apply(undefined, __spreadArray([t], s3, false)));
  };
  return s2.attrs = function(e) {
    return ut(n, o2, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e).filter(Boolean) }));
  }, s2.withConfig = function(e) {
    return ut(n, o2, __assign(__assign({}, r2), e));
  }, s2;
}
var pt = function(e) {
  return ut(it, e);
};
var dt = pt;
A.forEach(function(e) {
  dt[e] = pt(e);
});
var ht = function() {
  function e(e2, t) {
    this.rules = e2, this.componentId = t, this.isStatic = Ze(e2), ke.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(e2, t, n, o2) {
    var r2 = o2(ae(Xe(this.rules, t, n, o2)), ""), s2 = this.componentId + e2;
    n.insertRules(s2, s2, r2);
  }, e.prototype.removeStyles = function(e2, t) {
    t.clearRules(this.componentId + e2);
  }, e.prototype.renderStyles = function(e2, t, n, o2) {
    e2 > 2 && ke.registerId(this.componentId + e2), this.removeStyles(e2, n), this.createStyles(e2, t, n, o2);
  }, e;
}();
var vt = function() {
  function e() {
    var e2 = this;
    this._emitSheetCSS = function() {
      var t = e2.instance.toString();
      if (!t)
        return "";
      var n = Ce(), o2 = ae([n && 'nonce="'.concat(n, '"'), "".concat(f, '="true"'), "".concat(y, '="').concat(v, '"')].filter(Boolean), " ");
      return "<style ".concat(o2, ">").concat(t, "</style>");
    }, this.getStyleTags = function() {
      if (e2.sealed)
        throw he(2);
      return e2._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n;
      if (e2.sealed)
        throw he(2);
      var r2 = e2.instance.toString();
      if (!r2)
        return [];
      var s2 = ((n = {})[f] = "", n[y] = v, n.dangerouslySetInnerHTML = { __html: r2 }, n), i2 = Ce();
      return i2 && (s2.nonce = i2), [import_react2.default.createElement("style", __assign({}, s2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e2.sealed = true;
    }, this.instance = new ke({ isServer: true }), this.sealed = false;
  }
  return e.prototype.collectStyles = function(e2) {
    if (this.sealed)
      throw he(2);
    return import_react2.default.createElement(Ye, { sheet: this.instance }, e2);
  }, e.prototype.interleaveWithNodeStream = function(e2) {
    throw he(3);
  }, e;
}();
var St = "__sc-".concat(f, "__");

// node_modules/tslib/tslib.es6.mjs
var __assign2 = function() {
  __assign2 = Object.assign || function __assign(t) {
    for (var s2, i2 = 1, n = arguments.length;i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2);i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __spreadArray2(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar;i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React12 = __toESM(require_react(), 1);

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React8 = __toESM(require_react(), 1);

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react3 = __toESM(require_react(), 1);
function useCallbackRef(initialValue, callback) {
  var ref = import_react3.useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React4 = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React4.useLayoutEffect : React4.useEffect;
var currentValues = new WeakMap;
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
// node_modules/use-sidecar/dist/es2015/hoc.js
var React5 = __toESM(require_react(), 1);

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react4 = __toESM(require_react(), 1);
var cache = new WeakMap;
// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware2) {
  if (middleware2 === undefined) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === undefined) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign2({ async: true, ssr: false }, options);
  return medium;
}
// node_modules/use-sidecar/dist/es2015/renderProp.js
var React6 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
// node_modules/use-sidecar/dist/es2015/exports.js
var React7 = __toESM(require_react(), 1);
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React7.createElement(Target, __assign2({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}
// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React8.forwardRef(function(props, parentRef) {
  var ref = React8.useRef(null);
  var _a = React8.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var { forwardProps, children, className, removeScrollBar, enabled, shards, sideCar, noIsolation, inert, allowPinchZoom, as: _b } = props, Container = _b === undefined ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign2(__assign2({}, rest), callbacks);
  return React8.createElement(React8.Fragment, null, enabled && React8.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }), forwardProps ? React8.cloneElement(React8.Children.only(children), __assign2(__assign2({}, containerProps), { ref: containerRef })) : React8.createElement(Container, __assign2({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React11 = __toESM(require_react(), 1);

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React10 = __toESM(require_react(), 1);

// node_modules/react-style-singleton/dist/es2015/hook.js
var React9 = __toESM(require_react(), 1);

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React9.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var { styles, dynamic } = _a;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var { left, top, right, gap } = _a;
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  return `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React10.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var { noRelative, noImportant, gapMode: _b } = _a, gapMode = _b === undefined ? "margin" : _b;
  useLockAttribute();
  var gap = React10.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React10.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  if (!(node2 instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node2);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node2) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument = node2.ownerDocument;
  var current2 = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current2 instanceof ShadowRoot) {
      current2 = current2.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current2);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current2), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current2 = current2.parentNode;
  } while (current2 && current2 !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var { scrollTop, scrollHeight, clientHeight } = _a;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var { scrollLeft, scrollWidth, clientWidth } = _a;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id) {
  return `
  .block-interactivity-`.concat(id, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id, ` {pointer-events: all;}
`);
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React11.useRef([]);
  var touchStartRef = React11.useRef([0, 0]);
  var activeAxis = React11.useRef();
  var id = React11.useState(idCounter++)[0];
  var Style2 = React11.useState(styleSingleton)[0];
  var lastProps = React11.useRef(props);
  React11.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React11.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray2([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React11.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React11.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React11.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React11.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = undefined;
  }, []);
  var scrollWheel = React11.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React11.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React11.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var { removeScrollBar, inert } = props;
  return React11.createElement(React11.Fragment, null, inert ? React11.createElement(Style2, { styles: generateStyle(id) }) : null, removeScrollBar ? React11.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null);
}
function getOutermostShadowParent(node2) {
  var shadowParent = null;
  while (node2 !== null) {
    if (node2 instanceof ShadowRoot) {
      shadowParent = node2.host;
      node2 = node2.host;
    }
    node2 = node2.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React12.forwardRef(function(props, ref) {
  return React12.createElement(RemoveScroll, __assign2({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;
// node_modules/@mantine/core/esm/core/utils/keys/keys.mjs
"use client";
function keys(object) {
  return Object.keys(object);
}

// node_modules/@mantine/core/esm/core/utils/deep-merge/deep-merge.mjs
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target };
  const _source = source;
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isObject(_source[key])) {
        if (!(key in target)) {
          result[key] = _source[key];
        } else {
          result[key] = deepMerge(result[key], _source[key]);
        }
      } else {
        result[key] = _source[key];
      }
    });
  }
  return result;
}

// node_modules/@mantine/core/esm/core/utils/camel-to-kebab-case/camel-to-kebab-case.mjs
"use client";
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}

// node_modules/@mantine/core/esm/core/utils/units-converters/px.mjs
function getTransformedScaledValue(value) {
  if (typeof value !== "string" || !value.includes("var(--mantine-scale)")) {
    return value;
  }
  return value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px(value) {
  const transformedValue = getTransformedScaledValue(value);
  if (typeof transformedValue === "number") {
    return transformedValue;
  }
  if (typeof transformedValue === "string") {
    if (transformedValue.includes("calc") || transformedValue.includes("var")) {
      return transformedValue;
    }
    if (transformedValue.includes("px")) {
      return Number(transformedValue.replace("px", ""));
    }
    if (transformedValue.includes("rem")) {
      return Number(transformedValue.replace("rem", "")) * 16;
    }
    if (transformedValue.includes("em")) {
      return Number(transformedValue.replace("em", "")) * 16;
    }
    return Number(transformedValue);
  }
  return NaN;
}

// node_modules/@mantine/core/esm/core/utils/units-converters/rem.mjs
function scaleRem(remValue) {
  if (remValue === "0rem") {
    return "0rem";
  }
  return `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = false } = {}) {
  function converter(value) {
    if (value === 0 || value === "0") {
      return `0${units}`;
    }
    if (typeof value === "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value === "string") {
      if (value === "") {
        return value;
      }
      if (value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba(")) {
        return value;
      }
      if (value.includes(",")) {
        return value.split(",").map((val) => converter(val)).join(",");
      }
      if (value.includes(" ")) {
        return value.split(" ").map((val) => converter(val)).join(" ");
      }
      if (value.includes(units)) {
        return shouldScale ? scaleRem(value) : value;
      }
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
var rem = createConverter("rem", { shouldScale: true });
var em = createConverter("em");

// node_modules/@mantine/core/esm/core/utils/filter-props/filter-props.mjs
"use client";
function filterProps(props) {
  return Object.keys(props).reduce((acc, key) => {
    if (props[key] !== undefined) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
}

// node_modules/@mantine/core/esm/core/utils/is-number-like/is-number-like.mjs
"use client";
function isNumberLike(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value === "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "") {
      return true;
    }
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    const values = value.trim().split(/\s+/);
    return values.every((val) => cssUnitsRegex.test(val));
  }
  return false;
}

// node_modules/@mantine/core/esm/core/utils/is-element/is-element.mjs
var import_react6 = __toESM(require_react(), 1);
"use client";
function isElement(value) {
  if (Array.isArray(value) || value === null) {
    return false;
  }
  if (typeof value === "object") {
    if (value.type === import_react6.Fragment) {
      return false;
    }
    return true;
  }
  return false;
}

// node_modules/@mantine/core/esm/core/utils/create-safe-context/create-safe-context.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
"use client";
function createSafeContext(errorMessage) {
  const Context = import_react7.createContext(null);
  const useSafeContext = () => {
    const ctx = import_react7.useContext(Context);
    if (ctx === null) {
      throw new Error(errorMessage);
    }
    return ctx;
  };
  const Provider = ({ children, value }) => /* @__PURE__ */ import_jsx_runtime.jsx(Context.Provider, { value, children });
  return [Provider, useSafeContext];
}

// node_modules/@mantine/core/esm/core/utils/create-optional-context/create-optional-context.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
"use client";
function createOptionalContext(initialValue = null) {
  const Context = import_react8.createContext(initialValue);
  const useOptionalContext = () => import_react8.useContext(Context);
  const Provider = ({ children, value }) => /* @__PURE__ */ import_jsx_runtime2.jsx(Context.Provider, { value, children });
  return [Provider, useOptionalContext];
}

// node_modules/@mantine/core/esm/core/utils/find-element-ancestor/find-element-ancestor.mjs
"use client";
function findElementAncestor(element, selector) {
  let _element = element;
  while ((_element = _element.parentElement) && !_element.matches(selector)) {
  }
  return _element;
}

// node_modules/@mantine/core/esm/core/utils/create-scoped-keydown-handler/create-scoped-keydown-handler.mjs
"use client";
function getPreviousIndex(current2, elements, loop) {
  for (let i2 = current2 - 1;i2 >= 0; i2 -= 1) {
    if (!elements[i2].disabled) {
      return i2;
    }
  }
  if (loop) {
    for (let i2 = elements.length - 1;i2 > -1; i2 -= 1) {
      if (!elements[i2].disabled) {
        return i2;
      }
    }
  }
  return current2;
}
function getNextIndex(current2, elements, loop) {
  for (let i2 = current2 + 1;i2 < elements.length; i2 += 1) {
    if (!elements[i2].disabled) {
      return i2;
    }
  }
  if (loop) {
    for (let i2 = 0;i2 < elements.length; i2 += 1) {
      if (!elements[i2].disabled) {
        return i2;
      }
    }
  }
  return current2;
}
function onSameLevel(target, sibling, parentSelector) {
  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({
  parentSelector,
  siblingSelector,
  onKeyDown,
  loop = true,
  activateOnFocus = false,
  dir = "rtl",
  orientation
}) {
  return (event) => {
    onKeyDown?.(event);
    const elements = Array.from(findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll(siblingSelector) || []).filter((node2) => onSameLevel(event.currentTarget, node2, parentSelector));
    const current2 = elements.findIndex((el) => event.currentTarget === el);
    const _nextIndex = getNextIndex(current2, elements, loop);
    const _previousIndex = getPreviousIndex(current2, elements, loop);
    const nextIndex = dir === "rtl" ? _previousIndex : _nextIndex;
    const previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
    switch (event.key) {
      case "ArrowRight": {
        if (orientation === "horizontal") {
          event.stopPropagation();
          event.preventDefault();
          elements[nextIndex].focus();
          activateOnFocus && elements[nextIndex].click();
        }
        break;
      }
      case "ArrowLeft": {
        if (orientation === "horizontal") {
          event.stopPropagation();
          event.preventDefault();
          elements[previousIndex].focus();
          activateOnFocus && elements[previousIndex].click();
        }
        break;
      }
      case "ArrowUp": {
        if (orientation === "vertical") {
          event.stopPropagation();
          event.preventDefault();
          elements[_previousIndex].focus();
          activateOnFocus && elements[_previousIndex].click();
        }
        break;
      }
      case "ArrowDown": {
        if (orientation === "vertical") {
          event.stopPropagation();
          event.preventDefault();
          elements[_nextIndex].focus();
          activateOnFocus && elements[_nextIndex].click();
        }
        break;
      }
      case "Home": {
        event.stopPropagation();
        event.preventDefault();
        !elements[0].disabled && elements[0].focus();
        break;
      }
      case "End": {
        event.stopPropagation();
        event.preventDefault();
        const last = elements.length - 1;
        !elements[last].disabled && elements[last].focus();
        break;
      }
    }
  };
}

// node_modules/@mantine/core/esm/core/utils/get-default-z-index/get-default-z-index.mjs
"use client";
var elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function getDefaultZIndex(level) {
  return elevations[level];
}

// node_modules/@mantine/core/esm/core/utils/noop/noop.mjs
"use client";
var noop4 = () => {
};

// node_modules/@mantine/core/esm/core/utils/close-on-escape/close-on-escape.mjs
"use client";
function closeOnEscape(callback, options = { active: true }) {
  if (typeof callback !== "function" || !options.active) {
    return options.onKeyDown || noop4;
  }
  return (event) => {
    if (event.key === "Escape") {
      callback(event);
      options.onTrigger?.();
    }
  };
}

// node_modules/@mantine/core/esm/core/utils/get-size/get-size.mjs
"use client";
function getSize(size, prefix3 = "size", convertToRem = true) {
  if (size === undefined) {
    return;
  }
  return isNumberLike(size) ? convertToRem ? rem(size) : size : `var(--${prefix3}-${size})`;
}
function getSpacing(size) {
  return getSize(size, "mantine-spacing");
}
function getRadius(size) {
  if (size === undefined) {
    return "var(--mantine-radius-default)";
  }
  return getSize(size, "mantine-radius");
}
function getFontSize(size) {
  return getSize(size, "mantine-font-size");
}
function getLineHeight(size) {
  return getSize(size, "mantine-line-height", false);
}
function getShadow(size) {
  if (!size) {
    return;
  }
  return getSize(size, "mantine-shadow", false);
}

// node_modules/@mantine/core/esm/core/utils/create-event-handler/create-event-handler.mjs
"use client";
function createEventHandler(parentEventHandler, eventHandler) {
  return (event) => {
    parentEventHandler?.(event);
    eventHandler?.(event);
  };
}

// node_modules/@mantine/core/esm/core/utils/get-breakpoint-value/get-breakpoint-value.mjs
"use client";
function getBreakpointValue(breakpoint, breakpoints) {
  if (breakpoint in breakpoints) {
    return px(breakpoints[breakpoint]);
  }
  return px(breakpoint);
}

// node_modules/@mantine/core/esm/core/utils/get-sorted-breakpoints/get-sorted-breakpoints.mjs
"use client";
function getSortedBreakpoints(values, breakpoints) {
  const convertedBreakpoints = values.map((breakpoint) => ({
    value: breakpoint,
    px: getBreakpointValue(breakpoint, breakpoints)
  }));
  convertedBreakpoints.sort((a2, b) => a2.px - b.px);
  return convertedBreakpoints;
}

// node_modules/@mantine/core/esm/core/utils/get-base-value/get-base-value.mjs
"use client";
function getBaseValue(value) {
  if (typeof value === "object" && value !== null) {
    if ("base" in value) {
      return value.base;
    }
    return;
  }
  return value;
}

// node_modules/@mantine/core/esm/core/utils/get-context-item-index/get-context-item-index.mjs
"use client";
function getContextItemIndex(elementSelector, parentSelector, node2) {
  if (!node2) {
    return null;
  }
  return Array.from(findElementAncestor(node2, parentSelector)?.querySelectorAll(elementSelector) || []).findIndex((element) => element === node2);
}

// node_modules/@mantine/core/esm/core/utils/use-hovered/use-hovered.mjs
var import_react9 = __toESM(require_react(), 1);
"use client";
function useHovered() {
  const [hovered, setHovered] = import_react9.useState(-1);
  const resetHovered = () => setHovered(-1);
  return [hovered, { setHovered, resetHovered }];
}

// node_modules/@mantine/hooks/esm/utils/clamp/clamp.mjs
"use client";
function clamp(value, min, max) {
  if (min === undefined && max === undefined) {
    return value;
  }
  if (min !== undefined && max === undefined) {
    return Math.max(value, min);
  }
  if (min === undefined && max !== undefined) {
    return Math.min(value, max);
  }
  return Math.min(Math.max(value, min), max);
}
// node_modules/@mantine/hooks/esm/utils/random-id/random-id.mjs
"use client";
function randomId(prefix3 = "mantine-") {
  return `${prefix3}${Math.random().toString(36).slice(2, 11)}`;
}

// node_modules/@mantine/hooks/esm/use-callback-ref/use-callback-ref.mjs
var import_react10 = __toESM(require_react(), 1);
"use client";
function useCallbackRef2(callback) {
  const callbackRef = import_react10.useRef(callback);
  import_react10.useEffect(() => {
    callbackRef.current = callback;
  });
  return import_react10.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
// node_modules/@mantine/hooks/esm/use-debounced-callback/use-debounced-callback.mjs
var import_react11 = __toESM(require_react(), 1);
"use client";
function useDebouncedCallback(callback, options) {
  const delay = typeof options === "number" ? options : options.delay;
  const flushOnUnmount = typeof options === "number" ? false : options.flushOnUnmount;
  const handleCallback = useCallbackRef2(callback);
  const debounceTimerRef = import_react11.useRef(0);
  const flushRef = import_react11.useRef(() => {
  });
  const lastCallback = Object.assign(import_react11.useCallback((...args) => {
    window.clearTimeout(debounceTimerRef.current);
    const flush = () => {
      if (debounceTimerRef.current !== 0) {
        debounceTimerRef.current = 0;
        handleCallback(...args);
      }
    };
    flushRef.current = flush;
    lastCallback.flush = flush;
    debounceTimerRef.current = window.setTimeout(flush, delay);
  }, [handleCallback, delay]), { flush: flushRef.current });
  import_react11.useEffect(() => () => {
    window.clearTimeout(debounceTimerRef.current);
    if (flushOnUnmount) {
      lastCallback.flush();
    }
  }, [lastCallback, flushOnUnmount]);
  return lastCallback;
}
// node_modules/@mantine/hooks/esm/use-click-outside/use-click-outside.mjs
var import_react12 = __toESM(require_react(), 1);
"use client";
var DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(handler, events, nodes) {
  const ref = import_react12.useRef(null);
  import_react12.useEffect(() => {
    const listener = (event) => {
      const { target } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = target?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(target) && target.tagName !== "HTML";
        const shouldTrigger = nodes.every((node2) => !!node2 && !event.composedPath().includes(node2));
        shouldTrigger && !shouldIgnore && handler();
      } else if (ref.current && !ref.current.contains(target)) {
        handler();
      }
    };
    (events || DEFAULT_EVENTS).forEach((fn) => document.addEventListener(fn, listener));
    return () => {
      (events || DEFAULT_EVENTS).forEach((fn) => document.removeEventListener(fn, listener));
    };
  }, [ref, handler, nodes]);
  return ref;
}
// node_modules/@mantine/hooks/esm/use-media-query/use-media-query.mjs
var import_react13 = __toESM(require_react(), 1);
"use client";
function attachMediaListener(query, callback) {
  try {
    query.addEventListener("change", callback);
    return () => query.removeEventListener("change", callback);
  } catch (e) {
    query.addListener(callback);
    return () => query.removeListener(callback);
  }
}
function getInitialValue(query, initialValue) {
  if (typeof window !== "undefined" && "matchMedia" in window) {
    return window.matchMedia(query).matches;
  }
  return false;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = {
  getInitialValueInEffect: true
}) {
  const [matches, setMatches] = import_react13.useState(getInitialValueInEffect ? initialValue : getInitialValue(query));
  const queryRef = import_react13.useRef(null);
  import_react13.useEffect(() => {
    if ("matchMedia" in window) {
      queryRef.current = window.matchMedia(query);
      setMatches(queryRef.current.matches);
      return attachMediaListener(queryRef.current, (event) => setMatches(event.matches));
    }
    return;
  }, [query]);
  return matches;
}

// node_modules/@mantine/hooks/esm/use-isomorphic-effect/use-isomorphic-effect.mjs
var import_react14 = __toESM(require_react(), 1);
"use client";
var useIsomorphicEffect = typeof document !== "undefined" ? import_react14.useLayoutEffect : import_react14.useEffect;

// node_modules/@mantine/hooks/esm/use-focus-return/use-focus-return.mjs
var import_react16 = __toESM(require_react(), 1);

// node_modules/@mantine/hooks/esm/use-did-update/use-did-update.mjs
var import_react15 = __toESM(require_react(), 1);
"use client";
function useDidUpdate(fn, dependencies) {
  const mounted = import_react15.useRef(false);
  import_react15.useEffect(() => () => {
    mounted.current = false;
  }, []);
  import_react15.useEffect(() => {
    if (mounted.current) {
      return fn();
    }
    mounted.current = true;
    return;
  }, dependencies);
}

// node_modules/@mantine/hooks/esm/use-focus-return/use-focus-return.mjs
"use client";
function useFocusReturn({ opened, shouldReturnFocus = true }) {
  const lastActiveElement = import_react16.useRef(null);
  const returnFocus = () => {
    if (lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus === "function") {
      lastActiveElement.current?.focus({ preventScroll: true });
    }
  };
  useDidUpdate(() => {
    let timeout = -1;
    const clearFocusTimeout = (event) => {
      if (event.key === "Tab") {
        window.clearTimeout(timeout);
      }
    };
    document.addEventListener("keydown", clearFocusTimeout);
    if (opened) {
      lastActiveElement.current = document.activeElement;
    } else if (shouldReturnFocus) {
      timeout = window.setTimeout(returnFocus, 10);
    }
    return () => {
      window.clearTimeout(timeout);
      document.removeEventListener("keydown", clearFocusTimeout);
    };
  }, [opened, shouldReturnFocus]);
  return returnFocus;
}
// node_modules/@mantine/hooks/esm/use-focus-trap/use-focus-trap.mjs
var import_react17 = __toESM(require_react(), 1);

// node_modules/@mantine/hooks/esm/use-focus-trap/tabbable.mjs
"use client";
var TABBABLE_NODES = /input|select|textarea|button|object/;
var FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  if (false) {
  }
  return element.style.display === "none";
}
function visible(element) {
  const isHidden = element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden";
  if (isHidden) {
    return false;
  }
  let parentElement = element;
  while (parentElement) {
    if (parentElement === document.body || parentElement.nodeType === 11) {
      break;
    }
    if (hidden(parentElement)) {
      return false;
    }
    parentElement = parentElement.parentNode;
  }
  return true;
}
function getElementTabIndex(element) {
  let tabIndex = element.getAttribute("tabindex");
  if (tabIndex === null) {
    tabIndex = undefined;
  }
  return parseInt(tabIndex, 10);
}
function focusable(element) {
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
  const res = TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);
  return res && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  const isTabIndexNaN = Number.isNaN(tabIndex);
  return (isTabIndexNaN || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}

// node_modules/@mantine/hooks/esm/use-focus-trap/scope-tab.mjs
"use client";
function scopeTab(node2, event) {
  const tabbable2 = findTabbableDescendants(node2);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1];
  const root2 = node2.getRootNode();
  let leavingFinalTabbable = finalTabbable === root2.activeElement || node2 === root2.activeElement;
  const activeElement2 = root2.activeElement;
  const activeElementIsRadio = activeElement2.tagName === "INPUT" && activeElement2.getAttribute("type") === "radio";
  if (activeElementIsRadio) {
    const activeRadioGroup = tabbable2.filter((element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement2.getAttribute("name"));
    leavingFinalTabbable = activeRadioGroup.includes(finalTabbable);
  }
  if (!leavingFinalTabbable) {
    return;
  }
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  if (target) {
    target.focus();
  }
}

// node_modules/@mantine/hooks/esm/use-focus-trap/use-focus-trap.mjs
"use client";
function useFocusTrap(active = true) {
  const ref = import_react17.useRef(null);
  const focusNode = (node2) => {
    let focusElement = node2.querySelector("[data-autofocus]");
    if (!focusElement) {
      const children = Array.from(node2.querySelectorAll(FOCUS_SELECTOR));
      focusElement = children.find(tabbable) || children.find(focusable) || null;
      if (!focusElement && focusable(node2)) {
        focusElement = node2;
      }
    }
    if (focusElement) {
      focusElement.focus({ preventScroll: true });
    } else if (false) {
    }
  };
  const setRef = import_react17.useCallback((node2) => {
    if (!active) {
      return;
    }
    if (node2 === null) {
      return;
    }
    if (ref.current === node2) {
      return;
    }
    if (node2) {
      setTimeout(() => {
        if (node2.getRootNode()) {
          focusNode(node2);
        } else if (false) {
        }
      });
      ref.current = node2;
    } else {
      ref.current = null;
    }
  }, [active]);
  import_react17.useEffect(() => {
    if (!active) {
      return;
    }
    ref.current && setTimeout(() => focusNode(ref.current));
    const handleKeyDown = (event) => {
      if (event.key === "Tab" && ref.current) {
        scopeTab(ref.current, event);
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [active]);
  return setRef;
}
// node_modules/@mantine/hooks/esm/use-id/use-id.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/@mantine/hooks/esm/use-id/use-react-id.mjs
var import_react18 = __toESM(require_react(), 1);
"use client";
var __useId = import_react18.default["useId".toString()] || (() => {
  return;
});
function useReactId() {
  const id = __useId();
  return id ? `mantine-${id.replace(/:/g, "")}` : "";
}

// node_modules/@mantine/hooks/esm/use-id/use-id.mjs
"use client";
function useId(staticId) {
  const reactId = useReactId();
  const [uuid, setUuid] = import_react19.useState(reactId);
  useIsomorphicEffect(() => {
    setUuid(randomId());
  }, []);
  if (typeof staticId === "string") {
    return staticId;
  }
  if (typeof window === "undefined") {
    return reactId;
  }
  return uuid;
}
// node_modules/@mantine/hooks/esm/use-window-event/use-window-event.mjs
var import_react20 = __toESM(require_react(), 1);
"use client";
function useWindowEvent(type, listener, options) {
  import_react20.useEffect(() => {
    window.addEventListener(type, listener, options);
    return () => window.removeEventListener(type, listener, options);
  }, [type, listener]);
}

// node_modules/@mantine/hooks/esm/use-merged-ref/use-merged-ref.mjs
var import_react21 = __toESM(require_react(), 1);
"use client";
function assignRef2(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (typeof ref === "object" && ref !== null && "current" in ref) {
    ref.current = value;
  }
}
function mergeRefs(...refs) {
  const cleanupMap = /* @__PURE__ */ new Map;
  return (node2) => {
    refs.forEach((ref) => {
      const cleanup = assignRef2(ref, node2);
      if (cleanup) {
        cleanupMap.set(ref, cleanup);
      }
    });
    if (cleanupMap.size > 0) {
      return () => {
        refs.forEach((ref) => {
          const cleanup = cleanupMap.get(ref);
          if (cleanup) {
            cleanup();
          } else {
            assignRef2(ref, null);
          }
        });
        cleanupMap.clear();
      };
    }
  };
}
function useMergedRef(...refs) {
  return import_react21.useCallback(mergeRefs(...refs), refs);
}
// node_modules/@mantine/hooks/esm/use-move/use-move.mjs
var import_react22 = __toESM(require_react(), 1);
"use client";
function useMove(onChange, handlers, dir = "ltr") {
  const ref = import_react22.useRef(null);
  const mounted = import_react22.useRef(false);
  const isSliding = import_react22.useRef(false);
  const frame = import_react22.useRef(0);
  const [active, setActive] = import_react22.useState(false);
  import_react22.useEffect(() => {
    mounted.current = true;
  }, []);
  import_react22.useEffect(() => {
    const node2 = ref.current;
    const onScrub = ({ x: x2, y: y2 }) => {
      cancelAnimationFrame(frame.current);
      frame.current = requestAnimationFrame(() => {
        if (mounted.current && node2) {
          node2.style.userSelect = "none";
          const rect = node2.getBoundingClientRect();
          if (rect.width && rect.height) {
            const _x = clamp((x2 - rect.left) / rect.width, 0, 1);
            onChange({
              x: dir === "ltr" ? _x : 1 - _x,
              y: clamp((y2 - rect.top) / rect.height, 0, 1)
            });
          }
        }
      });
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", stopScrubbing);
      document.addEventListener("touchmove", onTouchMove);
      document.addEventListener("touchend", stopScrubbing);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", stopScrubbing);
      document.removeEventListener("touchmove", onTouchMove);
      document.removeEventListener("touchend", stopScrubbing);
    };
    const startScrubbing = () => {
      if (!isSliding.current && mounted.current) {
        isSliding.current = true;
        typeof handlers?.onScrubStart === "function" && handlers.onScrubStart();
        setActive(true);
        bindEvents();
      }
    };
    const stopScrubbing = () => {
      if (isSliding.current && mounted.current) {
        isSliding.current = false;
        setActive(false);
        unbindEvents();
        setTimeout(() => {
          typeof handlers?.onScrubEnd === "function" && handlers.onScrubEnd();
        }, 0);
      }
    };
    const onMouseDown = (event) => {
      startScrubbing();
      event.preventDefault();
      onMouseMove(event);
    };
    const onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY });
    const onTouchStart = (event) => {
      if (event.cancelable) {
        event.preventDefault();
      }
      startScrubbing();
      onTouchMove(event);
    };
    const onTouchMove = (event) => {
      if (event.cancelable) {
        event.preventDefault();
      }
      onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });
    };
    node2?.addEventListener("mousedown", onMouseDown);
    node2?.addEventListener("touchstart", onTouchStart, { passive: false });
    return () => {
      if (node2) {
        node2.removeEventListener("mousedown", onMouseDown);
        node2.removeEventListener("touchstart", onTouchStart);
      }
    };
  }, [dir, onChange]);
  return { ref, active };
}
// node_modules/@mantine/hooks/esm/use-uncontrolled/use-uncontrolled.mjs
var import_react23 = __toESM(require_react(), 1);
"use client";
function useUncontrolled({
  value,
  defaultValue,
  finalValue,
  onChange = () => {
  }
}) {
  const [uncontrolledValue, setUncontrolledValue] = import_react23.useState(defaultValue !== undefined ? defaultValue : finalValue);
  const handleUncontrolledChange = (val, ...payload) => {
    setUncontrolledValue(val);
    onChange?.(val, ...payload);
  };
  if (value !== undefined) {
    return [value, onChange, true];
  }
  return [uncontrolledValue, handleUncontrolledChange, false];
}

// node_modules/@mantine/hooks/esm/use-reduced-motion/use-reduced-motion.mjs
"use client";
function useReducedMotion(initialValue, options) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}
// node_modules/@mantine/hooks/esm/use-previous/use-previous.mjs
var import_react24 = __toESM(require_react(), 1);
"use client";
function usePrevious(value) {
  const ref = import_react24.useRef(undefined);
  import_react24.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
// node_modules/@mantine/core/esm/core/utils/memoize/memoize.mjs
"use client";
function memoize2(func) {
  const cache2 = /* @__PURE__ */ new Map;
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    const result = func(...args);
    cache2.set(key, result);
    return result;
  };
}

// node_modules/@mantine/core/esm/core/utils/find-closest-number/find-closest-number.mjs
"use client";
function findClosestNumber(value, numbers) {
  if (numbers.length === 0) {
    return value;
  }
  return numbers.reduce((prev2, curr) => Math.abs(curr - value) < Math.abs(prev2 - value) ? curr : prev2);
}

// node_modules/@mantine/core/esm/core/utils/get-ref-prop/get-ref-prop.mjs
var import_react25 = __toESM(require_react(), 1);
"use client";
function getRefProp(element) {
  const version2 = import_react25.default.version;
  if (typeof import_react25.default.version !== "string") {
    return element?.ref;
  }
  if (version2.startsWith("18.")) {
    return element?.ref;
  }
  return element?.props?.ref;
}

// node_modules/@mantine/core/esm/core/styles-api/create-vars-resolver/create-vars-resolver.mjs
"use client";
function createVarsResolver(resolver) {
  return resolver;
}

// node_modules/clsx/dist/clsx.mjs
function r2(e) {
  var t, f2, n = "";
  if (typeof e == "string" || typeof e == "number")
    n += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var o2 = e.length;
      for (t = 0;t < o2; t++)
        e[t] && (f2 = r2(e[t])) && (n && (n += " "), n += f2);
    } else
      for (f2 in e)
        e[f2] && (n && (n += " "), n += f2);
  return n;
}
function clsx() {
  for (var e, t, f2 = 0, n = "", o2 = arguments.length;f2 < o2; f2++)
    (e = arguments[f2]) && (t = r2(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/resolve-class-names/resolve-class-names.mjs
"use client";
var EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  objects.forEach((obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (merged[key]) {
        merged[key] = clsx_default(merged[key], value);
      } else {
        merged[key] = value;
      }
    });
  });
  return merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
  const arrayClassNames = Array.isArray(classNames) ? classNames : [classNames];
  const resolvedClassNames = arrayClassNames.map((item) => typeof item === "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES);
  return mergeClassNames(resolvedClassNames);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-styles/resolve-styles.mjs
"use client";
function resolveStyles({ theme, styles, props, stylesCtx }) {
  const arrayStyles = Array.isArray(styles) ? styles : [styles];
  return arrayStyles.reduce((acc, style2) => {
    if (typeof style2 === "function") {
      return { ...acc, ...style2(theme, props, stylesCtx) };
    }
    return { ...acc, ...style2 };
  }, {});
}

// node_modules/@mantine/core/esm/core/styles-api/use-resolved-styles-api/use-resolved-styles-api.mjs
var import_react39 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/Mantine.context.mjs
var import_react26 = __toESM(require_react(), 1);
"use client";
var MantineContext = import_react26.createContext(null);
function useMantineContext() {
  const ctx = import_react26.useContext(MantineContext);
  if (!ctx) {
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  }
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
  return useMantineContext().stylesTransform?.styles;
}
function useMantineEnv() {
  return useMantineContext().env || "default";
}

// node_modules/@mantine/core/esm/core/MantineProvider/default-theme.mjs
var import_react28 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/default-variant-colors-resolver/default-variant-colors-resolver.mjs
var import_react27 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/to-rgba/to-rgba.mjs
function isHexColor(hex) {
  const HEX_REGEXP = /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i;
  return HEX_REGEXP.test(hex);
}
function hexToRgba(color) {
  let hexString = color.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha
    };
  }
  const parsed = parseInt(hexString, 16);
  const r3 = parsed >> 16 & 255;
  const g2 = parsed >> 8 & 255;
  const b = parsed & 255;
  return {
    r: r3,
    g: g2,
    b,
    a: 1
  };
}
function rgbStringToRgba(color) {
  const [r3, g2, b, a2] = color.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r3, g: g2, b, a: a2 || 1 };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i;
  const matches = hslaString.match(hslaRegex);
  if (!matches) {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  }
  const h = parseInt(matches[1], 10);
  const s2 = parseInt(matches[2], 10) / 100;
  const l2 = parseInt(matches[3], 10) / 100;
  const a2 = matches[5] ? parseFloat(matches[5]) : undefined;
  const chroma = (1 - Math.abs(2 * l2 - 1)) * s2;
  const huePrime = h / 60;
  const x2 = chroma * (1 - Math.abs(huePrime % 2 - 1));
  const m2 = l2 - chroma / 2;
  let r3;
  let g2;
  let b;
  if (huePrime >= 0 && huePrime < 1) {
    r3 = chroma;
    g2 = x2;
    b = 0;
  } else if (huePrime >= 1 && huePrime < 2) {
    r3 = x2;
    g2 = chroma;
    b = 0;
  } else if (huePrime >= 2 && huePrime < 3) {
    r3 = 0;
    g2 = chroma;
    b = x2;
  } else if (huePrime >= 3 && huePrime < 4) {
    r3 = 0;
    g2 = x2;
    b = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    r3 = x2;
    g2 = 0;
    b = chroma;
  } else {
    r3 = chroma;
    g2 = 0;
    b = x2;
  }
  return {
    r: Math.round((r3 + m2) * 255),
    g: Math.round((g2 + m2) * 255),
    b: Math.round((b + m2) * 255),
    a: a2 || 1
  };
}
function toRgba(color) {
  if (isHexColor(color)) {
    return hexToRgba(color);
  }
  if (color.startsWith("rgb")) {
    return rgbStringToRgba(color);
  }
  if (color.startsWith("hsl")) {
    return hslStringToRgba(color);
  }
  return {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/darken/darken.mjs
function darken(color, alpha) {
  if (color.startsWith("var(")) {
    return `color-mix(in srgb, ${color}, black ${alpha * 100}%)`;
  }
  const { r: r3, g: g2, b, a: a2 } = toRgba(color);
  const f2 = 1 - alpha;
  const dark = (input) => Math.round(input * f2);
  return `rgba(${dark(r3)}, ${dark(g2)}, ${dark(b)}, ${a2})`;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-primary-shade/get-primary-shade.mjs
"use client";
function getPrimaryShade(theme, colorScheme) {
  if (typeof theme.primaryShade === "number") {
    return theme.primaryShade;
  }
  if (colorScheme === "dark") {
    return theme.primaryShade.dark;
  }
  return theme.primaryShade.light;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/luminance/luminance.mjs
function gammaCorrect(c2) {
  return c2 <= 0.03928 ? c2 / 12.92 : ((c2 + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match2 = oklchColor.match(/oklch\((.*?)%\s/);
  return match2 ? parseFloat(match2[1]) : null;
}
function luminance(color) {
  if (color.startsWith("oklch(")) {
    return (getLightnessFromOklch(color) || 0) / 100;
  }
  const { r: r3, g: g2, b } = toRgba(color);
  const sR = r3 / 255;
  const sG = g2 / 255;
  const sB = b / 255;
  const rLinear = gammaCorrect(sR);
  const gLinear = gammaCorrect(sG);
  const bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color, luminanceThreshold = 0.179) {
  if (color.startsWith("var(")) {
    return false;
  }
  return luminance(color) > luminanceThreshold;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/parse-theme-color/parse-theme-color.mjs
"use client";
function parseThemeColor({
  color,
  theme,
  colorScheme
}) {
  if (typeof color !== "string") {
    throw new Error(`[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color}`);
  }
  if (color === "bright") {
    return {
      color,
      value: colorScheme === "dark" ? theme.white : theme.black,
      shade: undefined,
      isThemeColor: false,
      isLight: isLightColor(colorScheme === "dark" ? theme.white : theme.black, theme.luminanceThreshold),
      variable: "--mantine-color-bright"
    };
  }
  if (color === "dimmed") {
    return {
      color,
      value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
      shade: undefined,
      isThemeColor: false,
      isLight: isLightColor(colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6], theme.luminanceThreshold),
      variable: "--mantine-color-dimmed"
    };
  }
  if (color === "white" || color === "black") {
    return {
      color,
      value: color === "white" ? theme.white : theme.black,
      shade: undefined,
      isThemeColor: false,
      isLight: isLightColor(color === "white" ? theme.white : theme.black, theme.luminanceThreshold),
      variable: `--mantine-color-${color}`
    };
  }
  const [_color, shade] = color.split(".");
  const colorShade = shade ? Number(shade) : undefined;
  const isThemeColor = _color in theme.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== undefined ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color,
    value: color,
    isThemeColor,
    isLight: isLightColor(color, theme.luminanceThreshold),
    shade: colorShade,
    variable: undefined
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs
"use client";
function getThemeColor(color, theme) {
  const parsed = parseThemeColor({ color: color || theme.primaryColor, theme });
  return parsed.variable ? `var(${parsed.variable})` : color;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-gradient/get-gradient.mjs
"use client";
function getGradient(gradient, theme) {
  const merged = {
    from: gradient?.from || theme.defaultGradient.from,
    to: gradient?.to || theme.defaultGradient.to,
    deg: gradient?.deg ?? theme.defaultGradient.deg ?? 0
  };
  const fromColor = getThemeColor(merged.from, theme);
  const toColor = getThemeColor(merged.to, theme);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/rgba/rgba.mjs
function rgba(color, alpha2) {
  if (typeof color !== "string" || alpha2 > 1 || alpha2 < 0) {
    return "rgba(0, 0, 0, 1)";
  }
  if (color.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color}, transparent ${mixPercentage}%)`;
  }
  if (color.startsWith("oklch")) {
    if (color.includes("/")) {
      return color.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`);
    }
    return color.replace(")", ` / ${alpha2})`);
  }
  const { r: r3, g: g2, b } = toRgba(color);
  return `rgba(${r3}, ${g2}, ${b}, ${alpha2})`;
}
var alpha = rgba;

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/default-variant-colors-resolver/default-variant-colors-resolver.mjs
"use client";
var defaultVariantColorsResolver = ({
  color,
  theme,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color, theme });
  const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
  if (variant === "filled") {
    const textColor = _autoContrast ? parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)" : "var(--mantine-color-white)";
    if (parsed.isThemeColor) {
      if (parsed.shade === undefined) {
        return {
          background: `var(--mantine-color-${color}-filled)`,
          hover: `var(--mantine-color-${color}-filled-hover)`,
          color: textColor,
          border: `${rem(1)} solid transparent`
        };
      }
      return {
        background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
        hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
        color: textColor,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: color,
      hover: darken(color, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === undefined) {
        return {
          background: `var(--mantine-color-${color}-light)`,
          hover: `var(--mantine-color-${color}-light-hover)`,
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      }
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: rgba(parsedColor, 0.1),
        hover: rgba(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba(color, 0.1),
      hover: rgba(color, 0.12),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline") {
    if (parsed.isThemeColor) {
      if (parsed.shade === undefined) {
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color}-outline-hover)`,
          color: `var(--mantine-color-${color}-outline)`,
          border: `${rem(1)} solid var(--mantine-color-${color}-outline)`
        };
      }
      return {
        background: "transparent",
        hover: rgba(theme.colors[parsed.color][parsed.shade], 0.05),
        color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
        border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
      };
    }
    return {
      background: "transparent",
      hover: rgba(color, 0.05),
      color,
      border: `${rem(1)} solid ${color}`
    };
  }
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === undefined) {
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color}-light-hover)`,
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      }
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba(color, 0.12),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "transparent") {
    if (parsed.isThemeColor) {
      if (parsed.shade === undefined) {
        return {
          background: "transparent",
          hover: "transparent",
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      }
      return {
        background: "transparent",
        hover: "transparent",
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: "transparent",
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "white") {
    if (parsed.isThemeColor) {
      if (parsed.shade === undefined) {
        return {
          background: "var(--mantine-color-white)",
          hover: darken(theme.white, 0.01),
          color: `var(--mantine-color-${color}-filled)`,
          border: `${rem(1)} solid transparent`
        };
      }
      return {
        background: "var(--mantine-color-white)",
        hover: darken(theme.white, 0.01),
        color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "var(--mantine-color-white)",
      hover: darken(theme.white, 0.01),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "gradient") {
    return {
      background: getGradient(gradient, theme),
      hover: getGradient(gradient, theme),
      color: "var(--mantine-color-white)",
      border: "none"
    };
  }
  if (variant === "default") {
    return {
      background: "var(--mantine-color-default)",
      hover: "var(--mantine-color-default-hover)",
      color: "var(--mantine-color-default-color)",
      border: `${rem(1)} solid var(--mantine-color-default-border)`
    };
  }
  return {};
};

// node_modules/@mantine/core/esm/core/MantineProvider/default-colors.mjs
var DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
};

// node_modules/@mantine/core/esm/core/MantineProvider/default-theme.mjs
var DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji";
var DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: true,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: false,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: false,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(15)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(25)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(23)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(28)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};

// node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-scheme-managers/is-mantine-color-scheme.mjs
"use client";
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-scheme-managers/local-storage-manager.mjs
"use client";
function localStorageColorSchemeManager({
  key = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window === "undefined") {
        return defaultValue;
      }
      try {
        const storedColorScheme = window.localStorage.getItem(key);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key, value);
      } catch (error) {
        console.warn("[@mantine/core] Local storage color scheme manager was unable to save color scheme.", error);
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        if (event.storageArea === window.localStorage && event.key === key) {
          isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
        }
      };
      window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key);
    }
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineClasses/MantineClasses.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/merge-mantine-theme/merge-mantine-theme.mjs
var import_react29 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color";
var INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  if (shade < 0 || shade > 9) {
    return false;
  }
  return parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
  if (!(theme.primaryColor in theme.colors)) {
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  }
  if (typeof theme.primaryShade === "object") {
    if (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)) {
      throw new Error(INVALID_PRIMARY_SHADE_ERROR);
    }
  }
  if (typeof theme.primaryShade === "number" && !isValidPrimaryShade(theme.primaryShade)) {
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  }
}
function mergeMantineTheme(currentTheme, themeOverride) {
  if (!themeOverride) {
    validateMantineTheme(currentTheme);
    return currentTheme;
  }
  const result = deepMerge(currentTheme, themeOverride);
  if (themeOverride.fontFamily && !themeOverride.headings?.fontFamily) {
    result.headings.fontFamily = themeOverride.fontFamily;
  }
  validateMantineTheme(result);
  return result;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs
"use client";
var MantineThemeContext = import_react30.createContext(null);
var useSafeMantineTheme = () => import_react30.useContext(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = import_react30.useContext(MantineThemeContext);
  if (!ctx) {
    throw new Error("@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app");
  }
  return ctx;
}
function MantineThemeProvider({
  theme,
  children,
  inherit = true
}) {
  const parentTheme = useSafeMantineTheme();
  const mergedTheme = import_react30.useMemo(() => mergeMantineTheme(inherit ? parentTheme : DEFAULT_THEME, theme), [theme, parentTheme, inherit]);
  return /* @__PURE__ */ import_jsx_runtime6.jsx(MantineThemeContext.Provider, { value: mergedTheme, children });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";

// node_modules/@mantine/core/esm/core/MantineProvider/MantineClasses/MantineClasses.mjs
"use client";
function MantineClasses() {
  const theme = useMantineTheme();
  const nonce = useMantineStyleNonce();
  const classes = keys(theme.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px");
    const pxValue = px(theme.breakpoints[breakpoint]);
    const maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1);
    const minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ import_jsx_runtime7.jsx("style", {
    "data-mantine-styles": "classes",
    nonce: nonce?.(),
    dangerouslySetInnerHTML: { __html: classes }
  });
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/css-variables-object-to-string.mjs
"use client";
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}

// node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/wrap-with-selector.mjs
"use client";
function wrapWithSelector(selectors, code) {
  const _selectors = Array.isArray(selectors) ? selectors : [selectors];
  return _selectors.reduce((acc, selector) => `${selector}{${acc}}`, code);
}

// node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/convert-css-variables.mjs
"use client";
function convertCssVariables(input, selector) {
  const sharedVariables = cssVariablesObjectToString(input.variables);
  const shared = sharedVariables ? wrapWithSelector(selector, sharedVariables) : "";
  const dark = cssVariablesObjectToString(input.dark);
  const light = cssVariablesObjectToString(input.light);
  const darkForced = dark ? selector === ":host" ? wrapWithSelector(`${selector}([data-mantine-color-scheme="dark"])`, dark) : wrapWithSelector(`${selector}[data-mantine-color-scheme="dark"]`, dark) : "";
  const lightForced = light ? selector === ":host" ? wrapWithSelector(`${selector}([data-mantine-color-scheme="light"])`, light) : wrapWithSelector(`${selector}[data-mantine-color-scheme="light"]`, light) : "";
  return `${shared}${darkForced}${lightForced}`;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-merged-variables.mjs
var import_react35 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/default-css-variables-resolver.mjs
var import_react34 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-contrast-color/get-contrast-color.mjs
"use client";
function getContrastColor({ color, theme, autoContrast }) {
  const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
  if (!_autoContrast) {
    return "var(--mantine-color-white)";
  }
  const parsed = parseThemeColor({ color: color || theme.primaryColor, theme });
  return parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
  return getContrastColor({
    color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
    theme,
    autoContrast: null
  });
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-css-color-variables.mjs
var import_react32 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
"use client";
function getCSSColorVariables({
  theme,
  color,
  colorScheme,
  name = color,
  withColorValues = true
}) {
  if (!theme.colors[color]) {
    return {};
  }
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme, "light");
    const dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha(theme.colors[color][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha(theme.colors[color][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha(theme.colors[color][primaryShade2], 0.05)
    };
    if (!withColorValues) {
      return dynamicVariables2;
    }
    return {
      [`--mantine-color-${name}-0`]: theme.colors[color][0],
      [`--mantine-color-${name}-1`]: theme.colors[color][1],
      [`--mantine-color-${name}-2`]: theme.colors[color][2],
      [`--mantine-color-${name}-3`]: theme.colors[color][3],
      [`--mantine-color-${name}-4`]: theme.colors[color][4],
      [`--mantine-color-${name}-5`]: theme.colors[color][5],
      [`--mantine-color-${name}-6`]: theme.colors[color][6],
      [`--mantine-color-${name}-7`]: theme.colors[color][7],
      [`--mantine-color-${name}-8`]: theme.colors[color][8],
      [`--mantine-color-${name}-9`]: theme.colors[color][9],
      ...dynamicVariables2
    };
  }
  const primaryShade = getPrimaryShade(theme, "dark");
  const dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha(theme.colors[color][Math.max(0, primaryShade - 2)], 0.15),
    [`--mantine-color-${name}-light-hover`]: alpha(theme.colors[color][Math.max(0, primaryShade - 2)], 0.2),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha(theme.colors[color][Math.max(primaryShade - 4, 0)], 0.05)
  };
  if (!withColorValues) {
    return dynamicVariables;
  }
  return {
    [`--mantine-color-${name}-0`]: theme.colors[color][0],
    [`--mantine-color-${name}-1`]: theme.colors[color][1],
    [`--mantine-color-${name}-2`]: theme.colors[color][2],
    [`--mantine-color-${name}-3`]: theme.colors[color][3],
    [`--mantine-color-${name}-4`]: theme.colors[color][4],
    [`--mantine-color-${name}-5`]: theme.colors[color][5],
    [`--mantine-color-${name}-6`]: theme.colors[color][6],
    [`--mantine-color-${name}-7`]: theme.colors[color][7],
    [`--mantine-color-${name}-8`]: theme.colors[color][8],
    [`--mantine-color-${name}-9`]: theme.colors[color][9],
    ...dynamicVariables
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/virtual-color/virtual-color.mjs
var import_react33 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
function isVirtualColor(value) {
  return !!value && typeof value === "object" && "mantine-virtual-color" in value;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/default-css-variables-resolver.mjs
"use client";
function assignSizeVariables(variables, sizes, name) {
  keys(sizes).forEach((size) => Object.assign(variables, { [`--mantine-${name}-${size}`]: sizes[size] }));
}
var defaultCssVariablesResolver = (theme) => {
  const lightPrimaryShade = getPrimaryShade(theme, "light");
  const defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius);
  const result = {
    variables: {
      "--mantine-scale": theme.scale.toString(),
      "--mantine-cursor-type": theme.cursorType,
      "--mantine-color-scheme": "light dark",
      "--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme.white,
      "--mantine-color-black": theme.black,
      "--mantine-line-height": theme.lineHeights.md,
      "--mantine-font-family": theme.fontFamily,
      "--mantine-font-family-monospace": theme.fontFamilyMonospace,
      "--mantine-font-family-headings": theme.headings.fontFamily,
      "--mantine-heading-font-weight": theme.headings.fontWeight,
      "--mantine-heading-text-wrap": theme.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      "--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
    },
    light: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme.black,
      "--mantine-color-body": theme.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)"
    },
    dark: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)"
    }
  };
  assignSizeVariables(result.variables, theme.breakpoints, "breakpoint");
  assignSizeVariables(result.variables, theme.spacing, "spacing");
  assignSizeVariables(result.variables, theme.fontSizes, "font-size");
  assignSizeVariables(result.variables, theme.lineHeights, "line-height");
  assignSizeVariables(result.variables, theme.shadows, "shadow");
  assignSizeVariables(result.variables, theme.radius, "radius");
  theme.colors[theme.primaryColor].forEach((_2, index2) => {
    result.variables[`--mantine-primary-color-${index2}`] = `var(--mantine-color-${theme.primaryColor}-${index2})`;
  });
  keys(theme.colors).forEach((color) => {
    const value = theme.colors[color];
    if (isVirtualColor(value)) {
      Object.assign(result.light, getCSSColorVariables({
        theme,
        name: value.name,
        color: value.light,
        colorScheme: "light",
        withColorValues: true
      }));
      Object.assign(result.dark, getCSSColorVariables({
        theme,
        name: value.name,
        color: value.dark,
        colorScheme: "dark",
        withColorValues: true
      }));
      return;
    }
    value.forEach((shade, index2) => {
      result.variables[`--mantine-color-${color}-${index2}`] = shade;
    });
    Object.assign(result.light, getCSSColorVariables({
      theme,
      color,
      colorScheme: "light",
      withColorValues: false
    }));
    Object.assign(result.dark, getCSSColorVariables({
      theme,
      color,
      colorScheme: "dark",
      withColorValues: false
    }));
  });
  const headings = theme.headings.sizes;
  keys(headings).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings[heading].fontSize;
    result.variables[`--mantine-${heading}-line-height`] = headings[heading].lineHeight;
    result.variables[`--mantine-${heading}-font-weight`] = headings[heading].fontWeight || theme.headings.fontWeight;
  });
  return result;
};

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-merged-variables.mjs
"use client";
function getMergedVariables({ theme, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme);
  const providerGenerator = generator?.(theme);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/remove-default-variables.mjs
var import_react36 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
"use client";
var defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  keys(input.variables).forEach((key) => {
    if (defaultCssVariables.variables[key] !== input.variables[key]) {
      cleaned.variables[key] = input.variables[key];
    }
  });
  keys(input.light).forEach((key) => {
    if (defaultCssVariables.light[key] !== input.light[key]) {
      cleaned.light[key] = input.light[key];
    }
  });
  keys(input.dark).forEach((key) => {
    if (defaultCssVariables.dark[key] !== input.dark[key]) {
      cleaned.dark[key] = input.dark[key];
    }
  });
  return cleaned;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs
"use client";
function getColorSchemeCssVariables(selector) {
  return `
  ${selector}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${selector}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme = useMantineTheme();
  const nonce = useMantineStyleNonce();
  const generator = useMantineCssVariablesResolver();
  const mergedVariables = getMergedVariables({ theme, generator });
  const shouldCleanVariables = cssVariablesSelector === ":root" && deduplicateCssVariables;
  const cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables;
  const css = convertCssVariables(cleanedVariables, cssVariablesSelector);
  if (css) {
    return /* @__PURE__ */ import_jsx_runtime13.jsx("style", {
      "data-mantine-styles": true,
      nonce: nonce?.(),
      dangerouslySetInnerHTML: {
        __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
      }
    });
  }
  return null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";

// node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
var import_react38 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/suppress-nextjs-warning.mjs
"use client";
function suppressNextjsWarning() {
  const originalError = console.error;
  console.error = (...args) => {
    if (args.length > 1 && typeof args[0] === "string" && args[0].toLowerCase().includes("extra attributes from the server") && typeof args[1] === "string" && args[1].toLowerCase().includes("data-mantine-color-scheme"))
      ;
    else {
      originalError(...args);
    }
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/use-mantine-color-scheme/use-provider-color-scheme.mjs
var import_react37 = __toESM(require_react(), 1);
"use client";
function setColorSchemeAttribute(colorScheme, getRootElement) {
  const hasDarkColorScheme = typeof window !== "undefined" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches;
  const computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
  getRootElement()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement,
  forceColorScheme
}) {
  const media = import_react37.useRef(null);
  const [value, setValue] = import_react37.useState(() => manager.get(defaultColorScheme));
  const colorSchemeValue = forceColorScheme || value;
  const setColorScheme = import_react37.useCallback((colorScheme) => {
    if (!forceColorScheme) {
      setColorSchemeAttribute(colorScheme, getRootElement);
      setValue(colorScheme);
      manager.set(colorScheme);
    }
  }, [manager.set, colorSchemeValue, forceColorScheme]);
  const clearColorScheme = import_react37.useCallback(() => {
    setValue(defaultColorScheme);
    setColorSchemeAttribute(defaultColorScheme, getRootElement);
    manager.clear();
  }, [manager.clear, defaultColorScheme]);
  import_react37.useEffect(() => {
    manager.subscribe(setColorScheme);
    return manager.unsubscribe;
  }, [manager.subscribe, manager.unsubscribe]);
  useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement);
  }, []);
  import_react37.useEffect(() => {
    if (forceColorScheme) {
      setColorSchemeAttribute(forceColorScheme, getRootElement);
      return () => {
      };
    }
    if (forceColorScheme === undefined) {
      setColorSchemeAttribute(value, getRootElement);
    }
    if (typeof window !== "undefined" && "matchMedia" in window) {
      media.current = window.matchMedia("(prefers-color-scheme: dark)");
    }
    const listener = (event) => {
      if (value === "auto") {
        setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement);
      }
    };
    media.current?.addEventListener("change", listener);
    return () => media.current?.removeEventListener("change", listener);
  }, [value, forceColorScheme]);
  return { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}

// node_modules/@mantine/core/esm/core/MantineProvider/use-respect-reduce-motion/use-respect-reduce-motion.mjs
"use client";
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement
}) {
  useIsomorphicEffect(() => {
    if (respectReducedMotion) {
      getRootElement()?.setAttribute("data-respect-reduced-motion", "true");
    }
  }, [respectReducedMotion]);
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
"use client";
suppressNextjsWarning();
function MantineProvider({
  theme,
  children,
  getStyleNonce,
  withStaticClasses = true,
  withGlobalClasses = true,
  deduplicateCssVariables = true,
  withCssVariables = true,
  cssVariablesSelector = ":root",
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform,
  env: env2
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement
  });
  useRespectReduceMotion({
    respectReducedMotion: theme?.respectReducedMotion || false,
    getRootElement
  });
  return /* @__PURE__ */ import_jsx_runtime14.jsx(MantineContext.Provider, {
    value: {
      colorScheme,
      setColorScheme,
      clearColorScheme,
      getRootElement,
      classNamesPrefix,
      getStyleNonce,
      cssVariablesResolver,
      cssVariablesSelector,
      withStaticClasses,
      stylesTransform,
      env: env2
    },
    children: /* @__PURE__ */ import_jsx_runtime14.jsxs(MantineThemeProvider, { theme, children: [
      withCssVariables && /* @__PURE__ */ import_jsx_runtime14.jsx(MantineCssVariables, {
        cssVariablesSelector,
        deduplicateCssVariables
      }),
      withGlobalClasses && /* @__PURE__ */ import_jsx_runtime14.jsx(MantineClasses, {}),
      children
    ] })
  });
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function HeadlessMantineProvider({ children, theme }) {
  return /* @__PURE__ */ import_jsx_runtime14.jsx(MantineContext.Provider, {
    value: {
      colorScheme: "auto",
      setColorScheme: () => {
      },
      clearColorScheme: () => {
      },
      getRootElement: () => document.documentElement,
      classNamesPrefix: "mantine",
      cssVariablesSelector: ":root",
      withStaticClasses: false,
      headless: true
    },
    children: /* @__PURE__ */ import_jsx_runtime14.jsx(MantineThemeProvider, { theme, children })
  });
}
HeadlessMantineProvider.displayName = "@mantine/core/HeadlessMantineProvider";

// node_modules/@mantine/core/esm/core/styles-api/use-resolved-styles-api/use-resolved-styles-api.mjs
"use client";
function useResolvedStylesApi({
  classNames,
  styles,
  props,
  stylesCtx
}) {
  const theme = useMantineTheme();
  return {
    resolvedClassNames: resolveClassNames({
      theme,
      classNames,
      props,
      stylesCtx: stylesCtx || undefined
    }),
    resolvedStyles: resolveStyles({
      theme,
      styles,
      props,
      stylesCtx: stylesCtx || undefined
    })
  };
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-global-class-names/get-global-class-names.mjs
"use client";
var FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options, unstyled }) {
  return clsx_default(options?.focusable && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]), options?.active && !unstyled && theme.activeClassName);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/use-styles.mjs
var import_react42 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-options-class-names/get-options-class-names.mjs
"use client";
function getOptionsClassNames({
  selector,
  stylesCtx,
  options,
  props,
  theme
}) {
  return resolveClassNames({
    theme,
    classNames: options?.classNames,
    props: options?.props || props,
    stylesCtx
  })[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-resolved-class-names/get-resolved-class-names.mjs
"use client";
function getResolvedClassNames({
  selector,
  stylesCtx,
  theme,
  classNames,
  props
}) {
  return resolveClassNames({ theme, classNames, props, stylesCtx })[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-root-class-name/get-root-class-name.mjs
"use client";
function getRootClassName({ rootSelector, selector, className }) {
  return rootSelector === selector ? className : undefined;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-selector-class-name/get-selector-class-name.mjs
"use client";
function getSelectorClassName({ selector, classes, unstyled }) {
  return unstyled ? undefined : classes[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-static-class-names/get-static-class-names.mjs
"use client";
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector,
  withStaticClass
}) {
  if (withStaticClass === false) {
    return [];
  }
  return themeName.map((n) => `${classNamesPrefix}-${n}-${selector}`);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-theme-class-names/get-theme-class-names.mjs
"use client";
function getThemeClassNames({
  themeName,
  theme,
  selector,
  props,
  stylesCtx
}) {
  return themeName.map((n) => resolveClassNames({
    theme,
    classNames: theme.components[n]?.classNames,
    props,
    stylesCtx
  })?.[selector]);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-variant-class-name/get-variant-class-name.mjs
"use client";
function getVariantClassName({
  options,
  classes,
  selector,
  unstyled
}) {
  return options?.variant && !unstyled ? classes[`${selector}--${options.variant}`] : undefined;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-class-name.mjs
"use client";
function getClassName({
  theme,
  options,
  themeName,
  selector,
  classNamesPrefix,
  classNames,
  classes,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx_default(getGlobalClassNames({ theme, options, unstyled: unstyled || headless }), getThemeClassNames({ theme, themeName, selector, props, stylesCtx }), getVariantClassName({ options, classes, selector, unstyled }), getResolvedClassNames({ selector, stylesCtx, theme, classNames, props }), getResolvedClassNames({ selector, stylesCtx, theme, classNames: transformedStyles, props }), getOptionsClassNames({ selector, stylesCtx, options, props, theme }), getRootClassName({ rootSelector, selector, className }), getSelectorClassName({ selector, classes, unstyled: unstyled || headless }), withStaticClasses && !headless && getStaticClassNames({
    themeName,
    classNamesPrefix,
    selector,
    withStaticClass: options?.withStaticClass
  }), options?.className);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/get-theme-styles/get-theme-styles.mjs
"use client";
function getThemeStyles({
  theme,
  themeName,
  props,
  stylesCtx,
  selector
}) {
  return themeName.map((n) => resolveStyles({
    theme,
    styles: theme.components[n]?.styles,
    props,
    stylesCtx
  })[selector]).reduce((acc, val) => ({ ...acc, ...val }), {});
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-style/resolve-style.mjs
"use client";
function resolveStyle({ style: style2, theme }) {
  if (Array.isArray(style2)) {
    return [...style2].reduce((acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme }) }), {});
  }
  if (typeof style2 === "function") {
    return style2(theme);
  }
  if (style2 == null) {
    return {};
  }
  return style2;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-vars/merge-vars.mjs
var import_react40 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
"use client";
function mergeVars(vars) {
  return vars.reduce((acc, current2) => {
    if (current2) {
      Object.keys(current2).forEach((key) => {
        acc[key] = { ...acc[key], ...filterProps(current2[key]) };
      });
    }
    return acc;
  }, {});
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-vars/resolve-vars.mjs
"use client";
function resolveVars({
  vars,
  varsResolver,
  theme,
  props,
  stylesCtx,
  selector,
  themeName,
  headless
}) {
  return mergeVars([
    headless ? {} : varsResolver?.(theme, props, stylesCtx),
    ...themeName.map((name) => theme.components?.[name]?.vars?.(theme, props, stylesCtx)),
    vars?.(theme, props, stylesCtx)
  ])?.[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/get-style.mjs
"use client";
function getStyle({
  theme,
  themeName,
  selector,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style: style2,
  vars,
  varsResolver,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme, themeName, props, stylesCtx, selector }),
    ...!withStylesTransform && resolveStyles({ theme, styles, props, stylesCtx })[selector],
    ...!withStylesTransform && resolveStyles({ theme, styles: options?.styles, props: options?.props || props, stylesCtx })[selector],
    ...resolveVars({ theme, props, stylesCtx, vars, varsResolver, selector, themeName, headless }),
    ...rootSelector === selector ? resolveStyle({ style: style2, theme }) : null,
    ...resolveStyle({ style: options?.style, theme })
  };
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/use-transformed-styles.mjs
var import_react41 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
"use client";
function useStylesTransform({ props, stylesCtx, themeName }) {
  const theme = useMantineTheme();
  const stylesTransform = useMantineStylesTransform()?.();
  const getTransformedStyles = (styles) => {
    if (!stylesTransform) {
      return [];
    }
    const transformedStyles = styles.map((style2) => stylesTransform(style2, { props, theme, ctx: stylesCtx }));
    return [
      ...transformedStyles,
      ...themeName.map((n) => stylesTransform(theme.components[n]?.styles, { props, theme, ctx: stylesCtx }))
    ].filter(Boolean);
  };
  return {
    getTransformedStyles,
    withStylesTransform: !!stylesTransform
  };
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/use-styles.mjs
"use client";
function useStyles({
  name,
  classes,
  props,
  stylesCtx,
  className,
  style: style2,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars,
  varsResolver
}) {
  const theme = useMantineTheme();
  const classNamesPrefix = useMantineClassNamesPrefix();
  const withStaticClasses = useMantineWithStaticClasses();
  const headless = useMantineIsHeadless();
  const themeName = (Array.isArray(name) ? name : [name]).filter((n) => n);
  const { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector, options) => ({
    className: getClassName({
      theme,
      options,
      themeName,
      selector,
      classNamesPrefix,
      classNames,
      classes,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options?.styles, styles])
    }),
    style: getStyle({
      theme,
      themeName,
      selector,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style: style2,
      vars,
      varsResolver,
      headless,
      withStylesTransform
    })
  });
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-auto-contrast-value/get-auto-contrast-value.mjs
"use client";
function getAutoContrastValue(autoContrast, theme) {
  return typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
}
// node_modules/@mantine/core/esm/core/MantineProvider/use-props/use-props.mjs
var import_react43 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
"use client";
function useProps(component, defaultProps, props) {
  const theme = useMantineTheme();
  const contextPropsPayload = theme.components[component]?.defaultProps;
  const contextProps = typeof contextPropsPayload === "function" ? contextPropsPayload(theme) : contextPropsPayload;
  return { ...defaultProps, ...contextProps, ...filterProps(props) };
}

// node_modules/@mantine/core/esm/core/MantineProvider/create-theme/create-theme.mjs
function createTheme(theme) {
  return theme;
}
// node_modules/@mantine/core/esm/core/InlineStyles/InlineStyles.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/InlineStyles/css-object-to-string/css-object-to-string.mjs
var import_react44 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
"use client";
function cssObjectToString(css) {
  return keys(css).reduce((acc, rule) => css[rule] !== undefined ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc, "").trim();
}

// node_modules/@mantine/core/esm/core/InlineStyles/styles-to-string/styles-to-string.mjs
"use client";
function stylesToString({ selector, styles, media, container }) {
  const baseStyles = styles ? cssObjectToString(styles) : "";
  const mediaQueryStyles = !Array.isArray(media) ? [] : media.map((item) => `@media${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
  const containerStyles = !Array.isArray(container) ? [] : container.map((item) => `@container ${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
  return `${baseStyles ? `${selector}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}

// node_modules/@mantine/core/esm/core/InlineStyles/InlineStyles.mjs
"use client";
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ import_jsx_runtime21.jsx("style", {
    "data-mantine-styles": "inline",
    nonce: nonce?.(),
    dangerouslySetInnerHTML: { __html: stylesToString(props) }
  });
}

// node_modules/@mantine/core/esm/core/Box/style-props/extract-style-props/extract-style-props.mjs
var import_react46 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
"use client";
function extractStyleProps(others) {
  const {
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me: me2,
    ms,
    p: p2,
    px: px2,
    py,
    pt: pt2,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c: c2,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt: tt2,
    td,
    w: w2,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  const styleProps = filterProps({
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me: me2,
    ms,
    p: p2,
    px: px2,
    py,
    pt: pt2,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c: c2,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt: tt2,
    td,
    w: w2,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  });
  return { styleProps, rest };
}

// node_modules/@mantine/core/esm/core/Box/style-props/style-props-data.mjs
"use client";
var STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};

// node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/parse-style-props.mjs
var import_react52 = __toESM(require_react(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/border-resolver/border-resolver.mjs
var import_react48 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/color-resolver/color-resolver.mjs
var import_react47 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
"use client";
function colorResolver(color, theme) {
  const parsedColor = parseThemeColor({ color, theme });
  if (parsedColor.color === "dimmed") {
    return "var(--mantine-color-dimmed)";
  }
  if (parsedColor.color === "bright") {
    return "var(--mantine-color-bright)";
  }
  return parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color, theme) {
  const parsedColor = parseThemeColor({ color, theme });
  if (parsedColor.isThemeColor && parsedColor.shade === undefined) {
    return `var(--mantine-color-${parsedColor.color}-text)`;
  }
  return colorResolver(color, theme);
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/border-resolver/border-resolver.mjs
"use client";
function borderResolver(value, theme) {
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    const [size, style2, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size)}`;
    style2 && (result += ` ${style2}`);
    colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`);
    return result.trim();
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/font-family-resolver/font-family-resolver.mjs
"use client";
var values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  if (typeof fontFamily === "string" && fontFamily in values) {
    return values[fontFamily];
  }
  return fontFamily;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/font-size-resolver/font-size-resolver.mjs
var import_react49 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
"use client";
var headings = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme) {
  if (typeof value === "string" && value in theme.fontSizes) {
    return `var(--mantine-font-size-${value})`;
  }
  if (typeof value === "string" && headings.includes(value)) {
    return `var(--mantine-${value}-font-size)`;
  }
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    return rem(value);
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/identity-resolver/identity-resolver.mjs
"use client";
function identityResolver(value) {
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/line-height-resolver/line-height-resolver.mjs
"use client";
var headings2 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme) {
  if (typeof value === "string" && value in theme.lineHeights) {
    return `var(--mantine-line-height-${value})`;
  }
  if (typeof value === "string" && headings2.includes(value)) {
    return `var(--mantine-${value}-line-height)`;
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/size-resolver/size-resolver.mjs
var import_react50 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
"use client";
function sizeResolver(value) {
  if (typeof value === "number") {
    return rem(value);
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/spacing-resolver/spacing-resolver.mjs
var import_react51 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
"use client";
function spacingResolver(value, theme) {
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme.spacing)) {
      return rem(value);
    }
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/index.mjs
"use client";
var resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};

// node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/sort-media-queries.mjs
"use client";
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const breakpoints = Object.keys(media);
  const sortedMedia = breakpoints.sort((a2, b) => Number(replaceMediaQuery(a2)) - Number(replaceMediaQuery(b))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}

// node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/parse-style-props.mjs
"use client";
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp !== "object" || styleProp === null) {
    return false;
  }
  const breakpoints = Object.keys(styleProp);
  if (breakpoints.length === 1 && breakpoints[0] === "base") {
    return false;
  }
  return true;
}
function getBaseValue2(value) {
  if (typeof value === "object" && value !== null) {
    if ("base" in value) {
      return value.base;
    }
    return;
  }
  return value;
}
function getBreakpointKeys(value) {
  if (typeof value === "object" && value !== null) {
    return keys(value).filter((key) => key !== "base");
  }
  return [];
}
function getBreakpointValue2(value, breakpoint) {
  if (typeof value === "object" && value !== null && breakpoint in value) {
    return value[breakpoint];
  }
  return value;
}
function parseStyleProps({
  styleProps,
  data,
  theme
}) {
  return sortMediaQueries(keys(styleProps).reduce((acc, styleProp) => {
    if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx") {
      return acc;
    }
    const propertyData = data[styleProp];
    const properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property];
    const baseValue = getBaseValue2(styleProps[styleProp]);
    if (!hasResponsiveStyles(styleProps[styleProp])) {
      properties.forEach((property) => {
        acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
      });
      return acc;
    }
    acc.hasResponsiveStyles = true;
    const breakpoints = getBreakpointKeys(styleProps[styleProp]);
    properties.forEach((property) => {
      if (baseValue) {
        acc.styles[property] = resolvers[propertyData.type](baseValue, theme);
      }
      breakpoints.forEach((breakpoint) => {
        const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
        acc.media[bp] = {
          ...acc.media[bp],
          [property]: resolvers[propertyData.type](getBreakpointValue2(styleProps[styleProp], breakpoint), theme)
        };
      });
    });
    return acc;
  }, {
    hasResponsiveStyles: false,
    styles: {},
    inlineStyles: {},
    media: {}
  }));
}

// node_modules/@mantine/core/esm/core/Box/use-random-classname/use-random-classname.mjs
var import_react53 = __toESM(require_react(), 1);
"use client";
function useRandomClassName() {
  const id = import_react53.useId().replace(/:/g, "");
  return `__m__-${id}`;
}

// node_modules/@mantine/core/esm/core/Box/get-style-object/get-style-object.mjs
"use client";
function getStyleObject(style2, theme) {
  if (Array.isArray(style2)) {
    return [...style2].reduce((acc, item) => ({ ...acc, ...getStyleObject(item, theme) }), {});
  }
  if (typeof style2 === "function") {
    return style2(theme);
  }
  if (style2 == null) {
    return {};
  }
  return style2;
}

// node_modules/@mantine/core/esm/core/Box/Box.mjs
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/factory/create-polymorphic-component.mjs
function createPolymorphicComponent(component) {
  return component;
}

// node_modules/@mantine/core/esm/core/Box/get-box-mod/get-box-mod.mjs
"use client";
function transformModKey(key) {
  return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key) => {
    const value = props[key];
    if (value === undefined || value === "" || value === false || value === null) {
      return acc;
    }
    acc[transformModKey(key)] = props[key];
    return acc;
  }, {});
}
function getBoxMod(mod) {
  if (!mod) {
    return null;
  }
  if (typeof mod === "string") {
    return { [transformModKey(mod)]: true };
  }
  if (Array.isArray(mod)) {
    return [...mod].reduce((acc, value) => ({ ...acc, ...getBoxMod(value) }), {});
  }
  return getMod(mod);
}

// node_modules/@mantine/core/esm/core/Box/get-box-style/get-box-style.mjs
"use client";
function mergeStyles(styles, theme) {
  if (Array.isArray(styles)) {
    return [...styles].reduce((acc, item) => ({ ...acc, ...mergeStyles(item, theme) }), {});
  }
  if (typeof styles === "function") {
    return styles(theme);
  }
  if (styles == null) {
    return {};
  }
  return styles;
}
function getBoxStyle({
  theme,
  style: style2,
  vars,
  styleProps
}) {
  const _style = mergeStyles(style2, theme);
  const _vars = mergeStyles(vars, theme);
  return { ..._style, ..._vars, ...styleProps };
}

// node_modules/@mantine/core/esm/core/Box/Box.mjs
"use client";
var _Box = import_react54.forwardRef(({
  component,
  style: style2,
  __vars,
  className,
  variant,
  mod,
  size,
  hiddenFrom,
  visibleFrom,
  lightHidden,
  darkHidden,
  renderRoot,
  __size,
  ...others
}, ref) => {
  const theme = useMantineTheme();
  const Element2 = component || "div";
  const { styleProps, rest } = extractStyleProps(others);
  const useSxTransform = useMantineSxTransform();
  const transformedSx = useSxTransform?.()?.(styleProps.sx);
  const responsiveClassName = useRandomClassName();
  const parsedStyleProps = parseStyleProps({
    styleProps,
    theme,
    data: STYlE_PROPS_DATA
  });
  const props = {
    ref,
    style: getBoxStyle({
      theme,
      style: style2,
      vars: __vars,
      styleProps: parsedStyleProps.inlineStyles
    }),
    className: clsx_default(className, transformedSx, {
      [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
      "mantine-light-hidden": lightHidden,
      "mantine-dark-hidden": darkHidden,
      [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
      [`mantine-visible-from-${visibleFrom}`]: visibleFrom
    }),
    "data-variant": variant,
    "data-size": isNumberLike(size) ? undefined : size || undefined,
    size: __size,
    ...getBoxMod(mod),
    ...rest
  };
  return /* @__PURE__ */ import_jsx_runtime29.jsxs(import_jsx_runtime29.Fragment, { children: [
    parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ import_jsx_runtime29.jsx(InlineStyles, {
      selector: `.${responsiveClassName}`,
      styles: parsedStyleProps.styles,
      media: parsedStyleProps.media
    }),
    typeof renderRoot === "function" ? renderRoot(props) : /* @__PURE__ */ import_jsx_runtime29.jsx(Element2, { ...props })
  ] });
});
_Box.displayName = "@mantine/core/Box";
var Box = createPolymorphicComponent(_Box);
// node_modules/@mantine/core/esm/core/factory/factory.mjs
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react55 = __toESM(require_react(), 1);
"use client";
function identity2(value) {
  return value;
}
function getWithProps(Component2) {
  const _Component = Component2;
  return (fixedProps) => {
    const Extended = import_react55.forwardRef((props, ref) => /* @__PURE__ */ import_jsx_runtime30.jsx(_Component, { ...fixedProps, ...props, ref }));
    Extended.extend = _Component.extend;
    Extended.displayName = `WithProps(${_Component.displayName})`;
    return Extended;
  };
}
function factory(ui) {
  const Component2 = import_react55.forwardRef(ui);
  Component2.extend = identity2;
  Component2.withProps = (fixedProps) => {
    const Extended = import_react55.forwardRef((props, ref) => /* @__PURE__ */ import_jsx_runtime30.jsx(Component2, { ...fixedProps, ...props, ref }));
    Extended.extend = Component2.extend;
    Extended.displayName = `WithProps(${Component2.displayName})`;
    return Extended;
  };
  return Component2;
}

// node_modules/@mantine/core/esm/core/factory/polymorphic-factory.mjs
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
"use client";
function polymorphicFactory(ui) {
  const Component2 = import_react56.forwardRef(ui);
  Component2.withProps = (fixedProps) => {
    const Extended = import_react56.forwardRef((props, ref) => /* @__PURE__ */ import_jsx_runtime31.jsx(Component2, { ...fixedProps, ...props, ref }));
    Extended.extend = Component2.extend;
    Extended.displayName = `WithProps(${Component2.displayName})`;
    return Extended;
  };
  Component2.extend = identity2;
  return Component2;
}

// node_modules/@mantine/core/esm/core/DirectionProvider/DirectionProvider.mjs
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);
"use client";
var DirectionContext = import_react57.createContext({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return import_react57.useContext(DirectionContext);
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.mjs
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React16 = __toESM(require_react(), 1);
var import_react59 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode2(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? undefined : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode2(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? undefined : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = node2.assignedSlot || node2.parentNode || isShadowRoot(node2) && node2.host || getDocumentElement(node2);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === undefined) {
    list = [];
  }
  if (traverseIframes === undefined) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? undefined : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function activeElement2(doc) {
  let activeElement3 = doc.activeElement;
  while (((_activeElement = activeElement3) == null || (_activeElement = _activeElement.shadowRoot) == null ? undefined : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement3 = activeElement3.shadowRoot.activeElement;
  }
  return activeElement3;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? undefined : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version: version2
      } = _ref;
      return brand + "/" + version2;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM())
    return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re2 = /android/i;
  return re2.test(getPlatform()) || re2.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  if (!strict) {
    values2.push("", undefined);
  }
  return values2.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node2) {
  return (node2 == null ? undefined : node2.ownerDocument) || document;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node2);
  }
  const e = event;
  return e.target != null && node2.contains(e.target);
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled])," + "[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === undefined) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var ReactDOM3 = __toESM(require_react_dom(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0;i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === undefined) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? undefined : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? undefined : platform.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(elements.floating));
  const offsetScale = await (platform.isElement == null ? undefined : platform.isElement(offsetParent)) ? await (platform.getScale == null ? undefined : platform.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform.isElement == null ? undefined : platform.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset = clamp2(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? undefined : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? undefined : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? undefined : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? undefined : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? undefined : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b) => a2.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i2 = 0;i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
var inline = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      const {
        padding = 2,
        x: x2,
        y: y2
      } = evaluate(options, state);
      const nativeClientRects = Array.from(await (platform.getClientRects == null ? undefined : platform.getClientRects(elements.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null) {
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === undefined) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? undefined : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === undefined) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === undefined) {
    includeScale = false;
  }
  if (isFixedStrategy === undefined) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === undefined) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : getWindowScrollBarX(documentElement, htmlRect));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === undefined) {
      skip = false;
    }
    if (threshold === undefined) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 0.0000001);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        root: root2.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === undefined) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var inline2 = inline;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = new Map;
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React15 = __toESM(require_react(), 1);
var import_react58 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);
var index2 = typeof document !== "undefined" ? import_react58.useLayoutEffect : import_react58.useEffect;
function deepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b.toString()) {
    return true;
  }
  let length2;
  let i2;
  let keys2;
  if (a2 && b && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 !== b.length)
        return false;
      for (i2 = length2;i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b).length) {
      return false;
    }
    for (i2 = length2;i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i2])) {
        return false;
      }
    }
    for (i2 = length2;i2-- !== 0; ) {
      const key = keys2[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React15.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === undefined) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React15.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React15.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React15.useState(null);
  const [_floating, _setFloating] = React15.useState(null);
  const setReference = React15.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = React15.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React15.useRef(null);
  const floatingRef = React15.useRef(null);
  const dataRef = React15.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React15.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM2.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React15.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React15.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React15.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React15.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React15.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var inline3 = (options, deps) => ({
  ...inline2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs2(refs) {
  return React16.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var SafeReact = {
  ...React16
};
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React16.useRef(() => {
    if (false) {
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React16.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? undefined : ref.current(...args);
  }, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var index3 = typeof document !== "undefined" ? import_react59.useLayoutEffect : import_react59.useEffect;
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
function useFloatingId() {
  const [id, setId] = React16.useState(() => serverHandoffComplete ? genId() : undefined);
  index3(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React16.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId2 = SafeReact.useId;
var useId3 = useReactId2 || useFloatingId;
if (false) {
}
function createPubSub() {
  const map = new Map;
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? undefined : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
var FloatingNodeContext = /* @__PURE__ */ React16.createContext(null);
var FloatingTreeContext = /* @__PURE__ */ React16.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React16.useContext(FloatingNodeContext)) == null ? undefined : _React$useContext.id) || null;
};
var useFloatingTree = () => React16.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef2(value) {
  const ref = import_react59.useRef(value);
  index3(() => {
    ref.current = value;
  });
  return ref;
}
var safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? undefined : value[prop];
}
function useHover(context, props) {
  if (props === undefined) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef2(handleClose);
  const delayRef = useLatestRef2(delay);
  const openRef = useLatestRef2(open);
  const pointerTypeRef = React16.useRef();
  const timeoutRef = React16.useRef(-1);
  const handlerRef = React16.useRef();
  const restTimeoutRef = React16.useRef(-1);
  const blockMouseMoveRef = React16.useRef(true);
  const performedPointerEventsMutationRef = React16.useRef(false);
  const unbindMouseMoveRef = React16.useRef(() => {
  });
  const restTimeoutPendingRef = React16.useRef(false);
  const isHoverOpen = React16.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? undefined : _dataRef$current$open.type;
    return (type == null ? undefined : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React16.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeout(timeoutRef.current);
        clearTimeout(restTimeoutRef.current);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]);
  React16.useEffect(() => {
    if (!enabled)
      return;
    if (!handleCloseRef.current)
      return;
    if (!open)
      return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(elements.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React16.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === undefined) {
      runElseBranch = true;
    }
    if (reason === undefined) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = undefined;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  React16.useEffect(() => {
    if (!enabled)
      return;
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open) {
        onOpenChange(true, event, "hover");
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent())
        return;
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      clearTimeout(restTimeoutRef.current);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent())
        return;
      if (!dataRef.current.floatingContext)
        return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    if (isElement2(elements.domReference)) {
      var _elements$floating;
      const ref = elements.domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      (_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        var _elements$floating2;
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave);
        move && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [elements, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]);
  index3(() => {
    var _handleCloseRef$curre;
    if (!enabled)
      return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement2(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? undefined : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index3(() => {
    if (!open) {
      pointerTypeRef.current = undefined;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React16.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React16.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || restMs === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeout(restTimeoutRef.current);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMs]);
  const floating = React16.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(timeoutRef.current);
    },
    onMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event.nativeEvent, false);
      }
    }
  }), [closeWithDelay, isClickLikeOpenEvent]);
  return React16.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
var NOOP = () => {
};
var FloatingDelayGroupContext = /* @__PURE__ */ React16.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var useDelayGroupContext = () => React16.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children,
    delay,
    timeoutMs = 0
  } = props;
  const [state, setState] = React16.useReducer((prev2, next2) => ({
    ...prev2,
    ...next2
  }), {
    delay,
    timeoutMs,
    initialDelay: delay,
    currentId: null,
    isInstantPhase: false
  });
  const initialCurrentIdRef = React16.useRef(null);
  const setCurrentId = React16.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  index3(() => {
    if (state.currentId) {
      if (initialCurrentIdRef.current === null) {
        initialCurrentIdRef.current = state.currentId;
      } else if (!state.isInstantPhase) {
        setState({
          isInstantPhase: true
        });
      }
    } else {
      if (state.isInstantPhase) {
        setState({
          isInstantPhase: false
        });
      }
      initialCurrentIdRef.current = null;
    }
  }, [state.currentId, state.isInstantPhase]);
  return /* @__PURE__ */ React16.createElement(FloatingDelayGroupContext.Provider, {
    value: React16.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId])
  }, children);
}
function useDelayGroup(context, options) {
  if (options === undefined) {
    options = {};
  }
  const {
    open,
    onOpenChange,
    floatingId
  } = context;
  const {
    id: optionId,
    enabled = true
  } = options;
  const id = optionId != null ? optionId : floatingId;
  const groupContext = useDelayGroupContext();
  const {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  index3(() => {
    if (!enabled)
      return;
    if (!currentId)
      return;
    setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    });
    if (currentId !== id) {
      onOpenChange(false);
    }
  }, [enabled, id, onOpenChange, setState, currentId, initialDelay]);
  index3(() => {
    function unset() {
      onOpenChange(false);
      setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (!enabled)
      return;
    if (!currentId)
      return;
    if (!open && currentId === id) {
      if (timeoutMs) {
        const timeout = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
  index3(() => {
    if (!enabled)
      return;
    if (setCurrentId === NOOP || !open)
      return;
    setCurrentId(id);
  }, [enabled, open, setCurrentId, id]);
  return groupContext;
}
function getChildren(nodes, id) {
  let allChildren = nodes.filter((node2) => {
    var _node$context;
    return node2.parentId === id && ((_node$context = node2.context) == null ? undefined : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node2) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? undefined : _currentChildren.some((n) => {
        var _node$context2;
        return node2.parentId === n.id && ((_node$context2 = node2.context) == null ? undefined : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
var captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
var normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? undefined : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
    outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? undefined : normalizable.outsidePress) != null ? _normalizable$outside : true
  };
};
function useDismiss(context, props) {
  if (props === undefined) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React16.useRef(false);
  const endedOrStartedInsideRef = React16.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const isComposingRef = React16.useRef(false);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    if (isComposingRef.current) {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? undefined : _dataRef$current$floa.nodeId;
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement2(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement2(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement2(target) && !isRootElement(target) && !contains(target, elements.floating) && Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL2 = getComputedStyle2(target).direction === "rtl";
        if (isRTL2) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? undefined : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node2.context) == null ? undefined : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React16.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout);
      isComposingRef.current = true;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(() => {
        isComposingRef.current = false;
      }, isWebKit() ? 5 : 0);
    }
    const doc = getDocument(elements.floating);
    if (escapeKey) {
      doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      doc.addEventListener("compositionstart", handleCompositionStart);
      doc.addEventListener("compositionend", handleCompositionEnd);
    }
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement2(elements.domReference)) {
        ancestors = getOverflowAncestors(elements.domReference);
      }
      if (isElement2(elements.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
      }
      if (!isElement2(elements.reference) && elements.reference && elements.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? undefined : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      if (escapeKey) {
        doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
        doc.removeEventListener("compositionstart", handleCompositionStart);
        doc.removeEventListener("compositionend", handleCompositionEnd);
      }
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
      window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React16.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  const reference = React16.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      if (referencePress) {
        onOpenChange(false, event.nativeEvent, "reference-press");
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = React16.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React16.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId3();
  const dataRef = React16.useRef({});
  const [events] = React16.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (false) {
  }
  const [positionReference, setPositionReference] = React16.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : undefined;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React16.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React16.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React16.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === undefined) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React16.useState(null);
  const [positionReference, _setPositionReference] = React16.useState(null);
  const optionDomReference = computedElements == null ? undefined : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React16.useRef(null);
  const tree = useFloatingTree();
  index3(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position2 = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React16.useCallback((node2) => {
    const computedPositionReference = isElement2(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference);
    position2.refs.setReference(computedPositionReference);
  }, [position2.refs]);
  const setReference = React16.useCallback((node2) => {
    if (isElement2(node2) || node2 === null) {
      domReferenceRef.current = node2;
      setDomReference(node2);
    }
    if (isElement2(position2.refs.reference.current) || position2.refs.reference.current === null || node2 !== null && !isElement2(node2)) {
      position2.refs.setReference(node2);
    }
  }, [position2.refs]);
  const refs = React16.useMemo(() => ({
    ...position2.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position2.refs, setReference, setPositionReference]);
  const elements = React16.useMemo(() => ({
    ...position2.elements,
    domReference
  }), [position2.elements, domReference]);
  const context = React16.useMemo(() => ({
    ...position2,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position2, refs, elements, nodeId, rootContext]);
  index3(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node2 = tree == null ? undefined : tree.nodesRef.current.find((node3) => node3.id === nodeId);
    if (node2) {
      node2.context = context;
    }
  });
  return React16.useMemo(() => ({
    ...position2,
    context,
    refs,
    elements
  }), [position2, refs, elements, context]);
}
function useFocus(context, props) {
  if (props === undefined) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context;
  const {
    enabled = true,
    visibleOnly = true
  } = props;
  const blockFocusRef = React16.useRef(false);
  const timeoutRef = React16.useRef();
  const keyboardModalityRef = React16.useRef(true);
  React16.useEffect(() => {
    if (!enabled)
      return;
    const win = getWindow(elements.domReference);
    function onBlur() {
      if (!open && isHTMLElement(elements.domReference) && elements.domReference === activeElement2(getDocument(elements.domReference))) {
        blockFocusRef.current = true;
      }
    }
    function onKeyDown() {
      keyboardModalityRef.current = true;
    }
    win.addEventListener("blur", onBlur);
    win.addEventListener("keydown", onKeyDown, true);
    return () => {
      win.removeEventListener("blur", onBlur);
      win.removeEventListener("keydown", onKeyDown, true);
    };
  }, [elements.domReference, open, enabled]);
  React16.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      if (reason === "reference-press" || reason === "escape-key") {
        blockFocusRef.current = true;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]);
  React16.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  const reference = React16.useMemo(() => ({
    onPointerDown(event) {
      if (isVirtualPointerEvent(event.nativeEvent))
        return;
      keyboardModalityRef.current = false;
    },
    onMouseLeave() {
      blockFocusRef.current = false;
    },
    onFocus(event) {
      if (blockFocusRef.current)
        return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement2(target)) {
        try {
          if (isSafari() && isMac())
            throw Error();
          if (!target.matches(":focus-visible"))
            return;
        } catch (e) {
          if (!keyboardModalityRef.current && !isTypeableElement(target)) {
            return;
          }
        }
      }
      onOpenChange(true, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = false;
      const relatedTarget = event.relatedTarget;
      const nativeEvent = event.nativeEvent;
      const movedToFocusGuard = isElement2(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement2(elements.domReference ? elements.domReference.ownerDocument : document);
        if (!relatedTarget && activeEl === elements.domReference)
          return;
        if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? undefined : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard) {
          return;
        }
        onOpenChange(false, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React16.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = new Map;
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? undefined : _map$get2.map((fn) => fn(...args)).find((val) => val !== undefined);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === undefined) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? undefined : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? undefined : key.floating);
  const itemDeps = propsList.map((key) => key == null ? undefined : key.item);
  const getReferenceProps = React16.useCallback((userProps) => mergeProps(userProps, propsList, "reference"), referenceDeps);
  const getFloatingProps = React16.useCallback((userProps) => mergeProps(userProps, propsList, "floating"), floatingDeps);
  const getItemProps = React16.useCallback((userProps) => mergeProps(userProps, propsList, "item"), itemDeps);
  return React16.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
var componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function useRole(context, props) {
  var _componentRoleToAriaR;
  if (props === undefined) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const referenceId = useId3();
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = React16.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : undefined
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : undefined,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role === "select" && {
        "aria-autocomplete": "none"
      },
      ...role === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role]);
  const floating = React16.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = React16.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected
        };
      case "combobox": {
        return {
          ...commonProps,
          ...active && {
            "aria-selected": true
          }
        };
      }
    }
    return {};
  }, [floatingId, role]);
  return React16.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.mjs
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react61 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.context.mjs
var import_react60 = __toESM(require_react(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ScrollAreaProvider, useScrollAreaContext] = createSafeContext("ScrollArea.Root component was not found in tree");

// node_modules/@mantine/core/esm/components/ScrollArea/use-resize-observer.mjs
"use client";
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef2(onResize);
  useIsomorphicEffect(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
    return;
  }, [element, handleResize]);
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.mjs
"use client";
var Corner = import_react61.forwardRef((props, ref) => {
  const { style: style2, ...others } = props;
  const ctx = useScrollAreaContext();
  const [width, setWidth] = import_react61.useState(0);
  const [height, setHeight] = import_react61.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver(ctx.scrollbarX, () => {
    const h = ctx.scrollbarX?.offsetHeight || 0;
    ctx.onCornerHeightChange(h);
    setHeight(h);
  });
  useResizeObserver(ctx.scrollbarY, () => {
    const w2 = ctx.scrollbarY?.offsetWidth || 0;
    ctx.onCornerWidthChange(w2);
    setWidth(w2);
  });
  return hasSize ? /* @__PURE__ */ import_jsx_runtime34.jsx("div", { ...others, ref, style: { ...style2, width, height } }) : null;
});
var ScrollAreaCorner = import_react61.forwardRef((props, ref) => {
  const ctx = useScrollAreaContext();
  const hasBothScrollbarsVisible = Boolean(ctx.scrollbarX && ctx.scrollbarY);
  const hasCorner = ctx.type !== "scroll" && hasBothScrollbarsVisible;
  return hasCorner ? /* @__PURE__ */ import_jsx_runtime34.jsx(Corner, { ...props, ref }) : null;
});

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaRoot/ScrollAreaRoot.mjs
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);
"use client";
var defaultProps = {
  scrollHideDelay: 1000,
  type: "hover"
};
var ScrollAreaRoot = import_react62.forwardRef((_props, ref) => {
  const props = useProps("ScrollAreaRoot", defaultProps, _props);
  const { type, scrollHideDelay, scrollbars, ...others } = props;
  const [scrollArea, setScrollArea] = import_react62.useState(null);
  const [viewport, setViewport] = import_react62.useState(null);
  const [content, setContent] = import_react62.useState(null);
  const [scrollbarX, setScrollbarX] = import_react62.useState(null);
  const [scrollbarY, setScrollbarY] = import_react62.useState(null);
  const [cornerWidth, setCornerWidth] = import_react62.useState(0);
  const [cornerHeight, setCornerHeight] = import_react62.useState(0);
  const [scrollbarXEnabled, setScrollbarXEnabled] = import_react62.useState(false);
  const [scrollbarYEnabled, setScrollbarYEnabled] = import_react62.useState(false);
  const rootRef = useMergedRef(ref, (node2) => setScrollArea(node2));
  return /* @__PURE__ */ import_jsx_runtime35.jsx(ScrollAreaProvider, {
    value: {
      type,
      scrollHideDelay,
      scrollArea,
      viewport,
      onViewportChange: setViewport,
      content,
      onContentChange: setContent,
      scrollbarX,
      onScrollbarXChange: setScrollbarX,
      scrollbarXEnabled,
      onScrollbarXEnabledChange: setScrollbarXEnabled,
      scrollbarY,
      onScrollbarYChange: setScrollbarY,
      scrollbarYEnabled,
      onScrollbarYEnabledChange: setScrollbarYEnabled,
      onCornerWidthChange: setCornerWidth,
      onCornerHeightChange: setCornerHeight
    },
    children: /* @__PURE__ */ import_jsx_runtime35.jsx(Box, {
      ...others,
      ref: rootRef,
      __vars: {
        "--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
        "--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
      }
    })
  });
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.mjs
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react71 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.mjs
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.mjs
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-ratio.mjs
"use client";
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}

// node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-size.mjs
"use client";
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}

// node_modules/@mantine/core/esm/components/ScrollArea/utils/linear-scale.mjs
"use client";
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) {
      return output[0];
    }
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}

// node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-offset-from-scroll.mjs
"use client";
function clamp3(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp3(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}

// node_modules/@mantine/core/esm/components/ScrollArea/utils/get-scroll-position-from-pointer.mjs
"use client";
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset4 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset4;
  const minPointerPos = sizes.scrollbar.paddingStart + offset4;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.mjs
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/utils/is-scrolling-within-scrollbar-bounds.mjs
"use client";
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}

// node_modules/@mantine/core/esm/components/ScrollArea/utils/to-int.mjs
"use client";
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.mjs
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/utils/compose-event-handlers.mjs
"use client";
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return (event) => {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      ourEventHandler?.(event);
    }
  };
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.context.mjs
var import_react63 = __toESM(require_react(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ScrollbarProvider, useScrollbarContext] = createSafeContext("ScrollAreaScrollbar was not found in tree");

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.mjs
"use client";
var Scrollbar = import_react64.forwardRef((props, forwardedRef) => {
  const {
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext();
  const [scrollbar, setScrollbar] = import_react64.useState(null);
  const composeRefs = useMergedRef(forwardedRef, (node2) => setScrollbar(node2));
  const rectRef = import_react64.useRef(null);
  const prevWebkitUserSelectRef = import_react64.useRef("");
  const { viewport } = context;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef2(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef2(onThumbPositionChange);
  const handleResize = useDebouncedCallback(onResize, 10);
  const handleDragScroll = (event) => {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left;
      const y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  };
  import_react64.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel) {
        handleWheelScroll(event, maxScrollPos);
      }
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  import_react64.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver(scrollbar, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ import_jsx_runtime37.jsx(ScrollbarProvider, {
    value: {
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef2(onThumbChange),
      onThumbPointerUp: useCallbackRef2(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef2(onThumbPointerDown)
    },
    children: /* @__PURE__ */ import_jsx_runtime37.jsx("div", {
      ...scrollbarProps,
      ref: composeRefs,
      "data-mantine-scrollbar": true,
      style: { position: "absolute", ...scrollbarProps.style },
      onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
        event.preventDefault();
        const mainPointer = 0;
        if (event.button === mainPointer) {
          const element = event.target;
          element.setPointerCapture(event.pointerId);
          rectRef.current = scrollbar.getBoundingClientRect();
          prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
          document.body.style.webkitUserSelect = "none";
          handleDragScroll(event);
        }
      }),
      onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
      onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
        const element = event.target;
        if (element.hasPointerCapture(event.pointerId)) {
          event.preventDefault();
          element.releasePointerCapture(event.pointerId);
        }
      }),
      onLostPointerCapture: () => {
        document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
        rectRef.current = null;
      }
    })
  });
});

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.mjs
"use client";
var ScrollAreaScrollbarX = import_react65.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, style: style2, ...others } = props;
  const ctx = useScrollAreaContext();
  const [computedStyle, setComputedStyle] = import_react65.useState();
  const ref = import_react65.useRef(null);
  const composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
  import_react65.useEffect(() => {
    if (ref.current) {
      setComputedStyle(getComputedStyle(ref.current));
    }
  }, [ref]);
  return /* @__PURE__ */ import_jsx_runtime38.jsx(Scrollbar, {
    "data-orientation": "horizontal",
    ...others,
    ref: composeRefs,
    sizes,
    style: {
      ...style2,
      ["--sa-thumb-width"]: `${getThumbSize(sizes)}px`
    },
    onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
    onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
    onWheelScroll: (event, maxScrollPos) => {
      if (ctx.viewport) {
        const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
        props.onWheelScroll(scrollPos);
        if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
          event.preventDefault();
        }
      }
    },
    onResize: () => {
      if (ref.current && ctx.viewport && computedStyle) {
        onSizesChange({
          content: ctx.viewport.scrollWidth,
          viewport: ctx.viewport.offsetWidth,
          scrollbar: {
            size: ref.current.clientWidth,
            paddingStart: toInt(computedStyle.paddingLeft),
            paddingEnd: toInt(computedStyle.paddingRight)
          }
        });
      }
    }
  });
});
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarY.mjs
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
"use client";
var ScrollAreaScrollbarY = import_react66.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, style: style2, ...others } = props;
  const context = useScrollAreaContext();
  const [computedStyle, setComputedStyle] = import_react66.useState();
  const ref = import_react66.useRef(null);
  const composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
  import_react66.useEffect(() => {
    if (ref.current) {
      setComputedStyle(window.getComputedStyle(ref.current));
    }
  }, []);
  return /* @__PURE__ */ import_jsx_runtime39.jsx(Scrollbar, {
    ...others,
    "data-orientation": "vertical",
    ref: composeRefs,
    sizes,
    style: {
      ["--sa-thumb-height"]: `${getThumbSize(sizes)}px`,
      ...style2
    },
    onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
    onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
    onWheelScroll: (event, maxScrollPos) => {
      if (context.viewport) {
        const scrollPos = context.viewport.scrollTop + event.deltaY;
        props.onWheelScroll(scrollPos);
        if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
          event.preventDefault();
        }
      }
    },
    onResize: () => {
      if (ref.current && context.viewport && computedStyle) {
        onSizesChange({
          content: context.viewport.scrollHeight,
          viewport: context.viewport.offsetHeight,
          scrollbar: {
            size: ref.current.clientHeight,
            paddingStart: toInt(computedStyle.paddingTop),
            paddingEnd: toInt(computedStyle.paddingBottom)
          }
        });
      }
    }
  });
});
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.mjs
"use client";
var ScrollAreaScrollbarVisible = import_react67.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const { dir } = useDirection();
  const context = useScrollAreaContext();
  const thumbRef = import_react67.useRef(null);
  const pointerOffsetRef = import_react67.useRef(0);
  const [sizes, setSizes] = import_react67.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => {
      thumbRef.current = thumb;
    },
    onThumbPointerUp: () => {
      pointerOffsetRef.current = 0;
    },
    onThumbPointerDown: (pointerPos) => {
      pointerOffsetRef.current = pointerPos;
    }
  };
  const getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, direction);
  if (orientation === "horizontal") {
    return /* @__PURE__ */ import_jsx_runtime40.jsx(ScrollAreaScrollbarX, {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollLeft;
          const offset4 = getThumbOffsetFromScroll(scrollPos, sizes, dir);
          thumbRef.current.style.transform = `translate3d(${offset4}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        if (context.viewport) {
          context.viewport.scrollLeft = scrollPos;
        }
      },
      onDragScroll: (pointerPos) => {
        if (context.viewport) {
          context.viewport.scrollLeft = getScrollPosition(pointerPos, dir);
        }
      }
    });
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ import_jsx_runtime40.jsx(ScrollAreaScrollbarY, {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollTop;
          const offset4 = getThumbOffsetFromScroll(scrollPos, sizes);
          if (sizes.scrollbar.size === 0) {
            thumbRef.current.style.setProperty("--thumb-opacity", "0");
          } else {
            thumbRef.current.style.setProperty("--thumb-opacity", "1");
          }
          thumbRef.current.style.transform = `translate3d(0, ${offset4}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        if (context.viewport) {
          context.viewport.scrollTop = scrollPos;
        }
      },
      onDragScroll: (pointerPos) => {
        if (context.viewport) {
          context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    });
  }
  return null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.mjs
"use client";
var ScrollAreaScrollbarAuto = import_react68.forwardRef((props, ref) => {
  const context = useScrollAreaContext();
  const { forceMount, ...scrollbarProps } = props;
  const [visible2, setVisible] = import_react68.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebouncedCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  if (forceMount || visible2) {
    return /* @__PURE__ */ import_jsx_runtime41.jsx(ScrollAreaScrollbarVisible, {
      "data-state": visible2 ? "visible" : "hidden",
      ...scrollbarProps,
      ref
    });
  }
  return null;
});
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarHover.mjs
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
"use client";
var ScrollAreaScrollbarHover = import_react69.forwardRef((props, ref) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext();
  const [visible2, setVisible] = import_react69.useState(false);
  import_react69.useEffect(() => {
    const { scrollArea } = context;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
    return;
  }, [context.scrollArea, context.scrollHideDelay]);
  if (forceMount || visible2) {
    return /* @__PURE__ */ import_jsx_runtime42.jsx(ScrollAreaScrollbarAuto, {
      "data-state": visible2 ? "visible" : "hidden",
      ...scrollbarProps,
      ref
    });
  }
  return null;
});
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.mjs
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);
"use client";
var ScrollAreaScrollbarScroll = import_react70.forwardRef((props, red) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext();
  const isHorizontal = props.orientation === "horizontal";
  const [state, setState] = import_react70.useState("hidden");
  const debounceScrollEnd = useDebouncedCallback(() => setState("idle"), 100);
  import_react70.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => setState("hidden"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
    return;
  }, [state, context.scrollHideDelay]);
  import_react70.useEffect(() => {
    const { viewport } = context;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          setState("scrolling");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
    return;
  }, [context.viewport, isHorizontal, debounceScrollEnd]);
  if (forceMount || state !== "hidden") {
    return /* @__PURE__ */ import_jsx_runtime43.jsx(ScrollAreaScrollbarVisible, {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: red,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
    });
  }
  return null;
});

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.mjs
"use client";
var ScrollAreaScrollbar = import_react71.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext();
  const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
  const isHorizontal = props.orientation === "horizontal";
  import_react71.useEffect(() => {
    isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
    return () => {
      isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
    };
  }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
  return context.type === "hover" ? /* @__PURE__ */ import_jsx_runtime44.jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ import_jsx_runtime44.jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ import_jsx_runtime44.jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ import_jsx_runtime44.jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
});
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.mjs
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ScrollArea/utils/add-unlinked-scroll-listener.mjs
"use client";
function addUnlinkedScrollListener(node2, handler = () => {
}) {
  let prevPosition = { left: node2.scrollLeft, top: node2.scrollTop };
  let rAF = 0;
  (function loop() {
    const position2 = { left: node2.scrollLeft, top: node2.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position2.left;
    const isVerticalScroll = prevPosition.top !== position2.top;
    if (isHorizontalScroll || isVerticalScroll) {
      handler();
    }
    prevPosition = position2;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
}

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.mjs
"use client";
var Thumb = import_react72.forwardRef((props, forwardedRef) => {
  const { style: style2, ...others } = props;
  const scrollAreaContext = useScrollAreaContext();
  const scrollbarContext = useScrollbarContext();
  const { onThumbPositionChange } = scrollbarContext;
  const composedRef = useMergedRef(forwardedRef, (node2) => scrollbarContext.onThumbChange(node2));
  const removeUnlinkedScrollListenerRef = import_react72.useRef(undefined);
  const debounceScrollEnd = useDebouncedCallback(() => {
    if (removeUnlinkedScrollListenerRef.current) {
      removeUnlinkedScrollListenerRef.current();
      removeUnlinkedScrollListenerRef.current = undefined;
    }
  }, 100);
  import_react72.useEffect(() => {
    const { viewport } = scrollAreaContext;
    if (viewport) {
      const handleScroll2 = () => {
        debounceScrollEnd();
        if (!removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener;
          onThumbPositionChange();
        }
      };
      onThumbPositionChange();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
    return;
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
  return /* @__PURE__ */ import_jsx_runtime45.jsx("div", {
    "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
    ...others,
    ref: composedRef,
    style: {
      width: "var(--sa-thumb-width)",
      height: "var(--sa-thumb-height)",
      ...style2
    },
    onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
      const thumb = event.target;
      const thumbRect = thumb.getBoundingClientRect();
      const x2 = event.clientX - thumbRect.left;
      const y2 = event.clientY - thumbRect.top;
      scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
    }),
    onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
  });
});
Thumb.displayName = "@mantine/core/ScrollAreaThumb";
var ScrollAreaThumb = import_react72.forwardRef((props, forwardedRef) => {
  const { forceMount, ...thumbProps } = props;
  const scrollbarContext = useScrollbarContext();
  if (forceMount || scrollbarContext.hasThumb) {
    return /* @__PURE__ */ import_jsx_runtime45.jsx(Thumb, { ref: forwardedRef, ...thumbProps });
  }
  return null;
});
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaViewport/ScrollAreaViewport.mjs
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);
"use client";
var ScrollAreaViewport = import_react73.forwardRef(({ children, style: style2, ...others }, ref) => {
  const ctx = useScrollAreaContext();
  const rootRef = useMergedRef(ref, ctx.onViewportChange);
  return /* @__PURE__ */ import_jsx_runtime46.jsx(Box, {
    ...others,
    ref: rootRef,
    style: {
      overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
      ...style2
    },
    children: /* @__PURE__ */ import_jsx_runtime46.jsx("div", { style: { minWidth: "100%" }, ref: ctx.onContentChange, children })
  });
});
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.module.css.mjs
"use client";
var classes = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };

// node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.mjs
"use client";
var defaultProps2 = {
  scrollHideDelay: 1000,
  type: "hover",
  scrollbars: "xy"
};
var varsResolver = createVarsResolver((_2, { scrollbarSize, overscrollBehavior }) => ({
  root: {
    "--scrollarea-scrollbar-size": rem(scrollbarSize),
    "--scrollarea-over-scroll-behavior": overscrollBehavior
  }
}));
var ScrollArea = factory((_props, ref) => {
  const props = useProps("ScrollArea", defaultProps2, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    scrollbarSize,
    vars,
    type,
    scrollHideDelay,
    viewportProps,
    viewportRef,
    onScrollPositionChange,
    children,
    offsetScrollbars,
    scrollbars,
    onBottomReached,
    onTopReached,
    overscrollBehavior,
    ...others
  } = props;
  const [scrollbarHovered, setScrollbarHovered] = import_react74.useState(false);
  const [verticalThumbVisible, setVerticalThumbVisible] = import_react74.useState(false);
  const [horizontalThumbVisible, setHorizontalThumbVisible] = import_react74.useState(false);
  const getStyles2 = useStyles({
    name: "ScrollArea",
    props,
    classes,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  });
  const localViewportRef = import_react74.useRef(null);
  const combinedViewportRef = useMergeRefs2([viewportRef, localViewportRef]);
  import_react74.useEffect(() => {
    if (!localViewportRef.current) {
      return;
    }
    if (offsetScrollbars !== "present") {
      return;
    }
    const element = localViewportRef.current;
    const observer = new ResizeObserver(() => {
      const { scrollHeight, clientHeight, scrollWidth, clientWidth } = element;
      setVerticalThumbVisible(scrollHeight > clientHeight);
      setHorizontalThumbVisible(scrollWidth > clientWidth);
    });
    observer.observe(element);
    return () => observer.disconnect();
  }, [localViewportRef, offsetScrollbars]);
  return /* @__PURE__ */ import_jsx_runtime47.jsxs(ScrollAreaRoot, {
    type: type === "never" ? "always" : type,
    scrollHideDelay,
    ref,
    scrollbars,
    ...getStyles2("root"),
    ...others,
    children: [
      /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollAreaViewport, {
        ...viewportProps,
        ...getStyles2("viewport", { style: viewportProps?.style }),
        ref: combinedViewportRef,
        "data-offset-scrollbars": offsetScrollbars === true ? "xy" : offsetScrollbars || undefined,
        "data-scrollbars": scrollbars || undefined,
        "data-horizontal-hidden": offsetScrollbars === "present" && !horizontalThumbVisible ? "true" : undefined,
        "data-vertical-hidden": offsetScrollbars === "present" && !verticalThumbVisible ? "true" : undefined,
        onScroll: (e) => {
          viewportProps?.onScroll?.(e);
          onScrollPositionChange?.({ x: e.currentTarget.scrollLeft, y: e.currentTarget.scrollTop });
          const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
          if (scrollTop - (scrollHeight - clientHeight) >= 0) {
            onBottomReached?.();
          }
          if (scrollTop === 0) {
            onTopReached?.();
          }
        },
        children
      }),
      (scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollAreaScrollbar, {
        ...getStyles2("scrollbar"),
        orientation: "horizontal",
        "data-hidden": type === "never" || offsetScrollbars === "present" && !horizontalThumbVisible ? true : undefined,
        forceMount: true,
        onMouseEnter: () => setScrollbarHovered(true),
        onMouseLeave: () => setScrollbarHovered(false),
        children: /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
      }),
      (scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollAreaScrollbar, {
        ...getStyles2("scrollbar"),
        orientation: "vertical",
        "data-hidden": type === "never" || offsetScrollbars === "present" && !verticalThumbVisible ? true : undefined,
        forceMount: true,
        onMouseEnter: () => setScrollbarHovered(true),
        onMouseLeave: () => setScrollbarHovered(false),
        children: /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
      }),
      /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollAreaCorner, {
        ...getStyles2("corner"),
        "data-hovered": scrollbarHovered || undefined,
        "data-hidden": type === "never" || undefined
      })
    ]
  });
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
var ScrollAreaAutosize = factory((props, ref) => {
  const {
    children,
    classNames,
    styles,
    scrollbarSize,
    scrollHideDelay,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    scrollbars,
    style: style2,
    vars,
    onBottomReached,
    onTopReached,
    ...others
  } = useProps("ScrollAreaAutosize", defaultProps2, props);
  return /* @__PURE__ */ import_jsx_runtime47.jsx(Box, { ...others, ref, style: [{ display: "flex", overflow: "auto" }, style2], children: /* @__PURE__ */ import_jsx_runtime47.jsx(Box, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: /* @__PURE__ */ import_jsx_runtime47.jsx(ScrollArea, {
    classNames,
    styles,
    scrollHideDelay,
    scrollbarSize,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    vars,
    scrollbars,
    onBottomReached,
    onTopReached,
    children
  }) }) });
});
ScrollArea.classes = classes;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes;
ScrollArea.Autosize = ScrollAreaAutosize;
// node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.mjs
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react76 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.module.css.mjs
"use client";
var classes2 = { root: "m_87cf2631" };

// node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.mjs
"use client";
var defaultProps3 = {
  __staticSelector: "UnstyledButton"
};
var UnstyledButton = polymorphicFactory((_props, ref) => {
  const props = useProps("UnstyledButton", defaultProps3, _props);
  const {
    className,
    component = "button",
    __staticSelector,
    unstyled,
    classNames,
    styles,
    style: style2,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes2,
    className,
    style: style2,
    classNames,
    styles,
    unstyled
  });
  return /* @__PURE__ */ import_jsx_runtime48.jsx(Box, {
    ...getStyles2("root", { focusable: true }),
    component,
    ref,
    type: component === "button" ? "button" : undefined,
    ...others
  });
});
UnstyledButton.classes = classes2;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";

// node_modules/@mantine/core/esm/components/VisuallyHidden/VisuallyHidden.mjs
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/VisuallyHidden/VisuallyHidden.module.css.mjs
"use client";
var classes3 = { root: "m_515a97f8" };

// node_modules/@mantine/core/esm/components/VisuallyHidden/VisuallyHidden.mjs
"use client";
var defaultProps4 = {};
var VisuallyHidden = factory((_props, ref) => {
  const props = useProps("VisuallyHidden", defaultProps4, _props);
  const { classNames, className, style: style2, styles, unstyled, vars, ...others } = props;
  const getStyles2 = useStyles({
    name: "VisuallyHidden",
    classes: classes3,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled
  });
  return /* @__PURE__ */ import_jsx_runtime49.jsx(Box, { component: "span", ref, ...getStyles2("root"), ...others });
});
VisuallyHidden.classes = classes3;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";

// node_modules/@mantine/core/esm/components/Paper/Paper.mjs
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react78 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Paper/Paper.module.css.mjs
"use client";
var classes4 = { root: "m_1b7284a3" };

// node_modules/@mantine/core/esm/components/Paper/Paper.mjs
"use client";
var defaultProps5 = {};
var varsResolver2 = createVarsResolver((_2, { radius, shadow }) => ({
  root: {
    "--paper-radius": radius === undefined ? undefined : getRadius(radius),
    "--paper-shadow": getShadow(shadow)
  }
}));
var Paper = polymorphicFactory((_props, ref) => {
  const props = useProps("Paper", defaultProps5, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    withBorder,
    vars,
    radius,
    shadow,
    variant,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Paper",
    props,
    classes: classes4,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver2
  });
  return /* @__PURE__ */ import_jsx_runtime50.jsx(Box, {
    ref,
    mod: [{ "data-with-border": withBorder }, mod],
    ...getStyles2("root"),
    variant,
    ...others
  });
});
Paper.classes = classes4;
Paper.displayName = "@mantine/core/Paper";
// node_modules/@mantine/core/esm/components/Popover/Popover.mjs
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react93 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Floating/get-floating-position/get-floating-position.mjs
"use client";
function getFloatingPosition(dir, position2) {
  if (dir === "rtl" && (position2.includes("right") || position2.includes("left"))) {
    const [side, placement] = position2.split("-");
    const flippedPosition = side === "right" ? "left" : "right";
    return placement === undefined ? flippedPosition : `${flippedPosition}-${placement}`;
  }
  return position2;
}

// node_modules/@mantine/core/esm/components/Floating/FloatingArrow/FloatingArrow.mjs
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Floating/FloatingArrow/get-arrow-position-styles.mjs
"use client";
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
  if (placement === "center" || arrowPosition === "center") {
    return { top: arrowY };
  }
  if (placement === "end") {
    return { bottom: arrowOffset };
  }
  if (placement === "start") {
    return { top: arrowOffset };
  }
  return {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
  if (placement === "center" || arrowPosition === "center") {
    return { left: arrowX };
  }
  if (placement === "end") {
    return { [dir === "ltr" ? "right" : "left"]: arrowOffset };
  }
  if (placement === "start") {
    return { [dir === "ltr" ? "left" : "right"]: arrowOffset };
  }
  return {};
}
var radiusByFloatingSide = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function getArrowPositionStyles({
  position: position2,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  arrowX,
  arrowY,
  dir
}) {
  const [side, placement = "center"] = position2.split("-");
  const baseStyles = {
    width: arrowSize,
    height: arrowSize,
    transform: "rotate(45deg)",
    position: "absolute",
    [radiusByFloatingSide[side]]: arrowRadius
  };
  const arrowPlacement = -arrowSize / 2;
  if (side === "left") {
    return {
      ...baseStyles,
      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
      right: arrowPlacement,
      borderLeftColor: "transparent",
      borderBottomColor: "transparent",
      clipPath: "polygon(100% 0, 0 0, 100% 100%)"
    };
  }
  if (side === "right") {
    return {
      ...baseStyles,
      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
      left: arrowPlacement,
      borderRightColor: "transparent",
      borderTopColor: "transparent",
      clipPath: "polygon(0 100%, 0 0, 100% 100%)"
    };
  }
  if (side === "top") {
    return {
      ...baseStyles,
      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
      bottom: arrowPlacement,
      borderTopColor: "transparent",
      borderLeftColor: "transparent",
      clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
    };
  }
  if (side === "bottom") {
    return {
      ...baseStyles,
      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
      top: arrowPlacement,
      borderBottomColor: "transparent",
      borderRightColor: "transparent",
      clipPath: "polygon(0 100%, 0 0, 100% 0)"
    };
  }
  return {};
}

// node_modules/@mantine/core/esm/components/Floating/FloatingArrow/FloatingArrow.mjs
"use client";
var FloatingArrow = import_react79.forwardRef(({
  position: position2,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  visible: visible2,
  arrowX,
  arrowY,
  style: style2,
  ...others
}, ref) => {
  const { dir } = useDirection();
  if (!visible2) {
    return null;
  }
  return /* @__PURE__ */ import_jsx_runtime51.jsx("div", {
    ...others,
    ref,
    style: {
      ...style2,
      ...getArrowPositionStyles({
        position: position2,
        arrowSize,
        arrowOffset,
        arrowRadius,
        arrowPosition,
        dir,
        arrowX,
        arrowY
      })
    }
  });
});
FloatingArrow.displayName = "@mantine/core/FloatingArrow";

// node_modules/@mantine/core/esm/components/Overlay/Overlay.mjs
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react80 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Overlay/Overlay.module.css.mjs
"use client";
var classes5 = { root: "m_9814e45f" };

// node_modules/@mantine/core/esm/components/Overlay/Overlay.mjs
"use client";
var defaultProps6 = {
  zIndex: getDefaultZIndex("modal")
};
var varsResolver3 = createVarsResolver((_2, { gradient, color, backgroundOpacity, blur, radius, zIndex }) => ({
  root: {
    "--overlay-bg": gradient || (color !== undefined || backgroundOpacity !== undefined) && rgba(color || "#000", backgroundOpacity ?? 0.6) || undefined,
    "--overlay-filter": blur ? `blur(${rem(blur)})` : undefined,
    "--overlay-radius": radius === undefined ? undefined : getRadius(radius),
    "--overlay-z-index": zIndex?.toString()
  }
}));
var Overlay = polymorphicFactory((_props, ref) => {
  const props = useProps("Overlay", defaultProps6, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    fixed,
    center,
    children,
    radius,
    zIndex,
    gradient,
    blur,
    color,
    backgroundOpacity,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Overlay",
    props,
    classes: classes5,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver3
  });
  return /* @__PURE__ */ import_jsx_runtime52.jsx(Box, { ref, ...getStyles2("root"), mod: [{ center, fixed }, mod], ...others, children });
});
Overlay.classes = classes5;
Overlay.displayName = "@mantine/core/Overlay";

// node_modules/@mantine/core/esm/components/Portal/Portal.mjs
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
"use client";
function createPortalNode(props) {
  const node2 = document.createElement("div");
  node2.setAttribute("data-portal", "true");
  typeof props.className === "string" && node2.classList.add(...props.className.split(" ").filter(Boolean));
  typeof props.style === "object" && Object.assign(node2.style, props.style);
  typeof props.id === "string" && node2.setAttribute("id", props.id);
  return node2;
}
function getTargetNode({
  target,
  reuseTargetNode,
  ...others
}) {
  if (target) {
    if (typeof target === "string") {
      return document.querySelector(target) || createPortalNode(others);
    }
    return target;
  }
  if (reuseTargetNode) {
    const existingNode = document.querySelector("[data-mantine-shared-portal-node]");
    if (existingNode) {
      return existingNode;
    }
    const node2 = createPortalNode(others);
    node2.setAttribute("data-mantine-shared-portal-node", "true");
    document.body.appendChild(node2);
    return node2;
  }
  return createPortalNode(others);
}
var defaultProps7 = {};
var Portal = factory((props, ref) => {
  const { children, target, reuseTargetNode, ...others } = useProps("Portal", defaultProps7, props);
  const [mounted, setMounted] = import_react81.useState(false);
  const nodeRef = import_react81.useRef(null);
  useIsomorphicEffect(() => {
    setMounted(true);
    nodeRef.current = getTargetNode({ target, reuseTargetNode, ...others });
    assignRef2(ref, nodeRef.current);
    if (!target && !reuseTargetNode && nodeRef.current) {
      document.body.appendChild(nodeRef.current);
    }
    return () => {
      if (!target && !reuseTargetNode && nodeRef.current) {
        document.body.removeChild(nodeRef.current);
      }
    };
  }, [target]);
  if (!mounted || !nodeRef.current) {
    return null;
  }
  return import_react_dom3.createPortal(/* @__PURE__ */ import_jsx_runtime53.jsx(import_jsx_runtime53.Fragment, { children }), nodeRef.current);
});
Portal.displayName = "@mantine/core/Portal";

// node_modules/@mantine/core/esm/components/Portal/OptionalPortal.mjs
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
"use client";
var OptionalPortal = factory(({ withinPortal = true, children, ...others }, ref) => {
  const env2 = useMantineEnv();
  if (env2 === "test" || !withinPortal) {
    return /* @__PURE__ */ import_jsx_runtime54.jsx(import_jsx_runtime54.Fragment, { children });
  }
  return /* @__PURE__ */ import_jsx_runtime54.jsx(Portal, { ref, ...others, children });
});
OptionalPortal.displayName = "@mantine/core/OptionalPortal";

// node_modules/@mantine/core/esm/components/Transition/Transition.mjs
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Transition/transitions.mjs
"use client";
var popIn = (from2) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${from2 === "bottom" ? 10 : -10}px)` },
  transitionProperty: "transform, opacity"
});
var transitions = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-30px)" },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...popIn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...popIn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...popIn("top"),
    common: { transformOrigin: "top right" }
  }
};

// node_modules/@mantine/core/esm/components/Transition/get-transition-styles/get-transition-styles.mjs
"use client";
var transitionStatuses = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function getTransitionStyles({
  transition,
  state,
  duration,
  timingFunction
}) {
  const shared = {
    WebkitBackfaceVisibility: "hidden",
    willChange: "transform, opacity",
    transitionDuration: `${duration}ms`,
    transitionTimingFunction: timingFunction
  };
  if (typeof transition === "string") {
    if (!(transition in transitions)) {
      return {};
    }
    return {
      transitionProperty: transitions[transition].transitionProperty,
      ...shared,
      ...transitions[transition].common,
      ...transitions[transition][transitionStatuses[state]]
    };
  }
  return {
    transitionProperty: transition.transitionProperty,
    ...shared,
    ...transition.common,
    ...transition[transitionStatuses[state]]
  };
}

// node_modules/@mantine/core/esm/components/Transition/use-transition.mjs
var import_react83 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
"use client";
function useTransition({
  duration,
  exitDuration,
  timingFunction,
  mounted,
  onEnter,
  onExit,
  onEntered,
  onExited,
  enterDelay,
  exitDelay
}) {
  const theme = useMantineTheme();
  const shouldReduceMotion = useReducedMotion();
  const reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : false;
  const [transitionDuration, setTransitionDuration] = import_react83.useState(reduceMotion ? 0 : duration);
  const [transitionStatus, setStatus] = import_react83.useState(mounted ? "entered" : "exited");
  const transitionTimeoutRef = import_react83.useRef(-1);
  const delayTimeoutRef = import_react83.useRef(-1);
  const rafRef = import_react83.useRef(-1);
  const handleStateChange = (shouldMount) => {
    const preHandler = shouldMount ? onEnter : onExit;
    const handler = shouldMount ? onEntered : onExited;
    window.clearTimeout(transitionTimeoutRef.current);
    const newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
    setTransitionDuration(newTransitionDuration);
    if (newTransitionDuration === 0) {
      typeof preHandler === "function" && preHandler();
      typeof handler === "function" && handler();
      setStatus(shouldMount ? "entered" : "exited");
    } else {
      rafRef.current = requestAnimationFrame(() => {
        import_react_dom4.default.flushSync(() => {
          setStatus(shouldMount ? "pre-entering" : "pre-exiting");
        });
        rafRef.current = requestAnimationFrame(() => {
          typeof preHandler === "function" && preHandler();
          setStatus(shouldMount ? "entering" : "exiting");
          transitionTimeoutRef.current = window.setTimeout(() => {
            typeof handler === "function" && handler();
            setStatus(shouldMount ? "entered" : "exited");
          }, newTransitionDuration);
        });
      });
    }
  };
  const handleTransitionWithDelay = (shouldMount) => {
    window.clearTimeout(delayTimeoutRef.current);
    const delay = shouldMount ? enterDelay : exitDelay;
    if (typeof delay !== "number") {
      handleStateChange(shouldMount);
      return;
    }
    delayTimeoutRef.current = window.setTimeout(() => {
      handleStateChange(shouldMount);
    }, shouldMount ? enterDelay : exitDelay);
  };
  useDidUpdate(() => {
    handleTransitionWithDelay(mounted);
  }, [mounted]);
  import_react83.useEffect(() => () => {
    window.clearTimeout(transitionTimeoutRef.current);
    cancelAnimationFrame(rafRef.current);
  }, []);
  return {
    transitionDuration,
    transitionStatus,
    transitionTimingFunction: timingFunction || "ease"
  };
}

// node_modules/@mantine/core/esm/components/Transition/Transition.mjs
"use client";
function Transition({
  keepMounted,
  transition = "fade",
  duration = 250,
  exitDuration = duration,
  mounted,
  children,
  timingFunction = "ease",
  onExit,
  onEntered,
  onEnter,
  onExited,
  enterDelay,
  exitDelay
}) {
  const env2 = useMantineEnv();
  const { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
    mounted,
    exitDuration,
    duration,
    timingFunction,
    onExit,
    onEntered,
    onEnter,
    onExited,
    enterDelay,
    exitDelay
  });
  if (transitionDuration === 0 || env2 === "test") {
    return mounted ? /* @__PURE__ */ import_jsx_runtime56.jsx(import_jsx_runtime56.Fragment, { children: children({}) }) : keepMounted ? children({ display: "none" }) : null;
  }
  return transitionStatus === "exited" ? keepMounted ? children({ display: "none" }) : null : /* @__PURE__ */ import_jsx_runtime56.jsx(import_jsx_runtime56.Fragment, { children: children(getTransitionStyles({
    transition,
    duration: transitionDuration,
    state: transitionStatus,
    timingFunction: transitionTimingFunction
  })) });
}
Transition.displayName = "@mantine/core/Transition";

// node_modules/@mantine/core/esm/components/Popover/Popover.context.mjs
var import_react85 = __toESM(require_react(), 1);
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
"use client";
var [PopoverContextProvider, usePopoverContext] = createSafeContext("Popover component was not found in the tree");

// node_modules/@mantine/core/esm/components/Popover/PopoverDropdown/PopoverDropdown.mjs
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/FocusTrap/FocusTrap.mjs
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);
"use client";
function FocusTrap({
  children,
  active = true,
  refProp = "ref",
  innerRef
}) {
  const focusTrapRef = useFocusTrap(active);
  const ref = useMergedRef(focusTrapRef, innerRef);
  if (!isElement(children)) {
    return children;
  }
  return import_react86.cloneElement(children, { [refProp]: ref });
}
function FocusTrapInitialFocus(props) {
  return /* @__PURE__ */ import_jsx_runtime58.jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": true, ...props });
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;

// node_modules/@mantine/core/esm/components/Popover/Popover.module.css.mjs
"use client";
var classes6 = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" };

// node_modules/@mantine/core/esm/components/Popover/PopoverDropdown/PopoverDropdown.mjs
"use client";
var defaultProps8 = {};
var PopoverDropdown = factory((_props, ref) => {
  const props = useProps("PopoverDropdown", defaultProps8, _props);
  const {
    className,
    style: style2,
    vars,
    children,
    onKeyDownCapture,
    variant,
    classNames,
    styles,
    ...others
  } = props;
  const ctx = usePopoverContext();
  const returnFocus = useFocusReturn({
    opened: ctx.opened,
    shouldReturnFocus: ctx.returnFocus
  });
  const accessibleProps = ctx.withRoles ? {
    "aria-labelledby": ctx.getTargetId(),
    id: ctx.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {};
  const mergedRef = useMergedRef(ref, ctx.floating);
  if (ctx.disabled) {
    return null;
  }
  return /* @__PURE__ */ import_jsx_runtime59.jsx(OptionalPortal, { ...ctx.portalProps, withinPortal: ctx.withinPortal, children: /* @__PURE__ */ import_jsx_runtime59.jsx(Transition, {
    mounted: ctx.opened,
    ...ctx.transitionProps,
    transition: ctx.transitionProps?.transition || "fade",
    duration: ctx.transitionProps?.duration ?? 150,
    keepMounted: ctx.keepMounted,
    exitDuration: typeof ctx.transitionProps?.exitDuration === "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
    children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime59.jsx(FocusTrap, { active: ctx.trapFocus && ctx.opened, innerRef: mergedRef, children: /* @__PURE__ */ import_jsx_runtime59.jsxs(Box, {
      ...accessibleProps,
      ...others,
      variant,
      onKeyDownCapture: closeOnEscape(() => {
        ctx.onClose?.();
        ctx.onDismiss?.();
      }, {
        active: ctx.closeOnEscape,
        onTrigger: returnFocus,
        onKeyDown: onKeyDownCapture
      }),
      "data-position": ctx.placement,
      "data-fixed": ctx.floatingStrategy === "fixed" || undefined,
      ...ctx.getStyles("dropdown", {
        className,
        props,
        classNames,
        styles,
        style: [
          {
            ...transitionStyles,
            zIndex: ctx.zIndex,
            top: ctx.y ?? 0,
            left: ctx.x ?? 0,
            width: ctx.width === "target" ? undefined : rem(ctx.width)
          },
          ctx.resolvedStyles.dropdown,
          styles?.dropdown,
          style2
        ]
      }),
      children: [
        children,
        /* @__PURE__ */ import_jsx_runtime59.jsx(FloatingArrow, {
          ref: ctx.arrowRef,
          arrowX: ctx.arrowX,
          arrowY: ctx.arrowY,
          visible: ctx.withArrow,
          position: ctx.placement,
          arrowSize: ctx.arrowSize,
          arrowRadius: ctx.arrowRadius,
          arrowOffset: ctx.arrowOffset,
          arrowPosition: ctx.arrowPosition,
          ...ctx.getStyles("arrow", {
            props,
            classNames,
            styles
          })
        })
      ]
    }) })
  }) });
});
PopoverDropdown.classes = classes6;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";

// node_modules/@mantine/core/esm/components/Popover/PopoverTarget/PopoverTarget.mjs
var import_react88 = __toESM(require_react(), 1);
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
"use client";
var defaultProps9 = {
  refProp: "ref",
  popupType: "dialog"
};
var PopoverTarget = factory((props, ref) => {
  const { children, refProp, popupType, ...others } = useProps("PopoverTarget", defaultProps9, props);
  if (!isElement(children)) {
    throw new Error("Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
  }
  const forwardedProps = others;
  const ctx = usePopoverContext();
  const targetRef = useMergedRef(ctx.reference, getRefProp(children), ref);
  const accessibleProps = ctx.withRoles ? {
    "aria-haspopup": popupType,
    "aria-expanded": ctx.opened,
    "aria-controls": ctx.getDropdownId(),
    id: ctx.getTargetId()
  } : {};
  return import_react88.cloneElement(children, {
    ...forwardedProps,
    ...accessibleProps,
    ...ctx.targetProps,
    className: clsx_default(ctx.targetProps.className, forwardedProps.className, children.props.className),
    [refProp]: targetRef,
    ...!ctx.controlled ? { onClick: ctx.onToggle } : null
  });
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";

// node_modules/@mantine/core/esm/components/Popover/use-popover.mjs
var import_react91 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Floating/use-floating-auto-update.mjs
var import_react89 = __toESM(require_react(), 1);
"use client";
function useFloatingAutoUpdate({
  opened,
  floating,
  position: position2,
  positionDependencies
}) {
  const [delayedUpdate, setDelayedUpdate] = import_react89.useState(0);
  import_react89.useEffect(() => {
    if (floating.refs.reference.current && floating.refs.floating.current && opened) {
      return autoUpdate(floating.refs.reference.current, floating.refs.floating.current, floating.update);
    }
    return;
  }, [
    floating.refs.reference.current,
    floating.refs.floating.current,
    opened,
    delayedUpdate,
    position2
  ]);
  useDidUpdate(() => {
    floating.update();
  }, positionDependencies);
  useDidUpdate(() => {
    setDelayedUpdate((c2) => c2 + 1);
  }, [opened]);
}

// node_modules/@mantine/core/esm/components/Popover/use-popover.mjs
"use client";
function getDefaultMiddlewares(middlewares) {
  if (middlewares === undefined) {
    return { shift: true, flip: true };
  }
  const result = { ...middlewares };
  if (middlewares.shift === undefined) {
    result.shift = true;
  }
  if (middlewares.flip === undefined) {
    result.flip = true;
  }
  return result;
}
function getPopoverMiddlewares(options, getFloating) {
  const middlewaresOptions = getDefaultMiddlewares(options.middlewares);
  const middlewares = [offset3(options.offset)];
  if (middlewaresOptions.shift) {
    middlewares.push(shift3(typeof middlewaresOptions.shift === "boolean" ? { limiter: limitShift3(), padding: 5 } : { limiter: limitShift3(), padding: 5, ...middlewaresOptions.shift }));
  }
  if (middlewaresOptions.flip) {
    middlewares.push(typeof middlewaresOptions.flip === "boolean" ? flip3() : flip3(middlewaresOptions.flip));
  }
  if (middlewaresOptions.inline) {
    middlewares.push(typeof middlewaresOptions.inline === "boolean" ? inline3() : inline3(middlewaresOptions.inline));
  }
  middlewares.push(arrow3({ element: options.arrowRef, padding: options.arrowOffset }));
  if (middlewaresOptions.size || options.width === "target") {
    middlewares.push(size3({
      ...typeof middlewaresOptions.size === "boolean" ? {} : middlewaresOptions.size,
      apply({ rects, availableWidth, availableHeight, ...rest }) {
        const floating = getFloating();
        const styles = floating.refs.floating.current?.style ?? {};
        if (middlewaresOptions.size) {
          if (typeof middlewaresOptions.size === "object" && !!middlewaresOptions.size.apply) {
            middlewaresOptions.size.apply({ rects, availableWidth, availableHeight, ...rest });
          } else {
            Object.assign(styles, {
              maxWidth: `${availableWidth}px`,
              maxHeight: `${availableHeight}px`
            });
          }
        }
        if (options.width === "target") {
          Object.assign(styles, {
            width: `${rects.reference.width}px`
          });
        }
      }
    }));
  }
  return middlewares;
}
function usePopover(options) {
  const [_opened, setOpened] = useUncontrolled({
    value: options.opened,
    defaultValue: options.defaultOpened,
    finalValue: false,
    onChange: options.onChange
  });
  const previouslyOpened = import_react91.useRef(_opened);
  const onClose = () => {
    if (_opened) {
      setOpened(false);
    }
  };
  const onToggle = () => setOpened(!_opened);
  const floating = useFloating2({
    strategy: options.strategy,
    placement: options.position,
    middleware: getPopoverMiddlewares(options, () => floating)
  });
  useFloatingAutoUpdate({
    opened: _opened,
    position: options.position,
    positionDependencies: options.positionDependencies || [],
    floating
  });
  useDidUpdate(() => {
    options.onPositionChange?.(floating.placement);
  }, [floating.placement]);
  useDidUpdate(() => {
    if (_opened !== previouslyOpened.current) {
      if (!_opened) {
        options.onClose?.();
      } else {
        options.onOpen?.();
      }
    }
    previouslyOpened.current = _opened;
  }, [_opened, options.onClose, options.onOpen]);
  return {
    floating,
    controlled: typeof options.opened === "boolean",
    opened: _opened,
    onClose,
    onToggle
  };
}

// node_modules/@mantine/core/esm/components/Popover/Popover.mjs
"use client";
var defaultProps10 = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: true, shift: true, inline: false },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: true,
  withinPortal: true,
  closeOnEscape: true,
  trapFocus: false,
  withRoles: true,
  returnFocus: false,
  withOverlay: false,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: getDefaultZIndex("popover"),
  __staticSelector: "Popover",
  width: "max-content"
};
var varsResolver4 = createVarsResolver((_2, { radius, shadow }) => ({
  dropdown: {
    "--popover-radius": radius === undefined ? undefined : getRadius(radius),
    "--popover-shadow": getShadow(shadow)
  }
}));
function Popover(_props) {
  const props = useProps("Popover", defaultProps10, _props);
  const {
    children,
    position: position2,
    offset: offset4,
    onPositionChange,
    positionDependencies,
    opened,
    transitionProps,
    onExitTransitionEnd,
    onEnterTransitionEnd,
    width,
    middlewares,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    unstyled,
    classNames,
    styles,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    closeOnEscape: closeOnEscape2,
    clickOutsideEvents,
    trapFocus,
    onClose,
    onDismiss,
    onOpen,
    onChange,
    zIndex,
    radius,
    shadow,
    id,
    defaultOpened,
    __staticSelector,
    withRoles,
    disabled,
    returnFocus,
    variant,
    keepMounted,
    vars,
    floatingStrategy,
    withOverlay,
    overlayProps,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes6,
    classNames,
    styles,
    unstyled,
    rootSelector: "dropdown",
    vars,
    varsResolver: varsResolver4
  });
  const { resolvedStyles } = useResolvedStylesApi({ classNames, styles, props });
  const arrowRef = import_react93.useRef(null);
  const [targetNode, setTargetNode] = import_react93.useState(null);
  const [dropdownNode, setDropdownNode] = import_react93.useState(null);
  const { dir } = useDirection();
  const uid = useId(id);
  const popover = usePopover({
    middlewares,
    width,
    position: getFloatingPosition(dir, position2),
    offset: typeof offset4 === "number" ? offset4 + (withArrow ? arrowSize / 2 : 0) : offset4,
    arrowRef,
    arrowOffset,
    onPositionChange,
    positionDependencies,
    opened,
    defaultOpened,
    onChange,
    onOpen,
    onClose,
    onDismiss,
    strategy: floatingStrategy
  });
  useClickOutside(() => {
    if (closeOnClickOutside) {
      popover.onClose();
      onDismiss?.();
    }
  }, clickOutsideEvents, [targetNode, dropdownNode]);
  const reference = import_react93.useCallback((node2) => {
    setTargetNode(node2);
    popover.floating.refs.setReference(node2);
  }, [popover.floating.refs.setReference]);
  const floating = import_react93.useCallback((node2) => {
    setDropdownNode(node2);
    popover.floating.refs.setFloating(node2);
  }, [popover.floating.refs.setFloating]);
  const onExited = import_react93.useCallback(() => {
    transitionProps?.onExited?.();
    onExitTransitionEnd?.();
  }, [transitionProps?.onExited, onExitTransitionEnd]);
  const onEntered = import_react93.useCallback(() => {
    transitionProps?.onEntered?.();
    onEnterTransitionEnd?.();
  }, [transitionProps?.onEntered, onEnterTransitionEnd]);
  return /* @__PURE__ */ import_jsx_runtime61.jsxs(PopoverContextProvider, {
    value: {
      returnFocus,
      disabled,
      controlled: popover.controlled,
      reference,
      floating,
      x: popover.floating.x,
      y: popover.floating.y,
      arrowX: popover.floating?.middlewareData?.arrow?.x,
      arrowY: popover.floating?.middlewareData?.arrow?.y,
      opened: popover.opened,
      arrowRef,
      transitionProps: { ...transitionProps, onExited, onEntered },
      width,
      withArrow,
      arrowSize,
      arrowOffset,
      arrowRadius,
      arrowPosition,
      placement: popover.floating.placement,
      trapFocus,
      withinPortal,
      portalProps,
      zIndex,
      radius,
      shadow,
      closeOnEscape: closeOnEscape2,
      onDismiss,
      onClose: popover.onClose,
      onToggle: popover.onToggle,
      getTargetId: () => `${uid}-target`,
      getDropdownId: () => `${uid}-dropdown`,
      withRoles,
      targetProps: others,
      __staticSelector,
      classNames,
      styles,
      unstyled,
      variant,
      keepMounted,
      getStyles: getStyles2,
      resolvedStyles,
      floatingStrategy
    },
    children: [
      children,
      withOverlay && /* @__PURE__ */ import_jsx_runtime61.jsx(Transition, {
        transition: "fade",
        mounted: popover.opened,
        duration: transitionProps?.duration || 250,
        exitDuration: transitionProps?.exitDuration || 250,
        children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime61.jsx(OptionalPortal, { withinPortal, children: /* @__PURE__ */ import_jsx_runtime61.jsx(Overlay, {
          ...overlayProps,
          ...getStyles2("overlay", {
            className: overlayProps?.className,
            style: [transitionStyles, overlayProps?.style]
          })
        }) })
      })
    ]
  });
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input) => input;
// node_modules/@mantine/core/esm/components/ActionIcon/ActionIcon.mjs
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Loader/Loader.mjs
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react97 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Loader/loaders/Bars.mjs
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react94 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Loader/Loader.module.css.mjs
"use client";
var classes7 = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };

// node_modules/@mantine/core/esm/components/Loader/loaders/Bars.mjs
"use client";
var Bars = import_react94.forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ import_jsx_runtime62.jsxs(Box, { component: "span", className: clsx_default(classes7.barsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ import_jsx_runtime62.jsx("span", { className: classes7.bar }),
  /* @__PURE__ */ import_jsx_runtime62.jsx("span", { className: classes7.bar }),
  /* @__PURE__ */ import_jsx_runtime62.jsx("span", { className: classes7.bar })
] }));
Bars.displayName = "@mantine/core/Bars";

// node_modules/@mantine/core/esm/components/Loader/loaders/Dots.mjs
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
"use client";
var Dots = import_react95.forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ import_jsx_runtime63.jsxs(Box, { component: "span", className: clsx_default(classes7.dotsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ import_jsx_runtime63.jsx("span", { className: classes7.dot }),
  /* @__PURE__ */ import_jsx_runtime63.jsx("span", { className: classes7.dot }),
  /* @__PURE__ */ import_jsx_runtime63.jsx("span", { className: classes7.dot })
] }));
Dots.displayName = "@mantine/core/Dots";

// node_modules/@mantine/core/esm/components/Loader/loaders/Oval.mjs
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);
"use client";
var Oval = import_react96.forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ import_jsx_runtime64.jsx(Box, { component: "span", className: clsx_default(classes7.ovalLoader, className), ...others, ref }));
Oval.displayName = "@mantine/core/Oval";

// node_modules/@mantine/core/esm/components/Loader/Loader.mjs
"use client";
var defaultLoaders = {
  bars: Bars,
  oval: Oval,
  dots: Dots
};
var defaultProps11 = {
  loaders: defaultLoaders,
  type: "oval"
};
var varsResolver5 = createVarsResolver((theme, { size: size4, color }) => ({
  root: {
    "--loader-size": getSize(size4, "loader-size"),
    "--loader-color": color ? getThemeColor(color, theme) : undefined
  }
}));
var Loader = factory((_props, ref) => {
  const props = useProps("Loader", defaultProps11, _props);
  const {
    size: size4,
    color,
    type,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    loaders,
    variant,
    children,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Loader",
    props,
    classes: classes7,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver5
  });
  if (children) {
    return /* @__PURE__ */ import_jsx_runtime65.jsx(Box, { ...getStyles2("root"), ref, ...others, children });
  }
  return /* @__PURE__ */ import_jsx_runtime65.jsx(Box, {
    ...getStyles2("root"),
    ref,
    component: loaders[type],
    variant,
    size: size4,
    ...others
  });
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes7;
Loader.displayName = "@mantine/core/Loader";

// node_modules/@mantine/core/esm/components/ActionIcon/ActionIconGroup/ActionIconGroup.mjs
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react98 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ActionIcon/ActionIcon.module.css.mjs
"use client";
var classes8 = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" };

// node_modules/@mantine/core/esm/components/ActionIcon/ActionIconGroup/ActionIconGroup.mjs
"use client";
var defaultProps12 = {
  orientation: "horizontal"
};
var varsResolver6 = createVarsResolver((_2, { borderWidth }) => ({
  group: { "--ai-border-width": rem(borderWidth) }
}));
var ActionIconGroup = factory((_props, ref) => {
  const props = useProps("ActionIconGroup", defaultProps12, _props);
  const {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    ...others
  } = useProps("ActionIconGroup", defaultProps12, _props);
  const getStyles2 = useStyles({
    name: "ActionIconGroup",
    props,
    classes: classes8,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver6,
    rootSelector: "group"
  });
  return /* @__PURE__ */ import_jsx_runtime66.jsx(Box, {
    ...getStyles2("group"),
    ref,
    variant,
    mod: [{ "data-orientation": orientation }, mod],
    role: "group",
    ...others
  });
});
ActionIconGroup.classes = classes8;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";

// node_modules/@mantine/core/esm/components/ActionIcon/ActionIconGroupSection/ActionIconGroupSection.mjs
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
"use client";
var defaultProps13 = {};
var varsResolver7 = createVarsResolver((theme, { radius, color, gradient, variant, autoContrast, size: size4 }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size4, "section-height"),
      "--section-padding-x": getSize(size4, "section-padding-x"),
      "--section-fz": getFontSize(size4),
      "--section-radius": radius === undefined ? undefined : getRadius(radius),
      "--section-bg": color || variant ? colors.background : undefined,
      "--section-color": colors.color,
      "--section-bd": color || variant ? colors.border : undefined
    }
  };
});
var ActionIconGroupSection = factory((_props, ref) => {
  const props = useProps("ActionIconGroupSection", defaultProps13, _props);
  const {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    ...others
  } = useProps("ActionIconGroupSection", defaultProps13, _props);
  const getStyles2 = useStyles({
    name: "ActionIconGroupSection",
    props,
    classes: classes8,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver7,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ import_jsx_runtime67.jsx(Box, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ActionIconGroupSection.classes = classes8;
ActionIconGroupSection.displayName = "@mantine/core/ActionIconGroupSection";

// node_modules/@mantine/core/esm/components/ActionIcon/ActionIcon.mjs
"use client";
var defaultProps14 = {};
var varsResolver8 = createVarsResolver((theme, { size: size4, radius, variant, gradient, color, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ai-size": getSize(size4, "ai-size"),
      "--ai-radius": radius === undefined ? undefined : getRadius(radius),
      "--ai-bg": color || variant ? colors.background : undefined,
      "--ai-hover": color || variant ? colors.hover : undefined,
      "--ai-hover-color": color || variant ? colors.hoverColor : undefined,
      "--ai-color": colors.color,
      "--ai-bd": color || variant ? colors.border : undefined
    }
  };
});
var ActionIcon = polymorphicFactory((_props, ref) => {
  const props = useProps("ActionIcon", defaultProps14, _props);
  const {
    className,
    unstyled,
    variant,
    classNames,
    styles,
    style: style2,
    loading,
    loaderProps,
    size: size4,
    color,
    radius,
    __staticSelector,
    gradient,
    vars,
    children,
    disabled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: ["ActionIcon", __staticSelector],
    props,
    className,
    style: style2,
    classes: classes8,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver8
  });
  return /* @__PURE__ */ import_jsx_runtime68.jsxs(UnstyledButton, {
    ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
    ...others,
    unstyled,
    variant,
    size: size4,
    disabled: disabled || loading,
    ref,
    mod: [{ loading, disabled: disabled || dataDisabled }, mod],
    children: [
      /* @__PURE__ */ import_jsx_runtime68.jsx(Transition, { mounted: !!loading, transition: "slide-down", duration: 150, children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime68.jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": true, children: /* @__PURE__ */ import_jsx_runtime68.jsx(Loader, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...loaderProps }) }) }),
      /* @__PURE__ */ import_jsx_runtime68.jsx(Box, { component: "span", mod: { loading }, ...getStyles2("icon"), children })
    ]
  });
});
ActionIcon.classes = classes8;
ActionIcon.displayName = "@mantine/core/ActionIcon";
ActionIcon.Group = ActionIconGroup;
ActionIcon.GroupSection = ActionIconGroupSection;
// node_modules/@mantine/core/esm/components/CloseButton/CloseIcon.mjs
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);
"use client";
var CloseIcon = import_react101.forwardRef(({ size: size4 = "var(--cb-icon-size, 70%)", style: style2, ...others }, ref) => /* @__PURE__ */ import_jsx_runtime69.jsx("svg", {
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  style: { ...style2, width: size4, height: size4 },
  ref,
  ...others,
  children: /* @__PURE__ */ import_jsx_runtime69.jsx("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  })
}));
CloseIcon.displayName = "@mantine/core/CloseIcon";

// node_modules/@mantine/core/esm/components/CloseButton/CloseButton.mjs
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react102 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/CloseButton/CloseButton.module.css.mjs
"use client";
var classes9 = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };

// node_modules/@mantine/core/esm/components/CloseButton/CloseButton.mjs
"use client";
var defaultProps15 = {
  variant: "subtle"
};
var varsResolver9 = createVarsResolver((_2, { size: size4, radius, iconSize }) => ({
  root: {
    "--cb-size": getSize(size4, "cb-size"),
    "--cb-radius": radius === undefined ? undefined : getRadius(radius),
    "--cb-icon-size": rem(iconSize)
  }
}));
var CloseButton = polymorphicFactory((_props, ref) => {
  const props = useProps("CloseButton", defaultProps15, _props);
  const {
    iconSize,
    children,
    vars,
    radius,
    className,
    classNames,
    style: style2,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    disabled,
    variant,
    icon,
    mod,
    __staticSelector,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: __staticSelector || "CloseButton",
    props,
    className,
    style: style2,
    classes: classes9,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver9
  });
  return /* @__PURE__ */ import_jsx_runtime70.jsxs(UnstyledButton, {
    ref,
    ...others,
    unstyled,
    variant,
    disabled,
    mod: [{ disabled: disabled || dataDisabled }, mod],
    ...getStyles2("root", { variant, active: !disabled && !dataDisabled }),
    children: [
      icon || /* @__PURE__ */ import_jsx_runtime70.jsx(CloseIcon, {}),
      children
    ]
  });
});
CloseButton.classes = classes9;
CloseButton.displayName = "@mantine/core/CloseButton";

// node_modules/@mantine/core/esm/components/Group/Group.mjs
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Group/filter-falsy-children/filter-falsy-children.mjs
var import_react103 = __toESM(require_react(), 1);
"use client";
function filterFalsyChildren(children) {
  return import_react103.Children.toArray(children).filter(Boolean);
}

// node_modules/@mantine/core/esm/components/Group/Group.module.css.mjs
"use client";
var classes10 = { root: "m_4081bf90" };

// node_modules/@mantine/core/esm/components/Group/Group.mjs
"use client";
var defaultProps16 = {
  preventGrowOverflow: true,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
};
var varsResolver10 = createVarsResolver((_2, { grow, preventGrowOverflow, gap, align, justify, wrap }, { childWidth }) => ({
  root: {
    "--group-child-width": grow && preventGrowOverflow ? childWidth : undefined,
    "--group-gap": getSpacing(gap),
    "--group-align": align,
    "--group-justify": justify,
    "--group-wrap": wrap
  }
}));
var Group = factory((_props, ref) => {
  const props = useProps("Group", defaultProps16, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    children,
    gap,
    align,
    justify,
    wrap,
    grow,
    preventGrowOverflow,
    vars,
    variant,
    __size,
    mod,
    ...others
  } = props;
  const filteredChildren = filterFalsyChildren(children);
  const childrenCount = filteredChildren.length;
  const resolvedGap = getSpacing(gap ?? "md");
  const childWidth = `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))`;
  const stylesCtx = { childWidth };
  const getStyles2 = useStyles({
    name: "Group",
    props,
    stylesCtx,
    className,
    style: style2,
    classes: classes10,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver10
  });
  return /* @__PURE__ */ import_jsx_runtime71.jsx(Box, {
    ...getStyles2("root"),
    ref,
    variant,
    mod: [{ grow }, mod],
    size: __size,
    ...others,
    children: filteredChildren
  });
});
Group.classes = classes10;
Group.displayName = "@mantine/core/Group";
// node_modules/@mantine/core/esm/components/ModalBase/ModalBase.mjs
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react108 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ModalBase/ModalBase.context.mjs
var import_react105 = __toESM(require_react(), 1);
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ModalBaseProvider, useModalBaseContext] = createSafeContext("ModalBase component was not found in tree");

// node_modules/@mantine/core/esm/components/ModalBase/use-modal.mjs
var import_react107 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ModalBase/use-lock-scroll.mjs
var import_react106 = __toESM(require_react(), 1);
"use client";
function useLockScroll({ opened, transitionDuration }) {
  const [shouldLockScroll, setShouldLockScroll] = import_react106.useState(opened);
  const timeout = import_react106.useRef(-1);
  const reduceMotion = useReducedMotion();
  const _transitionDuration = reduceMotion ? 0 : transitionDuration;
  import_react106.useEffect(() => {
    if (opened) {
      setShouldLockScroll(true);
      window.clearTimeout(timeout.current);
    } else if (_transitionDuration === 0) {
      setShouldLockScroll(false);
    } else {
      timeout.current = window.setTimeout(() => setShouldLockScroll(false), _transitionDuration);
    }
    return () => window.clearTimeout(timeout.current);
  }, [opened, _transitionDuration]);
  return shouldLockScroll;
}

// node_modules/@mantine/core/esm/components/ModalBase/use-modal.mjs
"use client";
function useModal({
  id,
  transitionProps,
  opened,
  trapFocus,
  closeOnEscape: closeOnEscape2,
  onClose,
  returnFocus
}) {
  const _id = useId(id);
  const [titleMounted, setTitleMounted] = import_react107.useState(false);
  const [bodyMounted, setBodyMounted] = import_react107.useState(false);
  const transitionDuration = typeof transitionProps?.duration === "number" ? transitionProps?.duration : 200;
  const shouldLockScroll = useLockScroll({ opened, transitionDuration });
  useWindowEvent("keydown", (event) => {
    if (event.key === "Escape" && closeOnEscape2 && !event.isComposing && opened) {
      const shouldTrigger = event.target?.getAttribute("data-mantine-stop-propagation") !== "true";
      shouldTrigger && onClose();
    }
  }, { capture: true });
  useFocusReturn({ opened, shouldReturnFocus: trapFocus && returnFocus });
  return {
    _id,
    titleMounted,
    bodyMounted,
    shouldLockScroll,
    setTitleMounted,
    setBodyMounted
  };
}

// node_modules/@mantine/core/esm/components/ModalBase/ModalBase.mjs
"use client";
var ModalBase = import_react108.forwardRef(({
  keepMounted,
  opened,
  onClose,
  id,
  transitionProps,
  onExitTransitionEnd,
  onEnterTransitionEnd,
  trapFocus,
  closeOnEscape: closeOnEscape2,
  returnFocus,
  closeOnClickOutside,
  withinPortal,
  portalProps,
  lockScroll,
  children,
  zIndex,
  shadow,
  padding,
  __vars,
  unstyled,
  removeScrollProps,
  ...others
}, ref) => {
  const { _id, titleMounted, bodyMounted, shouldLockScroll, setTitleMounted, setBodyMounted } = useModal({ id, transitionProps, opened, trapFocus, closeOnEscape: closeOnEscape2, onClose, returnFocus });
  const { key: removeScrollKey, ...otherRemoveScrollProps } = removeScrollProps || {};
  return /* @__PURE__ */ import_jsx_runtime73.jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ import_jsx_runtime73.jsx(ModalBaseProvider, {
    value: {
      opened,
      onClose,
      closeOnClickOutside,
      onExitTransitionEnd,
      onEnterTransitionEnd,
      transitionProps: { ...transitionProps, keepMounted },
      getTitleId: () => `${_id}-title`,
      getBodyId: () => `${_id}-body`,
      titleMounted,
      bodyMounted,
      setTitleMounted,
      setBodyMounted,
      trapFocus,
      closeOnEscape: closeOnEscape2,
      zIndex,
      unstyled
    },
    children: /* @__PURE__ */ import_jsx_runtime73.jsx(Combination_default, {
      enabled: shouldLockScroll && lockScroll,
      ...otherRemoveScrollProps,
      children: /* @__PURE__ */ import_jsx_runtime73.jsx(Box, {
        ref,
        ...others,
        __vars: {
          ...__vars,
          "--mb-z-index": (zIndex || getDefaultZIndex("modal")).toString(),
          "--mb-shadow": getShadow(shadow),
          "--mb-padding": getSpacing(padding)
        },
        children
      })
    }, removeScrollKey)
  }) });
});
ModalBase.displayName = "@mantine/core/ModalBase";

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseBody.mjs
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react110 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ModalBase/use-modal-body-id.mjs
var import_react109 = __toESM(require_react(), 1);
"use client";
function useModalBodyId() {
  const ctx = useModalBaseContext();
  import_react109.useEffect(() => {
    ctx.setBodyMounted(true);
    return () => ctx.setBodyMounted(false);
  }, []);
  return ctx.getBodyId();
}

// node_modules/@mantine/core/esm/components/ModalBase/ModalBase.module.css.mjs
"use client";
var classes11 = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" };

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseBody.mjs
"use client";
var ModalBaseBody = import_react110.forwardRef(({ className, ...others }, ref) => {
  const bodyId = useModalBodyId();
  const ctx = useModalBaseContext();
  return /* @__PURE__ */ import_jsx_runtime74.jsx(Box, {
    ref,
    ...others,
    id: bodyId,
    className: clsx_default({ [classes11.body]: !ctx.unstyled }, className)
  });
});
ModalBaseBody.displayName = "@mantine/core/ModalBaseBody";

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseCloseButton.mjs
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react111 = __toESM(require_react(), 1);
"use client";
var ModalBaseCloseButton = import_react111.forwardRef(({ className, onClick, ...others }, ref) => {
  const ctx = useModalBaseContext();
  return /* @__PURE__ */ import_jsx_runtime75.jsx(CloseButton, {
    ref,
    ...others,
    onClick: (event) => {
      ctx.onClose();
      onClick?.(event);
    },
    className: clsx_default({ [classes11.close]: !ctx.unstyled }, className),
    unstyled: ctx.unstyled
  });
});
ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton";

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseContent.mjs
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react112 = __toESM(require_react(), 1);
"use client";
var ModalBaseContent = import_react112.forwardRef(({ transitionProps, className, innerProps, onKeyDown, style: style2, ...others }, ref) => {
  const ctx = useModalBaseContext();
  return /* @__PURE__ */ import_jsx_runtime76.jsx(Transition, {
    mounted: ctx.opened,
    transition: "pop",
    ...ctx.transitionProps,
    onExited: () => {
      ctx.onExitTransitionEnd?.();
      ctx.transitionProps?.onExited?.();
    },
    onEntered: () => {
      ctx.onEnterTransitionEnd?.();
      ctx.transitionProps?.onEntered?.();
    },
    ...transitionProps,
    children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime76.jsx("div", {
      ...innerProps,
      className: clsx_default({ [classes11.inner]: !ctx.unstyled }, innerProps.className),
      children: /* @__PURE__ */ import_jsx_runtime76.jsx(FocusTrap, { active: ctx.opened && ctx.trapFocus, innerRef: ref, children: /* @__PURE__ */ import_jsx_runtime76.jsx(Paper, {
        ...others,
        component: "section",
        role: "dialog",
        tabIndex: -1,
        "aria-modal": true,
        "aria-describedby": ctx.bodyMounted ? ctx.getBodyId() : undefined,
        "aria-labelledby": ctx.titleMounted ? ctx.getTitleId() : undefined,
        style: [style2, transitionStyles],
        className: clsx_default({ [classes11.content]: !ctx.unstyled }, className),
        unstyled: ctx.unstyled,
        children: others.children
      }) })
    })
  });
});
ModalBaseContent.displayName = "@mantine/core/ModalBaseContent";

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseHeader.mjs
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
"use client";
var ModalBaseHeader = import_react113.forwardRef(({ className, ...others }, ref) => {
  const ctx = useModalBaseContext();
  return /* @__PURE__ */ import_jsx_runtime77.jsx(Box, {
    component: "header",
    ref,
    className: clsx_default({ [classes11.header]: !ctx.unstyled }, className),
    ...others
  });
});
ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader";

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseOverlay.mjs
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ModalBase/use-modal-transition.mjs
"use client";
var DEFAULT_TRANSITION = {
  duration: 200,
  timingFunction: "ease",
  transition: "fade"
};
function useModalTransition(transitionOverride) {
  const ctx = useModalBaseContext();
  return { ...DEFAULT_TRANSITION, ...ctx.transitionProps, ...transitionOverride };
}

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseOverlay.mjs
"use client";
var ModalBaseOverlay = import_react114.forwardRef(({ onClick, transitionProps, style: style2, visible: visible2, ...others }, ref) => {
  const ctx = useModalBaseContext();
  const transition = useModalTransition(transitionProps);
  return /* @__PURE__ */ import_jsx_runtime78.jsx(Transition, {
    mounted: visible2 !== undefined ? visible2 : ctx.opened,
    ...transition,
    transition: "fade",
    children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime78.jsx(Overlay, {
      ref,
      fixed: true,
      style: [style2, transitionStyles],
      zIndex: ctx.zIndex,
      unstyled: ctx.unstyled,
      onClick: (event) => {
        onClick?.(event);
        ctx.closeOnClickOutside && ctx.onClose();
      },
      ...others
    })
  });
});
ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay";

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseTitle.mjs
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/ModalBase/use-modal-title-id.mjs
var import_react115 = __toESM(require_react(), 1);
"use client";
function useModalTitle() {
  const ctx = useModalBaseContext();
  import_react115.useEffect(() => {
    ctx.setTitleMounted(true);
    return () => ctx.setTitleMounted(false);
  }, []);
  return ctx.getTitleId();
}

// node_modules/@mantine/core/esm/components/ModalBase/ModalBaseTitle.mjs
"use client";
var ModalBaseTitle = import_react116.forwardRef(({ className, ...others }, ref) => {
  const id = useModalTitle();
  const ctx = useModalBaseContext();
  return /* @__PURE__ */ import_jsx_runtime79.jsx(Box, {
    component: "h2",
    ref,
    className: clsx_default({ [classes11.title]: !ctx.unstyled }, className),
    ...others,
    id
  });
});
ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle";

// node_modules/@mantine/core/esm/components/ModalBase/NativeScrollArea.mjs
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
"use client";
function NativeScrollArea({ children }) {
  return /* @__PURE__ */ import_jsx_runtime80.jsx(import_jsx_runtime80.Fragment, { children });
}

// node_modules/@mantine/core/esm/components/Input/Input.mjs
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react125 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Input/Input.context.mjs
var import_react117 = __toESM(require_react(), 1);
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
"use client";
var [InputContext, useInputContext] = createOptionalContext({
  size: "sm"
});

// node_modules/@mantine/core/esm/components/Input/InputClearButton/InputClearButton.mjs
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);
"use client";
var defaultProps17 = {};
var InputClearButton = factory((_props, ref) => {
  const props = useProps("InputClearButton", defaultProps17, _props);
  const { size: size4, variant, vars, classNames, styles, ...others } = props;
  const ctx = useInputContext();
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return /* @__PURE__ */ import_jsx_runtime82.jsx(CloseButton, {
    variant: variant || "transparent",
    ref,
    size: size4 || ctx?.size || "sm",
    classNames: resolvedClassNames,
    styles: resolvedStyles,
    __staticSelector: "InputClearButton",
    ...others
  });
});
InputClearButton.displayName = "@mantine/core/InputClearButton";

// node_modules/@mantine/core/esm/components/Input/InputDescription/InputDescription.mjs
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Input/InputWrapper.context.mjs
var import_react119 = __toESM(require_react(), 1);
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
"use client";
var [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
  offsetBottom: false,
  offsetTop: false,
  describedBy: undefined,
  getStyles: null,
  inputId: undefined,
  labelId: undefined
});

// node_modules/@mantine/core/esm/components/Input/Input.module.css.mjs
"use client";
var classes12 = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };

// node_modules/@mantine/core/esm/components/Input/InputDescription/InputDescription.mjs
"use client";
var defaultProps18 = {};
var varsResolver11 = createVarsResolver((_2, { size: size4 }) => ({
  description: {
    "--input-description-size": size4 === undefined ? undefined : `calc(${getFontSize(size4)} - ${rem(2)})`
  }
}));
var InputDescription = factory((_props, ref) => {
  const props = useProps("InputDescription", defaultProps18, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size4,
    __staticSelector,
    __inheritStyles = true,
    variant,
    ...others
  } = useProps("InputDescription", defaultProps18, props);
  const ctx = useInputWrapperContext();
  const _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes12,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "description",
    vars,
    varsResolver: varsResolver11
  });
  const getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ import_jsx_runtime84.jsx(Box, {
    component: "p",
    ref,
    variant,
    size: size4,
    ...getStyles2("description", ctx?.getStyles ? { className, style: style2 } : undefined),
    ...others
  });
});
InputDescription.classes = classes12;
InputDescription.displayName = "@mantine/core/InputDescription";

// node_modules/@mantine/core/esm/components/Input/InputError/InputError.mjs
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react121 = __toESM(require_react(), 1);
"use client";
var defaultProps19 = {};
var varsResolver12 = createVarsResolver((_2, { size: size4 }) => ({
  error: {
    "--input-error-size": size4 === undefined ? undefined : `calc(${getFontSize(size4)} - ${rem(2)})`
  }
}));
var InputError = factory((_props, ref) => {
  const props = useProps("InputError", defaultProps19, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size4,
    __staticSelector,
    __inheritStyles = true,
    variant,
    ...others
  } = props;
  const _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes12,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "error",
    vars,
    varsResolver: varsResolver12
  });
  const ctx = useInputWrapperContext();
  const getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ import_jsx_runtime85.jsx(Box, {
    component: "p",
    ref,
    variant,
    size: size4,
    ...getStyles2("error", ctx?.getStyles ? { className, style: style2 } : undefined),
    ...others
  });
});
InputError.classes = classes12;
InputError.displayName = "@mantine/core/InputError";

// node_modules/@mantine/core/esm/components/Input/InputLabel/InputLabel.mjs
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);
"use client";
var defaultProps20 = {
  labelElement: "label"
};
var varsResolver13 = createVarsResolver((_2, { size: size4 }) => ({
  label: {
    "--input-label-size": getFontSize(size4),
    "--input-asterisk-color": undefined
  }
}));
var InputLabel = factory((_props, ref) => {
  const props = useProps("InputLabel", defaultProps20, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    labelElement,
    size: size4,
    required,
    htmlFor,
    onMouseDown,
    children,
    __staticSelector,
    variant,
    mod,
    ...others
  } = useProps("InputLabel", defaultProps20, props);
  const _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes12,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "label",
    vars,
    varsResolver: varsResolver13
  });
  const ctx = useInputWrapperContext();
  const getStyles2 = ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ import_jsx_runtime86.jsxs(Box, {
    ...getStyles2("label", ctx?.getStyles ? { className, style: style2 } : undefined),
    component: labelElement,
    variant,
    size: size4,
    ref,
    htmlFor: labelElement === "label" ? htmlFor : undefined,
    mod: [{ required }, mod],
    onMouseDown: (event) => {
      onMouseDown?.(event);
      if (!event.defaultPrevented && event.detail > 1) {
        event.preventDefault();
      }
    },
    ...others,
    children: [
      children,
      required && /* @__PURE__ */ import_jsx_runtime86.jsx("span", { ...getStyles2("required"), "aria-hidden": true, children: " *" })
    ]
  });
});
InputLabel.classes = classes12;
InputLabel.displayName = "@mantine/core/InputLabel";

// node_modules/@mantine/core/esm/components/Input/InputPlaceholder/InputPlaceholder.mjs
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react123 = __toESM(require_react(), 1);
"use client";
var defaultProps21 = {};
var InputPlaceholder = factory((_props, ref) => {
  const props = useProps("InputPlaceholder", defaultProps21, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    __staticSelector,
    variant,
    error,
    mod,
    ...others
  } = useProps("InputPlaceholder", defaultProps21, props);
  const getStyles2 = useStyles({
    name: ["InputPlaceholder", __staticSelector],
    props,
    classes: classes12,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ import_jsx_runtime87.jsx(Box, {
    ...getStyles2("placeholder"),
    mod: [{ error: !!error }, mod],
    component: "span",
    variant,
    ref,
    ...others
  });
});
InputPlaceholder.classes = classes12;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";

// node_modules/@mantine/core/esm/components/Input/InputWrapper/InputWrapper.mjs
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react124 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Input/InputWrapper/get-input-offsets/get-input-offsets.mjs
"use client";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
  const inputIndex = inputWrapperOrder.findIndex((part) => part === "input");
  const aboveInput = inputWrapperOrder.slice(0, inputIndex);
  const belowInput = inputWrapperOrder.slice(inputIndex + 1);
  const offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
  const offsetBottom = hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error");
  return { offsetBottom, offsetTop };
}

// node_modules/@mantine/core/esm/components/Input/InputWrapper/InputWrapper.mjs
"use client";
var defaultProps22 = {
  labelElement: "label",
  inputContainer: (children) => children,
  inputWrapperOrder: ["label", "description", "input", "error"]
};
var varsResolver14 = createVarsResolver((_2, { size: size4 }) => ({
  label: {
    "--input-label-size": getFontSize(size4),
    "--input-asterisk-color": undefined
  },
  error: {
    "--input-error-size": size4 === undefined ? undefined : `calc(${getFontSize(size4)} - ${rem(2)})`
  },
  description: {
    "--input-description-size": size4 === undefined ? undefined : `calc(${getFontSize(size4)} - ${rem(2)})`
  }
}));
var InputWrapper = factory((_props, ref) => {
  const props = useProps("InputWrapper", defaultProps22, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size4,
    variant,
    __staticSelector,
    inputContainer,
    inputWrapperOrder,
    label,
    error,
    description,
    labelProps,
    descriptionProps,
    errorProps,
    labelElement,
    children,
    withAsterisk,
    id,
    required,
    __stylesApiProps,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: ["InputWrapper", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes12,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver14
  });
  const sharedProps = {
    size: size4,
    variant,
    __staticSelector
  };
  const idBase = useId(id);
  const isRequired = typeof withAsterisk === "boolean" ? withAsterisk : required;
  const errorId = errorProps?.id || `${idBase}-error`;
  const descriptionId = descriptionProps?.id || `${idBase}-description`;
  const inputId = idBase;
  const hasError = !!error && typeof error !== "boolean";
  const hasDescription = !!description;
  const _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`;
  const describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : undefined;
  const labelId = labelProps?.id || `${idBase}-label`;
  const _label = label && /* @__PURE__ */ import_jsx_runtime88.jsx(InputLabel, {
    labelElement,
    id: labelId,
    htmlFor: inputId,
    required: isRequired,
    ...sharedProps,
    ...labelProps,
    children: label
  }, "label");
  const _description = hasDescription && /* @__PURE__ */ import_jsx_runtime88.jsx(InputDescription, {
    ...descriptionProps,
    ...sharedProps,
    size: descriptionProps?.size || sharedProps.size,
    id: descriptionProps?.id || descriptionId,
    children: description
  }, "description");
  const _input = /* @__PURE__ */ import_jsx_runtime88.jsx(import_react124.Fragment, { children: inputContainer(children) }, "input");
  const _error = hasError && /* @__PURE__ */ import_react124.createElement(InputError, {
    ...errorProps,
    ...sharedProps,
    size: errorProps?.size || sharedProps.size,
    key: "error",
    id: errorProps?.id || errorId
  }, error);
  const content = inputWrapperOrder.map((part) => {
    switch (part) {
      case "label":
        return _label;
      case "input":
        return _input;
      case "description":
        return _description;
      case "error":
        return _error;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ import_jsx_runtime88.jsx(InputWrapperProvider, {
    value: {
      getStyles: getStyles2,
      describedBy,
      inputId,
      labelId,
      ...getInputOffsets(inputWrapperOrder, { hasDescription, hasError })
    },
    children: /* @__PURE__ */ import_jsx_runtime88.jsx(Box, {
      ref,
      variant,
      size: size4,
      mod: [{ error: !!error }, mod],
      ...getStyles2("root"),
      ...others,
      children: content
    })
  });
});
InputWrapper.classes = classes12;
InputWrapper.displayName = "@mantine/core/InputWrapper";

// node_modules/@mantine/core/esm/components/Input/Input.mjs
"use client";
var defaultProps23 = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: true,
  withErrorStyles: true
};
var varsResolver15 = createVarsResolver((_2, props, ctx) => ({
  wrapper: {
    "--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : undefined,
    "--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : undefined,
    "--input-height": getSize(props.size, "input-height"),
    "--input-fz": getFontSize(props.size),
    "--input-radius": props.radius === undefined ? undefined : getRadius(props.radius),
    "--input-left-section-width": props.leftSectionWidth !== undefined ? rem(props.leftSectionWidth) : undefined,
    "--input-right-section-width": props.rightSectionWidth !== undefined ? rem(props.rightSectionWidth) : undefined,
    "--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : undefined,
    "--input-left-section-pointer-events": props.leftSectionPointerEvents,
    "--input-right-section-pointer-events": props.rightSectionPointerEvents
  }
}));
var Input = polymorphicFactory((_props, ref) => {
  const props = useProps("Input", defaultProps23, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    required,
    __staticSelector,
    __stylesApiProps,
    size: size4,
    wrapperProps,
    error,
    disabled,
    leftSection,
    leftSectionProps,
    leftSectionWidth,
    rightSection,
    rightSectionProps,
    rightSectionWidth,
    rightSectionPointerEvents,
    leftSectionPointerEvents,
    variant,
    vars,
    pointer,
    multiline,
    radius,
    id,
    withAria,
    withErrorStyles,
    mod,
    inputSize,
    __clearSection,
    __clearable,
    __defaultRightSection,
    ...others
  } = props;
  const { styleProps, rest } = extractStyleProps(others);
  const ctx = useInputWrapperContext();
  const stylesCtx = { offsetBottom: ctx?.offsetBottom, offsetTop: ctx?.offsetTop };
  const getStyles2 = useStyles({
    name: ["Input", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes12,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    stylesCtx,
    rootSelector: "wrapper",
    vars,
    varsResolver: varsResolver15
  });
  const ariaAttributes = withAria ? {
    required,
    disabled,
    "aria-invalid": !!error,
    "aria-describedby": ctx?.describedBy,
    id: ctx?.inputId || id
  } : {};
  const _rightSection = rightSection || __clearable && __clearSection || __defaultRightSection;
  return /* @__PURE__ */ import_jsx_runtime89.jsx(InputContext, { value: { size: size4 || "sm" }, children: /* @__PURE__ */ import_jsx_runtime89.jsxs(Box, {
    ...getStyles2("wrapper"),
    ...styleProps,
    ...wrapperProps,
    mod: [
      {
        error: !!error && withErrorStyles,
        pointer,
        disabled,
        multiline,
        "data-with-right-section": !!_rightSection,
        "data-with-left-section": !!leftSection
      },
      mod
    ],
    variant,
    size: size4,
    children: [
      leftSection && /* @__PURE__ */ import_jsx_runtime89.jsx("div", {
        ...leftSectionProps,
        "data-position": "left",
        ...getStyles2("section", {
          className: leftSectionProps?.className,
          style: leftSectionProps?.style
        }),
        children: leftSection
      }),
      /* @__PURE__ */ import_jsx_runtime89.jsx(Box, {
        component: "input",
        ...rest,
        ...ariaAttributes,
        ref,
        required,
        mod: { disabled, error: !!error && withErrorStyles },
        variant,
        __size: inputSize,
        ...getStyles2("input")
      }),
      _rightSection && /* @__PURE__ */ import_jsx_runtime89.jsx("div", {
        ...rightSectionProps,
        "data-position": "right",
        ...getStyles2("section", {
          className: rightSectionProps?.className,
          style: rightSectionProps?.style
        }),
        children: _rightSection
      })
    ]
  }) });
});
Input.classes = classes12;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.ClearButton = InputClearButton;
Input.displayName = "@mantine/core/Input";
// node_modules/@mantine/core/esm/components/Input/use-input-props.mjs
var import_react126 = __toESM(require_react(), 1);
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
"use client";
function useInputProps(component, defaultProps24, _props) {
  const props = useProps(component, defaultProps24, _props);
  const {
    label,
    description,
    error,
    required,
    classNames,
    styles,
    className,
    unstyled,
    __staticSelector,
    __stylesApiProps,
    errorProps,
    labelProps,
    descriptionProps,
    wrapperProps: _wrapperProps,
    id,
    size: size4,
    style: style2,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    vars,
    mod,
    ...others
  } = props;
  const { styleProps, rest } = extractStyleProps(others);
  const wrapperProps = {
    label,
    description,
    error,
    required,
    classNames,
    className,
    __staticSelector,
    __stylesApiProps: __stylesApiProps || props,
    errorProps,
    labelProps,
    descriptionProps,
    unstyled,
    styles,
    size: size4,
    style: style2,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    id,
    mod,
    ..._wrapperProps
  };
  return {
    ...rest,
    classNames,
    styles,
    unstyled,
    wrapperProps: { ...wrapperProps, ...styleProps },
    inputProps: {
      required,
      classNames,
      styles,
      unstyled,
      size: size4,
      __staticSelector,
      __stylesApiProps: __stylesApiProps || props,
      error,
      variant,
      id
    }
  };
}

// node_modules/@mantine/core/esm/components/InputBase/InputBase.mjs
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react127 = __toESM(require_react(), 1);
"use client";
var defaultProps24 = {
  __staticSelector: "InputBase",
  withAria: true
};
var InputBase = polymorphicFactory((props, ref) => {
  const { inputProps, wrapperProps, ...others } = useInputProps("InputBase", defaultProps24, props);
  return /* @__PURE__ */ import_jsx_runtime91.jsx(Input.Wrapper, { ...wrapperProps, children: /* @__PURE__ */ import_jsx_runtime91.jsx(Input, { ...inputProps, ...others, ref }) });
});
InputBase.classes = { ...Input.classes, ...Input.Wrapper.classes };
InputBase.displayName = "@mantine/core/InputBase";

// node_modules/@mantine/core/esm/components/Alert/Alert.mjs
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react128 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Alert/Alert.module.css.mjs
"use client";
var classes13 = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };

// node_modules/@mantine/core/esm/components/Alert/Alert.mjs
"use client";
var defaultProps25 = {};
var varsResolver16 = createVarsResolver((theme, { radius, color, variant, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--alert-radius": radius === undefined ? undefined : getRadius(radius),
      "--alert-bg": color || variant ? colors.background : undefined,
      "--alert-color": colors.color,
      "--alert-bd": color || variant ? colors.border : undefined
    }
  };
});
var Alert = factory((_props, ref) => {
  const props = useProps("Alert", defaultProps25, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color,
    title,
    children,
    id,
    icon,
    withCloseButton,
    onClose,
    closeButtonLabel,
    variant,
    autoContrast,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Alert",
    classes: classes13,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver16
  });
  const rootId = useId(id);
  const titleId = title && `${rootId}-title` || undefined;
  const bodyId = `${rootId}-body`;
  return /* @__PURE__ */ import_jsx_runtime92.jsx(Box, {
    id: rootId,
    ...getStyles2("root", { variant }),
    variant,
    ref,
    ...others,
    role: "alert",
    "aria-describedby": bodyId,
    "aria-labelledby": titleId,
    children: /* @__PURE__ */ import_jsx_runtime92.jsxs("div", { ...getStyles2("wrapper"), children: [
      icon && /* @__PURE__ */ import_jsx_runtime92.jsx("div", { ...getStyles2("icon"), children: icon }),
      /* @__PURE__ */ import_jsx_runtime92.jsxs("div", { ...getStyles2("body"), children: [
        title && /* @__PURE__ */ import_jsx_runtime92.jsx("div", { ...getStyles2("title"), "data-with-close-button": withCloseButton || undefined, children: /* @__PURE__ */ import_jsx_runtime92.jsx("span", { id: titleId, ...getStyles2("label"), children: title }) }),
        children && /* @__PURE__ */ import_jsx_runtime92.jsx("div", { id: bodyId, ...getStyles2("message"), "data-variant": variant, children })
      ] }),
      withCloseButton && /* @__PURE__ */ import_jsx_runtime92.jsx(CloseButton, {
        ...getStyles2("closeButton"),
        onClick: onClose,
        variant: "transparent",
        size: 16,
        iconSize: 16,
        "aria-label": closeButtonLabel,
        unstyled
      })
    ] })
  });
});
Alert.classes = classes13;
Alert.displayName = "@mantine/core/Alert";
// node_modules/@mantine/core/esm/components/Anchor/Anchor.mjs
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Text/Text.mjs
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react129 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Text/Text.module.css.mjs
"use client";
var classes14 = { root: "m_b6d8b162" };

// node_modules/@mantine/core/esm/components/Text/Text.mjs
"use client";
function getTextTruncate(truncate) {
  if (truncate === "start") {
    return "start";
  }
  if (truncate === "end" || truncate) {
    return "end";
  }
  return;
}
var defaultProps26 = {
  inherit: false
};
var varsResolver17 = createVarsResolver((theme, { variant, lineClamp, gradient, size: size4, color }) => ({
  root: {
    "--text-fz": getFontSize(size4),
    "--text-lh": getLineHeight(size4),
    "--text-gradient": variant === "gradient" ? getGradient(gradient, theme) : undefined,
    "--text-line-clamp": typeof lineClamp === "number" ? lineClamp.toString() : undefined,
    "--text-color": color ? getThemeColor(color, theme) : undefined
  }
}));
var Text = polymorphicFactory((_props, ref) => {
  const props = useProps("Text", defaultProps26, _props);
  const {
    lineClamp,
    truncate,
    inline: inline4,
    inherit,
    gradient,
    span,
    __staticSelector,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    variant,
    mod,
    size: size4,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: ["Text", __staticSelector],
    props,
    classes: classes14,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver17
  });
  return /* @__PURE__ */ import_jsx_runtime93.jsx(Box, {
    ...getStyles2("root", { focusable: true }),
    ref,
    component: span ? "span" : "p",
    variant,
    mod: [
      {
        "data-truncate": getTextTruncate(truncate),
        "data-line-clamp": typeof lineClamp === "number",
        "data-inline": inline4,
        "data-inherit": inherit
      },
      mod
    ],
    size: size4,
    ...others
  });
});
Text.classes = classes14;
Text.displayName = "@mantine/core/Text";

// node_modules/@mantine/core/esm/components/Anchor/Anchor.module.css.mjs
"use client";
var classes15 = { root: "m_849cf0da" };

// node_modules/@mantine/core/esm/components/Anchor/Anchor.mjs
"use client";
var defaultProps27 = {
  underline: "hover"
};
var Anchor = polymorphicFactory((props, ref) => {
  const { underline, className, unstyled, mod, ...others } = useProps("Anchor", defaultProps27, props);
  return /* @__PURE__ */ import_jsx_runtime94.jsx(Text, {
    component: "a",
    ref,
    className: clsx_default({ [classes15.root]: !unstyled }, className),
    ...others,
    mod: [{ underline }, mod],
    __staticSelector: "Anchor",
    unstyled
  });
});
Anchor.classes = classes15;
Anchor.displayName = "@mantine/core/Anchor";
// node_modules/@mantine/core/esm/components/Combobox/get-parsed-combobox-data/get-parsed-combobox-data.mjs
"use client";
function parseItem(item) {
  if (typeof item === "string") {
    return { value: item, label: item };
  }
  if ("value" in item && !("label" in item)) {
    return { value: item.value, label: item.value, disabled: item.disabled };
  }
  if (typeof item === "number") {
    return { value: item.toString(), label: item.toString() };
  }
  if ("group" in item) {
    return {
      group: item.group,
      items: item.items.map((i2) => parseItem(i2))
    };
  }
  return item;
}
function getParsedComboboxData(data) {
  if (!data) {
    return [];
  }
  return data.map((item) => parseItem(item));
}

// node_modules/@mantine/core/esm/components/Combobox/get-options-lockup/get-options-lockup.mjs
"use client";
function getOptionsLockup(options) {
  return options.reduce((acc, item) => {
    if ("group" in item) {
      return { ...acc, ...getOptionsLockup(item.items) };
    }
    acc[item.value] = item;
    return acc;
  }, {});
}

// node_modules/@mantine/core/esm/components/Combobox/ComboboxChevron/ComboboxChevron.mjs
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react131 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Combobox/Combobox.module.css.mjs
"use client";
var classes16 = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2" };

// node_modules/@mantine/core/esm/components/Combobox/ComboboxChevron/ComboboxChevron.mjs
"use client";
var defaultProps28 = {
  error: null
};
var varsResolver18 = createVarsResolver((theme, { size: size4, color }) => ({
  chevron: {
    "--combobox-chevron-size": getSize(size4, "combobox-chevron-size"),
    "--combobox-chevron-color": color ? getThemeColor(color, theme) : undefined
  }
}));
var ComboboxChevron = factory((_props, ref) => {
  const props = useProps("ComboboxChevron", defaultProps28, _props);
  const { size: size4, error, style: style2, className, classNames, styles, unstyled, vars, mod, ...others } = props;
  const getStyles2 = useStyles({
    name: "ComboboxChevron",
    classes: classes16,
    props,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver18,
    rootSelector: "chevron"
  });
  return /* @__PURE__ */ import_jsx_runtime95.jsx(Box, {
    component: "svg",
    ...others,
    ...getStyles2("chevron"),
    size: size4,
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    mod: ["combobox-chevron", { error }, mod],
    ref,
    children: /* @__PURE__ */ import_jsx_runtime95.jsx("path", {
      d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
      fill: "currentColor",
      fillRule: "evenodd",
      clipRule: "evenodd"
    })
  });
});
ComboboxChevron.classes = classes16;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";

// node_modules/@mantine/core/esm/components/Combobox/Combobox.mjs
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react147 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Combobox/Combobox.context.mjs
var import_react132 = __toESM(require_react(), 1);
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ComboboxProvider, useComboboxContext] = createSafeContext("Combobox component was not found in tree");

// node_modules/@mantine/core/esm/components/Combobox/ComboboxClearButton/ComboboxClearButton.mjs
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react133 = __toESM(require_react(), 1);
"use client";
var ComboboxClearButton = import_react133.forwardRef(({ size: size4, onMouseDown, onClick, onClear, ...others }, ref) => /* @__PURE__ */ import_jsx_runtime97.jsx(Input.ClearButton, {
  ref,
  tabIndex: -1,
  "aria-hidden": true,
  ...others,
  onMouseDown: (event) => {
    event.preventDefault();
    onMouseDown?.(event);
  },
  onClick: (event) => {
    onClear();
    onClick?.(event);
  }
}));
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxDropdown/ComboboxDropdown.mjs
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react134 = __toESM(require_react(), 1);
"use client";
var defaultProps29 = {};
var ComboboxDropdown = factory((props, ref) => {
  const { classNames, styles, className, style: style2, hidden: hidden2, ...others } = useProps("ComboboxDropdown", defaultProps29, props);
  const ctx = useComboboxContext();
  return /* @__PURE__ */ import_jsx_runtime98.jsx(Popover.Dropdown, {
    ...others,
    ref,
    role: "presentation",
    "data-hidden": hidden2 || undefined,
    ...ctx.getStyles("dropdown", { className, style: style2, classNames, styles })
  });
});
ComboboxDropdown.classes = classes16;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxDropdownTarget/ComboboxDropdownTarget.mjs
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react135 = __toESM(require_react(), 1);
"use client";
var defaultProps30 = {
  refProp: "ref"
};
var ComboboxDropdownTarget = factory((props, ref) => {
  const { children, refProp } = useProps("ComboboxDropdownTarget", defaultProps30, props);
  useComboboxContext();
  if (!isElement(children)) {
    throw new Error("Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
  }
  return /* @__PURE__ */ import_jsx_runtime99.jsx(Popover.Target, { ref, refProp, children });
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxEmpty/ComboboxEmpty.mjs
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react136 = __toESM(require_react(), 1);
"use client";
var defaultProps31 = {};
var ComboboxEmpty = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps("ComboboxEmpty", defaultProps31, props);
  const ctx = useComboboxContext();
  return /* @__PURE__ */ import_jsx_runtime100.jsx(Box, {
    ref,
    ...ctx.getStyles("empty", { className, classNames, styles, style: style2 }),
    ...others
  });
});
ComboboxEmpty.classes = classes16;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxEventsTarget/ComboboxEventsTarget.mjs
var import_react138 = __toESM(require_react(), 1);
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/components/Combobox/use-combobox-target-props/use-combobox-target-props.mjs
var import_react137 = __toESM(require_react(), 1);
"use client";
function useComboboxTargetProps({
  onKeyDown,
  withKeyboardNavigation,
  withAriaAttributes,
  withExpandedAttribute,
  targetType,
  autoComplete
}) {
  const ctx = useComboboxContext();
  const [selectedOptionId, setSelectedOptionId] = import_react137.useState(null);
  const handleKeyDown = (event) => {
    onKeyDown?.(event);
    if (ctx.readOnly) {
      return;
    }
    if (withKeyboardNavigation) {
      if (event.nativeEvent.isComposing) {
        return;
      }
      if (event.nativeEvent.code === "ArrowDown") {
        event.preventDefault();
        if (!ctx.store.dropdownOpened) {
          ctx.store.openDropdown("keyboard");
          setSelectedOptionId(ctx.store.selectActiveOption());
          ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: true });
        } else {
          setSelectedOptionId(ctx.store.selectNextOption());
        }
      }
      if (event.nativeEvent.code === "ArrowUp") {
        event.preventDefault();
        if (!ctx.store.dropdownOpened) {
          ctx.store.openDropdown("keyboard");
          setSelectedOptionId(ctx.store.selectActiveOption());
          ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: true });
        } else {
          setSelectedOptionId(ctx.store.selectPreviousOption());
        }
      }
      if (event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
        if (event.nativeEvent.keyCode === 229) {
          return;
        }
        const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
        if (ctx.store.dropdownOpened && selectedOptionIndex !== -1) {
          event.preventDefault();
          ctx.store.clickSelectedOption();
        } else if (targetType === "button") {
          event.preventDefault();
          ctx.store.openDropdown("keyboard");
        }
      }
      if (event.key === "Escape") {
        ctx.store.closeDropdown("keyboard");
      }
      if (event.nativeEvent.code === "Space") {
        if (targetType === "button") {
          event.preventDefault();
          ctx.store.toggleDropdown("keyboard");
        }
      }
    }
  };
  const ariaAttributes = withAriaAttributes ? {
    "aria-haspopup": "listbox",
    "aria-expanded": withExpandedAttribute && !!(ctx.store.listId && ctx.store.dropdownOpened) || undefined,
    "aria-controls": ctx.store.dropdownOpened ? ctx.store.listId : undefined,
    "aria-activedescendant": ctx.store.dropdownOpened ? selectedOptionId || undefined : undefined,
    autoComplete,
    "data-expanded": ctx.store.dropdownOpened || undefined,
    "data-mantine-stop-propagation": ctx.store.dropdownOpened || undefined
  } : {};
  return {
    ...ariaAttributes,
    onKeyDown: handleKeyDown
  };
}

// node_modules/@mantine/core/esm/components/Combobox/ComboboxEventsTarget/ComboboxEventsTarget.mjs
"use client";
var defaultProps32 = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: true,
  withAriaAttributes: true,
  withExpandedAttribute: false,
  autoComplete: "off"
};
var ComboboxEventsTarget = factory((props, ref) => {
  const {
    children,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxEventsTarget", defaultProps32, props);
  if (!isElement(children)) {
    throw new Error("Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
  }
  const ctx = useComboboxContext();
  const targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: children.props.onKeyDown,
    autoComplete
  });
  return import_react138.cloneElement(children, {
    ...targetProps,
    ...others,
    [refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(children))
  });
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxFooter/ComboboxFooter.mjs
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react139 = __toESM(require_react(), 1);
"use client";
var defaultProps33 = {};
var ComboboxFooter = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps("ComboboxFooter", defaultProps33, props);
  const ctx = useComboboxContext();
  return /* @__PURE__ */ import_jsx_runtime102.jsx(Box, {
    ref,
    ...ctx.getStyles("footer", { className, classNames, style: style2, styles }),
    ...others,
    onMouseDown: (event) => {
      event.preventDefault();
    }
  });
});
ComboboxFooter.classes = classes16;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxGroup/ComboboxGroup.mjs
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react140 = __toESM(require_react(), 1);
"use client";
var defaultProps34 = {};
var ComboboxGroup = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, children, label, ...others } = useProps("ComboboxGroup", defaultProps34, props);
  const ctx = useComboboxContext();
  return /* @__PURE__ */ import_jsx_runtime103.jsxs(Box, {
    ref,
    ...ctx.getStyles("group", { className, classNames, style: style2, styles }),
    ...others,
    children: [
      label && /* @__PURE__ */ import_jsx_runtime103.jsx("div", { ...ctx.getStyles("groupLabel", { classNames, styles }), children: label }),
      children
    ]
  });
});
ComboboxGroup.classes = classes16;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxHeader/ComboboxHeader.mjs
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);
"use client";
var defaultProps35 = {};
var ComboboxHeader = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps("ComboboxHeader", defaultProps35, props);
  const ctx = useComboboxContext();
  return /* @__PURE__ */ import_jsx_runtime104.jsx(Box, {
    ref,
    ...ctx.getStyles("header", { className, classNames, style: style2, styles }),
    ...others,
    onMouseDown: (event) => {
      event.preventDefault();
    }
  });
});
ComboboxHeader.classes = classes16;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxHiddenInput/ComboboxHiddenInput.mjs
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
"use client";
function ComboboxHiddenInput({
  value,
  valuesDivider = ",",
  ...others
}) {
  return /* @__PURE__ */ import_jsx_runtime105.jsx("input", {
    type: "hidden",
    value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
    ...others
  });
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxOption/ComboboxOption.mjs
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react142 = __toESM(require_react(), 1);
"use client";
var defaultProps36 = {};
var ComboboxOption = factory((_props, ref) => {
  const props = useProps("ComboboxOption", defaultProps36, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onClick,
    id,
    active,
    onMouseDown,
    onMouseOver,
    disabled,
    selected,
    mod,
    ...others
  } = props;
  const ctx = useComboboxContext();
  const uuid = import_react142.useId();
  const _id = id || uuid;
  return /* @__PURE__ */ import_jsx_runtime106.jsx(Box, {
    ...ctx.getStyles("option", { className, classNames, styles, style: style2 }),
    ...others,
    ref,
    id: _id,
    mod: [
      "combobox-option",
      { "combobox-active": active, "combobox-disabled": disabled, "combobox-selected": selected },
      mod
    ],
    role: "option",
    onClick: (event) => {
      if (!disabled) {
        ctx.onOptionSubmit?.(props.value, props);
        onClick?.(event);
      } else {
        event.preventDefault();
      }
    },
    onMouseDown: (event) => {
      event.preventDefault();
      onMouseDown?.(event);
    },
    onMouseOver: (event) => {
      if (ctx.resetSelectionOnOptionHover) {
        ctx.store.resetSelectedOption();
      }
      onMouseOver?.(event);
    }
  });
});
ComboboxOption.classes = classes16;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxOptions/ComboboxOptions.mjs
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react143 = __toESM(require_react(), 1);
"use client";
var defaultProps37 = {};
var ComboboxOptions = factory((_props, ref) => {
  const props = useProps("ComboboxOptions", defaultProps37, _props);
  const { classNames, className, style: style2, styles, id, onMouseDown, labelledBy, ...others } = props;
  const ctx = useComboboxContext();
  const _id = useId(id);
  import_react143.useEffect(() => {
    ctx.store.setListId(_id);
  }, [_id]);
  return /* @__PURE__ */ import_jsx_runtime107.jsx(Box, {
    ref,
    ...ctx.getStyles("options", { className, style: style2, classNames, styles }),
    ...others,
    id: _id,
    role: "listbox",
    "aria-labelledby": labelledBy,
    onMouseDown: (event) => {
      event.preventDefault();
      onMouseDown?.(event);
    }
  });
});
ComboboxOptions.classes = classes16;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxSearch/ComboboxSearch.mjs
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react144 = __toESM(require_react(), 1);
"use client";
var defaultProps38 = {
  withAriaAttributes: true,
  withKeyboardNavigation: true
};
var ComboboxSearch = factory((_props, ref) => {
  const props = useProps("ComboboxSearch", defaultProps38, _props);
  const {
    classNames,
    styles,
    unstyled,
    vars,
    withAriaAttributes,
    onKeyDown,
    withKeyboardNavigation,
    size: size4,
    ...others
  } = props;
  const ctx = useComboboxContext();
  const _styles = ctx.getStyles("search");
  const targetProps = useComboboxTargetProps({
    targetType: "input",
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute: false,
    onKeyDown,
    autoComplete: "off"
  });
  return /* @__PURE__ */ import_jsx_runtime108.jsx(Input, {
    ref: useMergedRef(ref, ctx.store.searchRef),
    classNames: [{ input: _styles.className }, classNames],
    styles: [{ input: _styles.style }, styles],
    size: size4 || ctx.size,
    ...targetProps,
    ...others,
    __staticSelector: "Combobox"
  });
});
ComboboxSearch.classes = classes16;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";

// node_modules/@mantine/core/esm/components/Combobox/ComboboxTarget/ComboboxTarget.mjs
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react145 = __toESM(require_react(), 1);
"use client";
var defaultProps39 = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: true,
  withAriaAttributes: true,
  withExpandedAttribute: false,
  autoComplete: "off"
};
var ComboboxTarget = factory((props, ref) => {
  const {
    children,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxTarget", defaultProps39, props);
  if (!isElement(children)) {
    throw new Error("Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
  }
  const ctx = useComboboxContext();
  const targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: children.props.onKeyDown,
    autoComplete
  });
  const clonedElement = import_react145.cloneElement(children, {
    ...targetProps,
    ...others
  });
  return /* @__PURE__ */ import_jsx_runtime109.jsx(Popover.Target, { ref: useMergedRef(ref, ctx.store.targetRef), children: clonedElement });
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";

// node_modules/@mantine/core/esm/components/Combobox/use-combobox/use-combobox.mjs
var import_react146 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Combobox/use-combobox/get-index/get-index.mjs
"use client";
function getPreviousIndex2(currentIndex, elements, loop) {
  for (let i2 = currentIndex - 1;i2 >= 0; i2 -= 1) {
    if (!elements[i2].hasAttribute("data-combobox-disabled")) {
      return i2;
    }
  }
  if (loop) {
    for (let i2 = elements.length - 1;i2 > -1; i2 -= 1) {
      if (!elements[i2].hasAttribute("data-combobox-disabled")) {
        return i2;
      }
    }
  }
  return currentIndex;
}
function getNextIndex2(currentIndex, elements, loop) {
  for (let i2 = currentIndex + 1;i2 < elements.length; i2 += 1) {
    if (!elements[i2].hasAttribute("data-combobox-disabled")) {
      return i2;
    }
  }
  if (loop) {
    for (let i2 = 0;i2 < elements.length; i2 += 1) {
      if (!elements[i2].hasAttribute("data-combobox-disabled")) {
        return i2;
      }
    }
  }
  return currentIndex;
}
function getFirstIndex(elements) {
  for (let i2 = 0;i2 < elements.length; i2 += 1) {
    if (!elements[i2].hasAttribute("data-combobox-disabled")) {
      return i2;
    }
  }
  return -1;
}

// node_modules/@mantine/core/esm/components/Combobox/use-combobox/use-combobox.mjs
"use client";
function useCombobox({
  defaultOpened,
  opened,
  onOpenedChange,
  onDropdownClose,
  onDropdownOpen,
  loop = true,
  scrollBehavior = "instant"
} = {}) {
  const [dropdownOpened, setDropdownOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: false,
    onChange: onOpenedChange
  });
  const listId = import_react146.useRef(null);
  const selectedOptionIndex = import_react146.useRef(-1);
  const searchRef = import_react146.useRef(null);
  const targetRef = import_react146.useRef(null);
  const focusSearchTimeout = import_react146.useRef(-1);
  const focusTargetTimeout = import_react146.useRef(-1);
  const selectedIndexUpdateTimeout = import_react146.useRef(-1);
  const openDropdown = import_react146.useCallback((eventSource = "unknown") => {
    if (!dropdownOpened) {
      setDropdownOpened(true);
      onDropdownOpen?.(eventSource);
    }
  }, [setDropdownOpened, onDropdownOpen, dropdownOpened]);
  const closeDropdown = import_react146.useCallback((eventSource = "unknown") => {
    if (dropdownOpened) {
      setDropdownOpened(false);
      onDropdownClose?.(eventSource);
    }
  }, [setDropdownOpened, onDropdownClose, dropdownOpened]);
  const toggleDropdown = import_react146.useCallback((eventSource = "unknown") => {
    if (dropdownOpened) {
      closeDropdown(eventSource);
    } else {
      openDropdown(eventSource);
    }
  }, [closeDropdown, openDropdown, dropdownOpened]);
  const clearSelectedItem = import_react146.useCallback(() => {
    const selected = document.querySelector(`#${listId.current} [data-combobox-selected]`);
    selected?.removeAttribute("data-combobox-selected");
    selected?.removeAttribute("aria-selected");
  }, []);
  const selectOption = import_react146.useCallback((index4) => {
    const list = document.getElementById(listId.current);
    const items = list?.querySelectorAll("[data-combobox-option]");
    if (!items) {
      return null;
    }
    const nextIndex = index4 >= items.length ? 0 : index4 < 0 ? items.length - 1 : index4;
    selectedOptionIndex.current = nextIndex;
    if (items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled")) {
      clearSelectedItem();
      items[nextIndex].setAttribute("data-combobox-selected", "true");
      items[nextIndex].setAttribute("aria-selected", "true");
      items[nextIndex].scrollIntoView({ block: "nearest", behavior: scrollBehavior });
      return items[nextIndex].id;
    }
    return null;
  }, [scrollBehavior, clearSelectedItem]);
  const selectActiveOption = import_react146.useCallback(() => {
    const activeOption = document.querySelector(`#${listId.current} [data-combobox-active]`);
    if (activeOption) {
      const items = document.querySelectorAll(`#${listId.current} [data-combobox-option]`);
      const index4 = Array.from(items).findIndex((option) => option === activeOption);
      return selectOption(index4);
    }
    return selectOption(0);
  }, [selectOption]);
  const selectNextOption = import_react146.useCallback(() => selectOption(getNextIndex2(selectedOptionIndex.current, document.querySelectorAll(`#${listId.current} [data-combobox-option]`), loop)), [selectOption, loop]);
  const selectPreviousOption = import_react146.useCallback(() => selectOption(getPreviousIndex2(selectedOptionIndex.current, document.querySelectorAll(`#${listId.current} [data-combobox-option]`), loop)), [selectOption, loop]);
  const selectFirstOption = import_react146.useCallback(() => selectOption(getFirstIndex(document.querySelectorAll(`#${listId.current} [data-combobox-option]`))), [selectOption]);
  const updateSelectedOptionIndex = import_react146.useCallback((target = "selected", options) => {
    selectedIndexUpdateTimeout.current = window.setTimeout(() => {
      const items = document.querySelectorAll(`#${listId.current} [data-combobox-option]`);
      const index4 = Array.from(items).findIndex((option) => option.hasAttribute(`data-combobox-${target}`));
      selectedOptionIndex.current = index4;
      if (options?.scrollIntoView) {
        items[index4]?.scrollIntoView({ block: "nearest", behavior: scrollBehavior });
      }
    }, 0);
  }, []);
  const resetSelectedOption = import_react146.useCallback(() => {
    selectedOptionIndex.current = -1;
    clearSelectedItem();
  }, [clearSelectedItem]);
  const clickSelectedOption = import_react146.useCallback(() => {
    const items = document.querySelectorAll(`#${listId.current} [data-combobox-option]`);
    const item = items?.[selectedOptionIndex.current];
    item?.click();
  }, []);
  const setListId = import_react146.useCallback((id) => {
    listId.current = id;
  }, []);
  const focusSearchInput = import_react146.useCallback(() => {
    focusSearchTimeout.current = window.setTimeout(() => searchRef.current.focus(), 0);
  }, []);
  const focusTarget = import_react146.useCallback(() => {
    focusTargetTimeout.current = window.setTimeout(() => targetRef.current.focus(), 0);
  }, []);
  const getSelectedOptionIndex = import_react146.useCallback(() => selectedOptionIndex.current, []);
  import_react146.useEffect(() => () => {
    window.clearTimeout(focusSearchTimeout.current);
    window.clearTimeout(focusTargetTimeout.current);
    window.clearTimeout(selectedIndexUpdateTimeout.current);
  }, []);
  return {
    dropdownOpened,
    openDropdown,
    closeDropdown,
    toggleDropdown,
    selectedOptionIndex: selectedOptionIndex.current,
    getSelectedOptionIndex,
    selectOption,
    selectFirstOption,
    selectActiveOption,
    selectNextOption,
    selectPreviousOption,
    resetSelectedOption,
    updateSelectedOptionIndex,
    listId: listId.current,
    setListId,
    clickSelectedOption,
    searchRef,
    focusSearchInput,
    targetRef,
    focusTarget
  };
}

// node_modules/@mantine/core/esm/components/Combobox/Combobox.mjs
"use client";
var defaultProps40 = {
  keepMounted: true,
  withinPortal: true,
  resetSelectionOnOptionHover: false,
  width: "target",
  transitionProps: { transition: "fade", duration: 0 }
};
var varsResolver19 = createVarsResolver((_2, { size: size4, dropdownPadding }) => ({
  options: {
    "--combobox-option-fz": getFontSize(size4),
    "--combobox-option-padding": getSize(size4, "combobox-option-padding")
  },
  dropdown: {
    "--combobox-padding": dropdownPadding === undefined ? undefined : rem(dropdownPadding),
    "--combobox-option-fz": getFontSize(size4),
    "--combobox-option-padding": getSize(size4, "combobox-option-padding")
  }
}));
function Combobox(_props) {
  const props = useProps("Combobox", defaultProps40, _props);
  const {
    classNames,
    styles,
    unstyled,
    children,
    store: controlledStore,
    vars,
    onOptionSubmit,
    onClose,
    size: size4,
    dropdownPadding,
    resetSelectionOnOptionHover,
    __staticSelector,
    readOnly,
    ...others
  } = props;
  const uncontrolledStore = useCombobox();
  const store = controlledStore || uncontrolledStore;
  const getStyles2 = useStyles({
    name: __staticSelector || "Combobox",
    classes: classes16,
    props,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver19
  });
  const onDropdownClose = () => {
    onClose?.();
    store.closeDropdown();
  };
  return /* @__PURE__ */ import_jsx_runtime110.jsx(ComboboxProvider, {
    value: {
      getStyles: getStyles2,
      store,
      onOptionSubmit,
      size: size4,
      resetSelectionOnOptionHover,
      readOnly
    },
    children: /* @__PURE__ */ import_jsx_runtime110.jsx(Popover, {
      opened: store.dropdownOpened,
      ...others,
      onChange: (_opened) => !_opened && onDropdownClose(),
      withRoles: false,
      unstyled,
      children
    })
  });
}
var extendCombobox = (c2) => c2;
Combobox.extend = extendCombobox;
Combobox.classes = classes16;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;

// node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/OptionsDropdown.mjs
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/components/Checkbox/Checkbox.mjs
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react156 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/InlineInput/InlineInput.mjs
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react148 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/InlineInput/InlineInput.module.css.mjs
"use client";
var classes17 = { root: "m_5f75b09e", body: "m_5f6e695e", labelWrapper: "m_d3ea56bb", label: "m_8ee546b8", description: "m_328f68c0", error: "m_8e8a99cc" };

// node_modules/@mantine/core/esm/components/InlineInput/InlineInput.mjs
"use client";
var InlineInputClasses = classes17;
var InlineInput = import_react148.forwardRef(({
  __staticSelector,
  __stylesApiProps,
  className,
  classNames,
  styles,
  unstyled,
  children,
  label,
  description,
  id,
  disabled,
  error,
  size: size4,
  labelPosition = "left",
  bodyElement = "div",
  labelElement = "label",
  variant,
  style: style2,
  vars,
  mod,
  ...others
}, ref) => {
  const getStyles2 = useStyles({
    name: __staticSelector,
    props: __stylesApiProps,
    className,
    style: style2,
    classes: classes17,
    classNames,
    styles,
    unstyled
  });
  return /* @__PURE__ */ import_jsx_runtime111.jsx(Box, {
    ...getStyles2("root"),
    ref,
    __vars: {
      "--label-fz": getFontSize(size4),
      "--label-lh": getSize(size4, "label-lh")
    },
    mod: [{ "label-position": labelPosition }, mod],
    variant,
    size: size4,
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime111.jsxs(Box, {
      component: bodyElement,
      htmlFor: bodyElement === "label" ? id : undefined,
      ...getStyles2("body"),
      children: [
        children,
        /* @__PURE__ */ import_jsx_runtime111.jsxs("div", { ...getStyles2("labelWrapper"), "data-disabled": disabled || undefined, children: [
          label && /* @__PURE__ */ import_jsx_runtime111.jsx(Box, {
            component: labelElement,
            htmlFor: labelElement === "label" ? id : undefined,
            ...getStyles2("label"),
            "data-disabled": disabled || undefined,
            children: label
          }),
          description && /* @__PURE__ */ import_jsx_runtime111.jsx(Input.Description, { size: size4, __inheritStyles: false, ...getStyles2("description"), children: description }),
          error && typeof error !== "boolean" && /* @__PURE__ */ import_jsx_runtime111.jsx(Input.Error, { size: size4, __inheritStyles: false, ...getStyles2("error"), children: error })
        ] })
      ]
    })
  });
});
InlineInput.displayName = "@mantine/core/InlineInput";

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.mjs
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react151 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxGroup.context.mjs
var import_react149 = __toESM(require_react(), 1);
"use client";
var CheckboxGroupContext = import_react149.createContext(null);
var CheckboxGroupProvider = CheckboxGroupContext.Provider;
var useCheckboxGroupContext = () => import_react149.useContext(CheckboxGroupContext);

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.context.mjs
var import_react150 = __toESM(require_react(), 1);
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
"use client";
var [CheckboxCardProvider, useCheckboxCardContext] = createOptionalContext();

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.module.css.mjs
"use client";
var classes18 = { card: "m_26775b0a" };

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.mjs
"use client";
var defaultProps41 = {
  withBorder: true
};
var varsResolver20 = createVarsResolver((_2, { radius }) => ({
  card: {
    "--card-radius": getRadius(radius)
  }
}));
var CheckboxCard = factory((_props, ref) => {
  const props = useProps("CheckboxCard", defaultProps41, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    checked,
    mod,
    withBorder,
    value,
    onClick,
    defaultChecked,
    onChange,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "CheckboxCard",
    classes: classes18,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver20,
    rootSelector: "card"
  });
  const ctx = useCheckboxGroupContext();
  const _checked = typeof checked === "boolean" ? checked : ctx ? ctx.value.includes(value || "") : undefined;
  const [_value, setValue] = useUncontrolled({
    value: _checked,
    defaultValue: defaultChecked,
    finalValue: false,
    onChange
  });
  return /* @__PURE__ */ import_jsx_runtime113.jsx(CheckboxCardProvider, { value: { checked: _value }, children: /* @__PURE__ */ import_jsx_runtime113.jsx(UnstyledButton, {
    ref,
    mod: [{ "with-border": withBorder, checked: _value }, mod],
    ...getStyles2("card"),
    ...others,
    role: "checkbox",
    "aria-checked": _value,
    onClick: (event) => {
      onClick?.(event);
      ctx?.onChange(value || "");
      setValue(!_value);
    }
  }) });
});
CheckboxCard.displayName = "@mantine/core/CheckboxCard";
CheckboxCard.classes = classes18;

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxGroup/CheckboxGroup.mjs
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_react153 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/InputsGroupFieldset/InputsGroupFieldset.mjs
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react152 = __toESM(require_react(), 1);
"use client";
function InputsGroupFieldset({ children, role }) {
  const ctx = useInputWrapperContext();
  if (!ctx) {
    return /* @__PURE__ */ import_jsx_runtime114.jsx(import_jsx_runtime114.Fragment, { children });
  }
  return /* @__PURE__ */ import_jsx_runtime114.jsx("div", { role, "aria-labelledby": ctx.labelId, "aria-describedby": ctx.describedBy, children });
}

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxGroup/CheckboxGroup.mjs
"use client";
var defaultProps42 = {};
var CheckboxGroup = factory((props, ref) => {
  const { value, defaultValue, onChange, size: size4, wrapperProps, children, readOnly, ...others } = useProps("CheckboxGroup", defaultProps42, props);
  const [_value, setValue] = useUncontrolled({
    value,
    defaultValue,
    finalValue: [],
    onChange
  });
  const handleChange = (event) => {
    const itemValue = typeof event === "string" ? event : event.currentTarget.value;
    !readOnly && setValue(_value.includes(itemValue) ? _value.filter((item) => item !== itemValue) : [..._value, itemValue]);
  };
  return /* @__PURE__ */ import_jsx_runtime115.jsx(CheckboxGroupProvider, { value: { value: _value, onChange: handleChange, size: size4 }, children: /* @__PURE__ */ import_jsx_runtime115.jsx(Input.Wrapper, {
    size: size4,
    ref,
    ...wrapperProps,
    ...others,
    labelElement: "div",
    __staticSelector: "CheckboxGroup",
    children: /* @__PURE__ */ import_jsx_runtime115.jsx(InputsGroupFieldset, { role: "group", children })
  }) });
});
CheckboxGroup.classes = Input.Wrapper.classes;
CheckboxGroup.displayName = "@mantine/core/CheckboxGroup";

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxIndicator/CheckboxIndicator.mjs
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react155 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Checkbox/CheckIcon.mjs
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react154 = __toESM(require_react(), 1);
"use client";
function CheckIcon({ size: size4, style: style2, ...others }) {
  const _style = size4 !== undefined ? { width: rem(size4), height: rem(size4), ...style2 } : style2;
  return /* @__PURE__ */ import_jsx_runtime116.jsx("svg", {
    viewBox: "0 0 10 7",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: _style,
    "aria-hidden": true,
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime116.jsx("path", {
      d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
      fill: "currentColor",
      fillRule: "evenodd",
      clipRule: "evenodd"
    })
  });
}
function CheckboxIcon({ indeterminate, ...others }) {
  if (indeterminate) {
    return /* @__PURE__ */ import_jsx_runtime116.jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 32 6",
      "aria-hidden": true,
      ...others,
      children: /* @__PURE__ */ import_jsx_runtime116.jsx("rect", { width: "32", height: "6", fill: "currentColor", rx: "3" })
    });
  }
  return /* @__PURE__ */ import_jsx_runtime116.jsx(CheckIcon, { ...others });
}

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxIndicator/CheckboxIndicator.module.css.mjs
"use client";
var classes19 = { indicator: "m_5e5256ee", icon: "m_1b1c543a", "indicator--outline": "m_76e20374" };

// node_modules/@mantine/core/esm/components/Checkbox/CheckboxIndicator/CheckboxIndicator.mjs
"use client";
var defaultProps43 = {
  icon: CheckboxIcon
};
var varsResolver21 = createVarsResolver((theme, { radius, color, size: size4, iconColor, variant, autoContrast }) => {
  const parsedColor = parseThemeColor({ color: color || theme.primaryColor, theme });
  const outlineColor = parsedColor.isThemeColor && parsedColor.shade === undefined ? `var(--mantine-color-${parsedColor.color}-outline)` : parsedColor.color;
  return {
    indicator: {
      "--checkbox-size": getSize(size4, "checkbox-size"),
      "--checkbox-radius": radius === undefined ? undefined : getRadius(radius),
      "--checkbox-color": variant === "outline" ? outlineColor : getThemeColor(color, theme),
      "--checkbox-icon-color": iconColor ? getThemeColor(iconColor, theme) : getAutoContrastValue(autoContrast, theme) ? getContrastColor({ color, theme, autoContrast }) : undefined
    }
  };
});
var CheckboxIndicator = factory((_props, ref) => {
  const props = useProps("CheckboxIndicator", defaultProps43, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    icon,
    indeterminate,
    radius,
    color,
    iconColor,
    autoContrast,
    checked,
    mod,
    variant,
    disabled,
    ...others
  } = props;
  const Icon = icon;
  const getStyles2 = useStyles({
    name: "CheckboxIndicator",
    classes: classes19,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver21,
    rootSelector: "indicator"
  });
  const ctx = useCheckboxCardContext();
  const _checked = typeof checked === "boolean" || typeof indeterminate === "boolean" ? checked || indeterminate : ctx?.checked || false;
  return /* @__PURE__ */ import_jsx_runtime117.jsx(Box, {
    ref,
    ...getStyles2("indicator", { variant }),
    variant,
    mod: [{ checked: _checked, disabled }, mod],
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime117.jsx(Icon, { indeterminate, ...getStyles2("icon") })
  });
});
CheckboxIndicator.displayName = "@mantine/core/CheckboxIndicator";
CheckboxIndicator.classes = classes19;

// node_modules/@mantine/core/esm/components/Checkbox/Checkbox.module.css.mjs
"use client";
var classes20 = { root: "m_bf2d988c", inner: "m_26062bec", input: "m_26063560", icon: "m_bf295423", "input--outline": "m_215c4542" };

// node_modules/@mantine/core/esm/components/Checkbox/Checkbox.mjs
"use client";
var defaultProps44 = {
  labelPosition: "right",
  icon: CheckboxIcon
};
var varsResolver22 = createVarsResolver((theme, { radius, color, size: size4, iconColor, variant, autoContrast }) => {
  const parsedColor = parseThemeColor({ color: color || theme.primaryColor, theme });
  const outlineColor = parsedColor.isThemeColor && parsedColor.shade === undefined ? `var(--mantine-color-${parsedColor.color}-outline)` : parsedColor.color;
  return {
    root: {
      "--checkbox-size": getSize(size4, "checkbox-size"),
      "--checkbox-radius": radius === undefined ? undefined : getRadius(radius),
      "--checkbox-color": variant === "outline" ? outlineColor : getThemeColor(color, theme),
      "--checkbox-icon-color": iconColor ? getThemeColor(iconColor, theme) : getAutoContrastValue(autoContrast, theme) ? getContrastColor({ color, theme, autoContrast }) : undefined
    }
  };
});
var Checkbox = factory((_props, forwardedRef) => {
  const props = useProps("Checkbox", defaultProps44, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color,
    label,
    id,
    size: size4,
    radius,
    wrapperProps,
    checked,
    labelPosition,
    description,
    error,
    disabled,
    variant,
    indeterminate,
    icon,
    rootRef,
    iconColor,
    onChange,
    autoContrast,
    mod,
    ...others
  } = props;
  const ctx = useCheckboxGroupContext();
  const _size = size4 || ctx?.size;
  const Icon = icon;
  const getStyles2 = useStyles({
    name: "Checkbox",
    props,
    classes: classes20,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver22
  });
  const { styleProps, rest } = extractStyleProps(others);
  const uuid = useId(id);
  const contextProps = ctx ? {
    checked: ctx.value.includes(rest.value),
    onChange: (event) => {
      ctx.onChange(event);
      onChange?.(event);
    }
  } : {};
  const fallbackRef = import_react156.useRef(null);
  const ref = forwardedRef || fallbackRef;
  import_react156.useEffect(() => {
    if (ref && "current" in ref && ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */ import_jsx_runtime118.jsx(InlineInput, {
    ...getStyles2("root"),
    __staticSelector: "Checkbox",
    __stylesApiProps: props,
    id: uuid,
    size: _size,
    labelPosition,
    label,
    description,
    error,
    disabled,
    classNames,
    styles,
    unstyled,
    "data-checked": contextProps.checked || checked || undefined,
    variant,
    ref: rootRef,
    mod,
    ...styleProps,
    ...wrapperProps,
    children: /* @__PURE__ */ import_jsx_runtime118.jsxs(Box, { ...getStyles2("inner"), mod: { "data-label-position": labelPosition }, children: [
      /* @__PURE__ */ import_jsx_runtime118.jsx(Box, {
        component: "input",
        id: uuid,
        ref,
        checked,
        disabled,
        mod: { error: !!error, indeterminate },
        ...getStyles2("input", { focusable: true, variant }),
        onChange,
        ...rest,
        ...contextProps,
        type: "checkbox"
      }),
      /* @__PURE__ */ import_jsx_runtime118.jsx(Icon, { indeterminate, ...getStyles2("icon") })
    ] })
  });
});
Checkbox.classes = { ...classes20, ...InlineInputClasses };
Checkbox.displayName = "@mantine/core/Checkbox";
Checkbox.Group = CheckboxGroup;
Checkbox.Indicator = CheckboxIndicator;
Checkbox.Card = CheckboxCard;

// node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/is-options-group.mjs
"use client";
function isOptionsGroup(item) {
  return "group" in item;
}

// node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/default-options-filter.mjs
"use client";
function defaultOptionsFilter({
  options,
  search,
  limit
}) {
  const parsedSearch = search.trim().toLowerCase();
  const result = [];
  for (let i2 = 0;i2 < options.length; i2 += 1) {
    const item = options[i2];
    if (result.length === limit) {
      return result;
    }
    if (isOptionsGroup(item)) {
      result.push({
        group: item.group,
        items: defaultOptionsFilter({
          options: item.items,
          search,
          limit: limit - result.length
        })
      });
    }
    if (!isOptionsGroup(item)) {
      if (item.label.toLowerCase().includes(parsedSearch)) {
        result.push(item);
      }
    }
  }
  return result;
}

// node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/is-empty-combobox-data.mjs
"use client";
function isEmptyComboboxData(data) {
  if (data.length === 0) {
    return true;
  }
  for (const item of data) {
    if (!("group" in item)) {
      return false;
    }
    if (item.items.length > 0) {
      return false;
    }
  }
  return true;
}

// node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/validate-options.mjs
"use client";
function validateOptions(options, valuesSet = /* @__PURE__ */ new Set) {
  if (!Array.isArray(options)) {
    return;
  }
  for (const option of options) {
    if (isOptionsGroup(option)) {
      validateOptions(option.items, valuesSet);
    } else {
      if (typeof option.value === "undefined") {
        throw new Error("[@mantine/core] Each option must have value property");
      }
      if (typeof option.value !== "string") {
        throw new Error(`[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof option.value}`);
      }
      if (valuesSet.has(option.value)) {
        throw new Error(`[@mantine/core] Duplicate options are not supported. Option with value "${option.value}" was provided more than once`);
      }
      valuesSet.add(option.value);
    }
  }
}

// node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/OptionsDropdown.mjs
"use client";
function isValueChecked(value, optionValue) {
  return Array.isArray(value) ? value.includes(optionValue) : value === optionValue;
}
function Option({
  data,
  withCheckIcon,
  value,
  checkIconPosition,
  unstyled,
  renderOption
}) {
  if (!isOptionsGroup(data)) {
    const checked = isValueChecked(value, data.value);
    const check = withCheckIcon && checked && /* @__PURE__ */ import_jsx_runtime119.jsx(CheckIcon, { className: classes16.optionsDropdownCheckIcon });
    const defaultContent = /* @__PURE__ */ import_jsx_runtime119.jsxs(import_jsx_runtime119.Fragment, { children: [
      checkIconPosition === "left" && check,
      /* @__PURE__ */ import_jsx_runtime119.jsx("span", { children: data.label }),
      checkIconPosition === "right" && check
    ] });
    return /* @__PURE__ */ import_jsx_runtime119.jsx(Combobox.Option, {
      value: data.value,
      disabled: data.disabled,
      className: clsx_default({ [classes16.optionsDropdownOption]: !unstyled }),
      "data-reverse": checkIconPosition === "right" || undefined,
      "data-checked": checked || undefined,
      "aria-selected": checked,
      active: checked,
      children: typeof renderOption === "function" ? renderOption({ option: data, checked }) : defaultContent
    });
  }
  const options = data.items.map((item) => /* @__PURE__ */ import_jsx_runtime119.jsx(Option, {
    data: item,
    value,
    unstyled,
    withCheckIcon,
    checkIconPosition,
    renderOption
  }, item.value));
  return /* @__PURE__ */ import_jsx_runtime119.jsx(Combobox.Group, { label: data.group, children: options });
}
function OptionsDropdown({
  data,
  hidden: hidden2,
  hiddenWhenEmpty,
  filter: filter2,
  search,
  limit,
  maxDropdownHeight,
  withScrollArea = true,
  filterOptions = true,
  withCheckIcon = false,
  value,
  checkIconPosition,
  nothingFoundMessage,
  unstyled,
  labelId,
  renderOption,
  scrollAreaProps,
  "aria-label": ariaLabel
}) {
  validateOptions(data);
  const shouldFilter = typeof search === "string";
  const filteredData = shouldFilter ? (filter2 || defaultOptionsFilter)({
    options: data,
    search: filterOptions ? search : "",
    limit: limit ?? Infinity
  }) : data;
  const isEmpty = isEmptyComboboxData(filteredData);
  const options = filteredData.map((item) => /* @__PURE__ */ import_jsx_runtime119.jsx(Option, {
    data: item,
    withCheckIcon,
    value,
    checkIconPosition,
    unstyled,
    renderOption
  }, isOptionsGroup(item) ? item.group : item.value));
  return /* @__PURE__ */ import_jsx_runtime119.jsx(Combobox.Dropdown, { hidden: hidden2 || hiddenWhenEmpty && isEmpty, "data-composed": true, children: /* @__PURE__ */ import_jsx_runtime119.jsxs(Combobox.Options, { labelledBy: labelId, "aria-label": ariaLabel, children: [
    withScrollArea ? /* @__PURE__ */ import_jsx_runtime119.jsx(ScrollArea.Autosize, {
      mah: maxDropdownHeight ?? 220,
      type: "scroll",
      scrollbarSize: "var(--combobox-padding)",
      offsetScrollbars: "y",
      ...scrollAreaProps,
      children: options
    }) : options,
    isEmpty && nothingFoundMessage && /* @__PURE__ */ import_jsx_runtime119.jsx(Combobox.Empty, { children: nothingFoundMessage })
  ] }) });
}

// node_modules/@mantine/core/esm/components/Breadcrumbs/Breadcrumbs.mjs
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react157 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Breadcrumbs/Breadcrumbs.module.css.mjs
"use client";
var classes21 = { root: "m_8b3717df", breadcrumb: "m_f678d540", separator: "m_3b8f2208" };

// node_modules/@mantine/core/esm/components/Breadcrumbs/Breadcrumbs.mjs
"use client";
var defaultProps45 = {
  separator: "/"
};
var varsResolver23 = createVarsResolver((_2, { separatorMargin }) => ({
  root: {
    "--bc-separator-margin": getSpacing(separatorMargin)
  }
}));
var Breadcrumbs = factory((_props, ref) => {
  const props = useProps("Breadcrumbs", defaultProps45, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children,
    separator,
    separatorMargin,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Breadcrumbs",
    classes: classes21,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver23
  });
  const items = import_react157.Children.toArray(children).reduce((acc, child, index4, array) => {
    const item = isElement(child) ? import_react157.cloneElement(child, {
      ...getStyles2("breadcrumb", { className: child.props?.className }),
      key: index4
    }) : /* @__PURE__ */ import_react157.createElement("div", { ...getStyles2("breadcrumb"), key: index4 }, child);
    acc.push(item);
    if (index4 !== array.length - 1) {
      acc.push(/* @__PURE__ */ import_react157.createElement(Box, { ...getStyles2("separator"), key: `separator-${index4}` }, separator));
    }
    return acc;
  }, []);
  return /* @__PURE__ */ import_jsx_runtime120.jsx(Box, { ref, ...getStyles2("root"), ...others, children: items });
});
Breadcrumbs.classes = classes21;
Breadcrumbs.displayName = "@mantine/core/Breadcrumbs";
// node_modules/@mantine/core/esm/components/Button/Button.mjs
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var import_react160 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Button/ButtonGroup/ButtonGroup.mjs
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react158 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Button/Button.module.css.mjs
"use client";
var classes22 = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" };

// node_modules/@mantine/core/esm/components/Button/ButtonGroup/ButtonGroup.mjs
"use client";
var defaultProps46 = {
  orientation: "horizontal"
};
var varsResolver24 = createVarsResolver((_2, { borderWidth }) => ({
  group: { "--button-border-width": rem(borderWidth) }
}));
var ButtonGroup = factory((_props, ref) => {
  const props = useProps("ButtonGroup", defaultProps46, _props);
  const {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    ...others
  } = useProps("ButtonGroup", defaultProps46, _props);
  const getStyles2 = useStyles({
    name: "ButtonGroup",
    props,
    classes: classes22,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver24,
    rootSelector: "group"
  });
  return /* @__PURE__ */ import_jsx_runtime121.jsx(Box, {
    ...getStyles2("group"),
    ref,
    variant,
    mod: [{ "data-orientation": orientation }, mod],
    role: "group",
    ...others
  });
});
ButtonGroup.classes = classes22;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";

// node_modules/@mantine/core/esm/components/Button/ButtonGroupSection/ButtonGroupSection.mjs
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react159 = __toESM(require_react(), 1);
"use client";
var defaultProps47 = {};
var varsResolver25 = createVarsResolver((theme, { radius, color, gradient, variant, autoContrast, size: size4 }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size4, "section-height"),
      "--section-padding-x": getSize(size4, "section-padding-x"),
      "--section-fz": size4?.includes("compact") ? getFontSize(size4.replace("compact-", "")) : getFontSize(size4),
      "--section-radius": radius === undefined ? undefined : getRadius(radius),
      "--section-bg": color || variant ? colors.background : undefined,
      "--section-color": colors.color,
      "--section-bd": color || variant ? colors.border : undefined
    }
  };
});
var ButtonGroupSection = factory((_props, ref) => {
  const props = useProps("ButtonGroupSection", defaultProps47, _props);
  const {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    ...others
  } = useProps("ButtonGroupSection", defaultProps47, _props);
  const getStyles2 = useStyles({
    name: "ButtonGroupSection",
    props,
    classes: classes22,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver25,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ import_jsx_runtime122.jsx(Box, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ButtonGroupSection.classes = classes22;
ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection";

// node_modules/@mantine/core/esm/components/Button/Button.mjs
"use client";
var loaderTransition = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
};
var defaultProps48 = {};
var varsResolver26 = createVarsResolver((theme, { radius, color, gradient, variant, size: size4, justify, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--button-justify": justify,
      "--button-height": getSize(size4, "button-height"),
      "--button-padding-x": getSize(size4, "button-padding-x"),
      "--button-fz": size4?.includes("compact") ? getFontSize(size4.replace("compact-", "")) : getFontSize(size4),
      "--button-radius": radius === undefined ? undefined : getRadius(radius),
      "--button-bg": color || variant ? colors.background : undefined,
      "--button-hover": color || variant ? colors.hover : undefined,
      "--button-color": colors.color,
      "--button-bd": color || variant ? colors.border : undefined,
      "--button-hover-color": color || variant ? colors.hoverColor : undefined
    }
  };
});
var Button = polymorphicFactory((_props, ref) => {
  const props = useProps("Button", defaultProps48, _props);
  const {
    style: style2,
    vars,
    className,
    color,
    disabled,
    children,
    leftSection,
    rightSection,
    fullWidth,
    variant,
    radius,
    loading,
    loaderProps,
    gradient,
    classNames,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Button",
    props,
    classes: classes22,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver26
  });
  const hasLeftSection = !!leftSection;
  const hasRightSection = !!rightSection;
  return /* @__PURE__ */ import_jsx_runtime123.jsxs(UnstyledButton, {
    ref,
    ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
    unstyled,
    variant,
    disabled: disabled || loading,
    mod: [
      {
        disabled: disabled || dataDisabled,
        loading,
        block: fullWidth,
        "with-left-section": hasLeftSection,
        "with-right-section": hasRightSection
      },
      mod
    ],
    ...others,
    children: [
      /* @__PURE__ */ import_jsx_runtime123.jsx(Transition, { mounted: !!loading, transition: loaderTransition, duration: 150, children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime123.jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": true, children: /* @__PURE__ */ import_jsx_runtime123.jsx(Loader, {
        color: "var(--button-color)",
        size: "calc(var(--button-height) / 1.8)",
        ...loaderProps
      }) }) }),
      /* @__PURE__ */ import_jsx_runtime123.jsxs("span", { ...getStyles2("inner"), children: [
        leftSection && /* @__PURE__ */ import_jsx_runtime123.jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
        /* @__PURE__ */ import_jsx_runtime123.jsx(Box, { component: "span", mod: { loading }, ...getStyles2("label"), children }),
        rightSection && /* @__PURE__ */ import_jsx_runtime123.jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "right" }, children: rightSection })
      ] })
    ]
  });
});
Button.classes = classes22;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
Button.GroupSection = ButtonGroupSection;
// node_modules/@mantine/core/esm/components/Card/Card.mjs
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react163 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Card/Card.context.mjs
var import_react161 = __toESM(require_react(), 1);
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
"use client";
var [CardProvider, useCardContext] = createSafeContext("Card component was not found in tree");

// node_modules/@mantine/core/esm/components/Card/CardSection/CardSection.mjs
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react162 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Card/Card.module.css.mjs
"use client";
var classes23 = { root: "m_e615b15f", section: "m_599a2148" };

// node_modules/@mantine/core/esm/components/Card/CardSection/CardSection.mjs
"use client";
var defaultProps49 = {};
var CardSection = polymorphicFactory((_props, ref) => {
  const props = useProps("CardSection", defaultProps49, _props);
  const { classNames, className, style: style2, styles, vars, withBorder, inheritPadding, mod, ...others } = props;
  const ctx = useCardContext();
  return /* @__PURE__ */ import_jsx_runtime125.jsx(Box, {
    ref,
    mod: [{ "with-border": withBorder, "inherit-padding": inheritPadding }, mod],
    ...ctx.getStyles("section", { className, style: style2, styles, classNames }),
    ...others
  });
});
CardSection.classes = classes23;
CardSection.displayName = "@mantine/core/CardSection";

// node_modules/@mantine/core/esm/components/Card/Card.mjs
"use client";
var defaultProps50 = {};
var varsResolver27 = createVarsResolver((_2, { padding }) => ({
  root: {
    "--card-padding": getSpacing(padding)
  }
}));
var Card = polymorphicFactory((_props, ref) => {
  const props = useProps("Card", defaultProps50, _props);
  const { classNames, className, style: style2, styles, unstyled, vars, children, padding, ...others } = props;
  const getStyles2 = useStyles({
    name: "Card",
    props,
    classes: classes23,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver27
  });
  const _children = import_react163.Children.toArray(children);
  const content = _children.map((child, index4) => {
    if (typeof child === "object" && child && "type" in child && child.type === CardSection) {
      return import_react163.cloneElement(child, {
        "data-first-section": index4 === 0 || undefined,
        "data-last-section": index4 === _children.length - 1 || undefined
      });
    }
    return child;
  });
  return /* @__PURE__ */ import_jsx_runtime126.jsx(CardProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ import_jsx_runtime126.jsx(Paper, { ref, unstyled, ...getStyles2("root"), ...others, children: content }) });
});
Card.classes = classes23;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;
// node_modules/@mantine/core/esm/components/Center/Center.mjs
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react164 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Center/Center.module.css.mjs
"use client";
var classes24 = { root: "m_4451eb3a" };

// node_modules/@mantine/core/esm/components/Center/Center.mjs
"use client";
var defaultProps51 = {};
var Center = polymorphicFactory((_props, ref) => {
  const props = useProps("Center", defaultProps51, _props);
  const { classNames, className, style: style2, styles, unstyled, vars, inline: inline4, mod, ...others } = props;
  const getStyles2 = useStyles({
    name: "Center",
    props,
    classes: classes24,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars
  });
  return /* @__PURE__ */ import_jsx_runtime127.jsx(Box, { ref, mod: [{ inline: inline4 }, mod], ...getStyles2("root"), ...others });
});
Center.classes = classes24;
Center.displayName = "@mantine/core/Center";
// node_modules/@mantine/core/esm/components/Divider/Divider.mjs
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react165 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Divider/Divider.module.css.mjs
"use client";
var classes25 = { root: "m_3eebeb36", label: "m_9e365f20" };

// node_modules/@mantine/core/esm/components/Divider/Divider.mjs
"use client";
var defaultProps52 = {
  orientation: "horizontal"
};
var varsResolver28 = createVarsResolver((theme, { color, variant, size: size4 }) => ({
  root: {
    "--divider-color": color ? getThemeColor(color, theme) : undefined,
    "--divider-border-style": variant,
    "--divider-size": getSize(size4, "divider-size")
  }
}));
var Divider = factory((_props, ref) => {
  const props = useProps("Divider", defaultProps52, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color,
    orientation,
    label,
    labelPosition,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Divider",
    classes: classes25,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver28
  });
  return /* @__PURE__ */ import_jsx_runtime128.jsx(Box, {
    ref,
    mod: [{ orientation, "with-label": !!label }, mod],
    ...getStyles2("root"),
    ...others,
    role: "separator",
    children: label && /* @__PURE__ */ import_jsx_runtime128.jsx(Box, { component: "span", mod: { position: labelPosition }, ...getStyles2("label"), children: label })
  });
});
Divider.classes = classes25;
Divider.displayName = "@mantine/core/Divider";
// node_modules/@mantine/core/esm/components/Drawer/Drawer.mjs
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react175 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Drawer/DrawerBody.mjs
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react167 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Drawer/Drawer.context.mjs
var import_react166 = __toESM(require_react(), 1);
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
"use client";
var [DrawerProvider, useDrawerContext] = createSafeContext("Drawer component was not found in tree");

// node_modules/@mantine/core/esm/components/Drawer/Drawer.module.css.mjs
"use client";
var classes26 = { root: "m_f11b401e", header: "m_5a7c2c9", content: "m_b8a05bbd", inner: "m_31cd769a" };

// node_modules/@mantine/core/esm/components/Drawer/DrawerBody.mjs
"use client";
var defaultProps53 = {};
var DrawerBody = factory((_props, ref) => {
  const props = useProps("DrawerBody", defaultProps53, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useDrawerContext();
  return /* @__PURE__ */ import_jsx_runtime130.jsx(ModalBaseBody, {
    ref,
    ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
    ...others
  });
});
DrawerBody.classes = classes26;
DrawerBody.displayName = "@mantine/core/DrawerBody";

// node_modules/@mantine/core/esm/components/Drawer/DrawerCloseButton.mjs
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react168 = __toESM(require_react(), 1);
"use client";
var defaultProps54 = {};
var DrawerCloseButton = factory((_props, ref) => {
  const props = useProps("DrawerCloseButton", defaultProps54, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useDrawerContext();
  return /* @__PURE__ */ import_jsx_runtime131.jsx(ModalBaseCloseButton, {
    ref,
    ...ctx.getStyles("close", { classNames, style: style2, styles, className }),
    ...others
  });
});
DrawerCloseButton.classes = classes26;
DrawerCloseButton.displayName = "@mantine/core/DrawerCloseButton";

// node_modules/@mantine/core/esm/components/Drawer/DrawerContent.mjs
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react169 = __toESM(require_react(), 1);
"use client";
var defaultProps55 = {};
var DrawerContent = factory((_props, ref) => {
  const props = useProps("DrawerContent", defaultProps55, _props);
  const { classNames, className, style: style2, styles, vars, children, radius, __hidden, ...others } = props;
  const ctx = useDrawerContext();
  const Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ import_jsx_runtime132.jsx(ModalBaseContent, {
    ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
    innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
    ref,
    ...others,
    radius: radius || ctx.radius || 0,
    "data-hidden": __hidden || undefined,
    children: /* @__PURE__ */ import_jsx_runtime132.jsx(Scroll, { style: { height: "calc(100vh - var(--drawer-offset) * 2)" }, children })
  });
});
DrawerContent.classes = classes26;
DrawerContent.displayName = "@mantine/core/DrawerContent";

// node_modules/@mantine/core/esm/components/Drawer/DrawerHeader.mjs
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react170 = __toESM(require_react(), 1);
"use client";
var defaultProps56 = {};
var DrawerHeader = factory((_props, ref) => {
  const props = useProps("DrawerHeader", defaultProps56, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useDrawerContext();
  return /* @__PURE__ */ import_jsx_runtime133.jsx(ModalBaseHeader, {
    ref,
    ...ctx.getStyles("header", { classNames, style: style2, styles, className }),
    ...others
  });
});
DrawerHeader.classes = classes26;
DrawerHeader.displayName = "@mantine/core/DrawerHeader";

// node_modules/@mantine/core/esm/components/Drawer/DrawerOverlay.mjs
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_react171 = __toESM(require_react(), 1);
"use client";
var defaultProps57 = {};
var DrawerOverlay = factory((_props, ref) => {
  const props = useProps("DrawerOverlay", defaultProps57, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useDrawerContext();
  return /* @__PURE__ */ import_jsx_runtime134.jsx(ModalBaseOverlay, {
    ref,
    ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
    ...others
  });
});
DrawerOverlay.classes = classes26;
DrawerOverlay.displayName = "@mantine/core/DrawerOverlay";

// node_modules/@mantine/core/esm/components/Drawer/DrawerRoot.mjs
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react172 = __toESM(require_react(), 1);
"use client";
function getDrawerAlign(position2) {
  switch (position2) {
    case "top":
      return "flex-start";
    case "bottom":
      return "flex-end";
    default:
      return;
  }
}
function getDrawerFlex(position2) {
  if (position2 === "top" || position2 === "bottom") {
    return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)";
  }
  return;
}
var transitions2 = {
  top: "slide-down",
  bottom: "slide-up",
  left: "slide-right",
  right: "slide-left"
};
var rtlTransitions = {
  top: "slide-down",
  bottom: "slide-up",
  right: "slide-right",
  left: "slide-left"
};
var defaultProps58 = {
  closeOnClickOutside: true,
  withinPortal: true,
  lockScroll: true,
  trapFocus: true,
  returnFocus: true,
  closeOnEscape: true,
  keepMounted: false,
  zIndex: getDefaultZIndex("modal"),
  position: "left"
};
var varsResolver29 = createVarsResolver((_2, { position: position2, size: size4, offset: offset4 }) => ({
  root: {
    "--drawer-size": getSize(size4, "drawer-size"),
    "--drawer-flex": getDrawerFlex(position2),
    "--drawer-height": position2 === "left" || position2 === "right" ? undefined : "var(--drawer-size)",
    "--drawer-align": getDrawerAlign(position2),
    "--drawer-justify": position2 === "right" ? "flex-end" : undefined,
    "--drawer-offset": rem(offset4)
  }
}));
var DrawerRoot = factory((_props, ref) => {
  const props = useProps("DrawerRoot", defaultProps58, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    scrollAreaComponent,
    position: position2,
    transitionProps,
    radius,
    ...others
  } = props;
  const { dir } = useDirection();
  const getStyles2 = useStyles({
    name: "Drawer",
    classes: classes26,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver29
  });
  const drawerTransition = (dir === "rtl" ? rtlTransitions : transitions2)[position2];
  return /* @__PURE__ */ import_jsx_runtime135.jsx(DrawerProvider, { value: { scrollAreaComponent, getStyles: getStyles2, radius }, children: /* @__PURE__ */ import_jsx_runtime135.jsx(ModalBase, {
    ref,
    ...getStyles2("root"),
    transitionProps: { transition: drawerTransition, ...transitionProps },
    "data-offset-scrollbars": scrollAreaComponent === ScrollArea.Autosize || undefined,
    unstyled,
    ...others
  }) });
});
DrawerRoot.classes = classes26;
DrawerRoot.displayName = "@mantine/core/DrawerRoot";

// node_modules/@mantine/core/esm/components/Drawer/DrawerStack.mjs
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react173 = __toESM(require_react(), 1);
"use client";
var [DrawerStackProvider, useDrawerStackContext] = createOptionalContext();
function DrawerStack({ children }) {
  const [stack, setStack] = import_react173.useState([]);
  const [maxZIndex, setMaxZIndex] = import_react173.useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ import_jsx_runtime136.jsx(DrawerStackProvider, {
    value: {
      stack,
      addModal: (id, zIndex) => {
        setStack((current2) => [.../* @__PURE__ */ new Set([...current2, id])]);
        setMaxZIndex((current2) => typeof zIndex === "number" && typeof current2 === "number" ? Math.max(current2, zIndex) : current2);
      },
      removeModal: (id) => setStack((current2) => current2.filter((currentId) => currentId !== id)),
      getZIndex: (id) => `calc(${maxZIndex} + ${stack.indexOf(id)} + 1)`,
      currentId: stack[stack.length - 1],
      maxZIndex
    },
    children
  });
}
DrawerStack.displayName = "@mantine/core/DrawerStack";

// node_modules/@mantine/core/esm/components/Drawer/DrawerTitle.mjs
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react174 = __toESM(require_react(), 1);
"use client";
var defaultProps59 = {};
var DrawerTitle = factory((_props, ref) => {
  const props = useProps("DrawerTitle", defaultProps59, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useDrawerContext();
  return /* @__PURE__ */ import_jsx_runtime137.jsx(ModalBaseTitle, {
    ref,
    ...ctx.getStyles("title", { classNames, style: style2, styles, className }),
    ...others
  });
});
DrawerTitle.classes = classes26;
DrawerTitle.displayName = "@mantine/core/DrawerTitle";

// node_modules/@mantine/core/esm/components/Drawer/Drawer.mjs
"use client";
var defaultProps60 = {
  closeOnClickOutside: true,
  withinPortal: true,
  lockScroll: true,
  trapFocus: true,
  returnFocus: true,
  closeOnEscape: true,
  keepMounted: false,
  zIndex: getDefaultZIndex("modal"),
  withOverlay: true,
  withCloseButton: true
};
var Drawer = factory((_props, ref) => {
  const {
    title,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Drawer", defaultProps60, _props);
  const ctx = useDrawerStackContext();
  const hasHeader = !!title || withCloseButton;
  const stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {};
  const overlayVisible = withOverlay === false ? false : stackId && ctx ? ctx.currentId === stackId : opened;
  import_react175.useEffect(() => {
    if (ctx && stackId) {
      opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId);
    }
  }, [opened, stackId, zIndex]);
  return /* @__PURE__ */ import_jsx_runtime138.jsxs(DrawerRoot, {
    ref,
    opened,
    zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
    ...others,
    ...stackProps,
    children: [
      withOverlay && /* @__PURE__ */ import_jsx_runtime138.jsx(DrawerOverlay, {
        visible: overlayVisible,
        transitionProps: ctx && stackId ? { duration: 0 } : undefined,
        ...overlayProps
      }),
      /* @__PURE__ */ import_jsx_runtime138.jsxs(DrawerContent, { __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : false, children: [
        hasHeader && /* @__PURE__ */ import_jsx_runtime138.jsxs(DrawerHeader, { children: [
          title && /* @__PURE__ */ import_jsx_runtime138.jsx(DrawerTitle, { children: title }),
          withCloseButton && /* @__PURE__ */ import_jsx_runtime138.jsx(DrawerCloseButton, { ...closeButtonProps })
        ] }),
        /* @__PURE__ */ import_jsx_runtime138.jsx(DrawerBody, { children })
      ] })
    ]
  });
});
Drawer.classes = classes26;
Drawer.displayName = "@mantine/core/Drawer";
Drawer.Root = DrawerRoot;
Drawer.Overlay = DrawerOverlay;
Drawer.Content = DrawerContent;
Drawer.Body = DrawerBody;
Drawer.Header = DrawerHeader;
Drawer.Title = DrawerTitle;
Drawer.CloseButton = DrawerCloseButton;
Drawer.Stack = DrawerStack;
// node_modules/@mantine/core/esm/components/Floating/use-delayed-hover.mjs
var import_react176 = __toESM(require_react(), 1);
"use client";
function useDelayedHover({ open, close, openDelay, closeDelay }) {
  const openTimeout = import_react176.useRef(-1);
  const closeTimeout = import_react176.useRef(-1);
  const clearTimeouts = () => {
    window.clearTimeout(openTimeout.current);
    window.clearTimeout(closeTimeout.current);
  };
  const openDropdown = () => {
    clearTimeouts();
    if (openDelay === 0 || openDelay === undefined) {
      open();
    } else {
      openTimeout.current = window.setTimeout(open, openDelay);
    }
  };
  const closeDropdown = () => {
    clearTimeouts();
    if (closeDelay === 0 || closeDelay === undefined) {
      close();
    } else {
      closeTimeout.current = window.setTimeout(close, closeDelay);
    }
  };
  import_react176.useEffect(() => clearTimeouts, []);
  return { openDropdown, closeDropdown };
}

// node_modules/@mantine/core/esm/components/Grid/Grid.mjs
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react181 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Grid/Grid.context.mjs
var import_react177 = __toESM(require_react(), 1);
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
"use client";
var [GridProvider, useGridContext] = createSafeContext("Grid component was not found in tree");

// node_modules/@mantine/core/esm/components/Grid/GridCol/GridCol.mjs
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react179 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Grid/GridCol/GridColVariables.mjs
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react178 = __toESM(require_react(), 1);
"use client";
var getColumnFlexBasis = (colSpan, columns) => {
  if (colSpan === "content") {
    return "auto";
  }
  if (colSpan === "auto") {
    return "0rem";
  }
  return colSpan ? `${100 / (columns / colSpan)}%` : undefined;
};
var getColumnMaxWidth = (colSpan, columns, grow) => {
  if (grow || colSpan === "auto") {
    return "100%";
  }
  if (colSpan === "content") {
    return "unset";
  }
  return getColumnFlexBasis(colSpan, columns);
};
var getColumnFlexGrow = (colSpan, grow) => {
  if (!colSpan) {
    return;
  }
  return colSpan === "auto" || grow ? "1" : "auto";
};
var getColumnOffset = (offset4, columns) => offset4 === 0 ? "0" : offset4 ? `${100 / (columns / offset4)}%` : undefined;
function GridColVariables({ span, order, offset: offset4, selector }) {
  const theme = useMantineTheme();
  const ctx = useGridContext();
  const _breakpoints = ctx.breakpoints || theme.breakpoints;
  const baseValue = getBaseValue(span);
  const baseSpan = baseValue === undefined ? 12 : getBaseValue(span);
  const baseStyles = filterProps({
    "--col-order": getBaseValue(order)?.toString(),
    "--col-flex-grow": getColumnFlexGrow(baseSpan, ctx.grow),
    "--col-flex-basis": getColumnFlexBasis(baseSpan, ctx.columns),
    "--col-width": baseSpan === "content" ? "auto" : undefined,
    "--col-max-width": getColumnMaxWidth(baseSpan, ctx.columns, ctx.grow),
    "--col-offset": getColumnOffset(getBaseValue(offset4), ctx.columns)
  });
  const queries = keys(_breakpoints).reduce((acc, breakpoint) => {
    if (!acc[breakpoint]) {
      acc[breakpoint] = {};
    }
    if (typeof order === "object" && order[breakpoint] !== undefined) {
      acc[breakpoint]["--col-order"] = order[breakpoint]?.toString();
    }
    if (typeof span === "object" && span[breakpoint] !== undefined) {
      acc[breakpoint]["--col-flex-grow"] = getColumnFlexGrow(span[breakpoint], ctx.grow);
      acc[breakpoint]["--col-flex-basis"] = getColumnFlexBasis(span[breakpoint], ctx.columns);
      acc[breakpoint]["--col-width"] = span[breakpoint] === "content" ? "auto" : undefined;
      acc[breakpoint]["--col-max-width"] = getColumnMaxWidth(span[breakpoint], ctx.columns, ctx.grow);
    }
    if (typeof offset4 === "object" && offset4[breakpoint] !== undefined) {
      acc[breakpoint]["--col-offset"] = getColumnOffset(offset4[breakpoint], ctx.columns);
    }
    return acc;
  }, {});
  const sortedBreakpoints = getSortedBreakpoints(keys(queries), _breakpoints).filter((breakpoint) => keys(queries[breakpoint.value]).length > 0);
  const values2 = sortedBreakpoints.map((breakpoint) => ({
    query: ctx.type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ import_jsx_runtime140.jsx(InlineStyles, {
    styles: baseStyles,
    media: ctx.type === "container" ? undefined : values2,
    container: ctx.type === "container" ? values2 : undefined,
    selector
  });
}

// node_modules/@mantine/core/esm/components/Grid/Grid.module.css.mjs
"use client";
var classes27 = { container: "m_8478a6da", root: "m_410352e9", inner: "m_dee7bd2f", col: "m_96bdd299" };

// node_modules/@mantine/core/esm/components/Grid/GridCol/GridCol.mjs
"use client";
var defaultProps61 = {
  span: 12
};
var GridCol = factory((_props, ref) => {
  const props = useProps("GridCol", defaultProps61, _props);
  const { classNames, className, style: style2, styles, vars, span, order, offset: offset4, ...others } = props;
  const ctx = useGridContext();
  const responsiveClassName = useRandomClassName();
  return /* @__PURE__ */ import_jsx_runtime141.jsxs(import_jsx_runtime141.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime141.jsx(GridColVariables, {
      selector: `.${responsiveClassName}`,
      span,
      order,
      offset: offset4
    }),
    /* @__PURE__ */ import_jsx_runtime141.jsx(Box, {
      ref,
      ...ctx.getStyles("col", {
        className: clsx_default(className, responsiveClassName),
        style: style2,
        classNames,
        styles
      }),
      ...others
    })
  ] });
});
GridCol.classes = classes27;
GridCol.displayName = "@mantine/core/GridCol";

// node_modules/@mantine/core/esm/components/Grid/GridVariables.mjs
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react180 = __toESM(require_react(), 1);
"use client";
function GridVariables({ gutter, selector, breakpoints, type }) {
  const theme = useMantineTheme();
  const _breakpoints = breakpoints || theme.breakpoints;
  const baseStyles = filterProps({
    "--grid-gutter": getSpacing(getBaseValue(gutter))
  });
  const queries = keys(_breakpoints).reduce((acc, breakpoint) => {
    if (!acc[breakpoint]) {
      acc[breakpoint] = {};
    }
    if (typeof gutter === "object" && gutter[breakpoint] !== undefined) {
      acc[breakpoint]["--grid-gutter"] = getSpacing(gutter[breakpoint]);
    }
    return acc;
  }, {});
  const sortedBreakpoints = getSortedBreakpoints(keys(queries), _breakpoints).filter((breakpoint) => keys(queries[breakpoint.value]).length > 0);
  const values2 = sortedBreakpoints.map((breakpoint) => ({
    query: type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ import_jsx_runtime142.jsx(InlineStyles, {
    styles: baseStyles,
    media: type === "container" ? undefined : values2,
    container: type === "container" ? values2 : undefined,
    selector
  });
}

// node_modules/@mantine/core/esm/components/Grid/Grid.mjs
"use client";
var defaultProps62 = {
  gutter: "md",
  grow: false,
  columns: 12
};
var varsResolver30 = createVarsResolver((_2, { justify, align, overflow }) => ({
  root: {
    "--grid-justify": justify,
    "--grid-align": align,
    "--grid-overflow": overflow
  }
}));
var Grid = factory((_props, ref) => {
  const props = useProps("Grid", defaultProps62, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    grow,
    gutter,
    columns,
    align,
    justify,
    children,
    breakpoints,
    type,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Grid",
    classes: classes27,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver30
  });
  const responsiveClassName = useRandomClassName();
  if (type === "container" && breakpoints) {
    return /* @__PURE__ */ import_jsx_runtime143.jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns: columns || 12, breakpoints, type }, children: [
      /* @__PURE__ */ import_jsx_runtime143.jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
      /* @__PURE__ */ import_jsx_runtime143.jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ import_jsx_runtime143.jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ import_jsx_runtime143.jsx("div", { ...getStyles2("inner"), children }) }) })
    ] });
  }
  return /* @__PURE__ */ import_jsx_runtime143.jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns: columns || 12, breakpoints, type }, children: [
    /* @__PURE__ */ import_jsx_runtime143.jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ import_jsx_runtime143.jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ import_jsx_runtime143.jsx("div", { ...getStyles2("inner"), children }) })
  ] });
});
Grid.classes = classes27;
Grid.displayName = "@mantine/core/Grid";
Grid.Col = GridCol;
// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1;e < arguments.length; e++) {
      var t = arguments[e];
      for (var r3 in t)
        ({}).hasOwnProperty.call(t, r3) && (n[r3] = t[r3]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@mantine/core/esm/components/List/List.mjs
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react184 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/List/List.context.mjs
var import_react182 = __toESM(require_react(), 1);
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ListProvider, useListContext] = createSafeContext("List component was not found in tree");

// node_modules/@mantine/core/esm/components/List/ListItem/ListItem.mjs
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react183 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/List/List.module.css.mjs
"use client";
var classes28 = { root: "m_abbac491", item: "m_abb6bec2", itemWrapper: "m_75cd9f71", itemIcon: "m_60f83e5b" };

// node_modules/@mantine/core/esm/components/List/ListItem/ListItem.mjs
"use client";
var defaultProps63 = {};
var ListItem = factory((_props, ref) => {
  const props = useProps("ListItem", defaultProps63, _props);
  const { classNames, className, style: style2, styles, vars, icon, children, mod, ...others } = props;
  const ctx = useListContext();
  const _icon = icon || ctx.icon;
  const stylesApiProps = { classNames, styles };
  return /* @__PURE__ */ import_jsx_runtime145.jsx(Box, {
    ...ctx.getStyles("item", { ...stylesApiProps, className, style: style2 }),
    component: "li",
    mod: [{ "with-icon": !!_icon, centered: ctx.center }, mod],
    ref,
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime145.jsxs("div", { ...ctx.getStyles("itemWrapper", stylesApiProps), children: [
      _icon && /* @__PURE__ */ import_jsx_runtime145.jsx("span", { ...ctx.getStyles("itemIcon", stylesApiProps), children: _icon }),
      /* @__PURE__ */ import_jsx_runtime145.jsx("span", { ...ctx.getStyles("itemLabel", stylesApiProps), children })
    ] })
  });
});
ListItem.classes = classes28;
ListItem.displayName = "@mantine/core/ListItem";

// node_modules/@mantine/core/esm/components/List/List.mjs
"use client";
var defaultProps64 = {
  type: "unordered"
};
var varsResolver31 = createVarsResolver((_2, { size: size4, spacing }) => ({
  root: {
    "--list-fz": getFontSize(size4),
    "--list-lh": getLineHeight(size4),
    "--list-spacing": getSpacing(spacing)
  }
}));
var List = factory((_props, ref) => {
  const props = useProps("List", defaultProps64, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children,
    type,
    withPadding,
    icon,
    spacing,
    center,
    listStyleType,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "List",
    classes: classes28,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver31
  });
  return /* @__PURE__ */ import_jsx_runtime146.jsx(ListProvider, { value: { center, icon, getStyles: getStyles2 }, children: /* @__PURE__ */ import_jsx_runtime146.jsx(Box, {
    ...getStyles2("root", { style: { listStyleType } }),
    component: type === "unordered" ? "ul" : "ol",
    mod: [{ "with-padding": withPadding }, mod],
    ref,
    ...others,
    children
  }) });
});
List.classes = classes28;
List.displayName = "@mantine/core/List";
List.Item = ListItem;
// node_modules/@mantine/core/esm/components/Menu/Menu.mjs
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react191 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Menu/Menu.context.mjs
var import_react185 = __toESM(require_react(), 1);
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
"use client";
var [MenuContextProvider, useMenuContext] = createSafeContext("Menu component was not found in the tree");

// node_modules/@mantine/core/esm/components/Menu/MenuDivider/MenuDivider.mjs
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react186 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Menu/Menu.module.css.mjs
"use client";
var classes29 = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504" };

// node_modules/@mantine/core/esm/components/Menu/MenuDivider/MenuDivider.mjs
"use client";
var defaultProps65 = {};
var MenuDivider = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps("MenuDivider", defaultProps65, props);
  const ctx = useMenuContext();
  return /* @__PURE__ */ import_jsx_runtime148.jsx(Box, {
    ref,
    ...ctx.getStyles("divider", { className, style: style2, styles, classNames }),
    ...others
  });
});
MenuDivider.classes = classes29;
MenuDivider.displayName = "@mantine/core/MenuDivider";

// node_modules/@mantine/core/esm/components/Menu/MenuDropdown/MenuDropdown.mjs
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react187 = __toESM(require_react(), 1);
"use client";
var defaultProps66 = {};
var MenuDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children,
    ...others
  } = useProps("MenuDropdown", defaultProps66, props);
  const wrapperRef = import_react187.useRef(null);
  const ctx = useMenuContext();
  const handleKeyDown = createEventHandler(onKeyDown, (event) => {
    if (event.key === "ArrowUp" || event.key === "ArrowDown") {
      event.preventDefault();
      wrapperRef.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus();
    }
  });
  const handleMouseEnter = createEventHandler(onMouseEnter, () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown());
  const handleMouseLeave = createEventHandler(onMouseLeave, () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown());
  return /* @__PURE__ */ import_jsx_runtime149.jsxs(Popover.Dropdown, {
    ...others,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    role: "menu",
    "aria-orientation": "vertical",
    ref: useMergedRef(ref, wrapperRef),
    ...ctx.getStyles("dropdown", {
      className,
      style: style2,
      styles,
      classNames,
      withStaticClass: false
    }),
    tabIndex: -1,
    "data-menu-dropdown": true,
    onKeyDown: handleKeyDown,
    children: [
      ctx.withInitialFocusPlaceholder && /* @__PURE__ */ import_jsx_runtime149.jsx("div", { tabIndex: -1, "data-autofocus": true, "data-mantine-stop-propagation": true, style: { outline: 0 } }),
      children
    ]
  });
});
MenuDropdown.classes = classes29;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";

// node_modules/@mantine/core/esm/components/Menu/MenuItem/MenuItem.mjs
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react188 = __toESM(require_react(), 1);
"use client";
var defaultProps67 = {};
var MenuItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    color,
    closeMenuOnClick,
    leftSection,
    rightSection,
    children,
    disabled,
    "data-disabled": dataDisabled,
    ...others
  } = useProps("MenuItem", defaultProps67, props);
  const ctx = useMenuContext();
  const theme = useMantineTheme();
  const { dir } = useDirection();
  const itemRef = import_react188.useRef(null);
  const itemIndex = ctx.getItemIndex(itemRef.current);
  const _others = others;
  const handleMouseLeave = createEventHandler(_others.onMouseLeave, () => ctx.setHovered(-1));
  const handleMouseEnter = createEventHandler(_others.onMouseEnter, () => ctx.setHovered(ctx.getItemIndex(itemRef.current)));
  const handleClick = createEventHandler(_others.onClick, () => {
    if (dataDisabled) {
      return;
    }
    if (typeof closeMenuOnClick === "boolean") {
      closeMenuOnClick && ctx.closeDropdownImmediately();
    } else {
      ctx.closeOnItemClick && ctx.closeDropdownImmediately();
    }
  });
  const handleFocus = createEventHandler(_others.onFocus, () => ctx.setHovered(ctx.getItemIndex(itemRef.current)));
  const colors = color ? theme.variantColorResolver({ color, theme, variant: "light" }) : undefined;
  const parsedThemeColor = color ? parseThemeColor({ color, theme }) : null;
  return /* @__PURE__ */ import_jsx_runtime150.jsxs(UnstyledButton, {
    ...others,
    unstyled: ctx.unstyled,
    tabIndex: ctx.menuItemTabIndex,
    onFocus: handleFocus,
    ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
    ref: useMergedRef(itemRef, ref),
    role: "menuitem",
    disabled,
    "data-menu-item": true,
    "data-disabled": disabled || dataDisabled || undefined,
    "data-hovered": ctx.hovered === itemIndex ? true : undefined,
    "data-mantine-stop-propagation": true,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onKeyDown: createScopedKeydownHandler({
      siblingSelector: "[data-menu-item]:not([data-disabled])",
      parentSelector: "[data-menu-dropdown]",
      activateOnFocus: false,
      loop: ctx.loop,
      dir,
      orientation: "vertical",
      onKeyDown: _others.onKeyDown
    }),
    __vars: {
      "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === undefined ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
      "--menu-item-hover": colors?.hover
    },
    children: [
      leftSection && /* @__PURE__ */ import_jsx_runtime150.jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
      children && /* @__PURE__ */ import_jsx_runtime150.jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children }),
      rightSection && /* @__PURE__ */ import_jsx_runtime150.jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection })
    ]
  });
});
MenuItem.classes = classes29;
MenuItem.displayName = "@mantine/core/MenuItem";

// node_modules/@mantine/core/esm/components/Menu/MenuLabel/MenuLabel.mjs
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react189 = __toESM(require_react(), 1);
"use client";
var defaultProps68 = {};
var MenuLabel = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps("MenuLabel", defaultProps68, props);
  const ctx = useMenuContext();
  return /* @__PURE__ */ import_jsx_runtime151.jsx(Box, {
    ref,
    ...ctx.getStyles("label", { className, style: style2, styles, classNames }),
    ...others
  });
});
MenuLabel.classes = classes29;
MenuLabel.displayName = "@mantine/core/MenuLabel";

// node_modules/@mantine/core/esm/components/Menu/MenuTarget/MenuTarget.mjs
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react190 = __toESM(require_react(), 1);
"use client";
var defaultProps69 = {
  refProp: "ref"
};
var MenuTarget = import_react190.forwardRef((props, ref) => {
  const { children, refProp, ...others } = useProps("MenuTarget", defaultProps69, props);
  if (!isElement(children)) {
    throw new Error("Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
  }
  const ctx = useMenuContext();
  const _childrenProps = children.props;
  const onClick = createEventHandler(_childrenProps.onClick, () => {
    if (ctx.trigger === "click") {
      ctx.toggleDropdown();
    } else if (ctx.trigger === "click-hover") {
      ctx.setOpenedViaClick(true);
      if (!ctx.opened) {
        ctx.openDropdown();
      }
    }
  });
  const onMouseEnter = createEventHandler(_childrenProps.onMouseEnter, () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown());
  const onMouseLeave = createEventHandler(_childrenProps.onMouseLeave, () => {
    if (ctx.trigger === "hover") {
      ctx.closeDropdown();
    } else if (ctx.trigger === "click-hover" && !ctx.openedViaClick) {
      ctx.closeDropdown();
    }
  });
  return /* @__PURE__ */ import_jsx_runtime152.jsx(Popover.Target, { refProp, popupType: "menu", ref, ...others, children: import_react190.cloneElement(children, {
    onClick,
    onMouseEnter,
    onMouseLeave,
    "data-expanded": ctx.opened ? true : undefined
  }) });
});
MenuTarget.displayName = "@mantine/core/MenuTarget";

// node_modules/@mantine/core/esm/components/Menu/Menu.mjs
"use client";
var defaultProps70 = {
  trapFocus: true,
  closeOnItemClick: true,
  withInitialFocusPlaceholder: true,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: true,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function Menu(_props) {
  const props = useProps("Menu", defaultProps70, _props);
  const {
    children,
    onOpen,
    onClose,
    opened,
    defaultOpened,
    trapFocus,
    onChange,
    closeOnItemClick,
    loop,
    closeOnEscape: closeOnEscape2,
    trigger,
    openDelay,
    closeDelay,
    classNames,
    styles,
    unstyled,
    variant,
    vars,
    menuItemTabIndex,
    keepMounted,
    withInitialFocusPlaceholder,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Menu",
    classes: classes29,
    props,
    classNames,
    styles,
    unstyled
  });
  const [hovered, { setHovered, resetHovered }] = useHovered();
  const [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: false,
    onChange
  });
  const [openedViaClick, setOpenedViaClick] = import_react191.useState(false);
  const close = () => {
    setOpened(false);
    setOpenedViaClick(false);
    _opened && onClose?.();
  };
  const open = () => {
    setOpened(true);
    !_opened && onOpen?.();
  };
  const toggleDropdown = () => {
    _opened ? close() : open();
  };
  const { openDropdown, closeDropdown } = useDelayedHover({ open, close, closeDelay, openDelay });
  const getItemIndex = (node2) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node2);
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  useDidUpdate(() => {
    resetHovered();
  }, [_opened]);
  return /* @__PURE__ */ import_jsx_runtime153.jsx(MenuContextProvider, {
    value: {
      getStyles: getStyles2,
      opened: _opened,
      toggleDropdown,
      getItemIndex,
      hovered,
      setHovered,
      openedViaClick,
      setOpenedViaClick,
      closeOnItemClick,
      closeDropdown: trigger === "click" ? close : closeDropdown,
      openDropdown: trigger === "click" ? open : openDropdown,
      closeDropdownImmediately: close,
      loop,
      trigger,
      unstyled,
      menuItemTabIndex,
      withInitialFocusPlaceholder
    },
    children: /* @__PURE__ */ import_jsx_runtime153.jsx(Popover, {
      ...others,
      opened: _opened,
      onChange: toggleDropdown,
      defaultOpened,
      trapFocus: keepMounted ? false : trapFocus,
      closeOnEscape: closeOnEscape2,
      __staticSelector: "Menu",
      classNames: resolvedClassNames,
      styles: resolvedStyles,
      unstyled,
      variant,
      keepMounted,
      children
    })
  });
}
Menu.extend = (input) => input;
Menu.withProps = getWithProps(Menu);
Menu.classes = classes29;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
// node_modules/@mantine/core/esm/components/Modal/Modal.mjs
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react201 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Modal/ModalBody.mjs
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react193 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Modal/Modal.context.mjs
var import_react192 = __toESM(require_react(), 1);
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ModalProvider, useModalContext] = createSafeContext("Modal component was not found in tree");

// node_modules/@mantine/core/esm/components/Modal/Modal.module.css.mjs
"use client";
var classes30 = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" };

// node_modules/@mantine/core/esm/components/Modal/ModalBody.mjs
"use client";
var defaultProps71 = {};
var ModalBody = factory((_props, ref) => {
  const props = useProps("ModalBody", defaultProps71, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useModalContext();
  return /* @__PURE__ */ import_jsx_runtime155.jsx(ModalBaseBody, {
    ref,
    ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
    ...others
  });
});
ModalBody.classes = classes30;
ModalBody.displayName = "@mantine/core/ModalBody";

// node_modules/@mantine/core/esm/components/Modal/ModalCloseButton.mjs
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react194 = __toESM(require_react(), 1);
"use client";
var defaultProps72 = {};
var ModalCloseButton = factory((_props, ref) => {
  const props = useProps("ModalCloseButton", defaultProps72, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useModalContext();
  return /* @__PURE__ */ import_jsx_runtime156.jsx(ModalBaseCloseButton, {
    ref,
    ...ctx.getStyles("close", { classNames, style: style2, styles, className }),
    ...others
  });
});
ModalCloseButton.classes = classes30;
ModalCloseButton.displayName = "@mantine/core/ModalCloseButton";

// node_modules/@mantine/core/esm/components/Modal/ModalContent.mjs
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react195 = __toESM(require_react(), 1);
"use client";
var defaultProps73 = {};
var ModalContent = factory((_props, ref) => {
  const props = useProps("ModalContent", defaultProps73, _props);
  const { classNames, className, style: style2, styles, vars, children, __hidden, ...others } = props;
  const ctx = useModalContext();
  const Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ import_jsx_runtime157.jsx(ModalBaseContent, {
    ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
    innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
    "data-full-screen": ctx.fullScreen || undefined,
    "data-modal-content": true,
    "data-hidden": __hidden || undefined,
    ref,
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime157.jsx(Scroll, {
      style: {
        maxHeight: ctx.fullScreen ? "100dvh" : `calc(100dvh - (${rem(ctx.yOffset)} * 2))`
      },
      children
    })
  });
});
ModalContent.classes = classes30;
ModalContent.displayName = "@mantine/core/ModalContent";

// node_modules/@mantine/core/esm/components/Modal/ModalHeader.mjs
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react196 = __toESM(require_react(), 1);
"use client";
var defaultProps74 = {};
var ModalHeader = factory((_props, ref) => {
  const props = useProps("ModalHeader", defaultProps74, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useModalContext();
  return /* @__PURE__ */ import_jsx_runtime158.jsx(ModalBaseHeader, {
    ref,
    ...ctx.getStyles("header", { classNames, style: style2, styles, className }),
    ...others
  });
});
ModalHeader.classes = classes30;
ModalHeader.displayName = "@mantine/core/ModalHeader";

// node_modules/@mantine/core/esm/components/Modal/ModalOverlay.mjs
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react197 = __toESM(require_react(), 1);
"use client";
var defaultProps75 = {};
var ModalOverlay = factory((_props, ref) => {
  const props = useProps("ModalOverlay", defaultProps75, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useModalContext();
  return /* @__PURE__ */ import_jsx_runtime159.jsx(ModalBaseOverlay, {
    ref,
    ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
    ...others
  });
});
ModalOverlay.classes = classes30;
ModalOverlay.displayName = "@mantine/core/ModalOverlay";

// node_modules/@mantine/core/esm/components/Modal/ModalRoot.mjs
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react198 = __toESM(require_react(), 1);
"use client";
var defaultProps76 = {
  __staticSelector: "Modal",
  closeOnClickOutside: true,
  withinPortal: true,
  lockScroll: true,
  trapFocus: true,
  returnFocus: true,
  closeOnEscape: true,
  keepMounted: false,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  yOffset: "5dvh"
};
var varsResolver32 = createVarsResolver((_2, { radius, size: size4, yOffset, xOffset }) => ({
  root: {
    "--modal-radius": radius === undefined ? undefined : getRadius(radius),
    "--modal-size": getSize(size4, "modal-size"),
    "--modal-y-offset": rem(yOffset),
    "--modal-x-offset": rem(xOffset)
  }
}));
var ModalRoot = factory((_props, ref) => {
  const props = useProps("ModalRoot", defaultProps76, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    yOffset,
    scrollAreaComponent,
    radius,
    fullScreen,
    centered,
    xOffset,
    __staticSelector,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: __staticSelector,
    classes: classes30,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver32
  });
  return /* @__PURE__ */ import_jsx_runtime160.jsx(ModalProvider, { value: { yOffset, scrollAreaComponent, getStyles: getStyles2, fullScreen }, children: /* @__PURE__ */ import_jsx_runtime160.jsx(ModalBase, {
    ref,
    ...getStyles2("root"),
    "data-full-screen": fullScreen || undefined,
    "data-centered": centered || undefined,
    "data-offset-scrollbars": scrollAreaComponent === ScrollArea.Autosize || undefined,
    unstyled,
    ...others
  }) });
});
ModalRoot.classes = classes30;
ModalRoot.displayName = "@mantine/core/ModalRoot";

// node_modules/@mantine/core/esm/components/Modal/ModalStack.mjs
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react199 = __toESM(require_react(), 1);
"use client";
var [ModalStackProvider, useModalStackContext] = createOptionalContext();
function ModalStack({ children }) {
  const [stack, setStack] = import_react199.useState([]);
  const [maxZIndex, setMaxZIndex] = import_react199.useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ import_jsx_runtime161.jsx(ModalStackProvider, {
    value: {
      stack,
      addModal: (id, zIndex) => {
        setStack((current2) => [.../* @__PURE__ */ new Set([...current2, id])]);
        setMaxZIndex((current2) => typeof zIndex === "number" && typeof current2 === "number" ? Math.max(current2, zIndex) : current2);
      },
      removeModal: (id) => setStack((current2) => current2.filter((currentId) => currentId !== id)),
      getZIndex: (id) => `calc(${maxZIndex} + ${stack.indexOf(id)} + 1)`,
      currentId: stack[stack.length - 1],
      maxZIndex
    },
    children
  });
}
ModalStack.displayName = "@mantine/core/ModalStack";

// node_modules/@mantine/core/esm/components/Modal/ModalTitle.mjs
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react200 = __toESM(require_react(), 1);
"use client";
var defaultProps77 = {};
var ModalTitle = factory((_props, ref) => {
  const props = useProps("ModalTitle", defaultProps77, _props);
  const { classNames, className, style: style2, styles, vars, ...others } = props;
  const ctx = useModalContext();
  return /* @__PURE__ */ import_jsx_runtime162.jsx(ModalBaseTitle, {
    ref,
    ...ctx.getStyles("title", { classNames, style: style2, styles, className }),
    ...others
  });
});
ModalTitle.classes = classes30;
ModalTitle.displayName = "@mantine/core/ModalTitle";

// node_modules/@mantine/core/esm/components/Modal/Modal.mjs
"use client";
var defaultProps78 = {
  closeOnClickOutside: true,
  withinPortal: true,
  lockScroll: true,
  trapFocus: true,
  returnFocus: true,
  closeOnEscape: true,
  keepMounted: false,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  withOverlay: true,
  withCloseButton: true
};
var Modal = factory((_props, ref) => {
  const {
    title,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children,
    radius,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Modal", defaultProps78, _props);
  const ctx = useModalStackContext();
  const hasHeader = !!title || withCloseButton;
  const stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {};
  const overlayVisible = withOverlay === false ? false : stackId && ctx ? ctx.currentId === stackId : opened;
  import_react201.useEffect(() => {
    if (ctx && stackId) {
      opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId);
    }
  }, [opened, stackId, zIndex]);
  return /* @__PURE__ */ import_jsx_runtime163.jsxs(ModalRoot, {
    ref,
    radius,
    opened,
    zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
    ...others,
    ...stackProps,
    children: [
      withOverlay && /* @__PURE__ */ import_jsx_runtime163.jsx(ModalOverlay, {
        visible: overlayVisible,
        transitionProps: ctx && stackId ? { duration: 0 } : undefined,
        ...overlayProps
      }),
      /* @__PURE__ */ import_jsx_runtime163.jsxs(ModalContent, {
        radius,
        __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : false,
        children: [
          hasHeader && /* @__PURE__ */ import_jsx_runtime163.jsxs(ModalHeader, { children: [
            title && /* @__PURE__ */ import_jsx_runtime163.jsx(ModalTitle, { children: title }),
            withCloseButton && /* @__PURE__ */ import_jsx_runtime163.jsx(ModalCloseButton, { ...closeButtonProps })
          ] }),
          /* @__PURE__ */ import_jsx_runtime163.jsx(ModalBody, { children })
        ]
      })
    ]
  });
});
Modal.classes = classes30;
Modal.displayName = "@mantine/core/Modal";
Modal.Root = ModalRoot;
Modal.Overlay = ModalOverlay;
Modal.Content = ModalContent;
Modal.Body = ModalBody;
Modal.Header = ModalHeader;
Modal.Title = ModalTitle;
Modal.CloseButton = ModalCloseButton;
Modal.Stack = ModalStack;
// node_modules/@mantine/core/esm/components/MultiSelect/MultiSelect.mjs
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react209 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Pill/Pill.mjs
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react205 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/PillsInput/PillsInput.context.mjs
var import_react202 = __toESM(require_react(), 1);
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
"use client";
var [PillsInputProvider, usePillsInputContext] = createOptionalContext();

// node_modules/@mantine/core/esm/components/Pill/PillGroup.context.mjs
var import_react203 = __toESM(require_react(), 1);
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
"use client";
var [PillGroupProvider, usePillGroupContext] = createOptionalContext();

// node_modules/@mantine/core/esm/components/Pill/PillGroup/PillGroup.mjs
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react204 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Pill/Pill.module.css.mjs
"use client";
var classes31 = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };

// node_modules/@mantine/core/esm/components/Pill/PillGroup/PillGroup.mjs
"use client";
var defaultProps79 = {};
var varsResolver33 = createVarsResolver((_2, { gap }, { size: size4 }) => ({
  group: {
    "--pg-gap": gap !== undefined ? getSize(gap) : getSize(size4, "pg-gap")
  }
}));
var PillGroup = factory((_props, ref) => {
  const props = useProps("PillGroup", defaultProps79, _props);
  const { classNames, className, style: style2, styles, unstyled, vars, size: size4, disabled, ...others } = props;
  const pillsInputCtx = usePillsInputContext();
  const _size = pillsInputCtx?.size || size4 || undefined;
  const getStyles2 = useStyles({
    name: "PillGroup",
    classes: classes31,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver33,
    stylesCtx: { size: _size },
    rootSelector: "group"
  });
  return /* @__PURE__ */ import_jsx_runtime166.jsx(PillGroupProvider, { value: { size: _size, disabled }, children: /* @__PURE__ */ import_jsx_runtime166.jsx(Box, { ref, size: _size, ...getStyles2("group"), ...others }) });
});
PillGroup.classes = classes31;
PillGroup.displayName = "@mantine/core/PillGroup";

// node_modules/@mantine/core/esm/components/Pill/Pill.mjs
"use client";
var defaultProps80 = {
  variant: "default"
};
var varsResolver34 = createVarsResolver((_2, { radius }, { size: size4 }) => ({
  root: {
    "--pill-fz": getSize(size4, "pill-fz"),
    "--pill-height": getSize(size4, "pill-height"),
    "--pill-radius": radius === undefined ? undefined : getRadius(radius)
  }
}));
var Pill = factory((_props, ref) => {
  const props = useProps("Pill", defaultProps80, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    variant,
    children,
    withRemoveButton,
    onRemove,
    removeButtonProps,
    radius,
    size: size4,
    disabled,
    mod,
    ...others
  } = props;
  const ctx = usePillGroupContext();
  const pillsInputCtx = usePillsInputContext();
  const _size = size4 || ctx?.size || undefined;
  const _variant = pillsInputCtx?.variant === "filled" ? "contrast" : variant || "default";
  const getStyles2 = useStyles({
    name: "Pill",
    classes: classes31,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver34,
    stylesCtx: { size: _size }
  });
  return /* @__PURE__ */ import_jsx_runtime167.jsxs(Box, {
    component: "span",
    ref,
    variant: _variant,
    size: _size,
    ...getStyles2("root", { variant: _variant }),
    mod: [
      { "with-remove": withRemoveButton && !disabled, disabled: disabled || ctx?.disabled },
      mod
    ],
    ...others,
    children: [
      /* @__PURE__ */ import_jsx_runtime167.jsx("span", { ...getStyles2("label"), children }),
      withRemoveButton && /* @__PURE__ */ import_jsx_runtime167.jsx(CloseButton, {
        variant: "transparent",
        radius,
        tabIndex: -1,
        "aria-hidden": true,
        unstyled,
        ...removeButtonProps,
        ...getStyles2("remove", {
          className: removeButtonProps?.className,
          style: removeButtonProps?.style
        }),
        onMouseDown: (event) => {
          event.preventDefault();
          event.stopPropagation();
          removeButtonProps?.onMouseDown?.(event);
        },
        onClick: (event) => {
          event.stopPropagation();
          onRemove?.();
          removeButtonProps?.onClick?.(event);
        }
      })
    ]
  });
});
Pill.classes = classes31;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;

// node_modules/@mantine/core/esm/components/PillsInput/PillsInput.mjs
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react207 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/PillsInput/PillsInputField/PillsInputField.mjs
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react206 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/PillsInput/PillsInput.module.css.mjs
"use client";
var classes32 = { field: "m_45c4369d" };

// node_modules/@mantine/core/esm/components/PillsInput/PillsInputField/PillsInputField.mjs
"use client";
var defaultProps81 = {
  type: "visible"
};
var PillsInputField = factory((_props, ref) => {
  const props = useProps("PillsInputField", defaultProps81, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    type,
    disabled,
    id,
    pointer,
    mod,
    ...others
  } = props;
  const ctx = usePillsInputContext();
  const inputWrapperCtx = useInputWrapperContext();
  const getStyles2 = useStyles({
    name: "PillsInputField",
    classes: classes32,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "field"
  });
  const _disabled = disabled || ctx?.disabled;
  return /* @__PURE__ */ import_jsx_runtime168.jsx(Box, {
    component: "input",
    ref: useMergedRef(ref, ctx?.fieldRef),
    "data-type": type,
    disabled: _disabled,
    mod: [{ disabled: _disabled, pointer }, mod],
    ...getStyles2("field"),
    ...others,
    id: inputWrapperCtx?.inputId || id,
    "aria-invalid": ctx?.hasError,
    "aria-describedby": inputWrapperCtx?.describedBy,
    type: "text",
    onMouseDown: (event) => !pointer && event.stopPropagation()
  });
});
PillsInputField.classes = classes32;
PillsInputField.displayName = "@mantine/core/PillsInputField";

// node_modules/@mantine/core/esm/components/PillsInput/PillsInput.mjs
"use client";
var defaultProps82 = {};
var PillsInput = factory((_props, ref) => {
  const props = useProps("PillsInput", defaultProps82, _props);
  const {
    children,
    onMouseDown,
    onClick,
    size: size4,
    disabled,
    __staticSelector,
    error,
    variant,
    ...others
  } = props;
  const fieldRef = import_react207.useRef(null);
  return /* @__PURE__ */ import_jsx_runtime169.jsx(PillsInputProvider, { value: { fieldRef, size: size4, disabled, hasError: !!error, variant }, children: /* @__PURE__ */ import_jsx_runtime169.jsx(InputBase, {
    size: size4,
    error,
    variant,
    component: "div",
    ref,
    onMouseDown: (event) => {
      event.preventDefault();
      onMouseDown?.(event);
      fieldRef.current?.focus();
    },
    onClick: (event) => {
      event.preventDefault();
      const fieldset = event.currentTarget.closest("fieldset");
      if (!fieldset?.disabled) {
        fieldRef.current?.focus();
        onClick?.(event);
      }
    },
    ...others,
    multiline: true,
    disabled,
    __staticSelector: __staticSelector || "PillsInput",
    withAria: false,
    children
  }) });
});
PillsInput.displayName = "@mantine/core/PillsInput";
PillsInput.Field = PillsInputField;

// node_modules/@mantine/core/esm/components/MultiSelect/filter-picked-values.mjs
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react208 = __toESM(require_react(), 1);
"use client";
function filterPickedValues({ data, value }) {
  const normalizedValue = value.map((item) => item.trim().toLowerCase());
  const filtered = data.reduce((acc, item) => {
    if (isOptionsGroup(item)) {
      acc.push({
        group: item.group,
        items: item.items.filter((option) => normalizedValue.indexOf(option.value.toLowerCase().trim()) === -1)
      });
    } else if (normalizedValue.indexOf(item.value.toLowerCase().trim()) === -1) {
      acc.push(item);
    }
    return acc;
  }, []);
  return filtered;
}

// node_modules/@mantine/core/esm/components/MultiSelect/MultiSelect.mjs
"use client";
var defaultProps83 = {
  maxValues: Infinity,
  withCheckIcon: true,
  checkIconPosition: "left",
  hiddenInputValuesDivider: ","
};
var MultiSelect = factory((_props, ref) => {
  const props = useProps("MultiSelect", defaultProps83, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size4,
    value,
    defaultValue,
    onChange,
    onKeyDown,
    variant,
    data,
    dropdownOpened,
    defaultDropdownOpened,
    onDropdownOpen,
    onDropdownClose,
    selectFirstOptionOnChange,
    onOptionSubmit,
    comboboxProps,
    filter: filter2,
    limit,
    withScrollArea,
    maxDropdownHeight,
    searchValue,
    defaultSearchValue,
    onSearchChange,
    readOnly,
    disabled,
    onFocus,
    onBlur,
    onPaste,
    radius,
    rightSection,
    rightSectionWidth,
    rightSectionPointerEvents,
    rightSectionProps,
    leftSection,
    leftSectionWidth,
    leftSectionPointerEvents,
    leftSectionProps,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    labelProps,
    descriptionProps,
    errorProps,
    wrapperProps,
    description,
    label,
    error,
    maxValues,
    searchable,
    nothingFoundMessage,
    withCheckIcon,
    checkIconPosition,
    hidePickedOptions,
    withErrorStyles,
    name,
    form,
    id,
    clearable,
    clearButtonProps,
    hiddenInputProps,
    placeholder,
    hiddenInputValuesDivider,
    required,
    mod,
    renderOption,
    onRemove,
    onClear,
    scrollAreaProps,
    chevronColor,
    ...others
  } = props;
  const _id = useId(id);
  const parsedData = getParsedComboboxData(data);
  const optionsLockup = getOptionsLockup(parsedData);
  const combobox = useCombobox({
    opened: dropdownOpened,
    defaultOpened: defaultDropdownOpened,
    onDropdownOpen,
    onDropdownClose: () => {
      onDropdownClose?.();
      combobox.resetSelectedOption();
    }
  });
  const {
    styleProps,
    rest: { type, autoComplete, ...rest }
  } = extractStyleProps(others);
  const [_value, setValue] = useUncontrolled({
    value,
    defaultValue,
    finalValue: [],
    onChange
  });
  const [_searchValue, setSearchValue] = useUncontrolled({
    value: searchValue,
    defaultValue: defaultSearchValue,
    finalValue: "",
    onChange: onSearchChange
  });
  const handleSearchChange = (value2) => {
    setSearchValue(value2);
    combobox.resetSelectedOption();
  };
  const getStyles2 = useStyles({
    name: "MultiSelect",
    classes: {},
    props,
    classNames,
    styles,
    unstyled
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    props,
    styles,
    classNames
  });
  const handleInputKeydown = (event) => {
    onKeyDown?.(event);
    if (event.key === " " && !searchable) {
      event.preventDefault();
      combobox.toggleDropdown();
    }
    if (event.key === "Backspace" && _searchValue.length === 0 && _value.length > 0) {
      onRemove?.(_value[_value.length - 1]);
      setValue(_value.slice(0, _value.length - 1));
    }
  };
  const values2 = _value.map((item, index4) => /* @__PURE__ */ import_jsx_runtime171.jsx(Pill, {
    withRemoveButton: !readOnly && !optionsLockup[item]?.disabled,
    onRemove: () => {
      setValue(_value.filter((i2) => item !== i2));
      onRemove?.(item);
    },
    unstyled,
    disabled,
    ...getStyles2("pill"),
    children: optionsLockup[item]?.label || item
  }, `${item}-${index4}`));
  import_react209.useEffect(() => {
    if (selectFirstOptionOnChange) {
      combobox.selectFirstOption();
    }
  }, [selectFirstOptionOnChange, _searchValue]);
  const clearButton = /* @__PURE__ */ import_jsx_runtime171.jsx(Combobox.ClearButton, {
    ...clearButtonProps,
    onClear: () => {
      onClear?.();
      setValue([]);
      handleSearchChange("");
    }
  });
  const filteredData = filterPickedValues({ data: parsedData, value: _value });
  const _clearable = clearable && _value.length > 0 && !disabled && !readOnly;
  return /* @__PURE__ */ import_jsx_runtime171.jsxs(import_jsx_runtime171.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime171.jsxs(Combobox, {
      store: combobox,
      classNames: resolvedClassNames,
      styles: resolvedStyles,
      unstyled,
      size: size4,
      readOnly,
      __staticSelector: "MultiSelect",
      onOptionSubmit: (val) => {
        onOptionSubmit?.(val);
        handleSearchChange("");
        combobox.updateSelectedOptionIndex("selected");
        if (_value.includes(optionsLockup[val].value)) {
          setValue(_value.filter((v2) => v2 !== optionsLockup[val].value));
          onRemove?.(optionsLockup[val].value);
        } else if (_value.length < maxValues) {
          setValue([..._value, optionsLockup[val].value]);
        }
      },
      ...comboboxProps,
      children: [
        /* @__PURE__ */ import_jsx_runtime171.jsx(Combobox.DropdownTarget, { children: /* @__PURE__ */ import_jsx_runtime171.jsx(PillsInput, {
          ...styleProps,
          __staticSelector: "MultiSelect",
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          size: size4,
          className,
          style: style2,
          variant,
          disabled,
          radius,
          __defaultRightSection: /* @__PURE__ */ import_jsx_runtime171.jsx(Combobox.Chevron, {
            size: size4,
            error,
            unstyled,
            color: chevronColor
          }),
          __clearSection: clearButton,
          __clearable: _clearable,
          rightSection,
          rightSectionPointerEvents: rightSectionPointerEvents || (clearButton ? "all" : "none"),
          rightSectionWidth,
          rightSectionProps,
          leftSection,
          leftSectionWidth,
          leftSectionPointerEvents,
          leftSectionProps,
          inputContainer,
          inputWrapperOrder,
          withAsterisk,
          labelProps,
          descriptionProps,
          errorProps,
          wrapperProps,
          description,
          label,
          error,
          withErrorStyles,
          __stylesApiProps: {
            ...props,
            rightSectionPointerEvents: rightSectionPointerEvents || (_clearable ? "all" : "none"),
            multiline: true
          },
          pointer: !searchable,
          onClick: () => searchable ? combobox.openDropdown() : combobox.toggleDropdown(),
          "data-expanded": combobox.dropdownOpened || undefined,
          id: _id,
          required,
          mod,
          children: /* @__PURE__ */ import_jsx_runtime171.jsxs(Pill.Group, { disabled, unstyled, ...getStyles2("pillsList"), children: [
            values2,
            /* @__PURE__ */ import_jsx_runtime171.jsx(Combobox.EventsTarget, { autoComplete, children: /* @__PURE__ */ import_jsx_runtime171.jsx(PillsInput.Field, {
              ...rest,
              ref,
              id: _id,
              placeholder,
              type: !searchable && !placeholder ? "hidden" : "visible",
              ...getStyles2("inputField"),
              unstyled,
              onFocus: (event) => {
                onFocus?.(event);
                searchable && combobox.openDropdown();
              },
              onBlur: (event) => {
                onBlur?.(event);
                combobox.closeDropdown();
                handleSearchChange("");
              },
              onKeyDown: handleInputKeydown,
              value: _searchValue,
              onChange: (event) => {
                handleSearchChange(event.currentTarget.value);
                searchable && combobox.openDropdown();
                selectFirstOptionOnChange && combobox.selectFirstOption();
              },
              disabled,
              readOnly: readOnly || !searchable,
              pointer: !searchable
            }) })
          ] })
        }) }),
        /* @__PURE__ */ import_jsx_runtime171.jsx(OptionsDropdown, {
          data: hidePickedOptions ? filteredData : parsedData,
          hidden: readOnly || disabled,
          filter: filter2,
          search: _searchValue,
          limit,
          hiddenWhenEmpty: !nothingFoundMessage,
          withScrollArea,
          maxDropdownHeight,
          filterOptions: searchable,
          value: _value,
          checkIconPosition,
          withCheckIcon,
          nothingFoundMessage,
          unstyled,
          labelId: label ? `${_id}-label` : undefined,
          "aria-label": label ? undefined : others["aria-label"],
          renderOption,
          scrollAreaProps
        })
      ]
    }),
    /* @__PURE__ */ import_jsx_runtime171.jsx(Combobox.HiddenInput, {
      name,
      valuesDivider: hiddenInputValuesDivider,
      value: _value,
      form,
      disabled,
      ...hiddenInputProps
    })
  ] });
});
MultiSelect.classes = { ...InputBase.classes, ...Combobox.classes };
MultiSelect.displayName = "@mantine/core/MultiSelect";
// node_modules/react-number-format/dist/react-number-format.es.js
var import_react210 = __toESM(require_react(), 1);
function __rest2(s2, e) {
  var t = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0) {
      t[p2] = s2[p2];
    }
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2);i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) {
        t[p2[i2]] = s2[p2[i2]];
      }
    }
  }
  return t;
}
var SourceType;
(function(SourceType2) {
  SourceType2["event"] = "event";
  SourceType2["props"] = "prop";
})(SourceType || (SourceType = {}));
function noop5() {
}
function memoizeOnce(cb) {
  var lastArgs;
  var lastValue = undefined;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (lastArgs && args.length === lastArgs.length && args.every(function(value, index4) {
      return value === lastArgs[index4];
    })) {
      return lastValue;
    }
    lastArgs = args;
    lastValue = cb.apply(undefined, args);
    return lastValue;
  };
}
function charIsNumber(char2) {
  return !!(char2 || "").match(/\d/);
}
function isNil(val) {
  return val === null || val === undefined;
}
function isNanValue(val) {
  return typeof val === "number" && isNaN(val);
}
function isNotValidValue(val) {
  return isNil(val) || isNanValue(val) || typeof val === "number" && !isFinite(val);
}
function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function getThousandsGroupRegex(thousandsGroupStyle) {
  switch (thousandsGroupStyle) {
    case "lakh":
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case "wan":
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case "thousand":
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
  var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
  var index4 = str.search(/[1-9]/);
  index4 = index4 === -1 ? str.length : index4;
  return str.substring(0, index4) + str.substring(index4, str.length).replace(thousandsGroupRegex, "$1" + thousandSeparator);
}
function usePersistentCallback(cb) {
  var callbackRef = import_react210.useRef(cb);
  callbackRef.current = cb;
  var persistentCbRef = import_react210.useRef(function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return callbackRef.current.apply(callbackRef, args);
  });
  return persistentCbRef.current;
}
function splitDecimal(numStr, allowNegative) {
  if (allowNegative === undefined)
    allowNegative = true;
  var hasNegation = numStr[0] === "-";
  var addNegation = hasNegation && allowNegative;
  numStr = numStr.replace("-", "");
  var parts = numStr.split(".");
  var beforeDecimal = parts[0];
  var afterDecimal = parts[1] || "";
  return {
    beforeDecimal,
    afterDecimal,
    hasNegation,
    addNegation
  };
}
function fixLeadingZero(numStr) {
  if (!numStr) {
    return numStr;
  }
  var isNegative = numStr[0] === "-";
  if (isNegative) {
    numStr = numStr.substring(1, numStr.length);
  }
  var parts = numStr.split(".");
  var beforeDecimal = parts[0].replace(/^0+/, "") || "0";
  var afterDecimal = parts[1] || "";
  return "" + (isNegative ? "-" : "") + beforeDecimal + (afterDecimal ? "." + afterDecimal : "");
}
function limitToScale(numStr, scale, fixedDecimalScale) {
  var str = "";
  var filler = fixedDecimalScale ? "0" : "";
  for (var i2 = 0;i2 <= scale - 1; i2++) {
    str += numStr[i2] || filler;
  }
  return str;
}
function repeat(str, count2) {
  return Array(count2 + 1).join(str);
}
function toNumericString(num) {
  var _num = num + "";
  var sign = _num[0] === "-" ? "-" : "";
  if (sign) {
    _num = _num.substring(1);
  }
  var ref = _num.split(/[eE]/g);
  var coefficient = ref[0];
  var exponent = ref[1];
  exponent = Number(exponent);
  if (!exponent) {
    return sign + coefficient;
  }
  coefficient = coefficient.replace(".", "");
  var decimalIndex = 1 + exponent;
  var coffiecientLn = coefficient.length;
  if (decimalIndex < 0) {
    coefficient = "0." + repeat("0", Math.abs(decimalIndex)) + coefficient;
  } else if (decimalIndex >= coffiecientLn) {
    coefficient = coefficient + repeat("0", decimalIndex - coffiecientLn);
  } else {
    coefficient = (coefficient.substring(0, decimalIndex) || "0") + "." + coefficient.substring(decimalIndex);
  }
  return sign + coefficient;
}
function roundToPrecision(numStr, scale, fixedDecimalScale) {
  if (["", "-"].indexOf(numStr) !== -1) {
    return numStr;
  }
  var shouldHaveDecimalSeparator = (numStr.indexOf(".") !== -1 || fixedDecimalScale) && scale;
  var ref = splitDecimal(numStr);
  var beforeDecimal = ref.beforeDecimal;
  var afterDecimal = ref.afterDecimal;
  var hasNegation = ref.hasNegation;
  var floatValue = parseFloat("0." + (afterDecimal || "0"));
  var floatValueStr = afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale);
  var roundedDecimalParts = floatValueStr.split(".");
  var intPart = beforeDecimal;
  if (beforeDecimal && Number(roundedDecimalParts[0])) {
    intPart = beforeDecimal.split("").reverse().reduce(function(roundedStr, current2, idx) {
      if (roundedStr.length > idx) {
        return (Number(roundedStr[0]) + Number(current2)).toString() + roundedStr.substring(1, roundedStr.length);
      }
      return current2 + roundedStr;
    }, roundedDecimalParts[0]);
  }
  var decimalPart = limitToScale(roundedDecimalParts[1] || "", scale, fixedDecimalScale);
  var negation = hasNegation ? "-" : "";
  var decimalSeparator = shouldHaveDecimalSeparator ? "." : "";
  return "" + negation + intPart + decimalSeparator + decimalPart;
}
function setCaretPosition(el, caretPos) {
  el.value = el.value;
  if (el !== null) {
    if (el.createTextRange) {
      var range = el.createTextRange();
      range.move("character", caretPos);
      range.select();
      return true;
    }
    if (el.selectionStart || el.selectionStart === 0) {
      el.focus();
      el.setSelectionRange(caretPos, caretPos);
      return true;
    }
    el.focus();
    return false;
  }
}
var findChangeRange = memoizeOnce(function(prevValue, newValue) {
  var i2 = 0, j2 = 0;
  var prevLength = prevValue.length;
  var newLength = newValue.length;
  while (prevValue[i2] === newValue[i2] && i2 < prevLength) {
    i2++;
  }
  while (prevValue[prevLength - 1 - j2] === newValue[newLength - 1 - j2] && newLength - j2 > i2 && prevLength - j2 > i2) {
    j2++;
  }
  return {
    from: { start: i2, end: prevLength - j2 },
    to: { start: i2, end: newLength - j2 }
  };
});
var findChangedRangeFromCaretPositions = function(lastCaretPositions, currentCaretPosition) {
  var startPosition = Math.min(lastCaretPositions.selectionStart, currentCaretPosition);
  return {
    from: { start: startPosition, end: lastCaretPositions.selectionEnd },
    to: { start: startPosition, end: currentCaretPosition }
  };
};
function clamp4(num, min2, max2) {
  return Math.min(Math.max(num, min2), max2);
}
function geInputCaretPosition(el) {
  return Math.max(el.selectionStart, el.selectionEnd);
}
function addInputMode() {
  return typeof navigator !== "undefined" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: value.length
    },
    lastValue: ""
  };
}
function defaultIsCharacterSame(ref) {
  var currentValue = ref.currentValue;
  var formattedValue = ref.formattedValue;
  var currentValueIndex = ref.currentValueIndex;
  var formattedValueIndex = ref.formattedValueIndex;
  return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, isCharacterSame) {
  if (isCharacterSame === undefined)
    isCharacterSame = defaultIsCharacterSame;
  var firstAllowedPosition = boundary.findIndex(function(b) {
    return b;
  });
  var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
  if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
    lastFormattedValue = prefixFormat;
    curValue = prefixFormat + curValue;
    curCaretPos = curCaretPos + prefixFormat.length;
  }
  var curValLn = curValue.length;
  var formattedValueLn = newFormattedValue.length;
  var addedIndexMap = {};
  var indexMap = new Array(curValLn);
  for (var i2 = 0;i2 < curValLn; i2++) {
    indexMap[i2] = -1;
    for (var j2 = 0, jLn = formattedValueLn;j2 < jLn; j2++) {
      var isCharSame = isCharacterSame({
        currentValue: curValue,
        lastValue: lastFormattedValue,
        formattedValue: newFormattedValue,
        currentValueIndex: i2,
        formattedValueIndex: j2
      });
      if (isCharSame && addedIndexMap[j2] !== true) {
        indexMap[i2] = j2;
        addedIndexMap[j2] = true;
        break;
      }
    }
  }
  var pos = curCaretPos;
  while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) {
    pos++;
  }
  var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
  pos = curCaretPos - 1;
  while (pos > 0 && indexMap[pos] === -1) {
    pos--;
  }
  var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
  if (startIndex > endIndex) {
    return endIndex;
  }
  return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
function getCaretPosInBoundary(value, caretPos, boundary, direction) {
  var valLn = value.length;
  caretPos = clamp4(caretPos, 0, valLn);
  if (direction === "left") {
    while (caretPos >= 0 && !boundary[caretPos]) {
      caretPos--;
    }
    if (caretPos === -1) {
      caretPos = boundary.indexOf(true);
    }
  } else {
    while (caretPos <= valLn && !boundary[caretPos]) {
      caretPos++;
    }
    if (caretPos > valLn) {
      caretPos = boundary.lastIndexOf(true);
    }
  }
  if (caretPos === -1) {
    caretPos = valLn;
  }
  return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  for (var i2 = 0, ln = boundaryAry.length;i2 < ln; i2++) {
    boundaryAry[i2] = Boolean(charIsNumber(formattedValue[i2]) || charIsNumber(formattedValue[i2 - 1]));
  }
  return boundaryAry;
}
function useInternalValues(value, defaultValue, valueIsNumericString, format, removeFormatting, onValueChange) {
  if (onValueChange === undefined)
    onValueChange = noop5;
  var getValues = usePersistentCallback(function(value2, valueIsNumericString2) {
    var formattedValue, numAsString;
    if (isNotValidValue(value2)) {
      numAsString = "";
      formattedValue = "";
    } else if (typeof value2 === "number" || valueIsNumericString2) {
      numAsString = typeof value2 === "number" ? toNumericString(value2) : value2;
      formattedValue = format(numAsString);
    } else {
      numAsString = removeFormatting(value2, undefined);
      formattedValue = format(numAsString);
    }
    return { formattedValue, numAsString };
  });
  var ref = import_react210.useState(function() {
    return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);
  });
  var values2 = ref[0];
  var setValues = ref[1];
  var _onValueChange = function(newValues2, sourceInfo) {
    if (newValues2.formattedValue !== values2.formattedValue) {
      setValues({
        formattedValue: newValues2.formattedValue,
        numAsString: newValues2.value
      });
    }
    onValueChange(newValues2, sourceInfo);
  };
  var _value = value;
  var _valueIsNumericString = valueIsNumericString;
  if (isNil(value)) {
    _value = values2.numAsString;
    _valueIsNumericString = true;
  }
  var newValues = getValues(_value, _valueIsNumericString);
  import_react210.useMemo(function() {
    setValues(newValues);
  }, [newValues.formattedValue]);
  return [values2, _onValueChange];
}
function defaultRemoveFormatting(value) {
  return value.replace(/[^0-9]/g, "");
}
function defaultFormat(value) {
  return value;
}
function NumberFormatBase(props) {
  var type = props.type;
  if (type === undefined)
    type = "text";
  var displayType = props.displayType;
  if (displayType === undefined)
    displayType = "input";
  var customInput = props.customInput;
  var renderText = props.renderText;
  var getInputRef = props.getInputRef;
  var format = props.format;
  if (format === undefined)
    format = defaultFormat;
  var removeFormatting = props.removeFormatting;
  if (removeFormatting === undefined)
    removeFormatting = defaultRemoveFormatting;
  var defaultValue = props.defaultValue;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var isAllowed = props.isAllowed;
  var onChange = props.onChange;
  if (onChange === undefined)
    onChange = noop5;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === undefined)
    onKeyDown = noop5;
  var onMouseUp = props.onMouseUp;
  if (onMouseUp === undefined)
    onMouseUp = noop5;
  var onFocus = props.onFocus;
  if (onFocus === undefined)
    onFocus = noop5;
  var onBlur = props.onBlur;
  if (onBlur === undefined)
    onBlur = noop5;
  var propValue = props.value;
  var getCaretBoundary = props.getCaretBoundary;
  if (getCaretBoundary === undefined)
    getCaretBoundary = caretUnknownFormatBoundary;
  var isValidInputCharacter = props.isValidInputCharacter;
  if (isValidInputCharacter === undefined)
    isValidInputCharacter = charIsNumber;
  var isCharacterSame = props.isCharacterSame;
  var otherProps = __rest2(props, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]);
  var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format, removeFormatting, onValueChange);
  var ref_0 = ref[0];
  var formattedValue = ref_0.formattedValue;
  var numAsString = ref_0.numAsString;
  var onFormattedValueChange = ref[1];
  var caretPositionBeforeChange = import_react210.useRef();
  var lastUpdatedValue = import_react210.useRef({ formattedValue, numAsString });
  var _onValueChange = function(values2, source) {
    lastUpdatedValue.current = { formattedValue: values2.formattedValue, numAsString: values2.value };
    onFormattedValueChange(values2, source);
  };
  var ref$1 = import_react210.useState(false);
  var mounted = ref$1[0];
  var setMounted = ref$1[1];
  var focusedElm = import_react210.useRef(null);
  var timeout = import_react210.useRef({
    setCaretTimeout: null,
    focusTimeout: null
  });
  import_react210.useEffect(function() {
    setMounted(true);
    return function() {
      clearTimeout(timeout.current.setCaretTimeout);
      clearTimeout(timeout.current.focusTimeout);
    };
  }, []);
  var _format = format;
  var getValueObject = function(formattedValue2, numAsString2) {
    var floatValue = parseFloat(numAsString2);
    return {
      formattedValue: formattedValue2,
      value: numAsString2,
      floatValue: isNaN(floatValue) ? undefined : floatValue
    };
  };
  var setPatchedCaretPosition = function(el, caretPos, currentValue) {
    if (el.selectionStart === 0 && el.selectionEnd === el.value.length) {
      return;
    }
    setCaretPosition(el, caretPos);
    timeout.current.setCaretTimeout = setTimeout(function() {
      if (el.value === currentValue && el.selectionStart !== caretPos) {
        setCaretPosition(el, caretPos);
      }
    }, 0);
  };
  var correctCaretPosition = function(value, caretPos, direction) {
    return getCaretPosInBoundary(value, caretPos, getCaretBoundary(value), direction);
  };
  var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {
    var caretBoundary = getCaretBoundary(newFormattedValue);
    var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);
    updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
    return updatedCaretPos;
  };
  var updateValueAndCaretPosition = function(params) {
    var newFormattedValue = params.formattedValue;
    if (newFormattedValue === undefined)
      newFormattedValue = "";
    var input = params.input;
    var source = params.source;
    var event = params.event;
    var numAsString2 = params.numAsString;
    var caretPos;
    if (input) {
      var inputValue = params.inputValue || input.value;
      var currentCaretPosition2 = geInputCaretPosition(input);
      input.value = newFormattedValue;
      caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition2);
      if (caretPos !== undefined) {
        setPatchedCaretPosition(input, caretPos, newFormattedValue);
      }
    }
    if (newFormattedValue !== formattedValue) {
      _onValueChange(getValueObject(newFormattedValue, numAsString2), { event, source });
    }
  };
  import_react210.useEffect(function() {
    var ref2 = lastUpdatedValue.current;
    var lastFormattedValue = ref2.formattedValue;
    var lastNumAsString = ref2.numAsString;
    if (formattedValue !== lastFormattedValue || numAsString !== lastNumAsString) {
      _onValueChange(getValueObject(formattedValue, numAsString), {
        event: undefined,
        source: SourceType.props
      });
    }
  }, [formattedValue, numAsString]);
  var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : undefined;
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react210.useLayoutEffect : import_react210.useEffect;
  useIsomorphicLayoutEffect2(function() {
    var input = focusedElm.current;
    if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
      var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
    }
  }, [formattedValue]);
  var formatInputValue = function(inputValue, event, source) {
    var input = event.target;
    var changeRange = caretPositionBeforeChange.current ? findChangedRangeFromCaretPositions(caretPositionBeforeChange.current, input.selectionEnd) : findChangeRange(formattedValue, inputValue);
    var changeMeta = Object.assign(Object.assign({}, changeRange), { lastValue: formattedValue });
    var _numAsString = removeFormatting(inputValue, changeMeta);
    var _formattedValue = _format(_numAsString);
    _numAsString = removeFormatting(_formattedValue, undefined);
    if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
      var input$1 = event.target;
      var currentCaretPosition2 = geInputCaretPosition(input$1);
      var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition2);
      input$1.value = formattedValue;
      setPatchedCaretPosition(input$1, caretPos, formattedValue);
      return false;
    }
    updateValueAndCaretPosition({
      formattedValue: _formattedValue,
      numAsString: _numAsString,
      inputValue,
      event,
      source,
      input: event.target
    });
    return true;
  };
  var setCaretPositionInfoBeforeChange = function(el, endOffset) {
    if (endOffset === undefined)
      endOffset = 0;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    caretPositionBeforeChange.current = { selectionStart, selectionEnd: selectionEnd + endOffset };
  };
  var _onChange = function(e) {
    var el = e.target;
    var inputValue = el.value;
    var changed = formatInputValue(inputValue, e, SourceType.event);
    if (changed) {
      onChange(e);
    }
    caretPositionBeforeChange.current = undefined;
  };
  var _onKeyDown = function(e) {
    var el = e.target;
    var key = e.key;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value = el.value;
    if (value === undefined)
      value = "";
    var expectedCaretPosition;
    if (key === "ArrowLeft" || key === "Backspace") {
      expectedCaretPosition = Math.max(selectionStart - 1, 0);
    } else if (key === "ArrowRight") {
      expectedCaretPosition = Math.min(selectionStart + 1, value.length);
    } else if (key === "Delete") {
      expectedCaretPosition = selectionStart;
    }
    var endOffset = 0;
    if (key === "Delete" && selectionStart === selectionEnd) {
      endOffset = 1;
    }
    var isArrowKey = key === "ArrowLeft" || key === "ArrowRight";
    if (expectedCaretPosition === undefined || selectionStart !== selectionEnd && !isArrowKey) {
      onKeyDown(e);
      setCaretPositionInfoBeforeChange(el, endOffset);
      return;
    }
    var newCaretPosition = expectedCaretPosition;
    if (isArrowKey) {
      var direction = key === "ArrowLeft" ? "left" : "right";
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);
      if (newCaretPosition !== expectedCaretPosition) {
        e.preventDefault();
      }
    } else if (key === "Delete" && !isValidInputCharacter(value[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "right");
    } else if (key === "Backspace" && !isValidInputCharacter(value[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "left");
    }
    if (newCaretPosition !== expectedCaretPosition) {
      setPatchedCaretPosition(el, newCaretPosition, value);
    }
    onKeyDown(e);
    setCaretPositionInfoBeforeChange(el, endOffset);
  };
  var _onMouseUp = function(e) {
    var el = e.target;
    var correctCaretPositionIfRequired = function() {
      var selectionStart = el.selectionStart;
      var selectionEnd = el.selectionEnd;
      var value = el.value;
      if (value === undefined)
        value = "";
      if (selectionStart === selectionEnd) {
        var caretPosition = correctCaretPosition(value, selectionStart);
        if (caretPosition !== selectionStart) {
          setPatchedCaretPosition(el, caretPosition, value);
        }
      }
    };
    correctCaretPositionIfRequired();
    requestAnimationFrame(function() {
      correctCaretPositionIfRequired();
    });
    onMouseUp(e);
    setCaretPositionInfoBeforeChange(el);
  };
  var _onFocus = function(e) {
    if (e.persist) {
      e.persist();
    }
    var el = e.target;
    var currentTarget = e.currentTarget;
    focusedElm.current = el;
    timeout.current.focusTimeout = setTimeout(function() {
      var selectionStart = el.selectionStart;
      var selectionEnd = el.selectionEnd;
      var value = el.value;
      if (value === undefined)
        value = "";
      var caretPosition = correctCaretPosition(value, selectionStart);
      if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {
        setPatchedCaretPosition(el, caretPosition, value);
      }
      onFocus(Object.assign(Object.assign({}, e), { currentTarget }));
    }, 0);
  };
  var _onBlur = function(e) {
    focusedElm.current = null;
    clearTimeout(timeout.current.focusTimeout);
    clearTimeout(timeout.current.setCaretTimeout);
    onBlur(e);
  };
  var inputMode = mounted && addInputMode() ? "numeric" : undefined;
  var inputProps = Object.assign({ inputMode }, otherProps, {
    type,
    value: formattedValue,
    onChange: _onChange,
    onKeyDown: _onKeyDown,
    onMouseUp: _onMouseUp,
    onFocus: _onFocus,
    onBlur: _onBlur
  });
  if (displayType === "text") {
    return renderText ? import_react210.default.createElement(import_react210.default.Fragment, null, renderText(formattedValue, otherProps) || null) : import_react210.default.createElement("span", Object.assign({}, otherProps, { ref: getInputRef }), formattedValue);
  } else if (customInput) {
    var CustomInput = customInput;
    return import_react210.default.createElement(CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
  }
  return import_react210.default.createElement("input", Object.assign({}, inputProps, { ref: getInputRef }));
}
function format(numStr, props) {
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix3 = props.prefix;
  if (prefix3 === undefined)
    prefix3 = "";
  var suffix2 = props.suffix;
  if (suffix2 === undefined)
    suffix2 = "";
  var allowNegative = props.allowNegative;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  if (thousandsGroupStyle === undefined)
    thousandsGroupStyle = "thousand";
  if (numStr === "" || numStr === "-") {
    return numStr;
  }
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(".") !== -1 || decimalScale && fixedDecimalScale;
  var ref$1 = splitDecimal(numStr, allowNegative);
  var beforeDecimal = ref$1.beforeDecimal;
  var afterDecimal = ref$1.afterDecimal;
  var addNegation = ref$1.addNegation;
  if (decimalScale !== undefined) {
    afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
  }
  if (thousandSeparator) {
    beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
  }
  if (prefix3) {
    beforeDecimal = prefix3 + beforeDecimal;
  }
  if (suffix2) {
    afterDecimal = afterDecimal + suffix2;
  }
  if (addNegation) {
    beforeDecimal = "-" + beforeDecimal;
  }
  numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || "") + afterDecimal;
  return numStr;
}
function getSeparators(props) {
  var decimalSeparator = props.decimalSeparator;
  if (decimalSeparator === undefined)
    decimalSeparator = ".";
  var thousandSeparator = props.thousandSeparator;
  var allowedDecimalSeparators = props.allowedDecimalSeparators;
  if (thousandSeparator === true) {
    thousandSeparator = ",";
  }
  if (!allowedDecimalSeparators) {
    allowedDecimalSeparators = [decimalSeparator, "."];
  }
  return {
    decimalSeparator,
    thousandSeparator,
    allowedDecimalSeparators
  };
}
function handleNegation(value, allowNegative) {
  if (value === undefined)
    value = "";
  var negationRegex = new RegExp("(-)");
  var doubleNegationRegex = new RegExp("(-)(.)*(-)");
  var hasNegation = negationRegex.test(value);
  var removeNegation = doubleNegationRegex.test(value);
  value = value.replace(/-/g, "");
  if (hasNegation && !removeNegation && allowNegative) {
    value = "-" + value;
  }
  return value;
}
function getNumberRegex(decimalSeparator, global2) {
  return new RegExp("(^-)|[0-9]|" + escapeRegExp(decimalSeparator), global2 ? "g" : undefined);
}
function isNumericString(val, prefix3, suffix2) {
  if (val === "") {
    return true;
  }
  return !(prefix3 === null || prefix3 === undefined ? undefined : prefix3.match(/\d/)) && !(suffix2 === null || suffix2 === undefined ? undefined : suffix2.match(/\d/)) && typeof val === "string" && !isNaN(Number(val));
}
function removeFormatting(value, changeMeta, props) {
  var assign4;
  if (changeMeta === undefined)
    changeMeta = getDefaultChangeMeta(value);
  var allowNegative = props.allowNegative;
  var prefix3 = props.prefix;
  if (prefix3 === undefined)
    prefix3 = "";
  var suffix2 = props.suffix;
  if (suffix2 === undefined)
    suffix2 = "";
  var decimalScale = props.decimalScale;
  var from2 = changeMeta.from;
  var to = changeMeta.to;
  var start = to.start;
  var end = to.end;
  var ref = getSeparators(props);
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var decimalSeparator = ref.decimalSeparator;
  var isBeforeDecimalSeparator = value[end] === decimalSeparator;
  if (charIsNumber(value) && (value === prefix3 || value === suffix2) && changeMeta.lastValue === "") {
    return value;
  }
  if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {
    var separator = decimalScale === 0 ? "" : decimalSeparator;
    value = value.substring(0, start) + separator + value.substring(start + 1, value.length);
  }
  var stripNegation = function(value2, start2, end2) {
    var hasNegation2 = false;
    var hasDoubleNegation = false;
    if (prefix3.startsWith("-")) {
      hasNegation2 = false;
    } else if (value2.startsWith("--")) {
      hasNegation2 = false;
      hasDoubleNegation = true;
    } else if (suffix2.startsWith("-") && value2.length === suffix2.length) {
      hasNegation2 = false;
    } else if (value2[0] === "-") {
      hasNegation2 = true;
    }
    var charsToRemove = hasNegation2 ? 1 : 0;
    if (hasDoubleNegation) {
      charsToRemove = 2;
    }
    if (charsToRemove) {
      value2 = value2.substring(charsToRemove);
      start2 -= charsToRemove;
      end2 -= charsToRemove;
    }
    return { value: value2, start: start2, end: end2, hasNegation: hasNegation2 };
  };
  var toMetadata = stripNegation(value, start, end);
  var hasNegation = toMetadata.hasNegation;
  assign4 = toMetadata, value = assign4.value, start = assign4.start, end = assign4.end;
  var ref$1 = stripNegation(changeMeta.lastValue, from2.start, from2.end);
  var fromStart = ref$1.start;
  var fromEnd = ref$1.end;
  var lastValue = ref$1.value;
  var updatedSuffixPart = value.substring(start, end);
  if (value.length && lastValue.length && (fromStart > lastValue.length - suffix2.length || fromEnd < prefix3.length) && !(updatedSuffixPart && suffix2.startsWith(updatedSuffixPart))) {
    value = lastValue;
  }
  var startIndex = 0;
  if (value.startsWith(prefix3)) {
    startIndex += prefix3.length;
  } else if (start < prefix3.length) {
    startIndex = start;
  }
  value = value.substring(startIndex);
  end -= startIndex;
  var endIndex = value.length;
  var suffixStartIndex = value.length - suffix2.length;
  if (value.endsWith(suffix2)) {
    endIndex = suffixStartIndex;
  } else if (end > suffixStartIndex) {
    endIndex = end;
  } else if (end > value.length - suffix2.length) {
    endIndex = end;
  }
  value = value.substring(0, endIndex);
  value = handleNegation(hasNegation ? "-" + value : value, allowNegative);
  value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join("");
  var firstIndex = value.indexOf(decimalSeparator);
  value = value.replace(new RegExp(escapeRegExp(decimalSeparator), "g"), function(match2, index4) {
    return index4 === firstIndex ? "." : "";
  });
  var ref$2 = splitDecimal(value, allowNegative);
  var beforeDecimal = ref$2.beforeDecimal;
  var afterDecimal = ref$2.afterDecimal;
  var addNegation = ref$2.addNegation;
  if (to.end - to.start < from2.end - from2.start && beforeDecimal === "" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {
    value = addNegation ? "-" : "";
  }
  return value;
}
function getCaretBoundary(formattedValue, props) {
  var prefix3 = props.prefix;
  if (prefix3 === undefined)
    prefix3 = "";
  var suffix2 = props.suffix;
  if (suffix2 === undefined)
    suffix2 = "";
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  var hasNegation = formattedValue[0] === "-";
  boundaryAry.fill(false, 0, prefix3.length + (hasNegation ? 1 : 0));
  var valLn = formattedValue.length;
  boundaryAry.fill(false, valLn - suffix2.length + 1, valLn + 1);
  return boundaryAry;
}
function validateAndUpdateProps(props) {
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  var prefix3 = props.prefix;
  if (prefix3 === undefined)
    prefix3 = "";
  var allowNegative = props.allowNegative;
  if (allowNegative === undefined)
    allowNegative = true;
  if (thousandSeparator === decimalSeparator) {
    throw new Error(`
        Decimal separator can't be same as thousand separator.
        thousandSeparator: ` + thousandSeparator + ` (thousandSeparator = {true} is same as thousandSeparator = ",")
        decimalSeparator: ` + decimalSeparator + ` (default value for decimalSeparator is .)
     `);
  }
  if (prefix3.startsWith("-") && allowNegative) {
    console.error(`
      Prefix can't start with '-' when allowNegative is true.
      prefix: ` + prefix3 + `
      allowNegative: ` + allowNegative + `
    `);
    allowNegative = false;
  }
  return Object.assign(Object.assign({}, props), { allowNegative });
}
function useNumericFormat(props) {
  props = validateAndUpdateProps(props);
  var _decimalSeparator = props.decimalSeparator;
  var _allowedDecimalSeparators = props.allowedDecimalSeparators;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  var suffix2 = props.suffix;
  var allowNegative = props.allowNegative;
  var allowLeadingZeros = props.allowLeadingZeros;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === undefined)
    onKeyDown = noop5;
  var onBlur = props.onBlur;
  if (onBlur === undefined)
    onBlur = noop5;
  var thousandSeparator = props.thousandSeparator;
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix3 = props.prefix;
  if (prefix3 === undefined)
    prefix3 = "";
  var defaultValue = props.defaultValue;
  var value = props.value;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var restProps = __rest2(props, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]);
  var ref = getSeparators(props);
  var decimalSeparator = ref.decimalSeparator;
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var _format = function(numStr) {
    return format(numStr, props);
  };
  var _removeFormatting = function(inputValue, changeMeta) {
    return removeFormatting(inputValue, changeMeta, props);
  };
  var _value = isNil(value) ? defaultValue : value;
  var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== undefined ? valueIsNumericString : isNumericString(_value, prefix3, suffix2);
  if (!isNil(value)) {
    _valueIsNumericString = _valueIsNumericString || typeof value === "number";
  } else if (!isNil(defaultValue)) {
    _valueIsNumericString = _valueIsNumericString || typeof defaultValue === "number";
  }
  var roundIncomingValueToPrecision = function(value2) {
    if (isNotValidValue(value2)) {
      return value2;
    }
    if (typeof value2 === "number") {
      value2 = toNumericString(value2);
    }
    if (_valueIsNumericString && typeof decimalScale === "number") {
      return roundToPrecision(value2, decimalScale, Boolean(fixedDecimalScale));
    }
    return value2;
  };
  var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
  var ref$1_0 = ref$1[0];
  var numAsString = ref$1_0.numAsString;
  var formattedValue = ref$1_0.formattedValue;
  var _onValueChange = ref$1[1];
  var _onKeyDown = function(e) {
    var el = e.target;
    var key = e.key;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value2 = el.value;
    if (value2 === undefined)
      value2 = "";
    if ((key === "Backspace" || key === "Delete") && selectionEnd < prefix3.length) {
      e.preventDefault();
      return;
    }
    if (selectionStart !== selectionEnd) {
      onKeyDown(e);
      return;
    }
    if (key === "Backspace" && value2[0] === "-" && selectionStart === prefix3.length + 1 && allowNegative) {
      setCaretPosition(el, 1);
    }
    if (decimalScale && fixedDecimalScale) {
      if (key === "Backspace" && value2[selectionStart - 1] === decimalSeparator) {
        setCaretPosition(el, selectionStart - 1);
        e.preventDefault();
      } else if (key === "Delete" && value2[selectionStart] === decimalSeparator) {
        e.preventDefault();
      }
    }
    if ((allowedDecimalSeparators === null || allowedDecimalSeparators === undefined ? undefined : allowedDecimalSeparators.includes(key)) && value2[selectionStart] === decimalSeparator) {
      setCaretPosition(el, selectionStart + 1);
    }
    var _thousandSeparator = thousandSeparator === true ? "," : thousandSeparator;
    if (key === "Backspace" && value2[selectionStart - 1] === _thousandSeparator) {
      setCaretPosition(el, selectionStart - 1);
    }
    if (key === "Delete" && value2[selectionStart] === _thousandSeparator) {
      setCaretPosition(el, selectionStart + 1);
    }
    onKeyDown(e);
  };
  var _onBlur = function(e) {
    var _value2 = numAsString;
    if (!_value2.match(/\d/g)) {
      _value2 = "";
    }
    if (!allowLeadingZeros) {
      _value2 = fixLeadingZero(_value2);
    }
    if (fixedDecimalScale && decimalScale) {
      _value2 = roundToPrecision(_value2, decimalScale, fixedDecimalScale);
    }
    if (_value2 !== numAsString) {
      var formattedValue2 = format(_value2, props);
      _onValueChange({
        formattedValue: formattedValue2,
        value: _value2,
        floatValue: parseFloat(_value2)
      }, {
        event: e,
        source: SourceType.event
      });
    }
    onBlur(e);
  };
  var isValidInputCharacter = function(inputChar) {
    if (inputChar === decimalSeparator) {
      return true;
    }
    return charIsNumber(inputChar);
  };
  var isCharacterSame = function(ref2) {
    var currentValue = ref2.currentValue;
    var lastValue = ref2.lastValue;
    var formattedValue2 = ref2.formattedValue;
    var currentValueIndex = ref2.currentValueIndex;
    var formattedValueIndex = ref2.formattedValueIndex;
    var curChar = currentValue[currentValueIndex];
    var newChar = formattedValue2[formattedValueIndex];
    var typedRange = findChangeRange(lastValue, currentValue);
    var to = typedRange.to;
    var getDecimalSeparatorIndex = function(value2) {
      return _removeFormatting(value2).indexOf(".") + prefix3.length;
    };
    if (value === 0 && fixedDecimalScale && decimalScale && currentValue[to.start] === decimalSeparator && getDecimalSeparatorIndex(currentValue) < currentValueIndex && getDecimalSeparatorIndex(formattedValue2) > formattedValueIndex) {
      return false;
    }
    if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) {
      return true;
    }
    return curChar === newChar;
  };
  return Object.assign(Object.assign({}, restProps), {
    value: formattedValue,
    valueIsNumericString: false,
    isValidInputCharacter,
    isCharacterSame,
    onValueChange: _onValueChange,
    format: _format,
    removeFormatting: _removeFormatting,
    getCaretBoundary: function(formattedValue2) {
      return getCaretBoundary(formattedValue2, props);
    },
    onKeyDown: _onKeyDown,
    onBlur: _onBlur
  });
}
function NumericFormat(props) {
  var numericFormatProps = useNumericFormat(props);
  return import_react210.default.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}

// node_modules/@mantine/core/esm/components/NumberInput/NumberInput.mjs
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react211 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/NumberInput/NumberInputChevron.mjs
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
"use client";
function NumberInputChevron({ direction, style: style2, ...others }) {
  return /* @__PURE__ */ import_jsx_runtime172.jsx("svg", {
    style: {
      width: "var(--ni-chevron-size)",
      height: "var(--ni-chevron-size)",
      transform: direction === "up" ? "rotate(180deg)" : undefined,
      ...style2
    },
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime172.jsx("path", {
      d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
      fill: "currentColor",
      fillRule: "evenodd",
      clipRule: "evenodd"
    })
  });
}

// node_modules/@mantine/core/esm/components/NumberInput/NumberInput.module.css.mjs
"use client";
var classes33 = { root: "m_e2f5cd4e", controls: "m_95e17d22", control: "m_80b4b171" };

// node_modules/@mantine/core/esm/components/NumberInput/NumberInput.mjs
"use client";
var leadingDecimalZeroPattern = /^(0\.0*|-0(\.0*)?)$/;
var leadingZerosPattern = /^-?0\d+(\.\d+)?\.?$/;
function isNumberString(value) {
  return typeof value === "string" && value !== "" && !Number.isNaN(Number(value));
}
function canIncrement(value) {
  if (typeof value === "number") {
    return value < Number.MAX_SAFE_INTEGER;
  }
  return value === "" || isNumberString(value) && Number(value) < Number.MAX_SAFE_INTEGER;
}
function getDecimalPlaces(inputValue) {
  return inputValue.toString().replace(".", "").length;
}
function isValidNumber(floatValue, value) {
  return (typeof floatValue === "number" ? floatValue < Number.MAX_SAFE_INTEGER : !Number.isNaN(Number(floatValue))) && !Number.isNaN(floatValue) && getDecimalPlaces(value) < 14 && value !== "";
}
function isInRange(value, min2, max2) {
  if (value === undefined) {
    return true;
  }
  const minValid = min2 === undefined || value >= min2;
  const maxValid = max2 === undefined || value <= max2;
  return minValid && maxValid;
}
var defaultProps84 = {
  step: 1,
  clampBehavior: "blur",
  allowDecimal: true,
  allowNegative: true,
  withKeyboardEvents: true,
  allowLeadingZeros: true,
  trimLeadingZeroesOnBlur: true,
  startValue: 0
};
var varsResolver35 = createVarsResolver((_2, { size: size4 }) => ({
  controls: {
    "--ni-chevron-size": getSize(size4, "ni-chevron-size")
  }
}));
function clampAndSanitizeInput(sanitizedValue, max2, min2) {
  const replaced = sanitizedValue.toString().replace(/^0+/, "");
  const parsedValue = parseFloat(replaced);
  if (Number.isNaN(parsedValue)) {
    return replaced;
  } else if (parsedValue > Number.MAX_SAFE_INTEGER) {
    return max2 !== undefined ? String(max2) : replaced;
  }
  return clamp(parsedValue, min2, max2);
}
var NumberInput = factory((_props, ref) => {
  const props = useProps("NumberInput", defaultProps84, _props);
  const {
    className,
    classNames,
    styles,
    unstyled,
    vars,
    onChange,
    onValueChange,
    value,
    defaultValue,
    max: max2,
    min: min2,
    step,
    hideControls,
    rightSection,
    isAllowed,
    clampBehavior,
    onBlur,
    allowDecimal,
    decimalScale,
    onKeyDown,
    onKeyDownCapture,
    handlersRef,
    startValue,
    disabled,
    rightSectionPointerEvents,
    allowNegative,
    readOnly,
    size: size4,
    rightSectionWidth,
    stepHoldInterval,
    stepHoldDelay,
    allowLeadingZeros,
    withKeyboardEvents,
    trimLeadingZeroesOnBlur,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "NumberInput",
    classes: classes33,
    props,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver35
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const [_value, setValue] = useUncontrolled({
    value,
    defaultValue,
    finalValue: "",
    onChange
  });
  const shouldUseStepInterval = stepHoldDelay !== undefined && stepHoldInterval !== undefined;
  const inputRef = import_react211.useRef(null);
  const onStepTimeoutRef = import_react211.useRef(null);
  const stepCountRef = import_react211.useRef(0);
  const handleValueChange = (payload, event) => {
    if (event.source === "event") {
      setValue(isValidNumber(payload.floatValue, payload.value) && !leadingDecimalZeroPattern.test(payload.value) && !(allowLeadingZeros ? leadingZerosPattern.test(payload.value) : false) ? payload.floatValue : payload.value);
    }
    onValueChange?.(payload, event);
  };
  const getDecimalPlaces2 = (inputValue) => {
    const match2 = String(inputValue).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match2) {
      return 0;
    }
    return Math.max(0, (match2[1] ? match2[1].length : 0) - (match2[2] ? +match2[2] : 0));
  };
  const adjustCursor = (position2) => {
    if (inputRef.current && typeof position2 !== "undefined") {
      inputRef.current.setSelectionRange(position2, position2);
    }
  };
  const incrementRef = import_react211.useRef(noop4);
  incrementRef.current = () => {
    if (!canIncrement(_value)) {
      return;
    }
    let val;
    const currentValuePrecision = getDecimalPlaces2(_value);
    const stepPrecision = getDecimalPlaces2(step);
    const maxPrecision = Math.max(currentValuePrecision, stepPrecision);
    const factor = 10 ** maxPrecision;
    if (!isNumberString(_value) && (typeof _value !== "number" || Number.isNaN(_value))) {
      val = clamp(startValue, min2, max2);
    } else if (max2 !== undefined) {
      const incrementedValue = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;
      val = incrementedValue <= max2 ? incrementedValue : max2;
    } else {
      val = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;
    }
    const formattedValue = val.toFixed(maxPrecision);
    setValue(parseFloat(formattedValue));
    onValueChange?.({ floatValue: parseFloat(formattedValue), formattedValue, value: formattedValue }, { source: "increment" });
    setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);
  };
  const decrementRef = import_react211.useRef(noop4);
  decrementRef.current = () => {
    if (!canIncrement(_value)) {
      return;
    }
    let val;
    const minValue = min2 !== undefined ? min2 : !allowNegative ? 0 : Number.MIN_SAFE_INTEGER;
    const currentValuePrecision = getDecimalPlaces2(_value);
    const stepPrecision = getDecimalPlaces2(step);
    const maxPrecision = Math.max(currentValuePrecision, stepPrecision);
    const factor = 10 ** maxPrecision;
    if (!isNumberString(_value) && typeof _value !== "number" || Number.isNaN(_value)) {
      val = clamp(startValue, minValue, max2);
    } else {
      const decrementedValue = (Math.round(Number(_value) * factor) - Math.round(step * factor)) / factor;
      val = minValue !== undefined && decrementedValue < minValue ? minValue : decrementedValue;
    }
    const formattedValue = val.toFixed(maxPrecision);
    setValue(parseFloat(formattedValue));
    onValueChange?.({ floatValue: parseFloat(formattedValue), formattedValue, value: formattedValue }, { source: "decrement" });
    setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);
  };
  const handleKeyDown = (event) => {
    onKeyDown?.(event);
    if (readOnly || !withKeyboardEvents) {
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      incrementRef.current();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      decrementRef.current();
    }
  };
  const handleKeyDownCapture = (event) => {
    onKeyDownCapture?.(event);
    if (event.key === "Backspace") {
      const input = inputRef.current;
      if (input.selectionStart === 0 && input.selectionStart === input.selectionEnd) {
        event.preventDefault();
        window.setTimeout(() => adjustCursor(0), 0);
      }
    }
  };
  const handleBlur = (event) => {
    let sanitizedValue = _value;
    if (clampBehavior === "blur" && typeof sanitizedValue === "number") {
      sanitizedValue = clamp(sanitizedValue, min2, max2);
    }
    if (trimLeadingZeroesOnBlur && typeof sanitizedValue === "string" && getDecimalPlaces2(sanitizedValue) < 15) {
      sanitizedValue = clampAndSanitizeInput(sanitizedValue, max2, min2);
    }
    if (_value !== sanitizedValue) {
      setValue(sanitizedValue);
    }
    onBlur?.(event);
  };
  assignRef2(handlersRef, { increment: incrementRef.current, decrement: decrementRef.current });
  const onStepHandleChange = (isIncrement) => {
    if (isIncrement) {
      incrementRef.current();
    } else {
      decrementRef.current();
    }
    stepCountRef.current += 1;
  };
  const onStepLoop = (isIncrement) => {
    onStepHandleChange(isIncrement);
    if (shouldUseStepInterval) {
      const interval = typeof stepHoldInterval === "number" ? stepHoldInterval : stepHoldInterval(stepCountRef.current);
      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), interval);
    }
  };
  const onStep = (event, isIncrement) => {
    event.preventDefault();
    inputRef.current?.focus();
    onStepHandleChange(isIncrement);
    if (shouldUseStepInterval) {
      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), stepHoldDelay);
    }
  };
  const onStepDone = () => {
    if (onStepTimeoutRef.current) {
      window.clearTimeout(onStepTimeoutRef.current);
    }
    onStepTimeoutRef.current = null;
    stepCountRef.current = 0;
  };
  const controls = /* @__PURE__ */ import_jsx_runtime173.jsxs("div", { ...getStyles2("controls"), children: [
    /* @__PURE__ */ import_jsx_runtime173.jsx(UnstyledButton, {
      ...getStyles2("control"),
      tabIndex: -1,
      "aria-hidden": true,
      disabled: disabled || typeof _value === "number" && max2 !== undefined && _value >= max2,
      mod: { direction: "up" },
      onMouseDown: (event) => event.preventDefault(),
      onPointerDown: (event) => {
        onStep(event, true);
      },
      onPointerUp: onStepDone,
      onPointerLeave: onStepDone,
      children: /* @__PURE__ */ import_jsx_runtime173.jsx(NumberInputChevron, { direction: "up" })
    }),
    /* @__PURE__ */ import_jsx_runtime173.jsx(UnstyledButton, {
      ...getStyles2("control"),
      tabIndex: -1,
      "aria-hidden": true,
      disabled: disabled || typeof _value === "number" && min2 !== undefined && _value <= min2,
      mod: { direction: "down" },
      onMouseDown: (event) => event.preventDefault(),
      onPointerDown: (event) => {
        onStep(event, false);
      },
      onPointerUp: onStepDone,
      onPointerLeave: onStepDone,
      children: /* @__PURE__ */ import_jsx_runtime173.jsx(NumberInputChevron, { direction: "down" })
    })
  ] });
  return /* @__PURE__ */ import_jsx_runtime173.jsx(InputBase, {
    component: NumericFormat,
    allowNegative,
    className: clsx_default(classes33.root, className),
    size: size4,
    ...others,
    readOnly,
    disabled,
    value: _value,
    getInputRef: useMergedRef(ref, inputRef),
    onValueChange: handleValueChange,
    rightSection: hideControls || readOnly || !canIncrement(_value) ? rightSection : rightSection || controls,
    classNames: resolvedClassNames,
    styles: resolvedStyles,
    unstyled,
    __staticSelector: "NumberInput",
    decimalScale: allowDecimal ? decimalScale : 0,
    onKeyDown: handleKeyDown,
    onKeyDownCapture: handleKeyDownCapture,
    rightSectionPointerEvents: rightSectionPointerEvents ?? (disabled ? "none" : undefined),
    rightSectionWidth: rightSectionWidth ?? `var(--ni-right-section-width-${size4 || "sm"})`,
    allowLeadingZeros,
    onBlur: handleBlur,
    isAllowed: (val) => {
      if (clampBehavior === "strict") {
        if (isAllowed) {
          return isAllowed(val) && isInRange(val.floatValue, min2, max2);
        }
        return isInRange(val.floatValue, min2, max2);
      }
      return isAllowed ? isAllowed(val) : true;
    }
  });
});
NumberInput.classes = { ...InputBase.classes, ...classes33 };
NumberInput.displayName = "@mantine/core/NumberInput";
// node_modules/@mantine/core/esm/components/Tooltip/Tooltip.mjs
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react220 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Transition/get-transition-props/get-transition-props.mjs
"use client";
var defaultTransition = {
  duration: 100,
  transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
  return { ...defaultTransition, ...componentTransition, ...transitionProps };
}

// node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/TooltipFloating.mjs
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var import_react214 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/use-floating-tooltip.mjs
var import_react212 = __toESM(require_react(), 1);
"use client";
function useFloatingTooltip({
  offset: offset4,
  position: position2,
  defaultOpened
}) {
  const [opened, setOpened] = import_react212.useState(defaultOpened);
  const boundaryRef = import_react212.useRef(null);
  const { x: x2, y: y2, elements, refs, update, placement } = useFloating2({
    placement: position2,
    middleware: [
      shift3({
        crossAxis: true,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  });
  const horizontalOffset = placement.includes("right") ? offset4 : position2.includes("left") ? offset4 * -1 : 0;
  const verticalOffset = placement.includes("bottom") ? offset4 : position2.includes("top") ? offset4 * -1 : 0;
  const handleMouseMove = import_react212.useCallback(({ clientX, clientY }) => {
    refs.setPositionReference({
      getBoundingClientRect() {
        return {
          width: 0,
          height: 0,
          x: clientX,
          y: clientY,
          left: clientX + horizontalOffset,
          top: clientY + verticalOffset,
          right: clientX,
          bottom: clientY
        };
      }
    });
  }, [elements.reference]);
  import_react212.useEffect(() => {
    if (refs.floating.current) {
      const boundary = boundaryRef.current;
      boundary.addEventListener("mousemove", handleMouseMove);
      const parents = getOverflowAncestors(refs.floating.current);
      parents.forEach((parent) => {
        parent.addEventListener("scroll", update);
      });
      return () => {
        boundary.removeEventListener("mousemove", handleMouseMove);
        parents.forEach((parent) => {
          parent.removeEventListener("scroll", update);
        });
      };
    }
    return;
  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]);
  return { handleMouseMove, x: x2, y: y2, opened, setOpened, boundaryRef, floating: refs.setFloating };
}

// node_modules/@mantine/core/esm/components/Tooltip/Tooltip.module.css.mjs
"use client";
var classes34 = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };

// node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/TooltipFloating.mjs
"use client";
var defaultProps85 = {
  refProp: "ref",
  withinPortal: true,
  offset: 10,
  defaultOpened: false,
  position: "right",
  zIndex: getDefaultZIndex("popover")
};
var varsResolver36 = createVarsResolver((theme, { radius, color }) => ({
  tooltip: {
    "--tooltip-radius": radius === undefined ? undefined : getRadius(radius),
    "--tooltip-bg": color ? getThemeColor(color, theme) : undefined,
    "--tooltip-color": color ? "var(--mantine-color-white)" : undefined
  }
}));
var TooltipFloating = factory((_props, ref) => {
  const props = useProps("TooltipFloating", defaultProps85, _props);
  const {
    children,
    refProp,
    withinPortal,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    radius,
    color,
    label,
    offset: offset4,
    position: position2,
    multiline,
    zIndex,
    disabled,
    defaultOpened,
    variant,
    vars,
    portalProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles2 = useStyles({
    name: "TooltipFloating",
    props,
    classes: classes34,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver36
  });
  const { handleMouseMove, x: x2, y: y2, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
    offset: offset4,
    position: position2,
    defaultOpened
  });
  if (!isElement(children)) {
    throw new Error("[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported");
  }
  const targetRef = useMergedRef(boundaryRef, getRefProp(children), ref);
  const _childrenProps = children.props;
  const onMouseEnter = (event) => {
    _childrenProps.onMouseEnter?.(event);
    handleMouseMove(event);
    setOpened(true);
  };
  const onMouseLeave = (event) => {
    _childrenProps.onMouseLeave?.(event);
    setOpened(false);
  };
  return /* @__PURE__ */ import_jsx_runtime174.jsxs(import_jsx_runtime174.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime174.jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ import_jsx_runtime174.jsx(Box, {
      ...others,
      ...getStyles2("tooltip", {
        style: {
          ...getStyleObject(style2, theme),
          zIndex,
          display: !disabled && opened ? "block" : "none",
          top: (y2 && Math.round(y2)) ?? "",
          left: (x2 && Math.round(x2)) ?? ""
        }
      }),
      variant,
      ref: floating,
      mod: { multiline },
      children: label
    }) }),
    import_react214.cloneElement(children, {
      ..._childrenProps,
      [refProp]: targetRef,
      onMouseEnter,
      onMouseLeave
    })
  ] });
});
TooltipFloating.classes = classes34;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";

// node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.mjs
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react217 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.context.mjs
var import_react215 = __toESM(require_react(), 1);
"use client";
var TooltipGroupContext = import_react215.createContext(false);
var TooltipGroupProvider = TooltipGroupContext.Provider;
var useTooltipGroupContext = () => import_react215.useContext(TooltipGroupContext);

// node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.mjs
"use client";
var defaultProps86 = {
  openDelay: 0,
  closeDelay: 0
};
function TooltipGroup(props) {
  const { openDelay, closeDelay, children } = useProps("TooltipGroup", defaultProps86, props);
  return /* @__PURE__ */ import_jsx_runtime175.jsx(TooltipGroupProvider, { value: true, children: /* @__PURE__ */ import_jsx_runtime175.jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children }) });
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c2) => c2;

// node_modules/@mantine/core/esm/components/Tooltip/use-tooltip.mjs
var import_react218 = __toESM(require_react(), 1);
"use client";
function getDefaultMiddlewares2(middlewares) {
  if (middlewares === undefined) {
    return { shift: true, flip: true };
  }
  const result = { ...middlewares };
  if (middlewares.shift === undefined) {
    result.shift = true;
  }
  if (middlewares.flip === undefined) {
    result.flip = true;
  }
  return result;
}
function getTooltipMiddlewares(settings) {
  const middlewaresOptions = getDefaultMiddlewares2(settings.middlewares);
  const middlewares = [offset3(settings.offset)];
  if (middlewaresOptions.shift) {
    middlewares.push(shift3(typeof middlewaresOptions.shift === "boolean" ? { padding: 8 } : { padding: 8, ...middlewaresOptions.shift }));
  }
  if (middlewaresOptions.flip) {
    middlewares.push(typeof middlewaresOptions.flip === "boolean" ? flip3() : flip3(middlewaresOptions.flip));
  }
  middlewares.push(arrow3({ element: settings.arrowRef, padding: settings.arrowOffset }));
  if (middlewaresOptions.inline) {
    middlewares.push(typeof middlewaresOptions.inline === "boolean" ? inline3() : inline3(middlewaresOptions.inline));
  } else if (settings.inline) {
    middlewares.push(inline3());
  }
  return middlewares;
}
function useTooltip(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = import_react218.useState(settings.defaultOpened);
  const controlled = typeof settings.opened === "boolean";
  const opened = controlled ? settings.opened : uncontrolledOpened;
  const withinGroup = useTooltipGroupContext();
  const uid = useId();
  const onChange = import_react218.useCallback((_opened) => {
    setUncontrolledOpened(_opened);
    if (_opened) {
      setCurrentId(uid);
    }
  }, [uid]);
  const {
    x: x2,
    y: y2,
    context,
    refs,
    update,
    placement,
    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
  } = useFloating2({
    strategy: settings.strategy,
    placement: settings.position,
    open: opened,
    onOpenChange: onChange,
    middleware: getTooltipMiddlewares(settings)
  });
  const { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context, { id: uid });
  const { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context, {
      enabled: settings.events?.hover,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },
      mouseOnly: !settings.events?.touch
    }),
    useFocus(context, { enabled: settings.events?.focus, visibleOnly: true }),
    useRole(context, { role: "tooltip" }),
    useDismiss(context, { enabled: typeof settings.opened === "undefined" })
  ]);
  useFloatingAutoUpdate({
    opened,
    position: settings.position,
    positionDependencies: settings.positionDependencies,
    floating: { refs, update }
  });
  useDidUpdate(() => {
    settings.onPositionChange?.(placement);
  }, [placement]);
  const isGroupPhase = opened && currentId && currentId !== uid;
  return {
    x: x2,
    y: y2,
    arrowX,
    arrowY,
    reference: refs.setReference,
    floating: refs.setFloating,
    getFloatingProps,
    getReferenceProps,
    isGroupPhase,
    opened,
    placement
  };
}

// node_modules/@mantine/core/esm/components/Tooltip/Tooltip.mjs
"use client";
var defaultProps87 = {
  position: "top",
  refProp: "ref",
  withinPortal: true,
  inline: false,
  defaultOpened: false,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: true, focus: false, touch: false },
  zIndex: getDefaultZIndex("popover"),
  positionDependencies: [],
  middlewares: { flip: true, shift: true, inline: false }
};
var varsResolver37 = createVarsResolver((theme, { radius, color }) => ({
  tooltip: {
    "--tooltip-radius": radius === undefined ? undefined : getRadius(radius),
    "--tooltip-bg": color ? getThemeColor(color, theme) : undefined,
    "--tooltip-color": color ? "var(--mantine-color-white)" : undefined
  }
}));
var Tooltip = factory((_props, ref) => {
  const props = useProps("Tooltip", defaultProps87, _props);
  const {
    children,
    position: position2,
    refProp,
    label,
    openDelay,
    closeDelay,
    onPositionChange,
    opened,
    defaultOpened,
    withinPortal,
    radius,
    color,
    classNames,
    styles,
    unstyled,
    style: style2,
    className,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    offset: offset4,
    transitionProps,
    multiline,
    events,
    zIndex,
    disabled,
    positionDependencies,
    onClick,
    onMouseEnter,
    onMouseLeave,
    inline: inline4,
    variant,
    keepMounted,
    vars,
    portalProps,
    mod,
    floatingStrategy,
    middlewares,
    ...others
  } = useProps("Tooltip", defaultProps87, props);
  const { dir } = useDirection();
  const arrowRef = import_react220.useRef(null);
  const tooltip = useTooltip({
    position: getFloatingPosition(dir, position2),
    closeDelay,
    openDelay,
    onPositionChange,
    opened,
    defaultOpened,
    events,
    arrowRef,
    arrowOffset,
    offset: typeof offset4 === "number" ? offset4 + (withArrow ? arrowSize / 2 : 0) : offset4,
    positionDependencies: [...positionDependencies, children],
    inline: inline4,
    strategy: floatingStrategy,
    middlewares
  });
  const getStyles2 = useStyles({
    name: "Tooltip",
    props,
    classes: classes34,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver37
  });
  if (!isElement(children)) {
    throw new Error("[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported");
  }
  const targetRef = useMergedRef(tooltip.reference, getRefProp(children), ref);
  const transition = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
  const _childrenProps = children.props;
  return /* @__PURE__ */ import_jsx_runtime176.jsxs(import_jsx_runtime176.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime176.jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ import_jsx_runtime176.jsx(Transition, {
      ...transition,
      keepMounted,
      mounted: !disabled && !!tooltip.opened,
      duration: tooltip.isGroupPhase ? 10 : transition.duration,
      children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime176.jsxs(Box, {
        ...others,
        "data-fixed": floatingStrategy === "fixed" || undefined,
        variant,
        mod: [{ multiline }, mod],
        ...tooltip.getFloatingProps({
          ref: tooltip.floating,
          className: getStyles2("tooltip").className,
          style: {
            ...getStyles2("tooltip").style,
            ...transitionStyles,
            zIndex,
            top: tooltip.y ?? 0,
            left: tooltip.x ?? 0
          }
        }),
        children: [
          label,
          /* @__PURE__ */ import_jsx_runtime176.jsx(FloatingArrow, {
            ref: arrowRef,
            arrowX: tooltip.arrowX,
            arrowY: tooltip.arrowY,
            visible: withArrow,
            position: tooltip.placement,
            arrowSize,
            arrowOffset,
            arrowRadius,
            arrowPosition,
            ...getStyles2("arrow")
          })
        ]
      })
    }) }),
    import_react220.cloneElement(children, tooltip.getReferenceProps({
      onClick,
      onMouseEnter,
      onMouseLeave,
      onMouseMove: props.onMouseMove,
      onPointerDown: props.onPointerDown,
      onPointerEnter: props.onPointerEnter,
      className: clsx_default(className, _childrenProps.className),
      ..._childrenProps,
      [refProp]: targetRef
    }))
  ] });
});
Tooltip.classes = classes34;
Tooltip.displayName = "@mantine/core/Tooltip";
Tooltip.Floating = TooltipFloating;
Tooltip.Group = TooltipGroup;

// node_modules/@mantine/core/esm/components/Select/Select.mjs
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react221 = __toESM(require_react(), 1);
"use client";
var defaultProps88 = {
  searchable: false,
  withCheckIcon: true,
  allowDeselect: true,
  checkIconPosition: "left"
};
var Select = factory((_props, ref) => {
  const props = useProps("Select", defaultProps88, _props);
  const {
    classNames,
    styles,
    unstyled,
    vars,
    dropdownOpened,
    defaultDropdownOpened,
    onDropdownClose,
    onDropdownOpen,
    onFocus,
    onBlur,
    onClick,
    onChange,
    data,
    value,
    defaultValue,
    selectFirstOptionOnChange,
    onOptionSubmit,
    comboboxProps,
    readOnly,
    disabled,
    filter: filter2,
    limit,
    withScrollArea,
    maxDropdownHeight,
    size: size4,
    searchable,
    rightSection,
    checkIconPosition,
    withCheckIcon,
    nothingFoundMessage,
    name,
    form,
    searchValue,
    defaultSearchValue,
    onSearchChange,
    allowDeselect,
    error,
    rightSectionPointerEvents,
    id,
    clearable,
    clearButtonProps,
    hiddenInputProps,
    renderOption,
    onClear,
    autoComplete,
    scrollAreaProps,
    __defaultRightSection,
    __clearSection,
    __clearable,
    chevronColor,
    ...others
  } = props;
  const parsedData = import_react221.useMemo(() => getParsedComboboxData(data), [data]);
  const optionsLockup = import_react221.useMemo(() => getOptionsLockup(parsedData), [parsedData]);
  const _id = useId(id);
  const [_value, setValue, controlled] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  });
  const selectedOption = typeof _value === "string" ? optionsLockup[_value] : undefined;
  const previousSelectedOption = usePrevious(selectedOption);
  const [search, setSearch] = useUncontrolled({
    value: searchValue,
    defaultValue: defaultSearchValue,
    finalValue: selectedOption ? selectedOption.label : "",
    onChange: onSearchChange
  });
  const combobox = useCombobox({
    opened: dropdownOpened,
    defaultOpened: defaultDropdownOpened,
    onDropdownOpen: () => {
      onDropdownOpen?.();
      combobox.updateSelectedOptionIndex("active", { scrollIntoView: true });
    },
    onDropdownClose: () => {
      onDropdownClose?.();
      combobox.resetSelectedOption();
    }
  });
  const handleSearchChange = (value2) => {
    setSearch(value2);
    combobox.resetSelectedOption();
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    props,
    styles,
    classNames
  });
  import_react221.useEffect(() => {
    if (selectFirstOptionOnChange) {
      combobox.selectFirstOption();
    }
  }, [selectFirstOptionOnChange, search]);
  import_react221.useEffect(() => {
    if (value === null) {
      handleSearchChange("");
    }
    if (typeof value === "string" && selectedOption && (previousSelectedOption?.value !== selectedOption.value || previousSelectedOption?.label !== selectedOption.label)) {
      handleSearchChange(selectedOption.label);
    }
  }, [value, selectedOption]);
  import_react221.useEffect(() => {
    if (!controlled) {
      handleSearchChange(typeof _value === "string" ? optionsLockup[_value]?.label || "" : "");
    }
  }, [data, _value]);
  const clearButton = /* @__PURE__ */ import_jsx_runtime177.jsx(Combobox.ClearButton, {
    ...clearButtonProps,
    onClear: () => {
      setValue(null, null);
      handleSearchChange("");
      onClear?.();
    }
  });
  const _clearable = clearable && !!_value && !disabled && !readOnly;
  return /* @__PURE__ */ import_jsx_runtime177.jsxs(import_jsx_runtime177.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime177.jsxs(Combobox, {
      store: combobox,
      __staticSelector: "Select",
      classNames: resolvedClassNames,
      styles: resolvedStyles,
      unstyled,
      readOnly,
      onOptionSubmit: (val) => {
        onOptionSubmit?.(val);
        const optionLockup = allowDeselect ? optionsLockup[val].value === _value ? null : optionsLockup[val] : optionsLockup[val];
        const nextValue = optionLockup ? optionLockup.value : null;
        nextValue !== _value && setValue(nextValue, optionLockup);
        !controlled && handleSearchChange(typeof nextValue === "string" ? optionLockup?.label || "" : "");
        combobox.closeDropdown();
      },
      size: size4,
      ...comboboxProps,
      children: [
        /* @__PURE__ */ import_jsx_runtime177.jsx(Combobox.Target, { targetType: searchable ? "input" : "button", autoComplete, children: /* @__PURE__ */ import_jsx_runtime177.jsx(InputBase, {
          id: _id,
          ref,
          __defaultRightSection: /* @__PURE__ */ import_jsx_runtime177.jsx(Combobox.Chevron, {
            size: size4,
            error,
            unstyled,
            color: chevronColor
          }),
          __clearSection: clearButton,
          __clearable: _clearable,
          rightSection,
          rightSectionPointerEvents: rightSectionPointerEvents || (_clearable ? "all" : "none"),
          ...others,
          size: size4,
          __staticSelector: "Select",
          disabled,
          readOnly: readOnly || !searchable,
          value: search,
          onChange: (event) => {
            handleSearchChange(event.currentTarget.value);
            combobox.openDropdown();
            selectFirstOptionOnChange && combobox.selectFirstOption();
          },
          onFocus: (event) => {
            searchable && combobox.openDropdown();
            onFocus?.(event);
          },
          onBlur: (event) => {
            searchable && combobox.closeDropdown();
            handleSearchChange(_value != null ? optionsLockup[_value]?.label || "" : "");
            onBlur?.(event);
          },
          onClick: (event) => {
            searchable ? combobox.openDropdown() : combobox.toggleDropdown();
            onClick?.(event);
          },
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          pointer: !searchable,
          error
        }) }),
        /* @__PURE__ */ import_jsx_runtime177.jsx(OptionsDropdown, {
          data: parsedData,
          hidden: readOnly || disabled,
          filter: filter2,
          search,
          limit,
          hiddenWhenEmpty: !nothingFoundMessage,
          withScrollArea,
          maxDropdownHeight,
          filterOptions: searchable && selectedOption?.label !== search,
          value: _value,
          checkIconPosition,
          withCheckIcon,
          nothingFoundMessage,
          unstyled,
          labelId: others.label ? `${_id}-label` : undefined,
          "aria-label": others.label ? undefined : others["aria-label"],
          renderOption,
          scrollAreaProps
        })
      ]
    }),
    /* @__PURE__ */ import_jsx_runtime177.jsx(Combobox.HiddenInput, {
      value: _value,
      name,
      form,
      disabled,
      ...hiddenInputProps
    })
  ] });
});
Select.classes = { ...InputBase.classes, ...Combobox.classes };
Select.displayName = "@mantine/core/Select";
// node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGrid.mjs
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react223 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGridVariables.mjs
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react222 = __toESM(require_react(), 1);
"use client";
function SimpleGridMediaVariables({
  spacing,
  verticalSpacing,
  cols,
  selector
}) {
  const theme = useMantineTheme();
  const _verticalSpacing = verticalSpacing === undefined ? spacing : verticalSpacing;
  const baseStyles = filterProps({
    "--sg-spacing-x": getSpacing(getBaseValue(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue(_verticalSpacing)),
    "--sg-cols": getBaseValue(cols)?.toString()
  });
  const queries = keys(theme.breakpoints).reduce((acc, breakpoint) => {
    if (!acc[breakpoint]) {
      acc[breakpoint] = {};
    }
    if (typeof spacing === "object" && spacing[breakpoint] !== undefined) {
      acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint]);
    }
    if (typeof _verticalSpacing === "object" && _verticalSpacing[breakpoint] !== undefined) {
      acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint]);
    }
    if (typeof cols === "object" && cols[breakpoint] !== undefined) {
      acc[breakpoint]["--sg-cols"] = cols[breakpoint];
    }
    return acc;
  }, {});
  const sortedBreakpoints = getSortedBreakpoints(keys(queries), theme.breakpoints).filter((breakpoint) => keys(queries[breakpoint.value]).length > 0);
  const media = sortedBreakpoints.map((breakpoint) => ({
    query: `(min-width: ${theme.breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ import_jsx_runtime178.jsx(InlineStyles, { styles: baseStyles, media, selector });
}
function getBreakpoints(values2) {
  if (typeof values2 === "object" && values2 !== null) {
    return keys(values2);
  }
  return [];
}
function sortBreakpoints(breakpoints) {
  return breakpoints.sort((a2, b) => px(a2) - px(b));
}
function getUniqueBreakpoints({
  spacing,
  verticalSpacing,
  cols
}) {
  const breakpoints = Array.from(/* @__PURE__ */ new Set([
    ...getBreakpoints(spacing),
    ...getBreakpoints(verticalSpacing),
    ...getBreakpoints(cols)
  ]));
  return sortBreakpoints(breakpoints);
}
function SimpleGridContainerVariables({
  spacing,
  verticalSpacing,
  cols,
  selector
}) {
  const _verticalSpacing = verticalSpacing === undefined ? spacing : verticalSpacing;
  const baseStyles = filterProps({
    "--sg-spacing-x": getSpacing(getBaseValue(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue(_verticalSpacing)),
    "--sg-cols": getBaseValue(cols)?.toString()
  });
  const uniqueBreakpoints = getUniqueBreakpoints({ spacing, verticalSpacing, cols });
  const queries = uniqueBreakpoints.reduce((acc, breakpoint) => {
    if (!acc[breakpoint]) {
      acc[breakpoint] = {};
    }
    if (typeof spacing === "object" && spacing[breakpoint] !== undefined) {
      acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint]);
    }
    if (typeof _verticalSpacing === "object" && _verticalSpacing[breakpoint] !== undefined) {
      acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint]);
    }
    if (typeof cols === "object" && cols[breakpoint] !== undefined) {
      acc[breakpoint]["--sg-cols"] = cols[breakpoint];
    }
    return acc;
  }, {});
  const media = uniqueBreakpoints.map((breakpoint) => ({
    query: `simple-grid (min-width: ${breakpoint})`,
    styles: queries[breakpoint]
  }));
  return /* @__PURE__ */ import_jsx_runtime178.jsx(InlineStyles, { styles: baseStyles, container: media, selector });
}

// node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGrid.module.css.mjs
"use client";
var classes35 = { container: "m_925c2d2c", root: "m_2415a157" };

// node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGrid.mjs
"use client";
var defaultProps89 = {
  cols: 1,
  spacing: "md",
  type: "media"
};
var SimpleGrid = factory((_props, ref) => {
  const props = useProps("SimpleGrid", defaultProps89, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    cols,
    verticalSpacing,
    spacing,
    type,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "SimpleGrid",
    classes: classes35,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars
  });
  const responsiveClassName = useRandomClassName();
  if (type === "container") {
    return /* @__PURE__ */ import_jsx_runtime179.jsxs(import_jsx_runtime179.Fragment, { children: [
      /* @__PURE__ */ import_jsx_runtime179.jsx(SimpleGridContainerVariables, { ...props, selector: `.${responsiveClassName}` }),
      /* @__PURE__ */ import_jsx_runtime179.jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ import_jsx_runtime179.jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others }) })
    ] });
  }
  return /* @__PURE__ */ import_jsx_runtime179.jsxs(import_jsx_runtime179.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime179.jsx(SimpleGridMediaVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ import_jsx_runtime179.jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others })
  ] });
});
SimpleGrid.classes = classes35;
SimpleGrid.displayName = "@mantine/core/SimpleGrid";
// node_modules/@mantine/core/esm/components/Slider/Slider/Slider.mjs
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react229 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Slider/Slider.context.mjs
var import_react224 = __toESM(require_react(), 1);
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
"use client";
var [SliderProvider, useSliderContext] = createSafeContext("SliderProvider was not found in tree");

// node_modules/@mantine/core/esm/components/Slider/SliderRoot/SliderRoot.mjs
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react225 = __toESM(require_react(), 1);
"use client";
var SliderRoot = import_react225.forwardRef(({ size: size4, disabled, variant, color, thumbSize, radius, ...others }, ref) => {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ import_jsx_runtime181.jsx(Box, {
    tabIndex: -1,
    variant,
    size: size4,
    ref,
    ...getStyles2("root"),
    ...others
  });
});
SliderRoot.displayName = "@mantine/core/SliderRoot";

// node_modules/@mantine/core/esm/components/Slider/Thumb/Thumb.mjs
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react226 = __toESM(require_react(), 1);
"use client";
var Thumb2 = import_react226.forwardRef(({
  max: max2,
  min: min2,
  value,
  position: position2,
  label,
  dragging,
  onMouseDown,
  onKeyDownCapture,
  labelTransitionProps,
  labelAlwaysOn,
  thumbLabel,
  onFocus,
  onBlur,
  showLabelOnHover,
  isHovered,
  children = null,
  disabled
}, ref) => {
  const { getStyles: getStyles2 } = useSliderContext();
  const [focused, setFocused] = import_react226.useState(false);
  const isVisible = labelAlwaysOn || dragging || focused || showLabelOnHover && isHovered;
  return /* @__PURE__ */ import_jsx_runtime182.jsxs(Box, {
    tabIndex: 0,
    role: "slider",
    "aria-label": thumbLabel,
    "aria-valuemax": max2,
    "aria-valuemin": min2,
    "aria-valuenow": value,
    ref,
    __vars: { "--slider-thumb-offset": `${position2}%` },
    ...getStyles2("thumb", { focusable: true }),
    mod: { dragging, disabled },
    onFocus: (event) => {
      setFocused(true);
      typeof onFocus === "function" && onFocus(event);
    },
    onBlur: (event) => {
      setFocused(false);
      typeof onBlur === "function" && onBlur(event);
    },
    onTouchStart: onMouseDown,
    onMouseDown,
    onKeyDownCapture,
    onClick: (event) => event.stopPropagation(),
    children: [
      children,
      /* @__PURE__ */ import_jsx_runtime182.jsx(Transition, {
        mounted: label != null && !!isVisible,
        transition: "fade",
        duration: 0,
        ...labelTransitionProps,
        children: (transitionStyles) => /* @__PURE__ */ import_jsx_runtime182.jsx("div", { ...getStyles2("label", { style: transitionStyles }), children: label })
      })
    ]
  });
});
Thumb2.displayName = "@mantine/core/SliderThumb";

// node_modules/@mantine/core/esm/components/Slider/Track/Track.mjs
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react228 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Slider/Marks/Marks.mjs
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_react227 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Slider/utils/get-position/get-position.mjs
"use client";
function getPosition({ value, min: min2, max: max2 }) {
  const position2 = (value - min2) / (max2 - min2) * 100;
  return Math.min(Math.max(position2, 0), 100);
}

// node_modules/@mantine/core/esm/components/Slider/Marks/is-mark-filled.mjs
"use client";
function isMarkFilled({ mark, offset: offset4, value, inverted = false }) {
  return inverted ? typeof offset4 === "number" ? mark.value <= offset4 || mark.value >= value : mark.value >= value : typeof offset4 === "number" ? mark.value >= offset4 && mark.value <= value : mark.value <= value;
}

// node_modules/@mantine/core/esm/components/Slider/Marks/Marks.mjs
"use client";
function Marks({ marks, min: min2, max: max2, disabled, value, offset: offset4, inverted }) {
  const { getStyles: getStyles2 } = useSliderContext();
  if (!marks) {
    return null;
  }
  const items = marks.map((mark, index4) => /* @__PURE__ */ import_react227.createElement(Box, {
    ...getStyles2("markWrapper"),
    __vars: { "--mark-offset": `${getPosition({ value: mark.value, min: min2, max: max2 })}%` },
    key: index4
  }, /* @__PURE__ */ import_jsx_runtime183.jsx(Box, {
    ...getStyles2("mark"),
    mod: { filled: isMarkFilled({ mark, value, offset: offset4, inverted }), disabled }
  }), mark.label && /* @__PURE__ */ import_jsx_runtime183.jsx("div", { ...getStyles2("markLabel"), children: mark.label })));
  return /* @__PURE__ */ import_jsx_runtime183.jsx("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";

// node_modules/@mantine/core/esm/components/Slider/Track/Track.mjs
"use client";
function Track({
  filled,
  children,
  offset: offset4,
  disabled,
  marksOffset,
  inverted,
  containerProps,
  ...others
}) {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ import_jsx_runtime184.jsx(Box, { ...getStyles2("trackContainer"), mod: { disabled }, ...containerProps, children: /* @__PURE__ */ import_jsx_runtime184.jsxs(Box, { ...getStyles2("track"), mod: { inverted, disabled }, children: [
    /* @__PURE__ */ import_jsx_runtime184.jsx(Box, {
      mod: { inverted, disabled },
      __vars: {
        "--slider-bar-width": `calc(${filled}% + var(--slider-size))`,
        "--slider-bar-offset": `calc(${offset4}% - var(--slider-size))`
      },
      ...getStyles2("bar")
    }),
    children,
    /* @__PURE__ */ import_jsx_runtime184.jsx(Marks, { ...others, offset: marksOffset, disabled, inverted })
  ] }) });
}
Track.displayName = "@mantine/core/SliderTrack";

// node_modules/@mantine/core/esm/components/Slider/utils/get-change-value/get-change-value.mjs
"use client";
function getChangeValue({
  value,
  containerWidth,
  min: min2,
  max: max2,
  step,
  precision
}) {
  const left = !containerWidth ? value : Math.min(Math.max(value, 0), containerWidth) / containerWidth;
  const dx = left * (max2 - min2);
  const nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min2;
  const nextValueWithinStep = Math.max(nextValue, min2);
  if (precision !== undefined) {
    return Number(nextValueWithinStep.toFixed(precision));
  }
  return nextValueWithinStep;
}

// node_modules/@mantine/core/esm/components/Slider/utils/get-floating-value/get-gloating-value.mjs
"use client";
function getFloatingValue(value, precision) {
  return parseFloat(value.toFixed(precision));
}

// node_modules/@mantine/core/esm/components/Slider/utils/get-precision/get-precision.mjs
"use client";
function getPrecision(step) {
  if (!step) {
    return 0;
  }
  const split = step.toString().split(".");
  return split.length > 1 ? split[1].length : 0;
}

// node_modules/@mantine/core/esm/components/Slider/utils/get-step-mark-value/get-step-mark-value.mjs
"use client";
function getNextMarkValue(currentValue, marks) {
  const sortedMarks = [...marks].sort((a2, b) => a2.value - b.value);
  const nextMark = sortedMarks.find((mark) => mark.value > currentValue);
  return nextMark ? nextMark.value : currentValue;
}
function getPreviousMarkValue(currentValue, marks) {
  const sortedMarks = [...marks].sort((a2, b) => b.value - a2.value);
  const previousMark = sortedMarks.find((mark) => mark.value < currentValue);
  return previousMark ? previousMark.value : currentValue;
}
function getFirstMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b) => a2.value - b.value);
  return sortedMarks.length > 0 ? sortedMarks[0].value : 0;
}
function getLastMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b) => a2.value - b.value);
  return sortedMarks.length > 0 ? sortedMarks[sortedMarks.length - 1].value : 100;
}

// node_modules/@mantine/core/esm/components/Slider/Slider.module.css.mjs
"use client";
var classes36 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };

// node_modules/@mantine/core/esm/components/Slider/Slider/Slider.mjs
"use client";
var defaultProps90 = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (f2) => f2,
  labelTransitionProps: { transition: "fade", duration: 0 },
  labelAlwaysOn: false,
  thumbLabel: "",
  showLabelOnHover: true,
  disabled: false,
  scale: (v2) => v2
};
var varsResolver38 = createVarsResolver((theme, { size: size4, color, thumbSize, radius }) => ({
  root: {
    "--slider-size": getSize(size4, "slider-size"),
    "--slider-color": color ? getThemeColor(color, theme) : undefined,
    "--slider-radius": radius === undefined ? undefined : getRadius(radius),
    "--slider-thumb-size": thumbSize !== undefined ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
  }
}));
var Slider = factory((_props, ref) => {
  const props = useProps("Slider", defaultProps90, _props);
  const {
    classNames,
    styles,
    value,
    onChange,
    onChangeEnd,
    size: size4,
    min: min2,
    max: max2,
    step,
    precision: _precision,
    defaultValue,
    name,
    marks,
    label,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    showLabelOnHover,
    thumbChildren,
    disabled,
    unstyled,
    scale,
    inverted,
    className,
    style: style2,
    vars,
    hiddenInputProps,
    restrictToMarks,
    thumbProps,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Slider",
    props,
    classes: classes36,
    classNames,
    className,
    styles,
    style: style2,
    vars,
    varsResolver: varsResolver38,
    unstyled
  });
  const { dir } = useDirection();
  const [hovered, setHovered] = import_react229.useState(false);
  const [_value, setValue] = useUncontrolled({
    value: typeof value === "number" ? clamp(value, min2, max2) : value,
    defaultValue: typeof defaultValue === "number" ? clamp(defaultValue, min2, max2) : defaultValue,
    finalValue: clamp(0, min2, max2),
    onChange
  });
  const valueRef = import_react229.useRef(_value);
  const onChangeEndRef = import_react229.useRef(onChangeEnd);
  import_react229.useEffect(() => {
    onChangeEndRef.current = onChangeEnd;
  }, [onChangeEnd]);
  const root2 = import_react229.useRef(null);
  const thumb = import_react229.useRef(null);
  const position2 = getPosition({ value: _value, min: min2, max: max2 });
  const scaledValue = scale(_value);
  const _label = typeof label === "function" ? label(scaledValue) : label;
  const precision = _precision ?? getPrecision(step);
  const handleChange = import_react229.useCallback(({ x: x2 }) => {
    if (!disabled) {
      const nextValue = getChangeValue({
        value: x2,
        min: min2,
        max: max2,
        step,
        precision
      });
      setValue(restrictToMarks && marks?.length ? findClosestNumber(nextValue, marks.map((mark) => mark.value)) : nextValue);
      valueRef.current = nextValue;
    }
  }, [disabled, min2, max2, step, precision, setValue, marks, restrictToMarks]);
  const handleScrubEnd = import_react229.useCallback(() => {
    if (!disabled && onChangeEndRef.current) {
      const finalValue = restrictToMarks && marks?.length ? findClosestNumber(valueRef.current, marks.map((mark) => mark.value)) : valueRef.current;
      onChangeEndRef.current(finalValue);
    }
  }, [disabled, marks, restrictToMarks]);
  const { ref: container, active } = useMove(handleChange, { onScrubEnd: handleScrubEnd }, dir);
  const callOnChangeEnd = import_react229.useCallback((value2) => {
    if (!disabled && onChangeEndRef.current) {
      onChangeEndRef.current(value2);
    }
  }, [disabled]);
  const handleTrackKeydownCapture = (event) => {
    if (!disabled) {
      switch (event.key) {
        case "ArrowUp": {
          event.preventDefault();
          thumb.current?.focus();
          if (restrictToMarks && marks) {
            const nextValue2 = getNextMarkValue(_value, marks);
            setValue(nextValue2);
            callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(Math.min(Math.max(_value + step, min2), max2), precision);
          setValue(nextValue);
          callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowRight": {
          event.preventDefault();
          thumb.current?.focus();
          if (restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getPreviousMarkValue(_value, marks) : getNextMarkValue(_value, marks);
            setValue(nextValue2);
            callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min2), max2), precision);
          setValue(nextValue);
          callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowDown": {
          event.preventDefault();
          thumb.current?.focus();
          if (restrictToMarks && marks) {
            const nextValue2 = getPreviousMarkValue(_value, marks);
            setValue(nextValue2);
            callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(Math.min(Math.max(_value - step, min2), max2), precision);
          setValue(nextValue);
          callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowLeft": {
          event.preventDefault();
          thumb.current?.focus();
          if (restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getNextMarkValue(_value, marks) : getPreviousMarkValue(_value, marks);
            setValue(nextValue2);
            callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min2), max2), precision);
          setValue(nextValue);
          callOnChangeEnd(nextValue);
          break;
        }
        case "Home": {
          event.preventDefault();
          thumb.current?.focus();
          if (restrictToMarks && marks) {
            setValue(getFirstMarkValue(marks));
            callOnChangeEnd(getFirstMarkValue(marks));
            break;
          }
          setValue(min2);
          callOnChangeEnd(min2);
          break;
        }
        case "End": {
          event.preventDefault();
          thumb.current?.focus();
          if (restrictToMarks && marks) {
            setValue(getLastMarkValue(marks));
            callOnChangeEnd(getLastMarkValue(marks));
            break;
          }
          setValue(max2);
          callOnChangeEnd(max2);
          break;
        }
      }
    }
  };
  return /* @__PURE__ */ import_jsx_runtime185.jsx(SliderProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ import_jsx_runtime185.jsxs(SliderRoot, {
    ...others,
    ref: useMergedRef(ref, root2),
    onKeyDownCapture: handleTrackKeydownCapture,
    onMouseDownCapture: () => root2.current?.focus(),
    size: size4,
    disabled,
    children: [
      /* @__PURE__ */ import_jsx_runtime185.jsx(Track, {
        inverted,
        offset: 0,
        filled: position2,
        marks,
        min: min2,
        max: max2,
        value: scaledValue,
        disabled,
        containerProps: {
          ref: container,
          onMouseEnter: showLabelOnHover ? () => setHovered(true) : undefined,
          onMouseLeave: showLabelOnHover ? () => setHovered(false) : undefined
        },
        children: /* @__PURE__ */ import_jsx_runtime185.jsx(Thumb2, {
          max: max2,
          min: min2,
          value: scaledValue,
          position: position2,
          dragging: active,
          label: _label,
          ref: thumb,
          labelTransitionProps,
          labelAlwaysOn,
          thumbLabel,
          showLabelOnHover,
          isHovered: hovered,
          disabled,
          ...thumbProps,
          children: thumbChildren
        })
      }),
      /* @__PURE__ */ import_jsx_runtime185.jsx("input", { type: "hidden", name, value: scaledValue, ...hiddenInputProps })
    ]
  }) });
});
Slider.classes = classes36;
Slider.displayName = "@mantine/core/Slider";
// node_modules/@mantine/core/esm/components/Stack/Stack.mjs
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var import_react230 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Stack/Stack.module.css.mjs
"use client";
var classes37 = { root: "m_6d731127" };

// node_modules/@mantine/core/esm/components/Stack/Stack.mjs
"use client";
var defaultProps91 = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
};
var varsResolver39 = createVarsResolver((_2, { gap, align, justify }) => ({
  root: {
    "--stack-gap": getSpacing(gap),
    "--stack-align": align,
    "--stack-justify": justify
  }
}));
var Stack = factory((_props, ref) => {
  const props = useProps("Stack", defaultProps91, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    align,
    justify,
    gap,
    variant,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Stack",
    props,
    classes: classes37,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver39
  });
  return /* @__PURE__ */ import_jsx_runtime186.jsx(Box, { ref, ...getStyles2("root"), variant, ...others });
});
Stack.classes = classes37;
Stack.displayName = "@mantine/core/Stack";
// node_modules/@mantine/core/esm/components/Switch/Switch.mjs
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react233 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Switch/SwitchGroup.context.mjs
var import_react231 = __toESM(require_react(), 1);
"use client";
var SwitchGroupContext = import_react231.createContext(null);
var SwitchGroupProvider = SwitchGroupContext.Provider;
var useSwitchGroupContext = () => import_react231.useContext(SwitchGroupContext);

// node_modules/@mantine/core/esm/components/Switch/SwitchGroup/SwitchGroup.mjs
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_react232 = __toESM(require_react(), 1);
"use client";
var defaultProps92 = {};
var SwitchGroup = factory((props, ref) => {
  const { value, defaultValue, onChange, size: size4, wrapperProps, children, readOnly, ...others } = useProps("SwitchGroup", defaultProps92, props);
  const [_value, setValue] = useUncontrolled({
    value,
    defaultValue,
    finalValue: [],
    onChange
  });
  const handleChange = (event) => {
    const itemValue = event.currentTarget.value;
    !readOnly && setValue(_value.includes(itemValue) ? _value.filter((item) => item !== itemValue) : [..._value, itemValue]);
  };
  return /* @__PURE__ */ import_jsx_runtime187.jsx(SwitchGroupProvider, { value: { value: _value, onChange: handleChange, size: size4 }, children: /* @__PURE__ */ import_jsx_runtime187.jsx(Input.Wrapper, {
    size: size4,
    ref,
    ...wrapperProps,
    ...others,
    labelElement: "div",
    __staticSelector: "SwitchGroup",
    children: /* @__PURE__ */ import_jsx_runtime187.jsx(InputsGroupFieldset, { role: "group", children })
  }) });
});
SwitchGroup.classes = Input.Wrapper.classes;
SwitchGroup.displayName = "@mantine/core/SwitchGroup";

// node_modules/@mantine/core/esm/components/Switch/Switch.module.css.mjs
"use client";
var classes38 = { root: "m_5f93f3bb", input: "m_926b4011", track: "m_9307d992", thumb: "m_93039a1d", trackLabel: "m_8277e082" };

// node_modules/@mantine/core/esm/components/Switch/Switch.mjs
"use client";
var defaultProps93 = {
  labelPosition: "right"
};
var varsResolver40 = createVarsResolver((theme, { radius, color, size: size4 }) => ({
  root: {
    "--switch-radius": radius === undefined ? undefined : getRadius(radius),
    "--switch-height": getSize(size4, "switch-height"),
    "--switch-width": getSize(size4, "switch-width"),
    "--switch-thumb-size": getSize(size4, "switch-thumb-size"),
    "--switch-label-font-size": getSize(size4, "switch-label-font-size"),
    "--switch-track-label-padding": getSize(size4, "switch-track-label-padding"),
    "--switch-color": color ? getThemeColor(color, theme) : undefined
  }
}));
var Switch = factory((_props, ref) => {
  const props = useProps("Switch", defaultProps93, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color,
    label,
    offLabel,
    onLabel,
    id,
    size: size4,
    radius,
    wrapperProps,
    thumbIcon,
    checked,
    defaultChecked,
    onChange,
    labelPosition,
    description,
    error,
    disabled,
    variant,
    rootRef,
    mod,
    ...others
  } = props;
  const ctx = useSwitchGroupContext();
  const _size = size4 || ctx?.size;
  const getStyles2 = useStyles({
    name: "Switch",
    props,
    classes: classes38,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver40
  });
  const { styleProps, rest } = extractStyleProps(others);
  const uuid = useId(id);
  const contextProps = ctx ? {
    checked: ctx.value.includes(rest.value),
    onChange: ctx.onChange
  } : {};
  const [_checked, handleChange] = useUncontrolled({
    value: contextProps.checked ?? checked,
    defaultValue: defaultChecked,
    finalValue: false
  });
  return /* @__PURE__ */ import_jsx_runtime188.jsxs(InlineInput, {
    ...getStyles2("root"),
    __staticSelector: "Switch",
    __stylesApiProps: props,
    id: uuid,
    size: _size,
    labelPosition,
    label,
    description,
    error,
    disabled,
    bodyElement: "label",
    labelElement: "span",
    classNames,
    styles,
    unstyled,
    "data-checked": contextProps.checked || checked || undefined,
    variant,
    ref: rootRef,
    mod,
    ...styleProps,
    ...wrapperProps,
    children: [
      /* @__PURE__ */ import_jsx_runtime188.jsx("input", {
        ...rest,
        disabled,
        checked: _checked,
        "data-checked": contextProps.checked || checked || undefined,
        onChange: (event) => {
          ctx ? contextProps.onChange?.(event) : onChange?.(event);
          handleChange(event.currentTarget.checked);
        },
        id: uuid,
        ref,
        type: "checkbox",
        role: "switch",
        ...getStyles2("input")
      }),
      /* @__PURE__ */ import_jsx_runtime188.jsxs(Box, {
        "aria-hidden": "true",
        mod: { error, "label-position": labelPosition, "without-labels": !onLabel && !offLabel },
        ...getStyles2("track"),
        children: [
          /* @__PURE__ */ import_jsx_runtime188.jsx(Box, { component: "span", mod: "reduce-motion", ...getStyles2("thumb"), children: thumbIcon }),
          /* @__PURE__ */ import_jsx_runtime188.jsx("span", { ...getStyles2("trackLabel"), children: _checked ? onLabel : offLabel })
        ]
      })
    ]
  });
});
Switch.classes = { ...classes38, ...InlineInputClasses };
Switch.displayName = "@mantine/core/Switch";
Switch.Group = SwitchGroup;
// node_modules/@mantine/core/esm/components/Table/Table.mjs
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_react237 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Table/Table.components.mjs
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react235 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Table/Table.context.mjs
var import_react234 = __toESM(require_react(), 1);
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
"use client";
var [TableProvider, useTableContext] = createSafeContext("Table component was not found in the tree");

// node_modules/@mantine/core/esm/components/Table/Table.module.css.mjs
"use client";
var classes39 = { table: "m_b23fa0ef", th: "m_4e7aa4f3", tr: "m_4e7aa4fd", td: "m_4e7aa4ef", tbody: "m_b2404537", thead: "m_b242d975", caption: "m_9e5a3ac7", scrollContainer: "m_a100c15", scrollContainerInner: "m_62259741" };

// node_modules/@mantine/core/esm/components/Table/Table.components.mjs
"use client";
function getDataAttributes(ctx, options) {
  if (!options) {
    return;
  }
  const data = {};
  if (options.columnBorder && ctx.withColumnBorders) {
    data["data-with-column-border"] = true;
  }
  if (options.rowBorder && ctx.withRowBorders) {
    data["data-with-row-border"] = true;
  }
  if (options.striped && ctx.striped) {
    data["data-striped"] = ctx.striped;
  }
  if (options.highlightOnHover && ctx.highlightOnHover) {
    data["data-hover"] = true;
  }
  if (options.captionSide && ctx.captionSide) {
    data["data-side"] = ctx.captionSide;
  }
  if (options.stickyHeader && ctx.stickyHeader) {
    data["data-sticky"] = true;
  }
  return data;
}
function tableElement(element, options) {
  const name = `Table${element.charAt(0).toUpperCase()}${element.slice(1)}`;
  const Component2 = factory((_props, ref) => {
    const props = useProps(name, {}, _props);
    const { classNames, className, style: style2, styles, ...others } = props;
    const ctx = useTableContext();
    return /* @__PURE__ */ import_jsx_runtime190.jsx(Box, {
      component: element,
      ref,
      ...getDataAttributes(ctx, options),
      ...ctx.getStyles(element, { className, classNames, style: style2, styles, props }),
      ...others
    });
  });
  Component2.displayName = `@mantine/core/${name}`;
  Component2.classes = classes39;
  return Component2;
}
var TableTh = tableElement("th", { columnBorder: true });
var TableTd = tableElement("td", { columnBorder: true });
var TableTr = tableElement("tr", {
  rowBorder: true,
  striped: true,
  highlightOnHover: true
});
var TableThead = tableElement("thead", { stickyHeader: true });
var TableTbody = tableElement("tbody");
var TableTfoot = tableElement("tfoot");
var TableCaption = tableElement("caption", { captionSide: true });

// node_modules/@mantine/core/esm/components/Table/TableDataRenderer.mjs
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
"use client";
function TableDataRenderer({ data }) {
  return /* @__PURE__ */ import_jsx_runtime191.jsxs(import_jsx_runtime191.Fragment, { children: [
    data.caption && /* @__PURE__ */ import_jsx_runtime191.jsx(TableCaption, { children: data.caption }),
    data.head && /* @__PURE__ */ import_jsx_runtime191.jsx(TableThead, { children: /* @__PURE__ */ import_jsx_runtime191.jsx(TableTr, { children: data.head.map((item, index4) => /* @__PURE__ */ import_jsx_runtime191.jsx(TableTh, { children: item }, index4)) }) }),
    data.body && /* @__PURE__ */ import_jsx_runtime191.jsx(TableTbody, { children: data.body.map((row, rowIndex) => /* @__PURE__ */ import_jsx_runtime191.jsx(TableTr, { children: row.map((item, index4) => /* @__PURE__ */ import_jsx_runtime191.jsx(TableTd, { children: item }, index4)) }, rowIndex)) }),
    data.foot && /* @__PURE__ */ import_jsx_runtime191.jsx(TableTfoot, { children: /* @__PURE__ */ import_jsx_runtime191.jsx(TableTr, { children: data.foot.map((item, index4) => /* @__PURE__ */ import_jsx_runtime191.jsx(TableTh, { children: item }, index4)) }) })
  ] });
}
TableDataRenderer.displayName = "@mantine/core/TableDataRenderer";

// node_modules/@mantine/core/esm/components/Table/TableScrollContainer.mjs
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react236 = __toESM(require_react(), 1);
"use client";
var defaultProps94 = {
  type: "scrollarea"
};
var varsResolver41 = createVarsResolver((_2, { minWidth, maxHeight, type }) => ({
  scrollContainer: {
    "--table-min-width": rem(minWidth),
    "--table-max-height": rem(maxHeight),
    "--table-overflow": type === "native" ? "auto" : undefined
  }
}));
var TableScrollContainer = factory((_props, ref) => {
  const props = useProps("TableScrollContainer", defaultProps94, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children,
    minWidth,
    maxHeight,
    type,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "TableScrollContainer",
    classes: classes39,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver41,
    rootSelector: "scrollContainer"
  });
  return /* @__PURE__ */ import_jsx_runtime192.jsx(Box, {
    component: type === "scrollarea" ? ScrollArea : "div",
    ...type === "scrollarea" ? maxHeight ? { offsetScrollbars: "xy" } : { offsetScrollbars: "x" } : {},
    ref,
    ...getStyles2("scrollContainer"),
    ...others,
    children: /* @__PURE__ */ import_jsx_runtime192.jsx("div", { ...getStyles2("scrollContainerInner"), children })
  });
});
TableScrollContainer.classes = classes39;
TableScrollContainer.displayName = "@mantine/core/TableScrollContainer";

// node_modules/@mantine/core/esm/components/Table/Table.mjs
"use client";
var defaultProps95 = {
  withRowBorders: true,
  verticalSpacing: 7
};
var varsResolver42 = createVarsResolver((theme, {
  layout,
  captionSide,
  horizontalSpacing,
  verticalSpacing,
  borderColor,
  stripedColor,
  highlightOnHoverColor,
  striped,
  highlightOnHover,
  stickyHeaderOffset,
  stickyHeader
}) => ({
  table: {
    "--table-layout": layout,
    "--table-caption-side": captionSide,
    "--table-horizontal-spacing": getSpacing(horizontalSpacing),
    "--table-vertical-spacing": getSpacing(verticalSpacing),
    "--table-border-color": borderColor ? getThemeColor(borderColor, theme) : undefined,
    "--table-striped-color": striped && stripedColor ? getThemeColor(stripedColor, theme) : undefined,
    "--table-highlight-on-hover-color": highlightOnHover && highlightOnHoverColor ? getThemeColor(highlightOnHoverColor, theme) : undefined,
    "--table-sticky-header-offset": stickyHeader ? rem(stickyHeaderOffset) : undefined
  }
}));
var Table = factory((_props, ref) => {
  const props = useProps("Table", defaultProps95, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    horizontalSpacing,
    verticalSpacing,
    captionSide,
    stripedColor,
    highlightOnHoverColor,
    striped,
    highlightOnHover,
    withColumnBorders,
    withRowBorders,
    withTableBorder,
    borderColor,
    layout,
    variant,
    data,
    children,
    stickyHeader,
    stickyHeaderOffset,
    mod,
    tabularNums,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Table",
    props,
    className,
    style: style2,
    classes: classes39,
    classNames,
    styles,
    unstyled,
    rootSelector: "table",
    vars,
    varsResolver: varsResolver42
  });
  return /* @__PURE__ */ import_jsx_runtime193.jsx(TableProvider, {
    value: {
      getStyles: getStyles2,
      stickyHeader,
      striped: striped === true ? "odd" : striped || undefined,
      highlightOnHover,
      withColumnBorders,
      withRowBorders,
      captionSide: captionSide || "bottom"
    },
    children: /* @__PURE__ */ import_jsx_runtime193.jsx(Box, {
      component: "table",
      variant,
      ref,
      mod: [{ "data-with-table-border": withTableBorder, "data-tabular-nums": tabularNums }, mod],
      ...getStyles2("table"),
      ...others,
      children: children || !!data && /* @__PURE__ */ import_jsx_runtime193.jsx(TableDataRenderer, { data })
    })
  });
});
Table.classes = classes39;
Table.displayName = "@mantine/core/Table";
Table.Td = TableTd;
Table.Th = TableTh;
Table.Tr = TableTr;
Table.Thead = TableThead;
Table.Tbody = TableTbody;
Table.Tfoot = TableTfoot;
Table.Caption = TableCaption;
Table.ScrollContainer = TableScrollContainer;
Table.DataRenderer = TableDataRenderer;
// node_modules/@mantine/core/esm/components/TextInput/TextInput.mjs
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_react238 = __toESM(require_react(), 1);
"use client";
var defaultProps96 = {};
var TextInput = factory((props, ref) => {
  const _props = useProps("TextInput", defaultProps96, props);
  return /* @__PURE__ */ import_jsx_runtime194.jsx(InputBase, { component: "input", ref, ..._props, __staticSelector: "TextInput" });
});
TextInput.classes = InputBase.classes;
TextInput.displayName = "@mantine/core/TextInput";
// node_modules/@mantine/core/esm/components/Title/Title.mjs
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react240 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Title/get-title-size.mjs
var import_react239 = __toESM(require_react(), 1);
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
"use client";
var headings3 = ["h1", "h2", "h3", "h4", "h5", "h6"];
var sizes = ["xs", "sm", "md", "lg", "xl"];
function getTitleSize(order, size4) {
  const titleSize = size4 !== undefined ? size4 : `h${order}`;
  if (headings3.includes(titleSize)) {
    return {
      fontSize: `var(--mantine-${titleSize}-font-size)`,
      fontWeight: `var(--mantine-${titleSize}-font-weight)`,
      lineHeight: `var(--mantine-${titleSize}-line-height)`
    };
  } else if (sizes.includes(titleSize)) {
    return {
      fontSize: `var(--mantine-font-size-${titleSize})`,
      fontWeight: `var(--mantine-h${order}-font-weight)`,
      lineHeight: `var(--mantine-h${order}-line-height)`
    };
  }
  return {
    fontSize: rem(titleSize),
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  };
}

// node_modules/@mantine/core/esm/components/Title/Title.module.css.mjs
"use client";
var classes40 = { root: "m_8a5d1357" };

// node_modules/@mantine/core/esm/components/Title/Title.mjs
"use client";
var defaultProps97 = {
  order: 1
};
var varsResolver43 = createVarsResolver((_2, { order, size: size4, lineClamp, textWrap }) => {
  const sizeVariables = getTitleSize(order, size4);
  return {
    root: {
      "--title-fw": sizeVariables.fontWeight,
      "--title-lh": sizeVariables.lineHeight,
      "--title-fz": sizeVariables.fontSize,
      "--title-line-clamp": typeof lineClamp === "number" ? lineClamp.toString() : undefined,
      "--title-text-wrap": textWrap
    }
  };
});
var Title = factory((_props, ref) => {
  const props = useProps("Title", defaultProps97, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    order,
    vars,
    size: size4,
    variant,
    lineClamp,
    textWrap,
    mod,
    ...others
  } = props;
  const getStyles2 = useStyles({
    name: "Title",
    props,
    classes: classes40,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver43
  });
  if (![1, 2, 3, 4, 5, 6].includes(order)) {
    return null;
  }
  return /* @__PURE__ */ import_jsx_runtime196.jsx(Box, {
    ...getStyles2("root"),
    component: `h${order}`,
    variant,
    ref,
    mod: [{ order, "data-line-clamp": typeof lineClamp === "number" }, mod],
    size: size4,
    ...others
  });
});
Title.classes = classes40;
Title.displayName = "@mantine/core/Title";
// node_modules/@mantine/core/esm/components/Tree/Tree.mjs
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var import_react245 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Tree/TreeNode.mjs
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react241 = __toESM(require_react(), 1);
"use client";
function getValuesRange(anchor, value, flatValues) {
  if (!anchor || !value) {
    return [];
  }
  const anchorIndex = flatValues.indexOf(anchor);
  const valueIndex = flatValues.indexOf(value);
  const start = Math.min(anchorIndex, valueIndex);
  const end = Math.max(anchorIndex, valueIndex);
  return flatValues.slice(start, end + 1);
}
function TreeNode({
  node: node2,
  getStyles: getStyles2,
  rootIndex,
  controller,
  expandOnClick,
  selectOnClick,
  isSubtree,
  level = 1,
  renderNode,
  flatValues,
  allowRangeSelection,
  expandOnSpace,
  checkOnSpace
}) {
  const ref = import_react241.useRef(null);
  const nested = (node2.children || []).map((child) => /* @__PURE__ */ import_jsx_runtime197.jsx(TreeNode, {
    node: child,
    flatValues,
    getStyles: getStyles2,
    rootIndex: undefined,
    level: level + 1,
    controller,
    expandOnClick,
    isSubtree: true,
    renderNode,
    selectOnClick,
    allowRangeSelection,
    expandOnSpace,
    checkOnSpace
  }, child.value));
  const handleKeyDown = (event) => {
    if (event.nativeEvent.code === "ArrowRight") {
      event.stopPropagation();
      event.preventDefault();
      if (controller.expandedState[node2.value]) {
        event.currentTarget.querySelector("[role=treeitem]")?.focus();
      } else {
        controller.expand(node2.value);
      }
    }
    if (event.nativeEvent.code === "ArrowLeft") {
      event.stopPropagation();
      event.preventDefault();
      if (controller.expandedState[node2.value] && (node2.children || []).length > 0) {
        controller.collapse(node2.value);
      } else if (isSubtree) {
        findElementAncestor(event.currentTarget, "[role=treeitem]")?.focus();
      }
    }
    if (event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
      const root2 = findElementAncestor(event.currentTarget, "[data-tree-root]");
      if (!root2) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const nodes = Array.from(root2.querySelectorAll("[role=treeitem]"));
      const index4 = nodes.indexOf(event.currentTarget);
      if (index4 === -1) {
        return;
      }
      const nextIndex = event.nativeEvent.code === "ArrowDown" ? index4 + 1 : index4 - 1;
      nodes[nextIndex]?.focus();
      if (event.shiftKey) {
        const selectNode = nodes[nextIndex];
        if (selectNode) {
          controller.setSelectedState(getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues));
        }
      }
    }
    if (event.nativeEvent.code === "Space") {
      if (expandOnSpace) {
        event.stopPropagation();
        event.preventDefault();
        controller.toggleExpanded(node2.value);
      }
      if (checkOnSpace) {
        event.stopPropagation();
        event.preventDefault();
        controller.isNodeChecked(node2.value) ? controller.uncheckNode(node2.value) : controller.checkNode(node2.value);
      }
    }
  };
  const handleNodeClick = (event) => {
    event.stopPropagation();
    if (allowRangeSelection && event.shiftKey && controller.anchorNode) {
      controller.setSelectedState(getValuesRange(controller.anchorNode, node2.value, flatValues));
      ref.current?.focus();
    } else {
      expandOnClick && controller.toggleExpanded(node2.value);
      selectOnClick && controller.select(node2.value);
      ref.current?.focus();
    }
  };
  const selected = controller.selectedState.includes(node2.value);
  const elementProps = {
    ...getStyles2("label"),
    onClick: handleNodeClick,
    "data-selected": selected || undefined,
    "data-value": node2.value,
    "data-hovered": controller.hoveredNode === node2.value || undefined
  };
  return /* @__PURE__ */ import_jsx_runtime197.jsxs("li", {
    ...getStyles2("node", {
      style: { "--label-offset": `calc(var(--level-offset) * ${level - 1})` }
    }),
    role: "treeitem",
    "aria-selected": selected,
    "data-value": node2.value,
    "data-selected": selected || undefined,
    "data-hovered": controller.hoveredNode === node2.value || undefined,
    "data-level": level,
    tabIndex: rootIndex === 0 ? 0 : -1,
    onKeyDown: handleKeyDown,
    ref,
    onMouseOver: (event) => {
      event.stopPropagation();
      controller.setHoveredNode(node2.value);
    },
    onMouseLeave: (event) => {
      event.stopPropagation();
      controller.setHoveredNode(null);
    },
    children: [
      typeof renderNode === "function" ? renderNode({
        node: node2,
        level,
        selected,
        tree: controller,
        expanded: controller.expandedState[node2.value] || false,
        hasChildren: Array.isArray(node2.children) && node2.children.length > 0,
        elementProps
      }) : /* @__PURE__ */ import_jsx_runtime197.jsx("div", { ...elementProps, children: node2.label }),
      controller.expandedState[node2.value] && nested.length > 0 && /* @__PURE__ */ import_jsx_runtime197.jsx("ul", { role: "group", ...getStyles2("subtree"), "data-level": level, children: nested })
    ]
  });
}
TreeNode.displayName = "@mantine/core/TreeNode";

// node_modules/@mantine/core/esm/components/Tree/use-tree.mjs
var import_react244 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/Tree/get-all-checked-nodes/get-all-checked-nodes.mjs
"use client";
function getAllCheckedNodes(data, checkedState, acc = []) {
  const currentTreeChecked = [];
  for (const node2 of data) {
    if (Array.isArray(node2.children) && node2.children.length > 0) {
      const innerChecked = getAllCheckedNodes(node2.children, checkedState, acc);
      if (innerChecked.currentTreeChecked.length === node2.children.length) {
        const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked);
        const item = {
          checked: isChecked,
          indeterminate: !isChecked,
          value: node2.value,
          hasChildren: true
        };
        currentTreeChecked.push(item);
        acc.push(item);
      } else if (innerChecked.currentTreeChecked.length > 0) {
        const item = { checked: false, indeterminate: true, value: node2.value, hasChildren: true };
        currentTreeChecked.push(item);
        acc.push(item);
      }
    } else if (checkedState.includes(node2.value)) {
      const item = {
        checked: true,
        indeterminate: false,
        value: node2.value,
        hasChildren: false
      };
      currentTreeChecked.push(item);
      acc.push(item);
    }
  }
  return { result: acc, currentTreeChecked };
}

// node_modules/@mantine/core/esm/components/Tree/get-children-nodes-values/get-children-nodes-values.mjs
"use client";
function findTreeNode(value, data) {
  for (const node2 of data) {
    if (node2.value === value) {
      return node2;
    }
    if (Array.isArray(node2.children)) {
      const childNode = findTreeNode(value, node2.children);
      if (childNode) {
        return childNode;
      }
    }
  }
  return null;
}
function getChildrenNodesValues(value, data, acc = []) {
  const node2 = findTreeNode(value, data);
  if (!node2) {
    return acc;
  }
  if (!Array.isArray(node2.children) || node2.children.length === 0) {
    return [node2.value];
  }
  node2.children.forEach((child) => {
    if (Array.isArray(child.children) && child.children.length > 0) {
      getChildrenNodesValues(child.value, data, acc);
    } else {
      acc.push(child.value);
    }
  });
  return acc;
}
function getAllChildrenNodes(data) {
  return data.reduce((acc, node2) => {
    if (Array.isArray(node2.children) && node2.children.length > 0) {
      acc.push(...getAllChildrenNodes(node2.children));
    } else {
      acc.push(node2.value);
    }
    return acc;
  }, []);
}

// node_modules/@mantine/core/esm/components/Tree/is-node-checked/is-node-checked.mjs
var import_react242 = __toESM(require_react(), 1);
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
"use client";
function isNodeChecked(value, data, checkedState) {
  if (checkedState.length === 0) {
    return false;
  }
  if (checkedState.includes(value)) {
    return true;
  }
  const checkedNodes = getAllCheckedNodes(data, checkedState).result;
  return checkedNodes.some((node2) => node2.value === value && node2.checked);
}
var memoizedIsNodeChecked = memoize2(isNodeChecked);

// node_modules/@mantine/core/esm/components/Tree/is-node-indeterminate/is-node-indeterminate.mjs
var import_react243 = __toESM(require_react(), 1);
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
"use client";
function isNodeIndeterminate(value, data, checkedState) {
  if (checkedState.length === 0) {
    return false;
  }
  const checkedNodes = getAllCheckedNodes(data, checkedState).result;
  return checkedNodes.some((node2) => node2.value === value && node2.indeterminate);
}
var memoizedIsNodeIndeterminate = memoize2(isNodeIndeterminate);

// node_modules/@mantine/core/esm/components/Tree/use-tree.mjs
"use client";
function getInitialTreeExpandedState(initialState, data, value, acc = {}) {
  data.forEach((node2) => {
    acc[node2.value] = node2.value in initialState ? initialState[node2.value] : node2.value === value;
    if (Array.isArray(node2.children)) {
      getInitialTreeExpandedState(initialState, node2.children, value, acc);
    }
  });
  return acc;
}
function getInitialCheckedState(initialState, data) {
  const acc = [];
  initialState.forEach((node2) => acc.push(...getChildrenNodesValues(node2, data)));
  return Array.from(new Set(acc));
}
function useTree({
  initialSelectedState = [],
  initialCheckedState = [],
  initialExpandedState = {},
  multiple = false,
  onNodeCollapse,
  onNodeExpand
} = {}) {
  const [data, setData] = import_react244.useState([]);
  const [expandedState, setExpandedState] = import_react244.useState(initialExpandedState);
  const [selectedState, setSelectedState] = import_react244.useState(initialSelectedState);
  const [checkedState, setCheckedState] = import_react244.useState(initialCheckedState);
  const [anchorNode, setAnchorNode] = import_react244.useState(null);
  const [hoveredNode, setHoveredNode] = import_react244.useState(null);
  const initialize = import_react244.useCallback((_data) => {
    setExpandedState((current2) => getInitialTreeExpandedState(current2, _data, selectedState));
    setCheckedState((current2) => getInitialCheckedState(current2, _data));
    setData(_data);
  }, [selectedState, checkedState]);
  const toggleExpanded = import_react244.useCallback((value) => {
    setExpandedState((current2) => {
      const nextState = { ...current2, [value]: !current2[value] };
      nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value);
      return nextState;
    });
  }, [onNodeCollapse, onNodeExpand]);
  const collapse = import_react244.useCallback((value) => {
    setExpandedState((current2) => {
      if (current2[value] !== false) {
        onNodeCollapse?.(value);
      }
      return { ...current2, [value]: false };
    });
  }, [onNodeCollapse]);
  const expand = import_react244.useCallback((value) => {
    setExpandedState((current2) => {
      if (current2[value] !== true) {
        onNodeExpand?.(value);
      }
      return { ...current2, [value]: true };
    });
  }, [onNodeExpand]);
  const expandAllNodes = import_react244.useCallback(() => {
    setExpandedState((current2) => {
      const next2 = { ...current2 };
      Object.keys(next2).forEach((key) => {
        next2[key] = true;
      });
      return next2;
    });
  }, []);
  const collapseAllNodes = import_react244.useCallback(() => {
    setExpandedState((current2) => {
      const next2 = { ...current2 };
      Object.keys(next2).forEach((key) => {
        next2[key] = false;
      });
      return next2;
    });
  }, []);
  const toggleSelected = import_react244.useCallback((value) => setSelectedState((current2) => {
    if (!multiple) {
      if (current2.includes(value)) {
        setAnchorNode(null);
        return [];
      }
      setAnchorNode(value);
      return [value];
    }
    if (current2.includes(value)) {
      setAnchorNode(null);
      return current2.filter((item) => item !== value);
    }
    setAnchorNode(value);
    return [...current2, value];
  }), []);
  const select = import_react244.useCallback((value) => {
    setAnchorNode(value);
    setSelectedState((current2) => multiple ? current2.includes(value) ? current2 : [...current2, value] : [value]);
  }, []);
  const deselect = import_react244.useCallback((value) => {
    anchorNode === value && setAnchorNode(null);
    setSelectedState((current2) => current2.filter((item) => item !== value));
  }, []);
  const clearSelected = import_react244.useCallback(() => {
    setSelectedState([]);
    setAnchorNode(null);
  }, []);
  const checkNode = import_react244.useCallback((value) => {
    const checkedNodes = getChildrenNodesValues(value, data);
    setCheckedState((current2) => Array.from(/* @__PURE__ */ new Set([...current2, ...checkedNodes])));
  }, [data]);
  const uncheckNode = import_react244.useCallback((value) => {
    const checkedNodes = getChildrenNodesValues(value, data);
    setCheckedState((current2) => current2.filter((item) => !checkedNodes.includes(item)));
  }, [data]);
  const checkAllNodes = import_react244.useCallback(() => {
    setCheckedState(() => getAllChildrenNodes(data));
  }, [data]);
  const uncheckAllNodes = import_react244.useCallback(() => {
    setCheckedState([]);
  }, []);
  const getCheckedNodes = () => getAllCheckedNodes(data, checkedState).result;
  const isNodeChecked2 = (value) => memoizedIsNodeChecked(value, data, checkedState);
  const isNodeIndeterminate2 = (value) => memoizedIsNodeIndeterminate(value, data, checkedState);
  return {
    multiple,
    expandedState,
    selectedState,
    checkedState,
    anchorNode,
    initialize,
    toggleExpanded,
    collapse,
    expand,
    expandAllNodes,
    collapseAllNodes,
    setExpandedState,
    checkNode,
    uncheckNode,
    checkAllNodes,
    uncheckAllNodes,
    setCheckedState,
    toggleSelected,
    select,
    deselect,
    clearSelected,
    setSelectedState,
    hoveredNode,
    setHoveredNode,
    getCheckedNodes,
    isNodeChecked: isNodeChecked2,
    isNodeIndeterminate: isNodeIndeterminate2
  };
}

// node_modules/@mantine/core/esm/components/Tree/Tree.module.css.mjs
"use client";
var classes41 = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };

// node_modules/@mantine/core/esm/components/Tree/Tree.mjs
"use client";
function getFlatValues(data) {
  return data.reduce((acc, item) => {
    acc.push(item.value);
    if (item.children) {
      acc.push(...getFlatValues(item.children));
    }
    return acc;
  }, []);
}
var defaultProps98 = {
  expandOnClick: true,
  allowRangeSelection: true,
  expandOnSpace: true
};
var varsResolver44 = createVarsResolver((_theme, { levelOffset }) => ({
  root: {
    "--level-offset": getSpacing(levelOffset)
  }
}));
var Tree = factory((_props, ref) => {
  const props = useProps("Tree", defaultProps98, _props);
  const {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    expandOnClick,
    tree,
    renderNode,
    selectOnClick,
    clearSelectionOnOutsideClick,
    allowRangeSelection,
    expandOnSpace,
    levelOffset,
    checkOnSpace,
    ...others
  } = props;
  const defaultController = useTree();
  const controller = tree || defaultController;
  const getStyles2 = useStyles({
    name: "Tree",
    classes: classes41,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver44
  });
  const clickOutsideRef = useClickOutside(() => clearSelectionOnOutsideClick && controller.clearSelected());
  const mergedRef = useMergedRef(ref, clickOutsideRef);
  const flatValues = import_react245.useMemo(() => getFlatValues(data), [data]);
  import_react245.useEffect(() => {
    controller.initialize(data);
  }, [data]);
  const nodes = data.map((node2, index4) => /* @__PURE__ */ import_jsx_runtime200.jsx(TreeNode, {
    node: node2,
    getStyles: getStyles2,
    rootIndex: index4,
    expandOnClick,
    selectOnClick,
    controller,
    renderNode,
    flatValues,
    allowRangeSelection,
    expandOnSpace,
    checkOnSpace
  }, node2.value));
  return /* @__PURE__ */ import_jsx_runtime200.jsx(Box, {
    component: "ul",
    ref: mergedRef,
    ...getStyles2("root"),
    ...others,
    role: "tree",
    "aria-multiselectable": controller.multiple,
    "data-tree-root": true,
    children: nodes
  });
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes41;
// src/studio-adapter/layoutMapingValidation.ts
function layoutMappingValidation(layoutMap, doc) {
  const cleanLayoutMap = JSON.parse(JSON.stringify(layoutMap));
  const report = {
    removedLayoutIds: [],
    removedVariables: [],
    removedDependents: [],
    removedVariableValues: []
  };
  const existingLayoutIds = new Set(doc.layouts.map((layout) => layout.id));
  const existingVariableIds = new Set(doc.variables.map((variable) => variable.id));
  cleanLayoutMap.layoutIds = cleanLayoutMap.layoutIds.filter((layoutId) => {
    const exists = existingLayoutIds.has(layoutId);
    if (!exists) {
      report.removedLayoutIds.push(layoutId);
    }
    return exists;
  });
  cleanLayoutMap.variables = cleanLayoutMap.variables.filter((imageVariable) => {
    console.log("ADGA");
    const imageVariableExists = imageVariable.id ? existingVariableIds.has(imageVariable.id) : false;
    if (!imageVariableExists && imageVariable.id) {
      report.removedVariables.push(imageVariable.id);
      return false;
    }
    processImageVariableDependentGroups(imageVariable, existingVariableIds, report);
    return imageVariableExists || !imageVariable.id;
  });
  return {
    cleanLayoutMap,
    report
  };
}
function processImageVariableDependentGroups(imageVariable, existingVariableIds, report) {
  imageVariable.dependentGroup = imageVariable.dependentGroup.filter((group, groupIndex) => {
    group.dependents = group.dependents.filter((dependent) => {
      const dependentExists = existingVariableIds.has(dependent.variableId);
      if (!dependentExists) {
        report.removedDependents.push({
          variableId: dependent.variableId,
          imageVariableId: imageVariable.id || "unknown"
        });
      }
      return dependentExists;
    });
    group.variableValue = group.variableValue.filter((value) => {
      if (typeof value === "string") {
        return true;
      }
      const variableValue = value;
      const valueExists = variableValue.id ? existingVariableIds.has(variableValue.id) : true;
      if (!valueExists && variableValue.id) {
        report.removedVariableValues.push({
          value: variableValue.id,
          imageVariableId: imageVariable.id || "unknown",
          dependentGroupIndex: groupIndex
        });
      }
      return valueExists;
    });
    return group.dependents.length > 0 || group.variableValue.length > 0;
  });
}

// node_modules/@tabler/icons-react/dist/esm/tabler-icons-react.mjs
init_IconRosetteDiscountCheckFilled();
init_IconAbc();
init_IconAlertCircle();
init_IconAlertTriangle();
init_IconArrowAutofitDown();
init_IconArrowsTransferUpDown();
init_IconBug();
init_IconCameraPlus();
init_IconChevronDown();
init_IconChevronLeft();
init_IconChevronRight();
init_IconCircleX();
init_IconCopyPlus();
init_IconCopy();
init_IconCrop();
init_IconDeselect();
init_IconDownload();
init_IconExchange();
init_IconExclamationCircle();
init_IconExternalLink();
init_IconEyeCheck();
init_IconEyeClosed();
init_IconFileDownload();
init_IconFileUpload();
init_IconFile();
init_IconFilter();
init_IconFolder();
init_IconGripVertical();
init_IconInfoCircle();
init_IconListTree();
init_IconList();
init_IconLoader();
init_IconMapBolt();
init_IconPencil();
init_IconPhotoCog();
init_IconPhotoSearch();
init_IconPlaystationSquare();
init_IconPlug();
init_IconPlus();
init_IconReplace();
init_IconSearch();
init_IconSettings();
init_IconSparkles();
init_IconTrash();
init_IconUpload();
init_IconWand();
init_IconX();
init_IconArrowBigLeftFilled();
init_IconBugFilled();
init_IconCaretDownFilled();
init_IconCircleCheckFilled();
init_IconCircleRectangleFilled();
init_IconFilterFilled();
init_IconInfoCircleFilled();
init_IconRadioactiveFilled();
init_IconRosetteFilled();
init_IconTrashFilled();

// src/components/LayoutMappingModal/AddMappingImageVariableModal.tsx
var import_react247 = __toESM(require_react(), 1);
var jsx_runtime = __toESM(require_jsx_runtime(), 1);
var AddMappingImageVariableModal = ({ currentMapConfig }) => {
  const setIsImageVariableMappingModalOpen = appStore((state) => state.effects.modal.setIsImageVariableMappingModalOpen);
  const setCurrentAddImageMappingSelectedVariables = appStore((state) => state.effects.modal.setCurrentAddImageMappingSelectedVariables);
  const addImageVariable = appStore((state) => state.effects.studio.layoutImageMapping.addImageVariable);
  const variables = appStore((state) => state.state.studio.document.variables);
  const currentSelectedMapId = appStore((state) => state.state.modal.currentSelectedMapId);
  const currentAddImageMappingSelectedVariables = appStore((state) => state.state.modal.currentAddImageMappingSelectedVariables);
  const isAddImageVariableMappingModalOpen = appStore((state) => state.state.modal.isAddImageVariableMappingModalOpen);
  const possibleVariableValues = import_react247.useMemo(() => {
    const allImageVariables = variables.filter((variable) => variable.type === "image").map((variable) => ({
      value: variable.id,
      label: variable.name,
      disabled: currentMapConfig?.variables.some((v2) => v2.id === variable.id) || false
    }));
    return allImageVariables;
  }, [variables, currentMapConfig]);
  const onClose = () => {
    setIsImageVariableMappingModalOpen(false);
    setCurrentAddImageMappingSelectedVariables([]);
  };
  const addImageVariables = () => {
    const mapId = currentSelectedMapId;
    if (mapId == null)
      return;
    currentAddImageMappingSelectedVariables.forEach((variableId) => {
      addImageVariable({
        mapId,
        imageVariable: {
          id: variableId,
          dependentGroup: []
        }
      });
    });
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime.jsx(Modal, {
    opened: isAddImageVariableMappingModalOpen,
    onClose,
    title: "Add Image Variables",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime.jsx(MultiSelect, {
          label: "Select Image Variable",
          placeholder: "Choose an image variable",
          data: possibleVariableValues,
          value: currentAddImageMappingSelectedVariables,
          onChange: setCurrentAddImageMappingSelectedVariables,
          searchable: true
        }),
        /* @__PURE__ */ jsx_runtime.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Close"
            }),
            /* @__PURE__ */ jsx_runtime.jsx(Button, {
              onClick: addImageVariables,
              disabled: currentAddImageMappingSelectedVariables.length == 0,
              children: "Add"
            })
          ]
        })
      ]
    })
  });
};

// src/components/LayoutMappingModal/AddDependentModal.tsx
var jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var AddDependentModal = () => {
  const raiseError2 = appStore((state) => state.raiseError);
  const setIsOpen = appStore((state) => state.effects.modal.dependentModal.setIsOpen);
  const setCurrentGroupIndex = appStore((state) => state.effects.modal.dependentModal.setCurrentGroupIndex);
  const setCurrentSelectedVariables = appStore((state) => state.effects.modal.dependentModal.setCurrentSelectedVariables);
  const addDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.addDependentGroup);
  const updateDependent = appStore((state) => state.effects.studio.layoutImageMapping.updateDependent);
  const variables = appStore((state) => state.state.studio.document.variables);
  const currentSelectedVariables = appStore((state) => state.state.modal.dependentModal.currentSelectedVariables);
  const currentImageVariableId = appStore((state) => state.state.modal.dependentModal.currentImageVariableId);
  const currentSelectedMapId = appStore((state) => state.state.modal.currentSelectedMapId);
  const currentGroupIndex = appStore((state) => state.state.modal.dependentModal.currentGroupIndex);
  const isOpen = appStore((state) => state.state.modal.dependentModal.isOpen);
  const onClose = () => {
    setIsOpen(false);
    setCurrentGroupIndex(null);
    setCurrentSelectedVariables([]);
  };
  const getVariableById = (id) => {
    return variables.find((v2) => v2.id === id);
  };
  const addDependents = () => {
    const selectedVariables = currentSelectedVariables;
    const imageVariableId = currentImageVariableId;
    const mapId = currentSelectedMapId;
    if (!mapId || !imageVariableId) {
      raiseError2(new Error(`One of these are null mapId:${mapId} or imageVariableId:${imageVariableId}`));
      return;
    }
    const groupIndex = currentGroupIndex;
    const dependents = selectedVariables.map((variableId) => {
      const variable = getVariableById(variableId);
      if (!variable) {
        const e = new Error(`Variable with id ${variableId} is not found`);
        raiseError2(e);
        throw e;
      }
      switch (variable.type) {
        case "list":
          return {
            variableId,
            values: variable.items.map((i2) => i2.value)
          };
        default:
          return {
            variableId,
            values: []
          };
      }
    });
    if (groupIndex === null) {
      addDependentGroup({
        mapId,
        imageVariableId,
        dependents
      });
    } else {
      dependents.forEach((dependent) => {
        updateDependent({
          mapId: currentSelectedMapId || "",
          imageVariableId,
          dependentGroupIndex: groupIndex,
          dependent
        });
      });
    }
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime2.jsx(Modal, {
    opened: isOpen,
    onClose,
    title: "Add Dependent Variable",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime2.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime2.jsx(MultiSelect, {
          label: "Select Variable",
          placeholder: "Choose a variable",
          data: variables.filter((variable) => variable.type !== "image" && variable.type !== "shortText").map((variable) => ({
            value: variable.id,
            label: variable.name
          })),
          value: currentSelectedVariables,
          onChange: setCurrentSelectedVariables,
          searchable: true
        }),
        /* @__PURE__ */ jsx_runtime2.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime2.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Close"
            }),
            /* @__PURE__ */ jsx_runtime2.jsx(Button, {
              onClick: addDependents,
              disabled: currentSelectedVariables.length === 0,
              children: "Add"
            })
          ]
        })
      ]
    })
  });
};

// src/components/LayoutMappingModal/SwapImageVariableModal.tsx
var import_react248 = __toESM(require_react(), 1);
var jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var SwapImageVariableModal = ({
  currentMapConfig,
  currentImageVariable
}) => {
  const setIsSwapImageVariableModalOpen = appStore((state) => state.effects.modal.setIsSwapImageVariableModalOpen);
  const setCurrentSwapImageVariableSelected = appStore((state) => state.effects.modal.setCurrentSwapImageVariableSelected);
  const swapImageVariable = appStore((state) => state.effects.studio.layoutImageMapping.swapImageVariable);
  const variables = appStore((state) => state.state.studio.document.variables);
  const currentSelectedMapId = appStore((state) => state.state.modal.currentSelectedMapId);
  const currentSwapImageVariableSelected = appStore((state) => state.state.modal.currentSwapImageVariableSelected);
  const isSwapImageVariableModalOpen = appStore((state) => state.state.modal.isSwapImageVariableModalOpen);
  const possibleVariableValues = import_react248.useMemo(() => {
    const allImageVariables = variables.filter((variable) => variable.type === "image").map((variable) => ({
      value: variable.id,
      label: variable.name,
      disabled: currentImageVariable && variable.id === currentImageVariable.id || currentMapConfig?.variables.some((v2) => v2.id === variable.id && (currentImageVariable ? v2.id !== currentImageVariable.id : true)) || false
    }));
    return allImageVariables;
  }, [variables, currentMapConfig, currentImageVariable]);
  const onClose = () => {
    setIsSwapImageVariableModalOpen(false);
    setCurrentSwapImageVariableSelected("");
  };
  const handleSwapImageVariable = () => {
    const mapId = currentSelectedMapId;
    const newImageVariableId = currentSwapImageVariableSelected;
    if (mapId == null || !currentImageVariable || !newImageVariableId)
      return;
    swapImageVariable({
      mapId,
      oldImageVariableId: currentImageVariable.id,
      newImageVariableId
    });
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime3.jsx(Modal, {
    opened: isSwapImageVariableModalOpen,
    onClose,
    title: "Swap Image Variable",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime3.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime3.jsx(Select, {
          label: "Select Image Variable",
          placeholder: "Choose an image variable to swap with",
          data: possibleVariableValues,
          value: currentSwapImageVariableSelected,
          onChange: (value) => value && setCurrentSwapImageVariableSelected(value),
          searchable: true
        }),
        /* @__PURE__ */ jsx_runtime3.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime3.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime3.jsx(Button, {
              onClick: handleSwapImageVariable,
              disabled: !currentSwapImageVariableSelected,
              children: "Swap"
            })
          ]
        })
      ]
    })
  });
};

// src/components/LayoutMappingModal/LayoutConfigSelection.tsx
var import_react256 = __toESM(require_react(), 1);

// src/components/LayoutMappingModal/LayoutMultiSelect.tsx
var import_react249 = __toESM(require_react(), 1);
var jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var buildTreeData = (documentLayouts, selectedLayoutIds, disabledLayoutIds) => {
  const layoutsByParent = {};
  documentLayouts.forEach((layout) => {
    const parentId = layout.parentId || "root";
    if (!layoutsByParent[parentId]) {
      layoutsByParent[parentId] = [];
    }
    layoutsByParent[parentId].push(layout);
  });
  const buildNodes = (parentId = "root") => {
    const children = layoutsByParent[parentId] || [];
    return children.map((layout) => ({
      value: layout.id,
      label: layout.name,
      disabled: disabledLayoutIds.includes(layout.id),
      children: buildNodes(layout.id)
    }));
  };
  return buildNodes();
};
var LayoutMultiSelect = ({
  layoutConfig,
  showButton
}) => {
  const documentLayouts = appStore((store) => store.state.studio.document.layouts);
  const layoutImageMapping = appStore((store) => store.state.studio.layoutImageMapping);
  const setLayoutIds = appStore((store) => store.effects.studio.layoutImageMapping.setLayoutIds);
  const [drawerOpened, setDrawerOpened] = import_react249.useState(false);
  const [selectedLayouts, setSelectedLayouts] = import_react249.useState(layoutImageMapping.find((lc) => lc.id === layoutConfig.id)?.layoutIds || []);
  const assignedToOtherMaps = layoutImageMapping.filter((map) => map.id !== layoutConfig.id).flatMap((map) => map.layoutIds);
  const handleMultiSelectChange = (updateLayoutIds) => {
    setLayoutIds({
      mapId: layoutConfig.id,
      layoutIds: updateLayoutIds
    });
  };
  const handleSave = () => {
    handleMultiSelectChange(selectedLayouts);
    setDrawerOpened(false);
  };
  const handleToggleLayout = (layoutId) => {
    setSelectedLayouts((prev2) => {
      if (prev2.includes(layoutId)) {
        return prev2.filter((id) => id !== layoutId);
      } else {
        return [...prev2, layoutId];
      }
    });
  };
  const treeData = buildTreeData(documentLayouts, selectedLayouts, assignedToOtherMaps);
  const renderTreeNode = ({
    node: node2,
    expanded,
    hasChildren,
    elementProps
  }) => {
    const isDisabled = node2.disabled;
    const isChecked = selectedLayouts.includes(node2.value);
    return /* @__PURE__ */ jsx_runtime4.jsxs(Group, {
      gap: "xs",
      ...elementProps,
      children: [
        /* @__PURE__ */ jsx_runtime4.jsx(Checkbox.Indicator, {
          checked: isChecked,
          disabled: isDisabled,
          onClick: (e) => {
            e.stopPropagation();
            if (!isDisabled) {
              handleToggleLayout(node2.value);
            }
          }
        }),
        /* @__PURE__ */ jsx_runtime4.jsxs(Group, {
          gap: 5,
          style: {
            color: isDisabled ? "var(--mantine-color-gray-6)" : undefined,
            cursor: isDisabled ? "not-allowed" : "pointer"
          },
          children: [
            /* @__PURE__ */ jsx_runtime4.jsx("span", {
              children: node2.label
            }),
            hasChildren && /* @__PURE__ */ jsx_runtime4.jsx(IconChevronDown, {
              size: 14,
              color: isDisabled ? "var(--mantine-color-gray-6)" : undefined,
              style: {
                transform: expanded ? "rotate(180deg)" : "rotate(0deg)"
              }
            })
          ]
        })
      ]
    });
  };
  return /* @__PURE__ */ jsx_runtime4.jsxs(jsx_runtime4.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime4.jsxs(Group, {
        children: [
          /* @__PURE__ */ jsx_runtime4.jsx(MultiSelect, {
            data: documentLayouts.map((layout) => {
              return {
                value: layout.id,
                label: layout.name,
                disabled: assignedToOtherMaps.includes(layout.id)
              };
            }),
            value: layoutImageMapping.find((lc) => lc.id === layoutConfig.id)?.layoutIds,
            onChange: handleMultiSelectChange,
            placeholder: "Select layouts",
            searchable: true,
            clearable: true,
            styles: {
              root: {
                width: showButton ? "80%" : "100%"
              }
            }
          }),
          showButton && /* @__PURE__ */ jsx_runtime4.jsxs(Button, {
            onClick: () => setDrawerOpened(true),
            children: [
              /* @__PURE__ */ jsx_runtime4.jsxs("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                width: "24",
                height: "24",
                strokeWidth: "2",
                children: [
                  /* @__PURE__ */ jsx_runtime4.jsx("path", {
                    d: "M13 5h8"
                  }),
                  /* @__PURE__ */ jsx_runtime4.jsx("path", {
                    d: "M13 9h5"
                  }),
                  /* @__PURE__ */ jsx_runtime4.jsx("path", {
                    d: "M13 15h8"
                  }),
                  /* @__PURE__ */ jsx_runtime4.jsx("path", {
                    d: "M13 19h5"
                  }),
                  /* @__PURE__ */ jsx_runtime4.jsx("path", {
                    d: "M3 4m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z"
                  }),
                  /* @__PURE__ */ jsx_runtime4.jsx("path", {
                    d: "M3 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z"
                  })
                ]
              }),
              /* @__PURE__ */ jsx_runtime4.jsx("span", {
                style: { marginLeft: "10px" },
                children: "Open Selector"
              })
            ]
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime4.jsxs(Drawer, {
        opened: drawerOpened,
        onClose: () => setDrawerOpened(false),
        title: "Select Layouts",
        position: "right",
        size: "md",
        padding: "md",
        children: [
          /* @__PURE__ */ jsx_runtime4.jsx("div", {
            style: { marginBottom: "20px" },
            children: /* @__PURE__ */ jsx_runtime4.jsx(Tree, {
              data: treeData,
              renderNode: renderTreeNode,
              expandOnClick: true
            })
          }),
          /* @__PURE__ */ jsx_runtime4.jsx(Button, {
            fullWidth: true,
            onClick: handleSave,
            children: "Save"
          })
        ]
      })
    ]
  });
};

// src/components/LayoutMappingModal/VariableCard.tsx
var import_react255 = __toESM(require_react(), 1);
init_dist();

// node_modules/@dnd-kit/core/dist/core.esm.js
var import_react252 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);

// node_modules/@dnd-kit/utilities/dist/utilities.esm.js
var import_react250 = __toESM(require_react(), 1);
function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0;_key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return import_react250.useMemo(() => (node2) => {
    refs.forEach((ref) => ref(node2));
  }, refs);
}
var canUseDOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || elementString === "[object global]";
}
function isNode3(node2) {
  return "nodeType" in node2;
}
function getWindow2(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode3(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? undefined : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node2) {
  const {
    Document
  } = getWindow2(node2);
  return node2 instanceof Document;
}
function isHTMLElement2(node2) {
  if (isWindow(node2)) {
    return false;
  }
  return node2 instanceof getWindow2(node2).HTMLElement;
}
function isSVGElement(node2) {
  return node2 instanceof getWindow2(node2).SVGElement;
}
function getOwnerDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode3(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement2(target) || isSVGElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
var useIsomorphicLayoutEffect2 = canUseDOM2 ? import_react250.useLayoutEffect : import_react250.useEffect;
function useEvent(handler) {
  const handlerRef = import_react250.useRef(handler);
  useIsomorphicLayoutEffect2(() => {
    handlerRef.current = handler;
  });
  return import_react250.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return handlerRef.current == null ? undefined : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = import_react250.useRef(null);
  const set2 = import_react250.useCallback((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = import_react250.useCallback(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set2, clear];
}
function useLatestValue(value, dependencies) {
  if (dependencies === undefined) {
    dependencies = [value];
  }
  const valueRef = import_react250.useRef(value);
  useIsomorphicLayoutEffect2(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = import_react250.useRef();
  return import_react250.useMemo(() => {
    const newValue = callback(valueRef.current);
    valueRef.current = newValue;
    return newValue;
  }, [...dependencies]);
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node2 = import_react250.useRef(null);
  const setNodeRef = import_react250.useCallback((element) => {
    if (element !== node2.current) {
      onChangeHandler == null || onChangeHandler(element, node2.current);
    }
    node2.current = element;
  }, []);
  return [node2, setNodeRef];
}
function usePrevious2(value) {
  const ref = import_react250.useRef();
  import_react250.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var ids = {};
function useUniqueId(prefix3, value) {
  return import_react250.useMemo(() => {
    if (value) {
      return value;
    }
    const id = ids[prefix3] == null ? 0 : ids[prefix3] + 1;
    ids[prefix3] = id;
    return prefix3 + "-" + id;
  }, [prefix3, value]);
}
function createAdjustmentFn(modifier) {
  return function(object) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key, valueAdjustment] of entries) {
        const value = accumulator[key];
        if (value != null) {
          accumulator[key] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object
    });
  };
}
var add = /* @__PURE__ */ createAdjustmentFn(1);
var subtract = /* @__PURE__ */ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent: KeyboardEvent2
  } = getWindow2(event.target);
  return KeyboardEvent2 && event instanceof KeyboardEvent2;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow2(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x2,
        clientY: y2
      } = event.touches[0];
      return {
        x: x2,
        y: y2
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x2,
        clientY: y2
      } = event.changedTouches[0];
      return {
        x: x2,
        y: y2
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
var CSS2 = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x2,
        y: y2
      } = transform;
      return "translate3d(" + (x2 ? Math.round(x2) : 0) + "px, " + (y2 ? Math.round(y2) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX,
        scaleY
      } = transform;
      return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS2.Translate.toString(transform), CSS2.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString(_ref) {
      let {
        property,
        duration,
        easing
      } = _ref;
      return property + " " + duration + "ms " + easing;
    }
  }
});
var SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }
  return element.querySelector(SELECTOR);
}

// node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js
var import_react251 = __toESM(require_react(), 1);
var hiddenStyles = {
  display: "none"
};
function HiddenText(_ref) {
  let {
    id,
    value
  } = _ref;
  return import_react251.default.createElement("div", {
    id,
    style: hiddenStyles
  }, value);
}
function LiveRegion(_ref) {
  let {
    id,
    announcement,
    ariaLiveType = "assertive"
  } = _ref;
  const visuallyHidden = {
    position: "fixed",
    top: 0,
    left: 0,
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
  };
  return import_react251.default.createElement("div", {
    id,
    style: visuallyHidden,
    role: "status",
    "aria-live": ariaLiveType,
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = import_react251.useState("");
  const announce = import_react251.useCallback((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}

// node_modules/@dnd-kit/core/dist/core.esm.js
var DndMonitorContext = /* @__PURE__ */ import_react252.createContext(null);
function useDndMonitor(listener) {
  const registerListener = import_react252.useContext(DndMonitorContext);
  import_react252.useEffect(() => {
    if (!registerListener) {
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    }
    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}
function useDndMonitorProvider() {
  const [listeners] = import_react252.useState(() => new Set);
  const registerListener = import_react252.useCallback((listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }, [listeners]);
  const dispatch = import_react252.useCallback((_ref) => {
    let {
      type,
      event
    } = _ref;
    listeners.forEach((listener) => {
      var _listener$type;
      return (_listener$type = listener[type]) == null ? undefined : _listener$type.call(listener, event);
    });
  }, [listeners]);
  return [dispatch, registerListener];
}
var defaultScreenReaderInstructions = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
};
var defaultAnnouncements = {
  onDragStart(_ref) {
    let {
      active
    } = _ref;
    return "Picked up draggable item " + active.id + ".";
  },
  onDragOver(_ref2) {
    let {
      active,
      over
    } = _ref2;
    if (over) {
      return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
    }
    return "Draggable item " + active.id + " is no longer over a droppable area.";
  },
  onDragEnd(_ref3) {
    let {
      active,
      over
    } = _ref3;
    if (over) {
      return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
    }
    return "Draggable item " + active.id + " was dropped.";
  },
  onDragCancel(_ref4) {
    let {
      active
    } = _ref4;
    return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
  }
};
function Accessibility(_ref) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId("DndLiveRegion");
  const [mounted, setMounted] = import_react252.useState(false);
  import_react252.useEffect(() => {
    setMounted(true);
  }, []);
  useDndMonitor(import_react252.useMemo(() => ({
    onDragStart(_ref2) {
      let {
        active
      } = _ref2;
      announce(announcements.onDragStart({
        active
      }));
    },
    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;
      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },
    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },
    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },
    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }
  }), [announce, announcements]));
  if (!mounted) {
    return null;
  }
  const markup = import_react252.default.createElement(import_react252.default.Fragment, null, import_react252.default.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), import_react252.default.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  }));
  return container ? import_react_dom5.createPortal(markup, container) : markup;
}
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop6() {
}
function useSensor(sensor, options) {
  return import_react252.useMemo(() => ({
    sensor,
    options: options != null ? options : {}
  }), [sensor, options]);
}
function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0;_key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }
  return import_react252.useMemo(() => [...sensors].filter((sensor) => sensor != null), [...sensors]);
}
var defaultCoordinates = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function sortCollisionsAsc(_ref, _ref2) {
  let {
    data: {
      value: a2
    }
  } = _ref;
  let {
    data: {
      value: b
    }
  } = _ref2;
  return a2 - b;
}
function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a2
    }
  } = _ref3;
  let {
    data: {
      value: b
    }
  } = _ref4;
  return b - a2;
}
function cornersOfRectangle(_ref5) {
  let {
    left,
    top,
    height,
    width
  } = _ref5;
  return [{
    x: left,
    y: top
  }, {
    x: left + width,
    y: top
  }, {
    x: left,
    y: top + height
  }, {
    x: left + width,
    y: top + height
  }];
}
function getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }
  const [firstCollision] = collisions;
  return property ? firstCollision[property] : firstCollision;
}
function centerOfRectangle(rect, left, top) {
  if (left === undefined) {
    left = rect.left;
  }
  if (top === undefined) {
    top = rect.top;
  }
  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
var closestCenter = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: distBetween
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
var closestCorners = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const corners = cornersOfRectangle(collisionRect);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const rectCorners = cornersOfRectangle(rect);
      const distances = corners.reduce((accumulator, corner, index4) => {
        return accumulator + distanceBetween(rectCorners[index4], corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: effectiveDistance
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.top);
  const left = Math.max(target.left, entry.left);
  const right = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
var rectIntersection = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > 0) {
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: intersectionRatio
          }
        });
      }
    }
  }
  return collisions.sort(sortCollisionsDesc);
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), {
      ...rect
    });
  };
}
var getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
function parseTransform(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
function inverseTransform(rect, transform, transformOrigin) {
  const parsedTransform = parseTransform(transform);
  if (!parsedTransform) {
    return rect;
  }
  const {
    scaleX,
    scaleY,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x2 = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y2 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX ? rect.width / scaleX : rect.width;
  const h = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w2,
    height: h,
    top: y2,
    right: x2 + w2,
    bottom: y2 + h,
    left: x2
  };
}
var defaultOptions = {
  ignoreTransform: false
};
function getClientRect(element, options) {
  if (options === undefined) {
    options = defaultOptions;
  }
  let rect = element.getBoundingClientRect();
  if (options.ignoreTransform) {
    const {
      transform,
      transformOrigin
    } = getWindow2(element).getComputedStyle(element);
    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin);
    }
  }
  const {
    top,
    left,
    width,
    height,
    bottom,
    right
  } = rect;
  return {
    top,
    left,
    width,
    height,
    bottom,
    right
  };
}
function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}
function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isFixed(node2, computedStyle) {
  if (computedStyle === undefined) {
    computedStyle = getWindow2(node2).getComputedStyle(node2);
  }
  return computedStyle.position === "fixed";
}
function isScrollable(element, computedStyle) {
  if (computedStyle === undefined) {
    computedStyle = getWindow2(element).getComputedStyle(element);
  }
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
function getScrollableAncestors(element, limit) {
  const scrollParents = [];
  function findScrollableAncestors(node2) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }
    if (!node2) {
      return scrollParents;
    }
    if (isDocument(node2) && node2.scrollingElement != null && !scrollParents.includes(node2.scrollingElement)) {
      scrollParents.push(node2.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement2(node2) || isSVGElement(node2)) {
      return scrollParents;
    }
    if (scrollParents.includes(node2)) {
      return scrollParents;
    }
    const computedStyle = getWindow2(element).getComputedStyle(node2);
    if (node2 !== element) {
      if (isScrollable(node2, computedStyle)) {
        scrollParents.push(node2);
      }
    }
    if (isFixed(node2, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node2.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node2) {
  const [firstScrollableAncestor] = getScrollableAncestors(node2, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
  if (!canUseDOM2 || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode3(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement2(element)) {
    return element;
  }
  return null;
}
function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }
  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }
  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function isDocumentScrollingElement(element) {
  if (!canUseDOM2 || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
  let {
    top,
    left,
    right,
    bottom
  } = _ref;
  if (acceleration === undefined) {
    acceleration = 10;
  }
  if (thresholdPercentage === undefined) {
    thresholdPercentage = defaultThreshold;
  }
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top <= scrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }
  if (!isRight && right >= scrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }
  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node2) => {
    return add(acc, getScrollCoordinates(node2));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node2) => {
    return acc + getScrollXCoordinate(node2);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node2) => {
    return acc + getScrollYCoordinate(node2);
  }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
  if (measure === undefined) {
    measure = getClientRect;
  }
  if (!element) {
    return;
  }
  const {
    top,
    left,
    bottom,
    right
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);
  if (!firstScrollableAncestor) {
    return;
  }
  if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
    element.scrollIntoView({
      block: "center",
      inline: "center"
    });
  }
}
var properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];

class Rect {
  constructor(rect, element) {
    this.rect = undefined;
    this.width = undefined;
    this.height = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.right = undefined;
    this.left = undefined;
    const scrollableAncestors = getScrollableAncestors(element);
    const scrollOffsets = getScrollOffsets(scrollableAncestors);
    this.rect = {
      ...rect
    };
    this.width = rect.width;
    this.height = rect.height;
    for (const [axis, keys2, getScrollOffset] of properties) {
      for (const key of keys2) {
        Object.defineProperty(this, key, {
          get: () => {
            const currentOffsets = getScrollOffset(scrollableAncestors);
            const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
            return this.rect[key] + scrollOffsetsDeltla;
          },
          enumerable: true
        });
      }
    }
    Object.defineProperty(this, "rect", {
      enumerable: false
    });
  }
}

class Listeners {
  constructor(target) {
    this.target = undefined;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? undefined : _this$target.removeEventListener(...listener);
      });
    };
    this.target = target;
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null || _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
}
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow2(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName2) {
  EventName2["Click"] = "click";
  EventName2["DragStart"] = "dragstart";
  EventName2["Keydown"] = "keydown";
  EventName2["ContextMenu"] = "contextmenu";
  EventName2["Resize"] = "resize";
  EventName2["SelectionChange"] = "selectionchange";
  EventName2["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation(event) {
  event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
  KeyboardCode2["Tab"] = "Tab";
})(KeyboardCode || (KeyboardCode = {}));
var defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
};
var defaultKeyboardCoordinateGetter = (event, _ref) => {
  let {
    currentCoordinates
  } = _ref;
  switch (event.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return;
};

class KeyboardSensor {
  constructor(props) {
    this.props = undefined;
    this.autoScrollEnabled = false;
    this.referenceCoordinates = undefined;
    this.listeners = undefined;
    this.windowListeners = undefined;
    this.props = props;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(getWindow2(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    const node2 = activeNode.node.current;
    if (node2) {
      scrollIntoViewIfNeeded(node2);
    }
    onStart(defaultCoordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const {
        collisionRect
      } = context.current;
      const currentCoordinates = collisionRect ? {
        x: collisionRect.left,
        y: collisionRect.top
      } : defaultCoordinates;
      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates
      });
      if (newCoordinates) {
        const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
            const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
            if (canScrollToNewCoordinates && !coordinatesDelta.y) {
              scrollContainer.scrollTo({
                left: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
            } else {
              scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            }
            if (scrollDelta.x) {
              scrollContainer.scrollBy({
                left: -scrollDelta.x,
                behavior: scrollBehavior
              });
            }
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
            const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
            if (canScrollToNewCoordinates && !coordinatesDelta.x) {
              scrollContainer.scrollTo({
                top: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
            } else {
              scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            }
            if (scrollDelta.y) {
              scrollContainer.scrollBy({
                top: -scrollDelta.y,
                behavior: scrollBehavior
              });
            }
            break;
          }
        }
        this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
}
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, _ref, _ref2) => {
    let {
      keyboardCodes = defaultKeyboardCodes,
      onActivation
    } = _ref;
    let {
      active
    } = _ref2;
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      const activator = active.activatorNode.current;
      if (activator && event.target !== activator) {
        return false;
      }
      event.preventDefault();
      onActivation == null || onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}

class AbstractPointerSensor {
  constructor(props, events, listenerTarget) {
    var _getEventCoordinates;
    if (listenerTarget === undefined) {
      listenerTarget = getEventListenerTarget(props.event.target);
    }
    this.props = undefined;
    this.events = undefined;
    this.autoScrollEnabled = true;
    this.document = undefined;
    this.activated = false;
    this.initialCoordinates = undefined;
    this.timeoutId = null;
    this.listeners = undefined;
    this.documentListeners = undefined;
    this.windowListeners = undefined;
    this.props = props;
    this.events = events;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events;
    this.document = getOwnerDocument(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow2(target));
    this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events,
      props: {
        options: {
          activationConstraint,
          bypassActivationConstraint
        }
      }
    } = this;
    this.listeners.add(events.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events.end.name, this.handleEnd);
    if (events.cancel) {
      this.listeners.add(events.cancel.name, this.handleCancel);
    }
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (bypassActivationConstraint != null && bypassActivationConstraint({
        event: this.props.event,
        activeNode: this.props.activeNode,
        options: this.props.options
      })) {
        return this.handleStart();
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        this.handlePending(activationConstraint);
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        this.handlePending(activationConstraint);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handlePending(constraint, offset4) {
    const {
      active,
      onPending
    } = this.props;
    onPending(active, constraint, this.initialCoordinates, offset4);
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    var _getEventCoordinates2;
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
      }
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
      }
      this.handlePending(activationConstraint, delta);
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onAbort,
      onEnd
    } = this.props;
    this.detach();
    if (!this.activated) {
      onAbort(this.props.active);
    }
    onEnd();
  }
  handleCancel() {
    const {
      onAbort,
      onCancel
    } = this.props;
    this.detach();
    if (!this.activated) {
      onAbort(this.props.active);
    }
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null || _this$document$getSel.removeAllRanges();
  }
}
var events = {
  cancel: {
    name: "pointercancel"
  },
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};

class PointerSensor extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument(event.target);
    super(props, events, listenerTarget);
  }
}
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null || onActivation({
      event
    });
    return true;
  }
}];
var events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));

class MouseSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }
}
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null || onActivation({
      event
    });
    return true;
  }
}];
var events$2 = {
  cancel: {
    name: "touchcancel"
  },
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};

class TouchSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop7, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop7);
    };
    function noop7() {
    }
  }
}
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    const {
      touches
    } = event;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null || onActivation({
      event
    });
    return true;
  }
}];
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller(_ref) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval = 5,
    order = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = import_react252.useRef({
    x: 0,
    y: 0
  });
  const scrollDirection = import_react252.useRef({
    x: 0,
    y: 0
  });
  const rect = import_react252.useMemo(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = import_react252.useRef(null);
  const autoScroll = import_react252.useCallback(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = import_react252.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  import_react252.useEffect(() => {
    if (!enabled || !scrollableAncestors.length || !rect) {
      clearAutoScrollInterval();
      return;
    }
    for (const scrollContainer of sortedScrollableAncestors) {
      if ((canScroll == null ? undefined : canScroll(scrollContainer)) === false) {
        continue;
      }
      const index4 = scrollableAncestors.indexOf(scrollContainer);
      const scrollContainerRect = scrollableAncestorRects[index4];
      if (!scrollContainerRect) {
        continue;
      }
      const {
        direction,
        speed
      } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
      for (const axis of ["x", "y"]) {
        if (!scrollIntent[axis][direction[axis]]) {
          speed[axis] = 0;
          direction[axis] = 0;
        }
      }
      if (speed.x > 0 || speed.y > 0) {
        clearAutoScrollInterval();
        scrollContainerRef.current = scrollContainer;
        setAutoScrollInterval(autoScroll, interval);
        scrollSpeed.current = speed;
        scrollDirection.current = direction;
        return;
      }
    }
    scrollSpeed.current = {
      x: 0,
      y: 0
    };
    scrollDirection.current = {
      x: 0,
      y: 0
    };
    clearAutoScrollInterval();
  }, [
    acceleration,
    autoScroll,
    canScroll,
    clearAutoScrollInterval,
    enabled,
    interval,
    JSON.stringify(rect),
    JSON.stringify(scrollIntent),
    setAutoScrollInterval,
    scrollableAncestors,
    sortedScrollableAncestors,
    scrollableAncestorRects,
    JSON.stringify(threshold)
  ]);
}
var defaultScrollIntent = {
  x: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  },
  y: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  }
};
function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = usePrevious2(delta);
  return useLazyMemo((previousIntent) => {
    if (disabled || !previousDelta || !previousIntent) {
      return defaultScrollIntent;
    }
    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    };
    return {
      x: {
        [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
        [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
      },
      y: {
        [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
        [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}
function useCachedNode(draggableNodes, id) {
  const draggableNode = id != null ? draggableNodes.get(id) : undefined;
  const node2 = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref;
    if (id == null) {
      return null;
    }
    return (_ref = node2 != null ? node2 : cachedNode) != null ? _ref : null;
  }, [node2, id]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return import_react252.useMemo(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
var defaultValue = /* @__PURE__ */ new Map;
function useDroppableMeasuring(containers, _ref) {
  let {
    dragging,
    dependencies,
    config
  } = _ref;
  const [queue, setQueue] = import_react252.useState(null);
  const {
    frequency,
    measure,
    strategy
  } = config;
  const containersRef = import_react252.useRef(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = import_react252.useCallback(function(ids2) {
    if (ids2 === undefined) {
      ids2 = [];
    }
    if (disabledRef.current) {
      return;
    }
    setQueue((value) => {
      if (value === null) {
        return ids2;
      }
      return value.concat(ids2.filter((id) => !value.includes(id)));
    });
  }, [disabledRef]);
  const timeoutId = import_react252.useRef(null);
  const droppableRects = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
      const map = new Map;
      for (let container of containers) {
        if (!container) {
          continue;
        }
        if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
          map.set(container.id, container.rect.current);
          continue;
        }
        const node2 = container.node.current;
        const rect = node2 ? new Rect(measure(node2), node2) : null;
        container.rect.current = rect;
        if (rect) {
          map.set(container.id, rect);
        }
      }
      return map;
    }
    return previousValue;
  }, [containers, queue, dragging, disabled, measure]);
  import_react252.useEffect(() => {
    containersRef.current = containers;
  }, [containers]);
  import_react252.useEffect(() => {
    if (disabled) {
      return;
    }
    measureDroppableContainers();
  }, [dragging, disabled]);
  import_react252.useEffect(() => {
    if (queue && queue.length > 0) {
      setQueue(null);
    }
  }, [JSON.stringify(queue)]);
  import_react252.useEffect(() => {
    if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
      return;
    }
    timeoutId.current = setTimeout(() => {
      measureDroppableContainers();
      timeoutId.current = null;
    }, frequency);
  }, [frequency, disabled, measureDroppableContainers, ...dependencies]);
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled: queue != null
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function useInitialValue(value, computeFn) {
  return useLazyMemo((previousValue) => {
    if (!value) {
      return null;
    }
    if (previousValue) {
      return previousValue;
    }
    return typeof computeFn === "function" ? computeFn(value) : value;
  }, [computeFn, value]);
}
function useInitialRect(node2, measure) {
  return useInitialValue(node2, measure);
}
function useMutationObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleMutations = useEvent(callback);
  const mutationObserver = import_react252.useMemo(() => {
    if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
      return;
    }
    const {
      MutationObserver: MutationObserver2
    } = window;
    return new MutationObserver2(handleMutations);
  }, [handleMutations, disabled]);
  import_react252.useEffect(() => {
    return () => mutationObserver == null ? undefined : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}
function useResizeObserver2(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleResize = useEvent(callback);
  const resizeObserver = import_react252.useMemo(() => {
    if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
      return;
    }
    const {
      ResizeObserver: ResizeObserver2
    } = window;
    return new ResizeObserver2(handleResize);
  }, [disabled]);
  import_react252.useEffect(() => {
    return () => resizeObserver == null ? undefined : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}
function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
  if (measure === undefined) {
    measure = defaultMeasure;
  }
  const [rect, setRect] = import_react252.useState(null);
  function measureRect() {
    setRect((currentRect) => {
      if (!element) {
        return null;
      }
      if (element.isConnected === false) {
        var _ref;
        return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
      }
      const newRect = measure(element);
      if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
        return currentRect;
      }
      return newRect;
    });
  }
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }
      for (const record of records) {
        const {
          type,
          target
        } = record;
        if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }
  });
  const resizeObserver = useResizeObserver2({
    callback: measureRect
  });
  useIsomorphicLayoutEffect2(() => {
    measureRect();
    if (element) {
      resizeObserver == null || resizeObserver.observe(element);
      mutationObserver == null || mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null || resizeObserver.disconnect();
      mutationObserver == null || mutationObserver.disconnect();
    }
  }, [element]);
  return rect;
}
function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}
var defaultValue$1 = [];
function useScrollableAncestors(node2) {
  const previousNode = import_react252.useRef(node2);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node2) {
      return defaultValue$1;
    }
    if (previousValue && previousValue !== defaultValue$1 && node2 && previousNode.current && node2.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node2);
  }, [node2]);
  import_react252.useEffect(() => {
    previousNode.current = node2;
  }, [node2]);
  return ancestors;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = import_react252.useState(null);
  const prevElements = import_react252.useRef(elements);
  const handleScroll2 = import_react252.useCallback((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  import_react252.useEffect(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll2, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null || scrollableElement.removeEventListener("scroll", handleScroll2);
      });
    }
  }, [handleScroll2, elements]);
  return import_react252.useMemo(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === undefined) {
    dependencies = [];
  }
  const initialScrollOffsets = import_react252.useRef(null);
  import_react252.useEffect(() => {
    initialScrollOffsets.current = null;
  }, dependencies);
  import_react252.useEffect(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }
    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
  import_react252.useEffect(() => {
    if (!canUseDOM2) {
      return;
    }
    const teardownFns = sensors.map((_ref) => {
      let {
        sensor
      } = _ref;
      return sensor.setup == null ? undefined : sensor.setup();
    });
    return () => {
      for (const teardown of teardownFns) {
        teardown == null || teardown();
      }
    };
  }, sensors.map((_ref2) => {
    let {
      sensor
    } = _ref2;
    return sensor;
  }));
}
function useSyntheticListeners(listeners, id) {
  return import_react252.useMemo(() => {
    return listeners.reduce((acc, _ref) => {
      let {
        eventName,
        handler
      } = _ref;
      acc[eventName] = (event) => {
        handler(event, id);
      };
      return acc;
    }, {});
  }, [listeners, id]);
}
function useWindowRect(element) {
  return import_react252.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
}
var defaultValue$2 = [];
function useRects(elements, measure) {
  if (measure === undefined) {
    measure = getClientRect;
  }
  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? getWindow2(firstElement) : null);
  const [rects, setRects] = import_react252.useState(defaultValue$2);
  function measureRects() {
    setRects(() => {
      if (!elements.length) {
        return defaultValue$2;
      }
      return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
    });
  }
  const resizeObserver = useResizeObserver2({
    callback: measureRects
  });
  useIsomorphicLayoutEffect2(() => {
    resizeObserver == null || resizeObserver.disconnect();
    measureRects();
    elements.forEach((element) => resizeObserver == null ? undefined : resizeObserver.observe(element));
  }, [elements]);
  return rects;
}
function getMeasurableNode(node2) {
  if (!node2) {
    return null;
  }
  if (node2.children.length > 1) {
    return node2;
  }
  const firstChild = node2.children[0];
  return isHTMLElement2(firstChild) ? firstChild : node2;
}
function useDragOverlayMeasuring(_ref) {
  let {
    measure
  } = _ref;
  const [rect, setRect] = import_react252.useState(null);
  const handleResize = import_react252.useCallback((entries) => {
    for (const {
      target
    } of entries) {
      if (isHTMLElement2(target)) {
        setRect((rect2) => {
          const newRect = measure(target);
          return rect2 ? {
            ...rect2,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver2({
    callback: handleResize
  });
  const handleNodeChange = import_react252.useCallback((element) => {
    const node2 = getMeasurableNode(element);
    resizeObserver == null || resizeObserver.disconnect();
    if (node2) {
      resizeObserver == null || resizeObserver.observe(node2);
    }
    setRect(node2 ? measure(node2) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef] = useNodeRef(handleNodeChange);
  return import_react252.useMemo(() => ({
    nodeRef,
    rect,
    setRef
  }), [rect, nodeRef, setRef]);
}
var defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
var defaultData = {
  current: {}
};
var defaultMeasuringConfiguration = {
  draggable: {
    measure: getTransformAgnosticClientRect
  },
  droppable: {
    measure: getTransformAgnosticClientRect,
    strategy: MeasuringStrategy.WhileDragging,
    frequency: MeasuringFrequency.Optimized
  },
  dragOverlay: {
    measure: getClientRect
  }
};

class DroppableContainersMap extends Map {
  get(id) {
    var _super$get;
    return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((_ref) => {
      let {
        disabled
      } = _ref;
      return !disabled;
    });
  }
  getNodeFor(id) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id)) == null ? undefined : _this$get.node.current) != null ? _this$get$node$curren : undefined;
  }
}
var defaultPublicContext = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map,
  droppableRects: /* @__PURE__ */ new Map,
  droppableContainers: /* @__PURE__ */ new DroppableContainersMap,
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop6
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: defaultMeasuringConfiguration,
  measureDroppableContainers: noop6,
  windowRect: null,
  measuringScheduled: false
};
var defaultInternalContext = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: noop6,
  draggableNodes: /* @__PURE__ */ new Map,
  over: null,
  measureDroppableContainers: noop6
};
var InternalContext = /* @__PURE__ */ import_react252.createContext(defaultInternalContext);
var PublicContext = /* @__PURE__ */ import_react252.createContext(defaultPublicContext);
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: new Map,
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action.DragMove:
      if (state.draggable.active == null) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action.DragEnd:
    case Action.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.SetDroppableDisabled: {
      const {
        id,
        key,
        disabled
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.UnregisterDroppable: {
      const {
        id,
        key
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
function RestoreFocus(_ref) {
  let {
    disabled
  } = _ref;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = import_react252.useContext(InternalContext);
  const previousActivatorEvent = usePrevious2(activatorEvent);
  const previousActiveId = usePrevious2(active == null ? undefined : active.id);
  import_react252.useEffect(() => {
    if (disabled) {
      return;
    }
    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!isKeyboardEvent(previousActivatorEvent)) {
        return;
      }
      if (document.activeElement === previousActivatorEvent.target) {
        return;
      }
      const draggableNode = draggableNodes.get(previousActiveId);
      if (!draggableNode) {
        return;
      }
      const {
        activatorNode,
        node: node2
      } = draggableNode;
      if (!activatorNode.current && !node2.current) {
        return;
      }
      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node2.current]) {
          if (!element) {
            continue;
          }
          const focusableNode = findFirstFocusableNode(element);
          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}
function applyModifiers(modifiers, _ref) {
  let {
    transform,
    ...args
  } = _ref;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
function useMeasuringConfiguration(config) {
  return import_react252.useMemo(() => ({
    draggable: {
      ...defaultMeasuringConfiguration.draggable,
      ...config == null ? undefined : config.draggable
    },
    droppable: {
      ...defaultMeasuringConfiguration.droppable,
      ...config == null ? undefined : config.droppable
    },
    dragOverlay: {
      ...defaultMeasuringConfiguration.dragOverlay,
      ...config == null ? undefined : config.dragOverlay
    }
  }), [config == null ? undefined : config.draggable, config == null ? undefined : config.droppable, config == null ? undefined : config.dragOverlay]);
}
function useLayoutShiftScrollCompensation(_ref) {
  let {
    activeNode,
    measure,
    initialRect,
    config = true
  } = _ref;
  const initialized = import_react252.useRef(false);
  const {
    x: x2,
    y: y2
  } = typeof config === "boolean" ? {
    x: config,
    y: config
  } : config;
  useIsomorphicLayoutEffect2(() => {
    const disabled = !x2 && !y2;
    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }
    if (initialized.current || !initialRect) {
      return;
    }
    const node2 = activeNode == null ? undefined : activeNode.node.current;
    if (!node2 || node2.isConnected === false) {
      return;
    }
    const rect = measure(node2);
    const rectDelta = getRectDelta(rect, initialRect);
    if (!x2) {
      rectDelta.x = 0;
    }
    if (!y2) {
      rectDelta.y = 0;
    }
    initialized.current = true;
    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node2);
      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x2, y2, initialRect, measure]);
}
var ActiveDraggableContext = /* @__PURE__ */ import_react252.createContext({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var Status;
(function(Status2) {
  Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
  Status2[Status2["Initializing"] = 1] = "Initializing";
  Status2[Status2["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));
var DndContext = /* @__PURE__ */ import_react252.memo(function DndContext2(_ref) {
  var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
  let {
    id,
    accessibility,
    autoScroll = true,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers,
    ...props
  } = _ref;
  const store = import_react252.useReducer(reducer, undefined, getInitialState);
  const [state, dispatch] = store;
  const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
  const [status, setStatus] = import_react252.useState(Status.Uninitialized);
  const isInitialized = status === Status.Initialized;
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node2 = activeId != null ? draggableNodes.get(activeId) : null;
  const activeRects = import_react252.useRef({
    initial: null,
    translated: null
  });
  const active = import_react252.useMemo(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      data: (_node$data = node2 == null ? undefined : node2.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node2]);
  const activeRef = import_react252.useRef(null);
  const [activeSensor, setActiveSensor] = import_react252.useState(null);
  const [activatorEvent, setActivatorEvent] = import_react252.useState(null);
  const latestProps = useLatestValue(props, Object.values(props));
  const draggableDescribedById = useUniqueId("DndDescribedBy", id);
  const enabledDroppableContainers = import_react252.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
  const measuringConfiguration = useMeasuringConfiguration(measuring);
  const {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isInitialized,
    dependencies: [translate.x, translate.y],
    config: measuringConfiguration.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = import_react252.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
  const autoScrollOptions = getAutoScrollerOptions();
  const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
  useLayoutShiftScrollCompensation({
    activeNode: activeId != null ? draggableNodes.get(activeId) : null,
    config: autoScrollOptions.layoutShiftCompensation,
    initialRect: initialActiveNodeRect,
    measure: measuringConfiguration.draggable.measure
  });
  const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
  const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
  const sensorContext = import_react252.useRef({
    activatorEvent: null,
    active: null,
    activeNode,
    collisionRect: null,
    collisions: null,
    droppableRects,
    draggableNodes,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? undefined : _sensorContext$curren.id);
  const dragOverlay = useDragOverlayMeasuring({
    measure: measuringConfiguration.dragOverlay.measure
  });
  const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
  const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
  const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
  const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
  const windowRect = useWindowRect(draggingNode ? getWindow2(draggingNode) : null);
  const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useRects(scrollableAncestors);
  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollOffsets = useScrollOffsets(scrollableAncestors);
  const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
  const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisions = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null;
  const overId = getFirstCollision(collisions, "id");
  const [over, setOver] = import_react252.useState(null);
  const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
  const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? undefined : over.rect) != null ? _over$rect : null, activeNodeRect);
  const activeSensorRef = import_react252.useRef(null);
  const instantiateSensor = import_react252.useCallback((event, _ref2) => {
    let {
      sensor: Sensor,
      options
    } = _ref2;
    if (activeRef.current == null) {
      return;
    }
    const activeNode2 = draggableNodes.get(activeRef.current);
    if (!activeNode2) {
      return;
    }
    const activatorEvent2 = event.nativeEvent;
    const sensorInstance = new Sensor({
      active: activeRef.current,
      activeNode: activeNode2,
      event: activatorEvent2,
      options,
      context: sensorContext,
      onAbort(id2) {
        const draggableNode = draggableNodes.get(id2);
        if (!draggableNode) {
          return;
        }
        const {
          onDragAbort
        } = latestProps.current;
        const event2 = {
          id: id2
        };
        onDragAbort == null || onDragAbort(event2);
        dispatchMonitorEvent({
          type: "onDragAbort",
          event: event2
        });
      },
      onPending(id2, constraint, initialCoordinates, offset4) {
        const draggableNode = draggableNodes.get(id2);
        if (!draggableNode) {
          return;
        }
        const {
          onDragPending
        } = latestProps.current;
        const event2 = {
          id: id2,
          constraint,
          initialCoordinates,
          offset: offset4
        };
        onDragPending == null || onDragPending(event2);
        dispatchMonitorEvent({
          type: "onDragPending",
          event: event2
        });
      },
      onStart(initialCoordinates) {
        const id2 = activeRef.current;
        if (id2 == null) {
          return;
        }
        const draggableNode = draggableNodes.get(id2);
        if (!draggableNode) {
          return;
        }
        const {
          onDragStart
        } = latestProps.current;
        const event2 = {
          activatorEvent: activatorEvent2,
          active: {
            id: id2,
            data: draggableNode.data,
            rect: activeRects
          }
        };
        import_react_dom5.unstable_batchedUpdates(() => {
          onDragStart == null || onDragStart(event2);
          setStatus(Status.Initializing);
          dispatch({
            type: Action.DragStart,
            initialCoordinates,
            active: id2
          });
          dispatchMonitorEvent({
            type: "onDragStart",
            event: event2
          });
          setActiveSensor(activeSensorRef.current);
          setActivatorEvent(activatorEvent2);
        });
      },
      onMove(coordinates) {
        dispatch({
          type: Action.DragMove,
          coordinates
        });
      },
      onEnd: createHandler(Action.DragEnd),
      onCancel: createHandler(Action.DragCancel)
    });
    activeSensorRef.current = sensorInstance;
    function createHandler(type) {
      return async function handler() {
        const {
          active: active2,
          collisions: collisions2,
          over: over2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        let event2 = null;
        if (active2 && scrollAdjustedTranslate2) {
          const {
            cancelDrop
          } = latestProps.current;
          event2 = {
            activatorEvent: activatorEvent2,
            active: active2,
            collisions: collisions2,
            delta: scrollAdjustedTranslate2,
            over: over2
          };
          if (type === Action.DragEnd && typeof cancelDrop === "function") {
            const shouldCancel = await Promise.resolve(cancelDrop(event2));
            if (shouldCancel) {
              type = Action.DragCancel;
            }
          }
        }
        activeRef.current = null;
        import_react_dom5.unstable_batchedUpdates(() => {
          dispatch({
            type
          });
          setStatus(Status.Uninitialized);
          setOver(null);
          setActiveSensor(null);
          setActivatorEvent(null);
          activeSensorRef.current = null;
          const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
          if (event2) {
            const handler = latestProps.current[eventName];
            handler == null || handler(event2);
            dispatchMonitorEvent({
              type: eventName,
              event: event2
            });
          }
        });
      };
    }
  }, [draggableNodes]);
  const bindActivatorToSensorInstantiator = import_react252.useCallback((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      const activeDraggableNode = draggableNodes.get(active2);
      if (activeRef.current !== null || !activeDraggableNode || nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }
      const activationContext = {
        active: activeDraggableNode
      };
      const shouldActivate = handler(event, sensor.options, activationContext);
      if (shouldActivate === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [draggableNodes, instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect2(() => {
    if (activeNodeRect && status === Status.Initializing) {
      setStatus(Status.Initialized);
    }
  }, [activeNodeRect, status]);
  import_react252.useEffect(() => {
    const {
      onDragMove
    } = latestProps.current;
    const {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      over: over2
    } = sensorContext.current;
    if (!active2 || !activatorEvent2) {
      return;
    }
    const event = {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over: over2
    };
    import_react_dom5.unstable_batchedUpdates(() => {
      onDragMove == null || onDragMove(event);
      dispatchMonitorEvent({
        type: "onDragMove",
        event
      });
    });
  }, [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
  import_react252.useEffect(() => {
    const {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      droppableContainers: droppableContainers2,
      scrollAdjustedTranslate: scrollAdjustedTranslate2
    } = sensorContext.current;
    if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
      return;
    }
    const {
      onDragOver
    } = latestProps.current;
    const overContainer = droppableContainers2.get(overId);
    const over2 = overContainer && overContainer.rect.current ? {
      id: overContainer.id,
      rect: overContainer.rect.current,
      data: overContainer.data,
      disabled: overContainer.disabled
    } : null;
    const event = {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      delta: {
        x: scrollAdjustedTranslate2.x,
        y: scrollAdjustedTranslate2.y
      },
      over: over2
    };
    import_react_dom5.unstable_batchedUpdates(() => {
      setOver(over2);
      onDragOver == null || onDragOver(event);
      dispatchMonitorEvent({
        type: "onDragOver",
        event
      });
    });
  }, [overId]);
  useIsomorphicLayoutEffect2(() => {
    sensorContext.current = {
      activatorEvent,
      active,
      activeNode,
      collisionRect,
      collisions,
      droppableRects,
      draggableNodes,
      draggingNode,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: collisionRect
    };
  }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
  useAutoScroller({
    ...autoScrollOptions,
    delta: translate,
    draggingRect: collisionRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const publicContext = import_react252.useMemo(() => {
    const context = {
      active,
      activeNode,
      activeNodeRect,
      activatorEvent,
      collisions,
      containerNodeRect,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      measureDroppableContainers,
      scrollableAncestors,
      scrollableAncestorRects,
      measuringConfiguration,
      measuringScheduled,
      windowRect
    };
    return context;
  }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
  const internalContext = import_react252.useMemo(() => {
    const context = {
      activatorEvent,
      activators,
      active,
      activeNodeRect,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      dispatch,
      draggableNodes,
      over,
      measureDroppableContainers
    };
    return context;
  }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
  return import_react252.default.createElement(DndMonitorContext.Provider, {
    value: registerMonitorListener
  }, import_react252.default.createElement(InternalContext.Provider, {
    value: internalContext
  }, import_react252.default.createElement(PublicContext.Provider, {
    value: publicContext
  }, import_react252.default.createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), import_react252.default.createElement(RestoreFocus, {
    disabled: (accessibility == null ? undefined : accessibility.restoreFocus) === false
  })), import_react252.default.createElement(Accessibility, {
    ...accessibility,
    hiddenTextDescribedById: draggableDescribedById
  }));
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? undefined : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return {
        ...autoScroll,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
var NullContext = /* @__PURE__ */ import_react252.createContext(null);
var defaultRole = "button";
var ID_PREFIX = "Draggable";
function useDraggable(_ref) {
  let {
    id,
    data,
    disabled = false,
    attributes
  } = _ref;
  const key = useUniqueId(ID_PREFIX);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = import_react252.useContext(InternalContext);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? undefined : active.id) === id;
  const transform = import_react252.useContext(isDragging ? ActiveDraggableContext : NullContext);
  const [node2, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id);
  const dataRef = useLatestValue(data);
  useIsomorphicLayoutEffect2(() => {
    draggableNodes.set(id, {
      id,
      key,
      node: node2,
      activatorNode,
      data: dataRef
    });
    return () => {
      const node3 = draggableNodes.get(id);
      if (node3 && node3.key === key) {
        draggableNodes.delete(id);
      }
    };
  }, [draggableNodes, id]);
  const memoizedAttributes = import_react252.useMemo(() => ({
    role,
    tabIndex,
    "aria-disabled": disabled,
    "aria-pressed": isDragging && role === defaultRole ? true : undefined,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? undefined : listeners,
    node: node2,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}
function useDndContext() {
  return import_react252.useContext(PublicContext);
}
var ID_PREFIX$1 = "Droppable";
var defaultResizeObserverConfig = {
  timeout: 25
};
function useDroppable(_ref) {
  let {
    data,
    disabled = false,
    id,
    resizeObserverConfig
  } = _ref;
  const key = useUniqueId(ID_PREFIX$1);
  const {
    active,
    dispatch,
    over,
    measureDroppableContainers
  } = import_react252.useContext(InternalContext);
  const previous = import_react252.useRef({
    disabled
  });
  const resizeObserverConnected = import_react252.useRef(false);
  const rect = import_react252.useRef(null);
  const callbackId = import_react252.useRef(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = {
    ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
  const handleResize = import_react252.useCallback(() => {
    if (!resizeObserverConnected.current) {
      resizeObserverConnected.current = true;
      return;
    }
    if (callbackId.current != null) {
      clearTimeout(callbackId.current);
    }
    callbackId.current = setTimeout(() => {
      measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
      callbackId.current = null;
    }, resizeObserverTimeout);
  }, [resizeObserverTimeout]);
  const resizeObserver = useResizeObserver2({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = import_react252.useCallback((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }
    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }
    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  import_react252.useEffect(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }
    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  import_react252.useEffect(() => {
    dispatch({
      type: Action.RegisterDroppable,
      element: {
        id,
        key,
        disabled,
        node: nodeRef,
        rect,
        data: dataRef
      }
    });
    return () => dispatch({
      type: Action.UnregisterDroppable,
      key,
      id
    });
  }, [id]);
  import_react252.useEffect(() => {
    if (disabled !== previous.current.disabled) {
      dispatch({
        type: Action.SetDroppableDisabled,
        id,
        key,
        disabled
      });
      previous.current.disabled = disabled;
    }
  }, [id, key, disabled, dispatch]);
  return {
    active,
    rect,
    isOver: (over == null ? undefined : over.id) === id,
    node: nodeRef,
    over,
    setNodeRef
  };
}

// node_modules/@dnd-kit/sortable/dist/sortable.esm.js
var import_react253 = __toESM(require_react(), 1);
function arrayMove(array, from2, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from2, 1)[0]);
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id, index4) => {
    const rect = rects.get(id);
    if (rect) {
      accumulator[index4] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index4) {
  return index4 !== null && index4 >= 0;
}
function itemsEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (a2.length !== b.length) {
    return false;
  }
  for (let i2 = 0;i2 < a2.length; i2++) {
    if (a2[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
var defaultScale = {
  scaleX: 1,
  scaleY: 1
};
var horizontalListSortingStrategy = (_ref) => {
  var _rects$activeIndex;
  let {
    rects,
    activeNodeRect: fallbackActiveRect,
    activeIndex,
    overIndex,
    index: index4
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  const itemGap = getItemGap(rects, index4, activeIndex);
  if (index4 === activeIndex) {
    const newIndexRect = rects[overIndex];
    if (!newIndexRect) {
      return null;
    }
    return {
      x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,
      y: 0,
      ...defaultScale
    };
  }
  if (index4 > activeIndex && index4 <= overIndex) {
    return {
      x: -activeNodeRect.width - itemGap,
      y: 0,
      ...defaultScale
    };
  }
  if (index4 < activeIndex && index4 >= overIndex) {
    return {
      x: activeNodeRect.width + itemGap,
      y: 0,
      ...defaultScale
    };
  }
  return {
    x: 0,
    y: 0,
    ...defaultScale
  };
};
function getItemGap(rects, index4, activeIndex) {
  const currentRect = rects[index4];
  const previousRect = rects[index4 - 1];
  const nextRect = rects[index4 + 1];
  if (!currentRect || !previousRect && !nextRect) {
    return 0;
  }
  if (activeIndex < index4) {
    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);
  }
  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);
}
var rectSortingStrategy = (_ref) => {
  let {
    rects,
    activeIndex,
    overIndex,
    index: index4
  } = _ref;
  const newRects = arrayMove(rects, overIndex, activeIndex);
  const oldRect = rects[index4];
  const newRect = newRects[index4];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
var ID_PREFIX2 = "Sortable";
var Context = /* @__PURE__ */ import_react253.default.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX2,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  disabled: {
    draggable: false,
    droppable: false
  }
});
function SortableContext(_ref) {
  let {
    children,
    id,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX2, id);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = import_react253.useMemo(() => userDefinedItems.map((item) => typeof item === "object" && ("id" in item) ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = import_react253.useRef(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect2(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  import_react253.useEffect(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = import_react253.useMemo(() => ({
    activeIndex,
    containerId,
    disabled,
    disableTransforms,
    items,
    overIndex,
    useDragOverlay,
    sortedRects: getSortedRects(items, droppableRects),
    strategy
  }), [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);
  return import_react253.default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
var defaultNewIndexGetter = (_ref) => {
  let {
    id,
    items,
    activeIndex,
    overIndex
  } = _ref;
  return arrayMove(items, activeIndex, overIndex).indexOf(id);
};
var defaultAnimateLayoutChanges = (_ref2) => {
  let {
    containerId,
    isSorting,
    wasDragging,
    index: index4,
    items,
    newIndex,
    previousItems,
    previousContainerId,
    transition
  } = _ref2;
  if (!transition || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index4 === newIndex) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex !== index4 && containerId === previousContainerId;
};
var defaultTransition2 = {
  duration: 200,
  easing: "ease"
};
var transitionProperty = "transform";
var disabledTransition = /* @__PURE__ */ CSS2.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
var defaultAttributes2 = {
  roleDescription: "sortable"
};
function useDerivedTransform(_ref) {
  let {
    disabled,
    index: index4,
    node: node2,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = import_react253.useState(null);
  const previousIndex = import_react253.useRef(index4);
  useIsomorphicLayoutEffect2(() => {
    if (!disabled && index4 !== previousIndex.current && node2.current) {
      const initial = rect.current;
      if (initial) {
        const current2 = getClientRect(node2.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current2.left,
          y: initial.top - current2.top,
          scaleX: initial.width / current2.width,
          scaleY: initial.height / current2.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index4 !== previousIndex.current) {
      previousIndex.current = index4;
    }
  }, [disabled, index4, node2, rect]);
  import_react253.useEffect(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = defaultTransition2
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = import_react253.useContext(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index4 = items.indexOf(id);
  const data = import_react253.useMemo(() => ({
    sortable: {
      containerId,
      index: index4,
      items
    },
    ...customData
  }), [containerId, customData, index4, items]);
  const itemsAfterCurrentSortable = import_react253.useMemo(() => items.slice(items.indexOf(id)), [items, id]);
  const {
    rect,
    node: node2,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id,
    data,
    attributes: {
      ...defaultAttributes2,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index: index4
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id,
    items,
    activeIndex,
    overIndex
  }) : index4;
  const activeId = active == null ? undefined : active.id;
  const previous = import_react253.useRef({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id,
    index: index4,
    items,
    newIndex: previous.current.newIndex,
    previousItems: previous.current.items,
    previousContainerId: previous.current.containerId,
    transition,
    wasDragging: previous.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index4,
    node: node2,
    rect
  });
  import_react253.useEffect(() => {
    if (isSorting && previous.current.newIndex !== newIndex) {
      previous.current.newIndex = newIndex;
    }
    if (containerId !== previous.current.containerId) {
      previous.current.containerId = containerId;
    }
    if (items !== previous.current.items) {
      previous.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  import_react253.useEffect(() => {
    if (activeId === previous.current.activeId) {
      return;
    }
    if (activeId != null && previous.current.activeId == null) {
      previous.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index: index4,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node: node2,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (derivedTransform || itemsHaveChanged && previous.current.newIndex === index4) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
      return;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS2.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? undefined : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? undefined : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
function hasSortableData(entry) {
  if (!entry) {
    return false;
  }
  const data = entry.data.current;
  if (data && "sortable" in data && typeof data.sortable === "object" && "containerId" in data.sortable && "items" in data.sortable && "index" in data.sortable) {
    return true;
  }
  return false;
}
var directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
var sortableKeyboardCoordinates = (event, _ref) => {
  let {
    context: {
      active,
      collisionRect,
      droppableRects,
      droppableContainers,
      over,
      scrollableAncestors
    }
  } = _ref;
  if (directions.includes(event.code)) {
    event.preventDefault();
    if (!active || !collisionRect) {
      return;
    }
    const filteredContainers = [];
    droppableContainers.getEnabled().forEach((entry) => {
      if (!entry || entry != null && entry.disabled) {
        return;
      }
      const rect = droppableRects.get(entry.id);
      if (!rect) {
        return;
      }
      switch (event.code) {
        case KeyboardCode.Down:
          if (collisionRect.top < rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Up:
          if (collisionRect.top > rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Left:
          if (collisionRect.left > rect.left) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Right:
          if (collisionRect.left < rect.left) {
            filteredContainers.push(entry);
          }
          break;
      }
    });
    const collisions = closestCorners({
      active,
      collisionRect,
      droppableRects,
      droppableContainers: filteredContainers,
      pointerCoordinates: null
    });
    let closestId = getFirstCollision(collisions, "id");
    if (closestId === (over == null ? undefined : over.id) && collisions.length > 1) {
      closestId = collisions[1].id;
    }
    if (closestId != null) {
      const activeDroppable = droppableContainers.get(active.id);
      const newDroppable = droppableContainers.get(closestId);
      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
      const newNode = newDroppable == null ? undefined : newDroppable.node.current;
      if (newNode && newRect && activeDroppable && newDroppable) {
        const newScrollAncestors = getScrollableAncestors(newNode);
        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index4) => scrollableAncestors[index4] !== element);
        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);
        const isAfterActive = isAfter(activeDroppable, newDroppable);
        const offset4 = hasDifferentScrollAncestors || !hasSameContainer ? {
          x: 0,
          y: 0
        } : {
          x: isAfterActive ? collisionRect.width - newRect.width : 0,
          y: isAfterActive ? collisionRect.height - newRect.height : 0
        };
        const rectCoordinates = {
          x: newRect.left,
          y: newRect.top
        };
        const newCoordinates = offset4.x && offset4.y ? rectCoordinates : subtract(rectCoordinates, offset4);
        return newCoordinates;
      }
    }
  }
  return;
};
function isSameContainer(a2, b) {
  if (!hasSortableData(a2) || !hasSortableData(b)) {
    return false;
  }
  return a2.data.current.sortable.containerId === b.data.current.sortable.containerId;
}
function isAfter(a2, b) {
  if (!hasSortableData(a2) || !hasSortableData(b)) {
    return false;
  }
  if (!isSameContainer(a2, b)) {
    return false;
  }
  return a2.data.current.sortable.index < b.data.current.sortable.index;
}

// src/components/LayoutMappingModal/DependentGroupSortableCard.tsx
var import_react254 = __toESM(require_react(), 1);
var jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var TransformCommandCard = ({
  transform,
  index: index4,
  onUpdate,
  onRemove
}) => {
  return /* @__PURE__ */ jsx_runtime5.jsxs(Card, {
    shadow: "sm",
    padding: "xs",
    radius: "md",
    withBorder: true,
    mb: "xs",
    children: [
      /* @__PURE__ */ jsx_runtime5.jsx(Group, {
        justify: "flex-end",
        mb: "xs",
        children: /* @__PURE__ */ jsx_runtime5.jsx(ActionIcon, {
          variant: "subtle",
          color: "red",
          size: "sm",
          onClick: () => onRemove(index4),
          children: /* @__PURE__ */ jsx_runtime5.jsx(IconX, {
            size: 16
          })
        })
      }),
      /* @__PURE__ */ jsx_runtime5.jsx(Text, {
        size: "xs",
        mb: "xs",
        children: "Find:"
      }),
      /* @__PURE__ */ jsx_runtime5.jsx(Input, {
        placeholder: "Text to find",
        value: transform.find,
        onChange: (e) => onUpdate(index4, { ...transform, find: e.target.value }),
        mb: "xs",
        size: "xs"
      }),
      /* @__PURE__ */ jsx_runtime5.jsx(Text, {
        size: "xs",
        mb: "xs",
        children: "Replace:"
      }),
      /* @__PURE__ */ jsx_runtime5.jsx(Input, {
        placeholder: "Replacement text",
        value: transform.replace,
        onChange: (e) => onUpdate(index4, { ...transform, replace: e.target.value }),
        mb: "xs",
        size: "xs"
      }),
      /* @__PURE__ */ jsx_runtime5.jsx(Checkbox, {
        label: "Replace All",
        checked: transform.replaceAll,
        onChange: (e) => onUpdate(index4, { ...transform, replaceAll: e.target.checked }),
        size: "xs"
      })
    ]
  });
};
var DependentGroupValueSortableCard = ({
  id,
  value,
  groupIndex,
  imageVariableId,
  mapId,
  onRemove,
  getDisplayValue
}) => {
  const raiseError2 = appStore((state) => state.raiseError);
  const updateVarValueFromDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.updateVarValueFromDependentGroup);
  const variables = appStore((state) => state.state.studio.document.variables);
  const [transformModalOpen, setTransformModalOpen] = import_react254.useState(false);
  const [transforms, setTransforms] = import_react254.useState([]);
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({ id });
  const style2 = {
    transform: CSS2.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 1 : 0,
    minWidth: "120px",
    height: "auto",
    minHeight: "80px",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    position: "relative"
  };
  const variableValueIndex = parseInt(id.toString().split("-")[1]);
  const updateVarValue = (newValue) => {
    if (mapId && imageVariableId !== null && groupIndex !== null) {
      updateVarValueFromDependentGroup({
        mapId,
        imageVariableId,
        groupIndex,
        variableValueIndex,
        variableValue: newValue
      });
    } else {
      raiseError2(new Error(`Failed to update variable value: mapId=${mapId}, imageVariableId=${imageVariableId}, groupIndex=${groupIndex}`));
    }
  };
  const selectOptions = variables.filter((v2) => v2.type !== "image" && v2.type !== "boolean").map((v2) => ({
    value: v2.id,
    label: v2.name
  }));
  const openTransformModal = () => {
    if (typeof value !== "string" && value.transform) {
      setTransforms([...value.transform]);
    } else {
      setTransforms([]);
    }
    setTransformModalOpen(true);
  };
  const updateTransform = (index4, updatedTransform) => {
    const newTransforms = [...transforms];
    newTransforms[index4] = updatedTransform;
    setTransforms(newTransforms);
  };
  const removeTransform = (index4) => {
    setTransforms(transforms.filter((_2, i2) => i2 !== index4));
  };
  const addTransform = () => {
    setTransforms([
      ...transforms,
      { find: "", replace: "", replaceAll: false, regex: false }
    ]);
  };
  const saveTransforms = () => {
    const validTransforms = transforms.filter((t) => t.find.trim() !== "" && t.replace.trim() !== "");
    if (typeof value !== "string" && value.type) {
      updateVarValue({
        ...value,
        transform: validTransforms
      });
    }
    setTransformModalOpen(false);
  };
  const getWandColor = () => {
    if (typeof value !== "string" && value.transform && value.transform.length > 0) {
      return "blue";
    }
    return "gray";
  };
  const getWandOpacity = () => {
    if (typeof value !== "string" && value.transform && value.transform.length > 0) {
      return 1;
    }
    return 0.5;
  };
  return /* @__PURE__ */ jsx_runtime5.jsxs(jsx_runtime5.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime5.jsxs(Card, {
        ref: setNodeRef,
        shadow: "sm",
        padding: "xs",
        radius: "md",
        style: style2,
        children: [
          /* @__PURE__ */ jsx_runtime5.jsx(ActionIcon, {
            variant: "subtle",
            size: "sm",
            color: "red",
            radius: "xl",
            style: {
              position: "absolute",
              top: "5px",
              right: "5px"
            },
            onClick: onRemove,
            children: /* @__PURE__ */ jsx_runtime5.jsx(IconX, {})
          }),
          typeof value !== "string" && /* @__PURE__ */ jsx_runtime5.jsx(ActionIcon, {
            variant: "subtle",
            size: "sm",
            opacity: getWandOpacity(),
            color: getWandColor(),
            radius: "xl",
            style: {
              position: "absolute",
              top: "5px",
              right: "30px"
            },
            onClick: openTransformModal,
            children: /* @__PURE__ */ jsx_runtime5.jsx(IconWand, {
              size: 14
            })
          }),
          /* @__PURE__ */ jsx_runtime5.jsx(ActionIcon, {
            ...attributes,
            ...listeners,
            variant: "subtle",
            size: "md",
            style: {
              position: "absolute",
              top: "5px",
              left: "5px",
              cursor: "grab"
            },
            children: /* @__PURE__ */ jsx_runtime5.jsx(IconGripVertical, {
              size: 14
            })
          }),
          /* @__PURE__ */ jsx_runtime5.jsx("div", {
            style: { marginTop: "20px", marginBottom: "5px" },
            children: typeof value === "string" ? /* @__PURE__ */ jsx_runtime5.jsx(Input, {
              size: "xs",
              value,
              onChange: (e) => updateVarValue(e.target.value),
              placeholder: "Enter value"
            }) : value.type === "StudioList" ? /* @__PURE__ */ jsx_runtime5.jsx(Select, {
              size: "xs",
              data: selectOptions,
              value: value.id || null,
              onChange: (newId) => {
                if (newId) {
                  updateVarValue({
                    ...value,
                    id: newId
                  });
                }
              },
              placeholder: "Select variable",
              clearable: true
            }) : /* @__PURE__ */ jsx_runtime5.jsx(Text, {
              size: "sm",
              ta: "center",
              style: { wordBreak: "break-word" },
              children: getDisplayValue(value)
            })
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime5.jsx(Modal, {
        opened: transformModalOpen,
        onClose: () => setTransformModalOpen(false),
        title: "Transform Commands",
        centered: true,
        children: /* @__PURE__ */ jsx_runtime5.jsxs(Stack, {
          children: [
            transforms.map((t, index4) => /* @__PURE__ */ jsx_runtime5.jsx(TransformCommandCard, {
              transform: t,
              index: index4,
              onUpdate: updateTransform,
              onRemove: removeTransform
            }, index4)),
            /* @__PURE__ */ jsx_runtime5.jsx(Card, {
              shadow: "sm",
              padding: "xs",
              radius: "md",
              withBorder: true,
              children: /* @__PURE__ */ jsx_runtime5.jsx(Group, {
                justify: "center",
                children: /* @__PURE__ */ jsx_runtime5.jsx(ActionIcon, {
                  variant: "subtle",
                  color: "blue",
                  onClick: addTransform,
                  children: /* @__PURE__ */ jsx_runtime5.jsx(IconPlus, {
                    size: 20
                  })
                })
              })
            }),
            /* @__PURE__ */ jsx_runtime5.jsxs(Group, {
              justify: "flex-end",
              mt: "md",
              children: [
                /* @__PURE__ */ jsx_runtime5.jsx(Button, {
                  variant: "outline",
                  onClick: () => setTransformModalOpen(false),
                  children: "Cancel"
                }),
                /* @__PURE__ */ jsx_runtime5.jsx(Button, {
                  onClick: saveTransforms,
                  children: "Save"
                })
              ]
            })
          ]
        })
      })
    ]
  });
};

// src/components/LayoutMappingModal/DependentGroupSetValue.tsx
var jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var DependentGroupSetValue = ({
  groupIndex,
  imageVariableId,
  mapId,
  variableValue
}) => {
  const removeVarValueFromDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.removeVarValueFromDependentGroup);
  const addVarValueToDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.addVarValueToDependentGroup);
  const setIndexOfVarValueFromDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.setIndexOfVarValueFromDependentGroup);
  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));
  const handleRemoveVarValue = (valueIndex) => {
    removeVarValueFromDependentGroup({
      mapId,
      imageVariableId,
      groupIndex,
      variableValueIndex: valueIndex
    });
  };
  const handleAddStringValue = () => {
    addVarValueToDependentGroup({
      mapId,
      imageVariableId,
      groupIndex,
      variableValue: ""
    });
  };
  const handleAddListVariable = () => {
    addVarValueToDependentGroup({
      mapId,
      imageVariableId,
      groupIndex,
      variableValue: {
        id: null,
        type: "StudioList",
        transform: []
      }
    });
  };
  const getDisplayValue = (value) => {
    if (typeof value === "string") {
      return value;
    } else {
      return `Variable: ${value.id}`;
    }
  };
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      const oldIndex = parseInt(active.id.toString().split("-")[1]);
      const newIndex = parseInt(over.id.toString().split("-")[1]);
      setIndexOfVarValueFromDependentGroup({
        mapId,
        imageVariableId,
        groupIndex,
        oldVariableValueIndex: oldIndex,
        newVariableValueIndex: newIndex
      });
    }
  };
  return /* @__PURE__ */ jsx_runtime6.jsxs("div", {
    style: { marginTop: "10px" },
    children: [
      /* @__PURE__ */ jsx_runtime6.jsx(Text, {
        fw: 500,
        size: "sm",
        mb: 5,
        children: "Value ="
      }),
      /* @__PURE__ */ jsx_runtime6.jsx(ScrollArea.Autosize, {
        maw: screen.width * 0.9,
        children: /* @__PURE__ */ jsx_runtime6.jsx(DndContext, {
          sensors,
          collisionDetection: closestCenter,
          onDragEnd: handleDragEnd,
          children: /* @__PURE__ */ jsx_runtime6.jsx(SortableContext, {
            items: variableValue.map((_2, index4) => `item-${index4}`),
            strategy: horizontalListSortingStrategy,
            children: /* @__PURE__ */ jsx_runtime6.jsxs(Group, {
              gap: "xs",
              wrap: "nowrap",
              style: { minWidth: "100%" },
              children: [
                variableValue.map((value, index4) => /* @__PURE__ */ jsx_runtime6.jsx(DependentGroupValueSortableCard, {
                  id: `item-${index4}`,
                  value,
                  mapId,
                  groupIndex,
                  imageVariableId,
                  onRemove: () => handleRemoveVarValue(index4),
                  getDisplayValue
                }, `item-${index4}`)),
                /* @__PURE__ */ jsx_runtime6.jsxs(Menu, {
                  position: "bottom-end",
                  withArrow: true,
                  children: [
                    /* @__PURE__ */ jsx_runtime6.jsx(Menu.Target, {
                      children: /* @__PURE__ */ jsx_runtime6.jsx(Card, {
                        shadow: "sm",
                        padding: "xs",
                        radius: "md",
                        style: {
                          minWidth: "80px",
                          height: "80px",
                          display: "flex",
                          justifyContent: "center",
                          alignItems: "center",
                          border: "1px dashed #ccc",
                          cursor: "pointer"
                        },
                        children: /* @__PURE__ */ jsx_runtime6.jsx(ActionIcon, {
                          variant: "transparent",
                          size: "lg",
                          children: /* @__PURE__ */ jsx_runtime6.jsx(IconPlus, {})
                        })
                      })
                    }),
                    /* @__PURE__ */ jsx_runtime6.jsxs(Menu.Dropdown, {
                      children: [
                        /* @__PURE__ */ jsx_runtime6.jsx(Menu.Label, {
                          children: "Add Value Type"
                        }),
                        /* @__PURE__ */ jsx_runtime6.jsx(Menu.Item, {
                          leftSection: /* @__PURE__ */ jsx_runtime6.jsx(IconAbc, {
                            size: 14
                          }),
                          onClick: handleAddStringValue,
                          children: "String"
                        }),
                        /* @__PURE__ */ jsx_runtime6.jsx(Menu.Item, {
                          leftSection: /* @__PURE__ */ jsx_runtime6.jsx(IconList, {
                            size: 14
                          }),
                          onClick: handleAddListVariable,
                          children: "List Variable"
                        })
                      ]
                    })
                  ]
                })
              ]
            })
          })
        })
      })
    ]
  });
};

// src/components/LayoutMappingModal/DependentGroup.tsx
var jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var DependentGroup = ({
  dependentGroup,
  groupIndex,
  variableConfig,
  layoutMap
}) => {
  const bgColor = groupIndex % 2 === 0 ? "#5b575b" : "#335760";
  const variables = appStore((state) => state.state.studio.document.variables);
  const raiseError2 = appStore((state) => state.raiseError);
  const setCurrentImageVariableId = appStore((state) => state.effects.modal.dependentModal.setCurrentImageVariableId);
  const setCurrentSelectedMapId = appStore((state) => state.effects.modal.setCurrentSelectedMapId);
  const setCurrentGroupIndex = appStore((state) => state.effects.modal.dependentModal.setCurrentGroupIndex);
  const setIsOpen = appStore((state) => state.effects.modal.dependentModal.setIsOpen);
  const removeDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.removeDependentGroup);
  const copyDependentGroup = appStore((state) => state.effects.studio.layoutImageMapping.copyDependentGroup);
  const removeDependent = appStore((state) => state.effects.studio.layoutImageMapping.removeDependent);
  const updateDependent = appStore((state) => state.effects.studio.layoutImageMapping.updateDependent);
  const handleAddDependentToGroup = (groupIndex2) => {
    setCurrentImageVariableId(variableConfig.id);
    setCurrentSelectedMapId(layoutMap.id);
    setCurrentGroupIndex(groupIndex2);
    setIsOpen(true);
  };
  const handleRemoveGroup = (groupIndex2) => {
    removeDependentGroup({
      groupIndex: groupIndex2,
      imageVariableId: variableConfig.id,
      mapId: layoutMap.id
    });
  };
  const handleCopyGroup = (groupIndex2) => {
    copyDependentGroup({
      groupIndex: groupIndex2,
      imageVariableId: variableConfig.id,
      mapId: layoutMap.id
    });
  };
  console.log(dependentGroup, groupIndex, variableConfig);
  const getVariableById = (id) => {
    return variables.find((v2) => v2.id === id);
  };
  return /* @__PURE__ */ jsx_runtime7.jsxs(Stack, {
    style: {
      backgroundColor: bgColor,
      padding: "10px",
      borderRadius: "5px",
      marginBottom: "10px",
      gap: "8px"
    },
    children: [
      /* @__PURE__ */ jsx_runtime7.jsxs(Group, {
        align: "center",
        justify: "space-between",
        children: [
          /* @__PURE__ */ jsx_runtime7.jsxs(Text, {
            fw: 500,
            size: "sm",
            ta: "center",
            children: [
              "Group ",
              groupIndex + 1
            ]
          }),
          /* @__PURE__ */ jsx_runtime7.jsxs(Group, {
            gap: "xs",
            children: [
              /* @__PURE__ */ jsx_runtime7.jsx(ActionIcon, {
                variant: "subtle",
                size: "lg",
                radius: "xl",
                onClick: () => handleCopyGroup(groupIndex),
                children: /* @__PURE__ */ jsx_runtime7.jsx(IconCopy, {})
              }),
              /* @__PURE__ */ jsx_runtime7.jsx(ActionIcon, {
                variant: "subtle",
                size: "lg",
                color: "red",
                radius: "xl",
                onClick: () => handleRemoveGroup(groupIndex),
                children: /* @__PURE__ */ jsx_runtime7.jsx(IconTrashFilled, {})
              })
            ]
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime7.jsxs(Grid, {
        gutter: "xs",
        children: [
          dependentGroup.dependents.map((dependent, depIndex) => {
            const depVariable = getVariableById(dependent.variableId);
            return /* @__PURE__ */ jsx_runtime7.jsx(Grid.Col, {
              span: 4,
              children: /* @__PURE__ */ jsx_runtime7.jsxs(Card, {
                shadow: "sm",
                padding: "xs",
                radius: "md",
                style: {
                  minHeight: "100px",
                  height: "auto",
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "center",
                  position: "relative"
                },
                children: [
                  /* @__PURE__ */ jsx_runtime7.jsx(ActionIcon, {
                    variant: "subtle",
                    size: "sm",
                    color: "red",
                    radius: "xl",
                    style: {
                      position: "absolute",
                      top: "5px",
                      right: "5px"
                    },
                    onClick: () => {
                      removeDependent({
                        imageVariableId: variableConfig.id,
                        dependentGroupIndex: groupIndex,
                        dependent,
                        mapId: layoutMap.id
                      });
                    },
                    children: /* @__PURE__ */ jsx_runtime7.jsx(IconX, {})
                  }),
                  /* @__PURE__ */ jsx_runtime7.jsx(Text, {
                    fw: 500,
                    size: "sm",
                    ta: "center",
                    children: depVariable?.name || "Unknown"
                  }),
                  /* @__PURE__ */ jsx_runtime7.jsx(Text, {
                    size: "xs",
                    c: "dimmed",
                    ta: "center",
                    children: depVariable?.type || "Unknown"
                  }),
                  depVariable?.type === "list" && /* @__PURE__ */ jsx_runtime7.jsx(MultiSelect, {
                    size: "xs",
                    data: depVariable.items.map((item) => ({
                      value: item.value,
                      label: item.displayValue || item.value
                    })),
                    value: dependent.values,
                    onChange: (newValues) => {
                      updateDependent({
                        mapId: layoutMap.id,
                        imageVariableId: variableConfig.id,
                        dependentGroupIndex: groupIndex,
                        dependent: {
                          ...dependent,
                          values: newValues
                        }
                      });
                    },
                    placeholder: "Select values",
                    style: { marginTop: "5px" }
                  }),
                  depVariable?.type === "boolean" && /* @__PURE__ */ jsx_runtime7.jsx(MultiSelect, {
                    size: "xs",
                    data: [
                      { value: "true", label: "TRUE" },
                      { value: "false", label: "FALSE" }
                    ],
                    value: dependent.values,
                    onChange: (newValues) => {
                      updateDependent({
                        mapId: layoutMap.id,
                        imageVariableId: variableConfig.id,
                        dependentGroupIndex: groupIndex,
                        dependent: {
                          ...dependent,
                          values: newValues
                        }
                      });
                    },
                    placeholder: "Select values",
                    style: { marginTop: "5px" }
                  })
                ]
              })
            }, depIndex);
          }),
          /* @__PURE__ */ jsx_runtime7.jsx(Grid.Col, {
            span: 4,
            children: /* @__PURE__ */ jsx_runtime7.jsx(Card, {
              shadow: "sm",
              padding: "xs",
              radius: "md",
              style: {
                minHeight: "100px",
                height: "auto",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                border: "1px dashed #ccc",
                cursor: "pointer"
              },
              onClick: () => handleAddDependentToGroup(groupIndex),
              children: /* @__PURE__ */ jsx_runtime7.jsx(ActionIcon, {
                variant: "transparent",
                size: "xl",
                children: /* @__PURE__ */ jsx_runtime7.jsx(IconPlus, {})
              })
            })
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime7.jsx(DependentGroupSetValue, {
        groupIndex,
        imageVariableId: variableConfig.id,
        mapId: layoutMap.id,
        variableValue: dependentGroup.variableValue
      })
    ]
  }, groupIndex);
};

// src/components/LayoutMappingModal/VariableCard.tsx
var jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var VariableCard = ({
  variableConfig,
  layoutMap
}) => {
  const documentVariables = appStore((store) => store.state.studio.document.variables);
  const raiseError2 = appStore((store) => store.raiseError);
  const setCurrentImageVariableId = appStore((store) => store.effects.modal.dependentModal.setCurrentImageVariableId);
  const setDependentModalIsOpen = appStore((store) => store.effects.modal.dependentModal.setIsOpen);
  const removeImageVariable = appStore((store) => store.effects.studio.layoutImageMapping.removeImageVariable);
  const setIsSwapImageVariableModalOpen = appStore((store) => store.effects.modal.setIsSwapImageVariableModalOpen);
  const setCurrentSwapImageVariableId = appStore((store) => store.effects.modal.setCurrentSwapImageVariableId);
  const setCurrentSelectedMapId = appStore((store) => store.effects.modal.setCurrentSelectedMapId);
  const [isOpen, setIsOpen] = import_react255.useState(false);
  const variableImageConfig = documentVariables.find((v2) => v2.id === variableConfig.id);
  if (variableImageConfig == null) {
    raiseError2(Result.error(new Error("variableDocument is null")));
    throw "ERROR - DO BETTER!!!";
  }
  const handleAddGroup = () => {
    setCurrentImageVariableId(variableConfig.id);
    setDependentModalIsOpen(true, layoutMap.id);
  };
  const handleSwapImageVariable = (e) => {
    e.stopPropagation();
    setCurrentSwapImageVariableId(variableConfig.id);
    setCurrentSelectedMapId(layoutMap.id);
    setIsSwapImageVariableModalOpen(true);
  };
  return /* @__PURE__ */ jsx_runtime8.jsxs(Paper, {
    styles: { root: { margin: "15px" } },
    shadow: "sm",
    radius: "lg",
    p: "md",
    children: [
      /* @__PURE__ */ jsx_runtime8.jsxs(Group, {
        justify: "space-between",
        onClick: () => setIsOpen(!isOpen),
        children: [
          /* @__PURE__ */ jsx_runtime8.jsxs(Group, {
            children: [
              /* @__PURE__ */ jsx_runtime8.jsx(Title, {
                order: 5,
                children: variableImageConfig.name
              }),
              /* @__PURE__ */ jsx_runtime8.jsx(ActionIcon, {
                size: "lg",
                radius: "xl",
                color: "blue",
                onClick: handleSwapImageVariable,
                children: /* @__PURE__ */ jsx_runtime8.jsx(IconExchange, {})
              })
            ]
          }),
          /* @__PURE__ */ jsx_runtime8.jsxs(Group, {
            gap: "md",
            children: [
              /* @__PURE__ */ jsx_runtime8.jsx(ActionIcon, {
                size: "lg",
                radius: "xl",
                onClick: (e) => {
                  e.stopPropagation();
                  setIsOpen(!isOpen);
                },
                style: {
                  transform: isOpen ? "rotate(0deg)" : "rotate(90deg)",
                  transition: "transform 0.2s ease"
                },
                children: /* @__PURE__ */ jsx_runtime8.jsx(IconCaretDownFilled, {})
              }),
              /* @__PURE__ */ jsx_runtime8.jsx(ActionIcon, {
                size: "lg",
                color: "red",
                radius: "xl",
                onClick: (e) => {
                  e.stopPropagation();
                  removeImageVariable({
                    mapId: layoutMap.id,
                    imageVariableId: variableConfig.id
                  });
                },
                children: /* @__PURE__ */ jsx_runtime8.jsx(IconTrashFilled, {})
              })
            ]
          })
        ]
      }),
      isOpen && /* @__PURE__ */ jsx_runtime8.jsxs(jsx_runtime8.Fragment, {
        children: [
          /* @__PURE__ */ jsx_runtime8.jsxs(Text, {
            size: "small",
            c: "dimmed",
            children: [
              "Type: ",
              variableImageConfig.type
            ]
          }),
          /* @__PURE__ */ jsx_runtime8.jsx(Title, {
            order: 6,
            mt: "md",
            children: "Dependents:"
          }),
          variableConfig.dependentGroup.length === 0 ? /* @__PURE__ */ jsx_runtime8.jsx(Text, {
            size: "sm",
            c: "dimmed",
            children: "No dependents"
          }) : variableConfig.dependentGroup.map((dependentGroup, groupIndex) => {
            console.log(dependentGroup);
            return /* @__PURE__ */ jsx_runtime8.jsx(DependentGroup, {
              dependentGroup,
              groupIndex,
              variableConfig,
              layoutMap
            }, groupIndex);
          }),
          /* @__PURE__ */ jsx_runtime8.jsx(Group, {
            mt: "md",
            justify: "flex-end",
            children: /* @__PURE__ */ jsx_runtime8.jsx(Button, {
              variant: "subtle",
              size: "sm",
              onClick: handleAddGroup,
              children: /* @__PURE__ */ jsx_runtime8.jsxs(Group, {
                align: "center",
                style: { gap: "5px" },
                children: [
                  /* @__PURE__ */ jsx_runtime8.jsx(IconPlus, {
                    size: 16
                  }),
                  /* @__PURE__ */ jsx_runtime8.jsx(Text, {
                    children: "Add Group"
                  })
                ]
              })
            })
          })
        ]
      })
    ]
  }, variableConfig.id);
};

// src/components/LayoutMappingModal/LayoutConfigSelection.tsx
var jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var LayoutConfigSection = ({
  mapConfig,
  index: index4
}) => {
  const [isOpen, setIsOpen] = import_react256.useState(false);
  const [menuOpened, setMenuOpened] = import_react256.useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = import_react256.useState(false);
  const addLayoutMapFromCopy = appStore((store) => store.effects.studio.layoutImageMapping.addLayoutMapFromCopy);
  const setIsImageVariableMappingModalOpen = appStore((store) => store.effects.modal.setIsImageVariableMappingModalOpen);
  const setCurrentSelectedMapId = appStore((store) => store.effects.modal.setCurrentSelectedMapId);
  const setCurrentAddImageMappingSelectedVariables = appStore((store) => store.effects.modal.setCurrentAddImageMappingSelectedVariables);
  const deleteLayoutMap = appStore((store) => store.effects.studio.layoutImageMapping.deleteLayoutMap);
  return /* @__PURE__ */ jsx_runtime9.jsxs(Paper, {
    p: "md",
    children: [
      /* @__PURE__ */ jsx_runtime9.jsxs(Group, {
        justify: "space-between",
        mb: 20,
        onClick: () => setIsOpen(!isOpen),
        children: [
          /* @__PURE__ */ jsx_runtime9.jsxs(Title, {
            order: 3,
            children: [
              "Layout Mapping #",
              index4 + 1
            ]
          }),
          /* @__PURE__ */ jsx_runtime9.jsx(Group, {
            children: /* @__PURE__ */ jsx_runtime9.jsxs(Group, {
              gap: "xs",
              children: [
                /* @__PURE__ */ jsx_runtime9.jsx(ActionIcon, {
                  size: "lg",
                  radius: "xl",
                  onClick: () => addLayoutMapFromCopy(mapConfig.id),
                  children: /* @__PURE__ */ jsx_runtime9.jsx(IconCopy, {})
                }),
                /* @__PURE__ */ jsx_runtime9.jsx(ActionIcon, {
                  size: "lg",
                  color: "red",
                  radius: "xl",
                  onClick: () => setDeleteModalOpen(true),
                  children: /* @__PURE__ */ jsx_runtime9.jsx(IconTrashFilled, {})
                }),
                /* @__PURE__ */ jsx_runtime9.jsx(ActionIcon, {
                  size: "lg",
                  radius: "xl",
                  onClick: () => setIsOpen(!isOpen),
                  style: {
                    transform: isOpen ? "rotate(0deg)" : "rotate(90deg)",
                    transition: "transform 0.2s ease"
                  },
                  children: /* @__PURE__ */ jsx_runtime9.jsx(IconCaretDownFilled, {})
                })
              ]
            })
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime9.jsx(Title, {
        styles: { root: { marginTop: "30px" } },
        order: 5,
        mb: "md",
        children: "Layout Dependencies"
      }),
      /* @__PURE__ */ jsx_runtime9.jsx(LayoutMultiSelect, {
        showButton: isOpen,
        layoutConfig: mapConfig
      }, index4),
      isOpen && /* @__PURE__ */ jsx_runtime9.jsxs(jsx_runtime9.Fragment, {
        children: [
          /* @__PURE__ */ jsx_runtime9.jsx(Divider, {
            styles: { root: { marginTop: "30px" } }
          }),
          /* @__PURE__ */ jsx_runtime9.jsx(Title, {
            styles: { root: { marginTop: "20px" } },
            order: 5,
            mb: "md",
            children: "Set Variables"
          }),
          mapConfig.variables.map((variableConfig) => /* @__PURE__ */ jsx_runtime9.jsx(VariableCard, {
            variableConfig,
            layoutMap: mapConfig
          }, variableConfig.id)),
          /* @__PURE__ */ jsx_runtime9.jsxs(Button, {
            onClick: () => {
              setIsImageVariableMappingModalOpen(true);
              setCurrentSelectedMapId(mapConfig.id);
              setCurrentAddImageMappingSelectedVariables([]);
            },
            children: [
              /* @__PURE__ */ jsx_runtime9.jsx(IconPlus, {}),
              /* @__PURE__ */ jsx_runtime9.jsx("span", {
                style: { marginLeft: "10px" },
                children: "Add Variables"
              })
            ]
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime9.jsxs(Modal, {
        opened: deleteModalOpen,
        onClose: () => setDeleteModalOpen(false),
        title: "Confirm Deletion",
        centered: true,
        children: [
          /* @__PURE__ */ jsx_runtime9.jsx(Text, {
            size: "sm",
            mb: "lg",
            children: "Are you sure you want to delete this mapping?"
          }),
          /* @__PURE__ */ jsx_runtime9.jsxs(Group, {
            justify: "flex-end",
            mt: "md",
            children: [
              /* @__PURE__ */ jsx_runtime9.jsx(Button, {
                variant: "outline",
                onClick: () => setDeleteModalOpen(false),
                children: "Cancel"
              }),
              /* @__PURE__ */ jsx_runtime9.jsx(Button, {
                color: "red",
                onClick: () => {
                  deleteLayoutMap(mapConfig.id);
                  setDeleteModalOpen(false);
                },
                children: "Delete"
              })
            ]
          })
        ]
      })
    ]
  }, index4);
};

// src/components/LayoutMappingModal/LayoutModal.tsx
var jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var LayoutImageMappingModal = ({ onExportCSV = () => console.log("Export CSV clicked") }) => {
  const events2 = appStore((state) => state.effects);
  const raiseError2 = appStore((state) => state.raiseError);
  const enableToolbar = appStore((state) => state.enableToolbar);
  const document2 = appStore((state) => state.state.studio.document);
  const variables = appStore((state) => state.state.studio.document.variables);
  const isLayoutConfigLoaded = appStore((state) => state.state.studio.isLayoutConfigLoaded);
  const isDocumentLoaded = appStore((state) => state.state.studio.isDocumentLoaded);
  const isModalVisible = appStore((state) => state.state.modal.isModalVisible);
  const layoutImageMapping = appStore((state) => state.state.studio.layoutImageMapping);
  const currentSelectedMapId = appStore((state) => state.state.modal.currentSelectedMapId);
  const currentSwapImageVariableId = appStore((state) => state.state.modal.currentSwapImageVariableId);
  const [validationReport, setValidationReport] = import_react257.useState(null);
  const [isValidationModalOpen, setIsValidationModalOpen] = import_react257.useState(false);
  const imageVariables = import_react257.useMemo(() => {
    return variables.filter((variable) => variable.type === "image");
  }, [variables]);
  const imageVariableOptions = import_react257.useMemo(() => {
    return imageVariables.map((variable) => ({
      value: variable.id,
      label: variable.name
    }));
  }, [imageVariables]);
  import_react257.useEffect(() => {
    const loadConfig = async () => {
      if (!isLayoutConfigLoaded && !isDocumentLoaded) {
        const resultDoc = await loadDocFromDoc();
        const resultLayoutMap = await loadLayoutImageMapFromDoc();
        resultLayoutMap.fold((layoutMapArray) => {
          resultDoc.fold((doc) => {
            const combinedReport = {
              removedLayoutIds: [],
              removedVariables: [],
              removedDependents: [],
              removedVariableValues: []
            };
            const cleanedConfigArray = layoutMapArray.map((config) => {
              const { cleanLayoutMap, report } = layoutMappingValidation(config, doc);
              combinedReport.removedLayoutIds.push(...report.removedLayoutIds);
              combinedReport.removedVariables.push(...report.removedVariables);
              combinedReport.removedDependents.push(...report.removedDependents);
              combinedReport.removedVariableValues.push(...report.removedVariableValues);
              return cleanLayoutMap;
            });
            const hasRemovedItems = combinedReport.removedLayoutIds.length > 0 || combinedReport.removedVariables.length > 0 || combinedReport.removedDependents.length > 0 || combinedReport.removedVariableValues.length > 0;
            if (hasRemovedItems) {
              setValidationReport(combinedReport);
              setIsValidationModalOpen(true);
              events2.studio.layoutImageMapping.load(cleanedConfigArray);
            } else {
              events2.studio.layoutImageMapping.load(layoutMapArray);
            }
            events2.studio.document.load(doc);
          }, raiseError2);
        }, raiseError2);
      }
    };
    if (isModalVisible)
      loadConfig();
  }, [isModalVisible]);
  if (!isModalVisible)
    return null;
  const handleClose = () => {
    events2.studio.document.unload();
    events2.studio.layoutImageMapping.unload();
    enableToolbar();
    events2.modal.hideModal();
  };
  const handleSave = async () => {
    const saveToDocResult = await saveLayoutImageMapToDoc(layoutImageMapping);
    saveToDocResult.map(async (_2) => {
      return await saveLayoutMappingToAction(layoutImageMapping, document2);
    }).fold(handleClose, (e) => e ? raiseError2(e) : e);
  };
  const handleConfigChange = (updatedConfig) => {
    events2.studio.layoutImageMapping.load(updatedConfig);
  };
  const ModalHeader2 = () => {
    return /* @__PURE__ */ jsx_runtime10.jsx(TopBar, {
      children: /* @__PURE__ */ jsx_runtime10.jsxs(Group, {
        justify: "space-between",
        w: "100%",
        children: [
          /* @__PURE__ */ jsx_runtime10.jsx(Title, {
            order: 4,
            c: "white",
            children: "Layout Image Mapping Tool"
          }),
          /* @__PURE__ */ jsx_runtime10.jsx(Button, {
            leftSection: /* @__PURE__ */ jsx_runtime10.jsx(IconPlus, {
              size: 16
            }),
            onClick: () => events2.studio.layoutImageMapping.addLayoutMap(),
            children: "Add Mapping"
          })
        ]
      })
    });
  };
  const ModalFooter = () => {
    return /* @__PURE__ */ jsx_runtime10.jsx(BottomBar, {
      children: /* @__PURE__ */ jsx_runtime10.jsxs(Group, {
        justify: "flex-end",
        gap: "sm",
        children: [
          /* @__PURE__ */ jsx_runtime10.jsx(Checkbox, {
            defaultChecked: true,
            label: "Generate Action"
          }),
          /* @__PURE__ */ jsx_runtime10.jsx(Button, {
            color: "green",
            onClick: handleSave,
            children: "Save"
          }),
          /* @__PURE__ */ jsx_runtime10.jsx(Button, {
            onClick: handleClose,
            children: "Close"
          })
        ]
      })
    });
  };
  return /* @__PURE__ */ jsx_runtime10.jsxs(MantineProvider, {
    defaultColorScheme: "dark",
    children: [
      /* @__PURE__ */ jsx_runtime10.jsxs(Modal, {
        trapFocus: false,
        styles: {
          body: {
            width: "100%",
            height: "90%",
            padding: "0px",
            backgroundColor: "#4a4949",
            borderRadius: "8px",
            display: "flex",
            flexDirection: "column",
            boxShadow: "0 4px 8px rgba(0, 0, 0, 0.2)",
            overflow: "hidden"
          },
          content: {
            width: "100%",
            height: "100%",
            justifyContent: "center",
            alignItems: "center",
            display: "flex"
          }
        },
        centered: true,
        fullScreen: true,
        opened: isModalVisible,
        onClose: handleClose,
        withCloseButton: false,
        children: [
          /* @__PURE__ */ jsx_runtime10.jsx(ModalHeader2, {}),
          /* @__PURE__ */ jsx_runtime10.jsx(Content, {
            children: !isLayoutConfigLoaded || !isDocumentLoaded ? /* @__PURE__ */ jsx_runtime10.jsx(LoadingSpinner, {}) : /* @__PURE__ */ jsx_runtime10.jsx(Stack, {
              h: "100%",
              gap: "md",
              children: layoutImageMapping.map((config, index4) => /* @__PURE__ */ jsx_runtime10.jsx(LayoutConfigSection, {
                mapConfig: config,
                index: index4
              }, index4))
            })
          }),
          /* @__PURE__ */ jsx_runtime10.jsx(ModalFooter, {})
        ]
      }),
      /* @__PURE__ */ jsx_runtime10.jsx(AddMappingImageVariableModal, {
        currentMapConfig: layoutImageMapping.find((config) => config.id === currentSelectedMapId) || null
      }),
      /* @__PURE__ */ jsx_runtime10.jsx(AddDependentModal, {}),
      /* @__PURE__ */ jsx_runtime10.jsx(SwapImageVariableModal, {
        currentMapConfig: layoutImageMapping.find((config) => config.id === currentSelectedMapId) || null,
        currentImageVariable: currentSelectedMapId && currentSwapImageVariableId ? layoutImageMapping.find((config) => config.id === currentSelectedMapId)?.variables.find((v2) => v2.id === currentSwapImageVariableId) || null : null
      }),
      /* @__PURE__ */ jsx_runtime10.jsx(Modal, {
        opened: isValidationModalOpen,
        onClose: () => setIsValidationModalOpen(false),
        title: /* @__PURE__ */ jsx_runtime10.jsx(Title, {
          order: 4,
          children: "Layout Mapping Validation"
        }),
        centered: true,
        size: "lg",
        children: /* @__PURE__ */ jsx_runtime10.jsxs(Stack, {
          gap: "md",
          children: [
            /* @__PURE__ */ jsx_runtime10.jsx(Alert, {
              color: "yellow",
              title: "Items Removed from Layout Mapping",
              children: /* @__PURE__ */ jsx_runtime10.jsx(Text, {
                children: "Values were deleted from the document and thus we also removed those values from your layout mapping."
              })
            }),
            validationReport && /* @__PURE__ */ jsx_runtime10.jsxs(jsx_runtime10.Fragment, {
              children: [
                validationReport.removedLayoutIds.length > 0 && /* @__PURE__ */ jsx_runtime10.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime10.jsx(Text, {
                      fw: 600,
                      children: "Removed Layout IDs:"
                    }),
                    /* @__PURE__ */ jsx_runtime10.jsx(List, {
                      children: validationReport.removedLayoutIds.map((id, index4) => /* @__PURE__ */ jsx_runtime10.jsx(List.Item, {
                        children: id
                      }, index4))
                    })
                  ]
                }),
                validationReport.removedVariables.length > 0 && /* @__PURE__ */ jsx_runtime10.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime10.jsx(Text, {
                      fw: 600,
                      children: "Removed Variables:"
                    }),
                    /* @__PURE__ */ jsx_runtime10.jsx(List, {
                      children: validationReport.removedVariables.map((id, index4) => /* @__PURE__ */ jsx_runtime10.jsx(List.Item, {
                        children: id
                      }, index4))
                    })
                  ]
                }),
                validationReport.removedDependents.length > 0 && /* @__PURE__ */ jsx_runtime10.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime10.jsx(Text, {
                      fw: 600,
                      children: "Removed Dependents:"
                    }),
                    /* @__PURE__ */ jsx_runtime10.jsx(List, {
                      children: validationReport.removedDependents.map((item, index4) => /* @__PURE__ */ jsx_runtime10.jsxs(List.Item, {
                        children: [
                          "Variable ID: ",
                          item.variableId,
                          " (from Image Variable:",
                          " ",
                          item.imageVariableId,
                          ")"
                        ]
                      }, index4))
                    })
                  ]
                }),
                validationReport.removedVariableValues.length > 0 && /* @__PURE__ */ jsx_runtime10.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime10.jsx(Text, {
                      fw: 600,
                      children: "Removed Variable Values:"
                    }),
                    /* @__PURE__ */ jsx_runtime10.jsx(List, {
                      children: validationReport.removedVariableValues.map((item, index4) => /* @__PURE__ */ jsx_runtime10.jsxs(List.Item, {
                        children: [
                          "Value: ",
                          item.value,
                          " (from Image Variable:",
                          " ",
                          item.imageVariableId,
                          ", Group:",
                          " ",
                          item.dependentGroupIndex,
                          ")"
                        ]
                      }, index4))
                    })
                  ]
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime10.jsx(Group, {
              justify: "flex-end",
              children: /* @__PURE__ */ jsx_runtime10.jsx(Button, {
                onClick: () => setIsValidationModalOpen(false),
                children: "OK"
              })
            })
          ]
        })
      })
    ]
  });
};
var TopBar = dt.div`
  padding: 16px 20px;
  background-color: #3a3939;
  border-bottom: 1px solid #5a5a5a;
`;
var Content = dt.div`
  flex: 1;
  padding: 20px;
  overflow-y: auto;
`;
var BottomBar = dt.div`
  padding: 16px 20px;
  background-color: #3a3939;
  border-top: 1px solid #5a5a5a;
`;
var LoadingSpinner = dt.div`
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;

  &:after {
    content: "";
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #be4bdb;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;

// src/components/Toolbar.tsx
var import_react284 = __toESM(require_react(), 1);

// src/components/FrameSnapshotLayout/FrameSnapshotLayoutModal.tsx
var import_react264 = __toESM(require_react(), 1);

// src/components/FrameSnapshotLayout/FrameLayoutCard.tsx
var import_react263 = __toESM(require_react(), 1);

// src/components/FrameSnapshotLayout/FrameSnapshotRow.tsx
var import_react259 = __toESM(require_react(), 1);

// src/components/FrameSnapshotLayout/EditableCell.tsx
var import_react258 = __toESM(require_react(), 1);
var jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function EditableCell({
  rowKey,
  field,
  value,
  onEditStart,
  isEditing,
  editValue,
  onEditChange,
  onEditSave,
  onEditCancel
}) {
  const [isHovered, setIsHovered] = import_react258.useState(false);
  const inputRef = import_react258.useRef(null);
  const cellKey = `${rowKey}:${field}`;
  import_react258.useEffect(() => {
    if (isEditing) {
      setTimeout(() => inputRef.current?.focus(), 10);
    }
  }, [isEditing]);
  import_react258.useEffect(() => {
    console.log(rowKey);
  }, []);
  const handleKeyDown = (e) => {
    if (e.key === "Enter")
      onEditSave();
    if (e.key === "Escape")
      onEditCancel();
  };
  return /* @__PURE__ */ jsx_runtime11.jsx("div", {
    onMouseEnter: () => setIsHovered(true),
    onMouseLeave: () => setIsHovered(false),
    style: { position: "relative" },
    children: isEditing ? field === "imageName" ? /* @__PURE__ */ jsx_runtime11.jsx(TextInput, {
      ref: inputRef,
      value: editValue,
      onChange: (e) => onEditChange(e.target.value),
      onKeyDown: handleKeyDown,
      onBlur: onEditSave,
      size: "xs",
      style: { width: "100%" }
    }) : /* @__PURE__ */ jsx_runtime11.jsx(NumberInput, {
      ref: inputRef,
      value: Number(editValue),
      onChange: (val) => onEditChange(val || 0),
      onKeyDown: handleKeyDown,
      onBlur: onEditSave,
      size: "xs",
      style: { width: "100%" }
    }) : /* @__PURE__ */ jsx_runtime11.jsxs(jsx_runtime11.Fragment, {
      children: [
        value,
        isHovered && /* @__PURE__ */ jsx_runtime11.jsx(ActionIcon, {
          size: "xs",
          variant: "subtle",
          color: "blue",
          style: {
            position: "absolute",
            right: "5px",
            top: "50%",
            transform: "translateY(-50%)"
          },
          onClick: () => onEditStart(cellKey, value),
          children: /* @__PURE__ */ jsx_runtime11.jsx(IconPencil, {
            size: 14
          })
        })
      ]
    })
  });
}

// src/components/FrameSnapshotLayout/FrameSnapshotRow.tsx
var jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function FrameSnapshotRow({
  snapshot,
  layoutId,
  onEditCell,
  onCheckChange,
  isChecked
}) {
  const [editState, setEditState] = import_react259.useState({
    key: null,
    value: ""
  });
  const handleEditStart = import_react259.useCallback((key, value) => {
    setEditState({ key, value });
  }, []);
  const handleEditChange = import_react259.useCallback((value) => {
    setEditState((prev2) => ({ ...prev2, value }));
  }, []);
  const handleEditSave = import_react259.useCallback(() => {
    if (editState.key && onEditCell) {
      onEditCell(layoutId, editState.key, editState.value);
    }
    setEditState({ key: null, value: "" });
  }, [editState, onEditCell]);
  const handleEditCancel = import_react259.useCallback(() => {
    setEditState({ key: null, value: "" });
  }, []);
  const rowStyle = isChecked ? { backgroundColor: "#e6f7ff" } : {};
  return /* @__PURE__ */ jsx_runtime12.jsxs(Table.Tr, {
    style: rowStyle,
    children: [
      ["imageName", "x", "y", "width", "height"].map((field) => /* @__PURE__ */ jsx_runtime12.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime12.jsx(EditableCell, {
          rowKey: snapshot.uniqueId,
          field,
          value: snapshot[field],
          onEditStart: handleEditStart,
          isEditing: editState.key === `${snapshot.uniqueId}:${field}`,
          editValue: editState.value,
          onEditChange: handleEditChange,
          onEditSave: handleEditSave,
          onEditCancel: handleEditCancel
        })
      }, field)),
      /* @__PURE__ */ jsx_runtime12.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime12.jsx(Checkbox, {
          checked: isChecked,
          onChange: (event) => onCheckChange(snapshot.uniqueId, event.currentTarget.checked)
        })
      })
    ]
  });
}

// src/components/FrameSnapshotLayout/CopyToLayerModal.tsx
var import_react260 = __toESM(require_react(), 1);
var jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function CopyToLayerModal({
  opened,
  onClose,
  snapshots,
  sourceLayoutId,
  frameLayoutMaps,
  onUpdateFrameLayoutMaps
}) {
  const [layouts, setLayouts] = import_react260.useState([]);
  const [selectedLayoutId, setSelectedLayoutId] = import_react260.useState(null);
  const [isLoading, setIsLoading] = import_react260.useState(false);
  const raiseError2 = appStore((store) => store.raiseError);
  import_react260.useEffect(() => {
    if (opened) {
      loadAvailableLayouts();
    }
  }, [opened]);
  const loadAvailableLayouts = async () => {
    try {
      const layoutsResult = await getAllLayouts(window.SDK);
      if (!layoutsResult.isOk()) {
        raiseError2(new Error(layoutsResult.error?.message || "Failed to load layouts"));
        return;
      }
      const filteredLayouts = layoutsResult.value.filter((layout) => layout.id !== sourceLayoutId).map((layout) => ({
        value: layout.id,
        label: layout.name || "Unnamed Layout"
      }));
      setLayouts(filteredLayouts);
      if (filteredLayouts.length > 0) {
        setSelectedLayoutId(filteredLayouts[0].value);
      }
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    }
  };
  const handleCopy = () => {
    if (!selectedLayoutId) {
      raiseError2(new Error("No layout selected"));
      return;
    }
    setIsLoading(true);
    try {
      const updatedFrameLayoutMaps = [...frameLayoutMaps];
      let targetLayoutMap = updatedFrameLayoutMaps.find((map) => map.layoutId === selectedLayoutId);
      if (!targetLayoutMap) {
        const layoutName = layouts.find((l2) => l2.value === selectedLayoutId)?.label || "Unknown Layout";
        targetLayoutMap = {
          layoutId: selectedLayoutId,
          layoutName,
          frameSnapshots: []
        };
        updatedFrameLayoutMaps.push(targetLayoutMap);
      }
      for (const snapshot of snapshots) {
        const uniqueId = snapshot.uniqueId || `${snapshot.frameId}_${snapshot.imageName}`;
        const existingIndex = targetLayoutMap.frameSnapshots.findIndex((s2) => s2.id === uniqueId);
        if (existingIndex !== -1) {
          targetLayoutMap.frameSnapshots[existingIndex] = {
            frameId: snapshot.frameId,
            imageName: snapshot.imageName,
            x: snapshot.x,
            y: snapshot.y,
            width: snapshot.width,
            height: snapshot.height,
            id: uniqueId
          };
        } else {
          targetLayoutMap.frameSnapshots.push({
            frameId: snapshot.frameId,
            imageName: snapshot.imageName,
            x: snapshot.x,
            y: snapshot.y,
            width: snapshot.width,
            height: snapshot.height,
            id: uniqueId
          });
        }
      }
      onUpdateFrameLayoutMaps(updatedFrameLayoutMaps);
      onClose();
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ jsx_runtime13.jsx(Modal, {
    opened,
    onClose,
    title: "Copy to Layer",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime13.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime13.jsxs(Text, {
          size: "sm",
          children: [
            "Select a layout to copy ",
            snapshots.length,
            " snapshot",
            snapshots.length !== 1 ? "s" : "",
            " to:"
          ]
        }),
        /* @__PURE__ */ jsx_runtime13.jsx(Select, {
          label: "Target Layout",
          placeholder: "Select a layout",
          data: layouts,
          value: selectedLayoutId,
          onChange: setSelectedLayoutId,
          searchable: true,
          required: true
        }),
        /* @__PURE__ */ jsx_runtime13.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime13.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime13.jsx(Button, {
              onClick: handleCopy,
              loading: isLoading,
              disabled: !selectedLayoutId,
              children: "Copy"
            })
          ]
        })
      ]
    })
  });
}

// src/components/FrameSnapshotLayout/CopyAndAddRowModal.tsx
var import_react261 = __toESM(require_react(), 1);
var jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function CopyAndAddRowModal({
  opened,
  onClose,
  snapshot,
  layoutId,
  existingSnapshots,
  onAddCopy
}) {
  const [newName, setNewName] = import_react261.useState("");
  const [error, setError] = import_react261.useState(null);
  const [isLoading, setIsLoading] = import_react261.useState(false);
  import_react261.default.useEffect(() => {
    if (opened) {
      setNewName(snapshot.imageName);
      setError(null);
      setIsLoading(false);
    }
  }, [opened, snapshot]);
  const handleNameChange = (e) => {
    setNewName(e.target.value);
    setError(null);
  };
  const handleCreate = () => {
    if (!newName.trim()) {
      setError("Name cannot be empty");
      return;
    }
    const nameExists = existingSnapshots.some((s2) => s2.imageName === newName.trim());
    if (nameExists) {
      setError("Name already exists");
      return;
    }
    setIsLoading(true);
    onAddCopy(snapshot, newName.trim());
    setIsLoading(false);
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime14.jsx(Modal, {
    opened,
    onClose,
    title: "Copy and Add Row",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime14.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime14.jsx(Text, {
          size: "sm",
          children: "Enter a name for the new snapshot:"
        }),
        /* @__PURE__ */ jsx_runtime14.jsx(TextInput, {
          label: "Name",
          placeholder: "Enter name",
          value: newName,
          onChange: handleNameChange,
          error,
          required: true,
          autoFocus: true
        }),
        /* @__PURE__ */ jsx_runtime14.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime14.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime14.jsx(Button, {
              onClick: handleCreate,
              loading: isLoading,
              disabled: !newName.trim(),
              children: "Create"
            })
          ]
        })
      ]
    })
  });
}

// src/components/FrameSnapshotLayout/CopyAndReplaceModal.tsx
var import_react262 = __toESM(require_react(), 1);
var jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
function CopyAndReplaceModal({
  opened,
  onClose,
  snapshots,
  layoutId,
  existingSnapshots,
  onAddCopy
}) {
  const [searchText, setSearchText] = import_react262.useState("");
  const [replaceText, setReplaceText] = import_react262.useState("");
  const [errors, setErrors] = import_react262.useState({});
  const [isLoading, setIsLoading] = import_react262.useState(false);
  const [previewSnapshot, setPreviewSnapshot] = import_react262.useState(null);
  const [previewNewName, setPreviewNewName] = import_react262.useState("");
  const [isPreviewNameDifferent, setIsPreviewNameDifferent] = import_react262.useState(false);
  import_react262.useEffect(() => {
    if (opened) {
      setSearchText("");
      setReplaceText("");
      setErrors({});
      setIsLoading(false);
      if (snapshots.length > 0) {
        setPreviewSnapshot(snapshots[0]);
        setPreviewNewName(snapshots[0].imageName);
        setIsPreviewNameDifferent(false);
      }
    }
  }, [opened, snapshots]);
  import_react262.useEffect(() => {
    if (previewSnapshot) {
      const newName = previewSnapshot.imageName.replace(new RegExp(searchText, "g"), replaceText);
      setPreviewNewName(newName);
      setIsPreviewNameDifferent(newName !== previewSnapshot.imageName);
    }
  }, [searchText, replaceText, previewSnapshot]);
  const handleSearchChange = (e) => {
    setSearchText(e.target.value);
  };
  const handleReplaceChange = (e) => {
    setReplaceText(e.target.value);
  };
  const handleCopyAndReplace = () => {
    if (!searchText.trim()) {
      setErrors({ searchText: "Search text cannot be empty" });
      return;
    }
    setIsLoading(true);
    const newErrors = {};
    let hasErrors = false;
    snapshots.forEach((snapshot) => {
      const newName = snapshot.imageName.replace(new RegExp(searchText, "g"), replaceText);
      if (newName === snapshot.imageName) {
        return;
      }
      const nameExists = existingSnapshots.some((s2) => s2.imageName === newName);
      if (nameExists) {
        newErrors[snapshot.uniqueId] = `Name "${newName}" already exists`;
        hasErrors = true;
      }
    });
    if (hasErrors) {
      setErrors(newErrors);
      setIsLoading(false);
      return;
    }
    snapshots.forEach((snapshot) => {
      const newName = snapshot.imageName.replace(new RegExp(searchText, "g"), replaceText);
      if (newName === snapshot.imageName) {
        return;
      }
      onAddCopy(snapshot, newName);
    });
    setIsLoading(false);
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime15.jsx(Modal, {
    opened,
    onClose,
    title: "Copy and Replace",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime15.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime15.jsx(Text, {
          size: "sm",
          children: "Enter search and replace text to create copies with modified names:"
        }),
        /* @__PURE__ */ jsx_runtime15.jsx(TextInput, {
          label: "Search",
          placeholder: "Text to search for",
          value: searchText,
          onChange: handleSearchChange,
          error: errors.searchText,
          required: true,
          autoFocus: true
        }),
        /* @__PURE__ */ jsx_runtime15.jsx(TextInput, {
          label: "Replace",
          placeholder: "Text to replace with",
          value: replaceText,
          onChange: handleReplaceChange,
          required: true
        }),
        previewSnapshot && /* @__PURE__ */ jsx_runtime15.jsxs(Alert, {
          color: isPreviewNameDifferent ? "green" : "red",
          title: "Name Preview",
          children: [
            /* @__PURE__ */ jsx_runtime15.jsxs(Text, {
              size: "sm",
              children: [
                "Original: ",
                previewSnapshot.imageName
              ]
            }),
            /* @__PURE__ */ jsx_runtime15.jsxs(Text, {
              size: "sm",
              children: [
                "New: ",
                previewNewName
              ]
            }),
            /* @__PURE__ */ jsx_runtime15.jsxs(Text, {
              size: "sm",
              fw: 700,
              children: [
                "Is name different: ",
                isPreviewNameDifferent ? "Yes" : "No"
              ]
            })
          ]
        }),
        Object.keys(errors).length > 0 && Object.keys(errors).some((key) => key !== "searchText") && /* @__PURE__ */ jsx_runtime15.jsx(Alert, {
          color: "red",
          title: "Validation Errors",
          children: Object.entries(errors).filter(([key]) => key !== "searchText").map(([key, error]) => /* @__PURE__ */ jsx_runtime15.jsx(Text, {
            size: "sm",
            children: error
          }, key))
        }),
        /* @__PURE__ */ jsx_runtime15.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime15.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime15.jsx(Button, {
              onClick: handleCopyAndReplace,
              loading: isLoading,
              disabled: !searchText.trim() || !isPreviewNameDifferent,
              children: "Copy and Replace"
            })
          ]
        })
      ]
    })
  });
}

// src/components/FrameSnapshotLayout/FrameLayoutCard.tsx
var jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
function FrameLayoutCard({
  layoutMap,
  onRemoveSnapshot,
  onEditCell,
  frameLayoutMaps,
  onUpdateFrameLayoutMaps
}) {
  const [checkedSnapshots, setCheckedSnapshots] = import_react263.useState({});
  const [copyModalOpened, setCopyModalOpened] = import_react263.useState(false);
  const [copyAndAddRowModalOpened, setCopyAndAddRowModalOpened] = import_react263.useState(false);
  const [copyAndReplaceModalOpened, setCopyAndReplaceModalOpened] = import_react263.useState(false);
  const handleCheckChange = (snapshotKey, isChecked) => {
    setCheckedSnapshots((prev2) => ({
      ...prev2,
      [snapshotKey]: isChecked
    }));
  };
  const getCheckedSnapshots = () => {
    return layoutMap.snapshots.filter((snapshot) => checkedSnapshots[snapshot.uniqueId]);
  };
  const deleteCheckedSnapshots = async () => {
    const checked = getCheckedSnapshots();
    for (const snapshot of checked) {
      if (snapshot.uniqueId) {
        await onRemoveSnapshot(layoutMap.layoutId, snapshot.uniqueId);
      }
    }
    setCheckedSnapshots({});
  };
  const deselectAllRows = () => {
    setCheckedSnapshots({});
  };
  const hasCheckedSnapshots = Object.values(checkedSnapshots).some(Boolean);
  const checkedSnapshotsCount = Object.values(checkedSnapshots).filter(Boolean).length;
  const singleSelectedSnapshot = import_react263.useMemo(() => {
    if (checkedSnapshotsCount === 1) {
      const selectedKey = Object.keys(checkedSnapshots).find((key) => checkedSnapshots[key]);
      return layoutMap.snapshots.find((snapshot) => snapshot.uniqueId === selectedKey);
    }
    return null;
  }, [checkedSnapshots, layoutMap.snapshots]);
  const handleAddCopy = (snapshot, newName) => {
    const updatedFrameLayoutMaps = [...frameLayoutMaps];
    const currentLayoutMap = updatedFrameLayoutMaps.find((map) => map.layoutId === layoutMap.layoutId);
    if (!currentLayoutMap)
      return;
    const uniqueId = `${snapshot.frameId}_${newName}`;
    const newSnapshot = {
      frameId: snapshot.frameId,
      imageName: newName,
      x: snapshot.x,
      y: snapshot.y,
      width: snapshot.width,
      height: snapshot.height,
      id: uniqueId,
      uniqueId
    };
    if (!currentLayoutMap.frameSnapshots) {
      currentLayoutMap.frameSnapshots = [];
    }
    currentLayoutMap.frameSnapshots.push(newSnapshot);
    onUpdateFrameLayoutMaps(updatedFrameLayoutMaps);
  };
  return /* @__PURE__ */ jsx_runtime16.jsxs(Card, {
    shadow: "sm",
    padding: "md",
    radius: "md",
    withBorder: true,
    children: [
      /* @__PURE__ */ jsx_runtime16.jsx(Card.Section, {
        withBorder: true,
        inheritPadding: true,
        py: "xs",
        children: /* @__PURE__ */ jsx_runtime16.jsxs(Group, {
          justify: "space-between",
          children: [
            /* @__PURE__ */ jsx_runtime16.jsx(Title, {
              order: 4,
              children: layoutMap.layoutName
            }),
            /* @__PURE__ */ jsx_runtime16.jsx(Group, {
              children: hasCheckedSnapshots && /* @__PURE__ */ jsx_runtime16.jsxs(jsx_runtime16.Fragment, {
                children: [
                  /* @__PURE__ */ jsx_runtime16.jsx(ActionIcon, {
                    color: "red",
                    variant: "filled",
                    onClick: deleteCheckedSnapshots,
                    title: "Delete selected",
                    children: /* @__PURE__ */ jsx_runtime16.jsx(IconTrash, {
                      size: 16
                    })
                  }),
                  /* @__PURE__ */ jsx_runtime16.jsx(ActionIcon, {
                    color: "blue",
                    variant: "filled",
                    onClick: () => setCopyModalOpened(true),
                    title: "Copy to layer",
                    children: /* @__PURE__ */ jsx_runtime16.jsx(IconCopy, {
                      size: 16
                    })
                  }),
                  checkedSnapshotsCount === 1 && /* @__PURE__ */ jsx_runtime16.jsx(ActionIcon, {
                    color: "blue",
                    variant: "filled",
                    onClick: () => setCopyAndAddRowModalOpened(true),
                    title: "Copy and add row",
                    children: /* @__PURE__ */ jsx_runtime16.jsx(IconCopyPlus, {
                      size: 16
                    })
                  }),
                  /* @__PURE__ */ jsx_runtime16.jsx(ActionIcon, {
                    color: "blue",
                    variant: "filled",
                    onClick: () => setCopyAndReplaceModalOpened(true),
                    title: "Copy and replace",
                    children: /* @__PURE__ */ jsx_runtime16.jsx(IconReplace, {
                      size: 16
                    })
                  }),
                  /* @__PURE__ */ jsx_runtime16.jsx(ActionIcon, {
                    color: "blue",
                    variant: "filled",
                    onClick: deselectAllRows,
                    title: "Deselect all",
                    children: /* @__PURE__ */ jsx_runtime16.jsx(IconDeselect, {
                      size: 16
                    })
                  })
                ]
              })
            })
          ]
        })
      }),
      /* @__PURE__ */ jsx_runtime16.jsxs(Table, {
        mt: "md",
        striped: true,
        highlightOnHover: true,
        children: [
          /* @__PURE__ */ jsx_runtime16.jsx(Table.Thead, {
            children: /* @__PURE__ */ jsx_runtime16.jsxs(Table.Tr, {
              children: [
                /* @__PURE__ */ jsx_runtime16.jsx(Table.Th, {
                  children: "Image Name"
                }),
                /* @__PURE__ */ jsx_runtime16.jsx(Table.Th, {
                  children: "X"
                }),
                /* @__PURE__ */ jsx_runtime16.jsx(Table.Th, {
                  children: "Y"
                }),
                /* @__PURE__ */ jsx_runtime16.jsx(Table.Th, {
                  children: "Width"
                }),
                /* @__PURE__ */ jsx_runtime16.jsx(Table.Th, {
                  children: "Height"
                }),
                /* @__PURE__ */ jsx_runtime16.jsx(Table.Th, {
                  children: "Actions"
                })
              ]
            })
          }),
          /* @__PURE__ */ jsx_runtime16.jsx(Table.Tbody, {
            children: layoutMap.snapshots.map((snapshot) => /* @__PURE__ */ jsx_runtime16.jsx(FrameSnapshotRow, {
              snapshot,
              layoutId: layoutMap.layoutId,
              onRemoveSnapshot,
              onEditCell,
              onCheckChange: handleCheckChange,
              isChecked: !!checkedSnapshots[snapshot.uniqueId]
            }, snapshot.uniqueId))
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime16.jsx(CopyToLayerModal, {
        opened: copyModalOpened,
        onClose: () => setCopyModalOpened(false),
        snapshots: getCheckedSnapshots(),
        sourceLayoutId: layoutMap.layoutId,
        frameLayoutMaps,
        onUpdateFrameLayoutMaps
      }),
      singleSelectedSnapshot && /* @__PURE__ */ jsx_runtime16.jsx(CopyAndAddRowModal, {
        opened: copyAndAddRowModalOpened,
        onClose: () => setCopyAndAddRowModalOpened(false),
        snapshot: singleSelectedSnapshot,
        layoutId: layoutMap.layoutId,
        existingSnapshots: layoutMap.snapshots,
        onAddCopy: handleAddCopy
      }),
      /* @__PURE__ */ jsx_runtime16.jsx(CopyAndReplaceModal, {
        opened: copyAndReplaceModalOpened,
        onClose: () => setCopyAndReplaceModalOpened(false),
        snapshots: getCheckedSnapshots(),
        layoutId: layoutMap.layoutId,
        existingSnapshots: layoutMap.snapshots,
        onAddCopy: handleAddCopy
      })
    ]
  }, layoutMap.layoutId);
}

// src/components/FrameSnapshotLayout/FrameSnapshotLayoutModal.tsx
var jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
function FrameSnapshotLayoutModal({
  opened,
  onClose
}) {
  const [frameLayoutMaps, setFrameLayoutMaps] = import_react264.useState([]);
  const [isLoading, setIsLoading] = import_react264.useState(false);
  const [isRemoving, setIsRemoving] = import_react264.useState(false);
  const raiseError2 = appStore((store) => store.raiseError);
  const tableData = import_react264.useMemo(() => {
    return frameLayoutMaps.map((frameLayoutMap, layoutIndex) => {
      let snapshots = frameLayoutMap.frameSnapshots.map((snapshot, snapshotIndex) => {
        const uniqueId = `${snapshot.frameId}_${snapshot.imageName}`;
        return {
          ...snapshot,
          uniqueId
        };
      });
      snapshots = [...snapshots].sort((a2, b) => a2.imageName.localeCompare(b.imageName));
      return {
        layoutId: frameLayoutMap.layoutId,
        layoutName: frameLayoutMap.layoutName,
        snapshots
      };
    });
  }, [frameLayoutMaps]);
  const sortAlphabetically = (maps) => {
    return maps.map((map) => {
      map.frameSnapshots = [...map.frameSnapshots].sort((a2, b) => a2.imageName.localeCompare(b.imageName));
    });
  };
  const handleEditCell = import_react264.useCallback((layoutId, key, value) => {
    if (!key)
      return;
    const [uniqueId, field] = key.split(":");
    setFrameLayoutMaps((prev2) => {
      const next2 = [...prev2];
      const frameSnapshot = next2.find((map) => map.layoutId === layoutId)?.frameSnapshots.find((s2) => s2.uniqueId === uniqueId);
      if (!frameSnapshot)
        return prev2;
      if (field === "imageName") {
        const nameExists = next2.some((map) => map.frameSnapshots.some((s2) => s2.imageName === value && s2.uniqueId !== uniqueId));
        if (nameExists)
          return prev2;
        const stringValue = String(value).trim();
        if (stringValue === "")
          return prev2;
        frameSnapshot.imageName = String(value);
      } else {
        frameSnapshot[field] = Number(value);
      }
      return next2;
    });
  }, []);
  const loadFrameLayouts = async () => {
    setIsLoading(true);
    try {
      const frameLayoutsResult = await loadFrameLayoutMapsFromDoc();
      if (!frameLayoutsResult.isOk()) {
        raiseError2(new Error(frameLayoutsResult.error?.message || "Failed to load frame layouts"));
        return;
      }
      const layoutsResult = await getAllLayouts(window.SDK);
      if (!layoutsResult.isOk()) {
        raiseError2(new Error(layoutsResult.error?.message || "Failed to load layouts"));
        return;
      }
      const layoutMap = new Map;
      layoutsResult.value.forEach((layout) => {
        layoutMap.set(layout.id, layout.name || "Unnamed Layout");
      });
      const enhancedFrameLayoutMaps = frameLayoutsResult.value.map((frameLayoutMap) => ({
        ...frameLayoutMap,
        frameSnapshots: frameLayoutMap.frameSnapshots.map((snapshot) => ({
          ...snapshot,
          uniqueId: `${snapshot.frameId}_${snapshot.imageName}`
        })),
        layoutName: layoutMap.get(frameLayoutMap.layoutId) || "Unknown Layout"
      }));
      setFrameLayoutMaps(enhancedFrameLayoutMaps);
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setIsLoading(false);
    }
  };
  import_react264.useEffect(() => {
    if (opened) {
      loadFrameLayouts();
    }
  }, [opened]);
  const handleRemoveFrameLayout = async (layoutId, uniqueId) => {
    try {
      setIsRemoving(true);
      setFrameLayoutMaps((prev2) => {
        const next2 = [...prev2];
        for (let i2 = 0;i2 < next2.length; i2++) {
          const layout = next2[i2];
          if (layout.layoutId === layoutId) {
            const snapshotIndex = layout.frameSnapshots.findIndex((s2) => s2.uniqueId === uniqueId);
            if (snapshotIndex !== -1) {
              layout.frameSnapshots.splice(snapshotIndex, 1);
              break;
            }
          }
        }
        return next2;
      });
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setIsRemoving(false);
    }
  };
  const cleanupFrameLayoutMaps = import_react264.useCallback(() => {
    return frameLayoutMaps.map((map) => {
      const { layoutName, ...cleanMap } = map;
      const sortedSnapshots = [...cleanMap.frameSnapshots].sort((a2, b) => a2.imageName.localeCompare(b.imageName));
      return {
        ...cleanMap,
        frameSnapshots: sortedSnapshots
      };
    });
  }, [frameLayoutMaps]);
  const saveCleanedFrameLayoutMaps = import_react264.useCallback(async () => {
    const cleanFrameLayoutMaps = cleanupFrameLayoutMaps();
    return await saveFrameLayoutMapsToDoc(cleanFrameLayoutMaps);
  }, [cleanupFrameLayoutMaps]);
  const handleUpdateActions = async () => {
    setIsLoading(true);
    try {
      const saveResult = await saveCleanedFrameLayoutMaps();
      if (!saveResult.isOk()) {
        raiseError2(new Error(saveResult.error?.message || "Failed to save frame layout maps"));
        return;
      }
      const result = await saveImageSizingMappingToAction(cleanupFrameLayoutMaps());
      if (result.isError()) {
        raiseError2(result.error);
      }
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setIsLoading(false);
      onClose();
    }
  };
  const handleCleanupAndClose = async () => {
    setIsLoading(true);
    try {
      const saveResult = await saveCleanedFrameLayoutMaps();
      if (!saveResult.isOk()) {
        raiseError2(new Error(saveResult.error?.message || "Failed to save frame layout maps"));
      }
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setIsLoading(false);
      onClose();
    }
  };
  return /* @__PURE__ */ jsx_runtime17.jsx(Modal, {
    opened,
    onClose: handleCleanupAndClose,
    title: "Frame Position Viewer",
    fullScreen: true,
    centered: true,
    children: /* @__PURE__ */ jsx_runtime17.jsxs("div", {
      style: {
        display: "flex",
        flexDirection: "column",
        height: "calc(100vh - 120px)"
      },
      children: [
        /* @__PURE__ */ jsx_runtime17.jsx(Group, {
          justify: "flex-end",
          mb: "md"
        }),
        /* @__PURE__ */ jsx_runtime17.jsx(ScrollArea, {
          style: { flex: 1 },
          children: isLoading ? /* @__PURE__ */ jsx_runtime17.jsx(Center, {
            style: { height: "100%", width: "100%" },
            children: /* @__PURE__ */ jsx_runtime17.jsx(Loader, {
              size: "lg"
            })
          }) : /* @__PURE__ */ jsx_runtime17.jsx(Stack, {
            children: frameLayoutMaps.length === 0 ? /* @__PURE__ */ jsx_runtime17.jsx(Text, {
              children: "No frame layouts found."
            }) : tableData.map((layout) => /* @__PURE__ */ jsx_runtime17.jsx(FrameLayoutCard, {
              layoutMap: layout,
              onRemoveSnapshot: handleRemoveFrameLayout,
              onEditCell: handleEditCell,
              frameLayoutMaps,
              onUpdateFrameLayoutMaps: setFrameLayoutMaps
            }, layout.layoutId))
          })
        }),
        /* @__PURE__ */ jsx_runtime17.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime17.jsx(Button, {
              onClick: handleUpdateActions,
              color: "blue",
              disabled: isLoading || isRemoving,
              loading: isLoading || isRemoving,
              children: "Update Actions"
            }),
            /* @__PURE__ */ jsx_runtime17.jsx(Button, {
              onClick: handleCleanupAndClose,
              disabled: isRemoving,
              children: "Close"
            })
          ]
        })
      ]
    })
  });
}

// src/components/AddFrameSnapshotModal.tsx
var import_react265 = __toESM(require_react(), 1);
var jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
function AddFrameSnapshotModal({
  opened,
  onClose,
  raiseError: raiseError2
}) {
  const [status, setStatus] = import_react265.useState("idle");
  const [message, setMessage] = import_react265.useState(null);
  const [positionData, setPositionData] = import_react265.useState(null);
  import_react265.useEffect(() => {
    if (!opened) {
      setStatus("idle");
      setMessage(null);
      setPositionData(null);
      return;
    }
    const fetchAndValidateFrame = async () => {
      setStatus("loading");
      setMessage(null);
      try {
        const studioResult = await getStudio();
        if (!studioResult.isOk()) {
          throw studioResult.error;
        }
        const studio2 = studioResult.value;
        const selectedResult = await getSelected2(studio2);
        if (!selectedResult.isOk()) {
          throw selectedResult.error;
        }
        const selectedFrames = selectedResult.value;
        if (selectedFrames.length === 0) {
          setStatus("error");
          setMessage("Please select an image frame.");
          return;
        }
        if (selectedFrames.length > 1) {
          setStatus("error");
          setMessage(`Please select only one frame - ${selectedFrames.length} were selected.`);
          return;
        }
        const selectedFrameType = selectedFrames[0];
        if (selectedFrameType.type !== "image") {
          setStatus("error");
          setMessage(`Please select an image frame, you selected a ${selectedFrameType.type || "non-image"} frame.`);
          return;
        }
        const frameResult = await getById2(studio2, selectedFrameType.id);
        if (!frameResult.isOk()) {
          throw frameResult.error;
        }
        const frame = frameResult.value;
        const frameVariableId = frame.src?.id;
        if (!frameVariableId) {
          throw new Error("Image frame is not tied to image variable");
        }
        const variableResult = await getById(studio2, frameVariableId);
        if (!variableResult.isOk()) {
          throw variableResult.error;
        }
        const linkedVariable = variableResult.value;
        const variableValue = linkedVariable.value?.assetId;
        if (!variableValue) {
          throw new Error("assetId not found on linked variable");
        }
        const propertiesResult = await getPropertiesOnSelectedLayout(studio2);
        if (!propertiesResult.isOk()) {
          throw propertiesResult.error;
        }
        const allProperties = propertiesResult.value;
        const frameProperties = Array.isArray(allProperties) ? allProperties.find((prop) => prop.id === selectedFrameType.id) : null;
        if (!frameProperties) {
          throw new Error(`Could not find properties for selected frame ${selectedFrameType.name} with ID: ${selectedFrameType.id}`);
        }
        const { x: x2, y: y2, width, height } = frameProperties;
        if (x2?.value === undefined || y2?.value === undefined || width?.value === undefined || height?.value === undefined) {
          throw new Error("Selected image frame is missing position properties (x, y, width, or height values).");
        }
        const extractedPosition = {
          x: x2.value,
          y: y2.value,
          width: width.value,
          height: height.value
        };
        setPositionData(extractedPosition);
        const updateResult = await updateFrameLayoutMaps({
          frameId: selectedFrameType.id,
          assetId: variableValue,
          x: extractedPosition.x,
          y: extractedPosition.y,
          width: extractedPosition.width,
          height: extractedPosition.height
        });
        if (!updateResult.isOk()) {
          throw updateResult.error;
        }
        setStatus("success");
        setMessage("Image position successfully saved to layout mapping");
      } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        setStatus("error");
        setMessage(err.message);
        raiseError2(err);
      }
    };
    fetchAndValidateFrame();
  }, [opened, raiseError2]);
  return /* @__PURE__ */ jsx_runtime18.jsx(Modal, {
    opened,
    onClose: status === "loading" ? () => {
    } : onClose,
    title: "Snapshot Image Position",
    centered: true,
    closeOnClickOutside: status !== "loading",
    closeOnEscape: status !== "loading",
    children: /* @__PURE__ */ jsx_runtime18.jsxs(Stack, {
      children: [
        status === "loading" && /* @__PURE__ */ jsx_runtime18.jsxs(Stack, {
          align: "center",
          children: [
            /* @__PURE__ */ jsx_runtime18.jsx(Loader, {}),
            /* @__PURE__ */ jsx_runtime18.jsx(Text, {
              children: "Processing frame snapshot..."
            })
          ]
        }),
        status === "error" && message && /* @__PURE__ */ jsx_runtime18.jsx(Alert, {
          icon: /* @__PURE__ */ jsx_runtime18.jsx(IconAlertCircle, {
            size: "1rem"
          }),
          title: "Error",
          color: "red",
          children: message
        }),
        status === "success" && message && /* @__PURE__ */ jsx_runtime18.jsx(Alert, {
          color: "green",
          title: "Success",
          children: message
        }),
        status === "idle" && /* @__PURE__ */ jsx_runtime18.jsx(Text, {
          size: "sm",
          c: "dimmed",
          children: "Initializing..."
        })
      ]
    })
  });
}

// src/components/LayoutManagerModal.tsx
var import_react266 = __toESM(require_react(), 1);
var jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
function LayoutManagerModal({
  opened,
  onClose
}) {
  const [layouts, setLayouts] = import_react266.useState([]);
  const [studio2, setStudio] = import_react266.useState(null);
  const raiseError2 = appStore((store) => store.raiseError);
  import_react266.useEffect(() => {
    const fetchLayouts = async () => {
      try {
        const studioResult = await getStudio();
        if (!studioResult.isOk()) {
          raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
          return;
        }
        setStudio(studioResult.value);
        const layoutsResult = await getAllLayouts(studioResult.value);
        if (!layoutsResult.isOk()) {
          raiseError2(new Error(layoutsResult.error?.message || "Failed to get layouts"));
          return;
        }
        const layoutNodes = layoutsResult.value.map((layout) => ({
          id: layout.id,
          name: layout.name,
          parentId: layout.parentId,
          available: true,
          resizable: layout.resizableByUser.enabled,
          minWidth: layout.resizableByUser.minWidth,
          maxWidth: layout.resizableByUser.maxWidth,
          minHeight: layout.resizableByUser.minHeight,
          maxHeight: layout.resizableByUser.maxHeight,
          lockAspectRatio: false,
          percentage: 100
        }));
        const sortedLayouts = sortLayouts(layoutNodes);
        setLayouts(sortedLayouts);
      } catch (error) {
        raiseError2(error instanceof Error ? error : new Error(String(error)));
      }
    };
    if (opened) {
      fetchLayouts();
    }
  }, [opened, raiseError2]);
  const sortLayouts = (layoutNodes) => {
    const nodeMap = new Map;
    layoutNodes.forEach((node2) => {
      nodeMap.set(node2.id, node2);
    });
    const depthMap = new Map;
    const getDepth = (nodeId) => {
      if (depthMap.has(nodeId)) {
        return depthMap.get(nodeId);
      }
      const node2 = nodeMap.get(nodeId);
      if (!node2 || !node2.parentId) {
        depthMap.set(nodeId, 0);
        return 0;
      }
      const parentDepth = getDepth(node2.parentId);
      const depth = parentDepth + 1;
      depthMap.set(nodeId, depth);
      return depth;
    };
    layoutNodes.forEach((node2) => getDepth(node2.id));
    return [...layoutNodes].sort((a2, b) => {
      const depthA = depthMap.get(a2.id) || 0;
      const depthB = depthMap.get(b.id) || 0;
      if (depthA !== depthB) {
        return depthA - depthB;
      }
      return a2.name.localeCompare(b.name);
    });
  };
  const handleSaveLayout = async (layout) => {
    if (!studio2)
      return;
    try {
      const update = {
        enabled: { value: layout.resizable },
        minWidth: layout.minWidth !== undefined ? { value: String(layout.minWidth) } : undefined,
        maxWidth: layout.maxWidth !== undefined ? { value: String(layout.maxWidth) } : undefined,
        minHeight: layout.minHeight !== undefined ? { value: String(layout.minHeight) } : undefined,
        maxHeight: layout.maxHeight !== undefined ? { value: String(layout.maxHeight) } : undefined
      };
      const result = await updateLayoutResizable(studio2, layout.id, update);
      if (!result.isOk()) {
        raiseError2(new Error(result.error?.message || "Failed to update layout"));
        return;
      }
    } catch (error) {
      raiseError2(error instanceof Error ? error : new Error(String(error)));
    }
  };
  const handleLayoutChange = (layoutId, property, value) => {
    setLayouts(layouts.map((node2) => node2.id === layoutId ? { ...node2, [property]: value } : node2));
  };
  const LayoutCard = ({ node: node2 }) => {
    const getParentInfo = () => {
      if (!node2.parentId)
        return null;
      const parent = layouts.find((layout) => layout.id === node2.parentId);
      if (!parent)
        return null;
      return /* @__PURE__ */ jsx_runtime19.jsxs(Text, {
        size: "sm",
        color: "dimmed",
        children: [
          "Parent: ",
          parent.name
        ]
      });
    };
    const getIndentation = () => {
      const parent = layouts.find((layout) => layout.id === node2.parentId);
      return parent ? 20 : 0;
    };
    return /* @__PURE__ */ jsx_runtime19.jsx(Box, {
      mb: "sm",
      ml: getIndentation(),
      children: /* @__PURE__ */ jsx_runtime19.jsx(Card, {
        shadow: "sm",
        p: "md",
        radius: "md",
        withBorder: true,
        children: /* @__PURE__ */ jsx_runtime19.jsxs(Stack, {
          children: [
            /* @__PURE__ */ jsx_runtime19.jsx(Group, {
              justify: "space-between",
              children: /* @__PURE__ */ jsx_runtime19.jsxs(Stack, {
                gap: "xs",
                children: [
                  /* @__PURE__ */ jsx_runtime19.jsx(Title, {
                    order: 5,
                    children: node2.name
                  }),
                  getParentInfo()
                ]
              })
            }),
            /* @__PURE__ */ jsx_runtime19.jsxs(Group, {
              children: [
                /* @__PURE__ */ jsx_runtime19.jsx(Switch, {
                  label: "Available",
                  checked: node2.available,
                  onChange: (event) => handleLayoutChange(node2.id, "available", event.currentTarget.checked)
                }),
                /* @__PURE__ */ jsx_runtime19.jsx(Switch, {
                  label: "Resizable",
                  checked: node2.resizable,
                  onChange: (event) => handleLayoutChange(node2.id, "resizable", event.currentTarget.checked)
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime19.jsxs(Group, {
              children: [
                /* @__PURE__ */ jsx_runtime19.jsx(NumberInput, {
                  label: "Min Width",
                  value: node2.minWidth !== null ? node2.minWidth : undefined,
                  onChange: (value) => handleLayoutChange(node2.id, "minWidth", value),
                  disabled: !node2.resizable,
                  style: { width: "80px" }
                }),
                /* @__PURE__ */ jsx_runtime19.jsx(NumberInput, {
                  label: "Max Width",
                  value: node2.maxWidth !== null ? node2.maxWidth : undefined,
                  onChange: (value) => handleLayoutChange(node2.id, "maxWidth", value),
                  disabled: !node2.resizable,
                  style: { width: "80px" }
                }),
                /* @__PURE__ */ jsx_runtime19.jsx(NumberInput, {
                  label: "Min Height",
                  value: node2.minHeight !== null ? node2.minHeight : undefined,
                  onChange: (value) => handleLayoutChange(node2.id, "minHeight", value),
                  disabled: !node2.resizable,
                  style: { width: "80px" }
                }),
                /* @__PURE__ */ jsx_runtime19.jsx(NumberInput, {
                  label: "Max Height",
                  value: node2.maxHeight !== null ? node2.maxHeight : undefined,
                  onChange: (value) => handleLayoutChange(node2.id, "maxHeight", value),
                  disabled: !node2.resizable,
                  style: { width: "80px" }
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime19.jsx(Checkbox, {
              label: "Lock Aspect Ratio",
              checked: node2.lockAspectRatio,
              onChange: (event) => handleLayoutChange(node2.id, "lockAspectRatio", event.currentTarget.checked),
              disabled: !node2.resizable
            }),
            node2.lockAspectRatio && /* @__PURE__ */ jsx_runtime19.jsx(NumberInput, {
              label: "Percentage",
              value: node2.percentage,
              onChange: (value) => handleLayoutChange(node2.id, "percentage", value),
              min: 0,
              max: 50,
              step: 1,
              style: { width: "60px" }
            }),
            /* @__PURE__ */ jsx_runtime19.jsx(Group, {
              justify: "flex-end",
              mt: "xs",
              children: /* @__PURE__ */ jsx_runtime19.jsx(Button, {
                onClick: () => handleSaveLayout(node2),
                color: "blue",
                size: "sm",
                children: "Save Changes"
              })
            })
          ]
        })
      })
    });
  };
  return /* @__PURE__ */ jsx_runtime19.jsx(Modal, {
    opened,
    onClose,
    title: "Layout Manager",
    size: "xl",
    fullScreen: true,
    children: /* @__PURE__ */ jsx_runtime19.jsxs(Box, {
      style: {
        height: "calc(100vh - 120px)",
        overflowY: "auto",
        padding: "16px"
      },
      children: [
        /* @__PURE__ */ jsx_runtime19.jsx(Title, {
          order: 4,
          mb: "md",
          children: "Layouts"
        }),
        /* @__PURE__ */ jsx_runtime19.jsx(Stack, {
          children: layouts.map((node2) => /* @__PURE__ */ jsx_runtime19.jsx(LayoutCard, {
            node: node2
          }, node2.id))
        })
      ]
    })
  });
}

// src/components/DownloadModalNew.tsx
var import_react273 = __toESM(require_react(), 1);
init_documentHandler();

// src/studio/fontHandler.ts
init_utils();
async function getFontFamilies(studio2) {
  return await handleStudioFunc(studio2.font.getFontFamilies);
}

// src/studio/mediaConnectorHandler.ts
init_utils();
init_dist();
async function downloadMediaConnector({
  studio: studio2,
  connectorId,
  assetId,
  downloadType,
  metadata = {}
}) {
  return Result.wrap(studio2.mediaConnector.download)(connectorId, assetId, downloadType, metadata);
}
var baseQueryOptions = {
  pageSize: 15,
  filter: [""]
};
async function queryMediaConnectorSimple(studio2, connectorId, path, pageToken = "") {
  const queryOptions = {
    collection: path,
    pageToken,
    ...baseQueryOptions
  };
  return handleStudioFunc(studio2.mediaConnector.query, connectorId, queryOptions);
}

// src/utils/smartCrop/getVision.ts
init_dist();

// src/utils/smartCrop/sha256Concat.ts
async function sha256Concat(a2, b) {
  const concatenated = a2 + b;
  const encoder = new TextEncoder;
  const data = encoder.encode(concatenated);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// src/utils/smartCrop/smartCrop.types.ts
init_dist();

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set2,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse5,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version2,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse3,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  function: () => _function,
  formatError: () => formatError,
  flattenError: () => flattenError,
  config: () => config,
  clone: () => clone,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = new Set);
    inst._zod.traits.add(name);
    initializer(inst, def);
    for (const k2 in _2.prototype) {
      if (!(k2 in inst))
        Object.defineProperty(inst, k2, { value: _2.prototype[k2].bind(inst) });
    }
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _2(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_2, "name", { value: name });
  return _2;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  stringifyPrimitive: () => stringifyPrimitive,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject2,
  isObject: () => isObject2,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error;
}
function assert(_2) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values2 = Object.entries(entries).filter(([k2, _2]) => numericValues.indexOf(+k2) === -1).map(([_2, v2]) => v2);
  return values2;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  const set2 = false;
  Object.defineProperty(object, key, {
    get() {
      if (!set2) {
        const value = getter();
        object[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v2) {
      Object.defineProperty(object, key, {
        value: v2
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys2 = Object.keys(promisesObj);
  const promises = keys2.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0;i2 < keys2.length; i2++) {
      resolvedObj[keys2[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
function randomString(length2 = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0;i2 < length2; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F2 = Function;
    new F2("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject2(o2) {
  if (isObject2(o2) === false)
    return false;
  const ctor = o2.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_2, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_2, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_2, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_2, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_2) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_2, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_2, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k2) => {
    return shape[k2]._zod.optin === "optional" && shape[k2]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone(schema, def);
}
function merge(a2, b) {
  return clone(a2, {
    ...a2._zod.def,
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function aborted(x2, startIndex = 0) {
  for (let i2 = startIndex;i2 < x2.issues.length; i2++) {
    if (x2.issues[i2]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k2, _2]) => {
    return Number.isNaN(Number.parseInt(k2, 10));
  }).map((el) => el[1]);
}

class Class {
  constructor(..._args) {
  }
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i2++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a2, b) => a2.path.length - b.path.length);
  for (const issue2 of issues) {
    lines.push(`✖ ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  → at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse3 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  html5Email: () => html5Email,
  hostname: () => hostname,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size4 = input.size;
    if (size4 <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size4 = input.size;
    if (size4 >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size4 = input.size;
    if (size4 === def.size)
      return;
    const tooBig = size4 > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length2 = input.length;
    if (length2 <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length2 = input.length;
    if (length2 >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length2 = input.length;
    if (length2 === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length2 > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line2 of dedented) {
      this.content.push(line2);
    }
  }
  compile() {
    const F2 = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x2) => `  ${x2}`)];
    return new F2(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 0,
  patch: 5
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _2 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r3 = safeParse(inst, value);
        return r3.success ? { value: r3.data } : { issues: r3.error?.issues };
      } catch (_2) {
        return safeParseAsync(inst, value).then((r3) => r3.success ? { value: r3.data } : { issues: r3.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix3] = payload.value.split("/");
    try {
      if (!prefix3)
        throw new Error;
      const prefixNum = Number(prefix3);
      if (`${prefixNum}` !== prefix3)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token2, algorithm = null) {
  try {
    const tokensParts = token2.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_2) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_2) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index4) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index4, result.issues));
  }
  final.value[index4] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0;i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === undefined) {
      if (key in input) {
        final.value[key] = undefined;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === undefined) {
    if (key in input)
      final.value[key] = undefined;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys2 = Object.keys(def.shape);
    for (const k2 of keys2) {
      if (!(def.shape[k2] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k2}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys: keys2,
      keySet: new Set(keys2),
      numKeys: keys2.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v2 of field.values)
          propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k2 = esc(key);
      return `shape[${k2}]._zod.run({ value: input[${k2}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids2 = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids2[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids2[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k2 = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k2}] === undefined) {
            if (${k2} in input) {
              newResult[${k2}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k2}, ...iss.path] : [${k2}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k2} in input) newResult[${k2}] = undefined;
        } else {
          newResult[${k2}] = ${id}.value;
        }
        `);
      } else {
        const id = ids2[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r3 = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r3 instanceof Promise) {
          proms.push(r3.then((r4) => isOptional ? handleOptionalObjectResult(r4, payload, key, input) : handleObjectResult(r4, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r3, payload, key, input);
        } else {
          handleObjectResult(r3, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r3 = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r3 instanceof Promise) {
        proms.push(r3.then((r4) => handleObjectResult(r4, payload, key)));
      } else {
        handleObjectResult(r3, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k2, v2] of Object.entries(pv)) {
        if (!propValues[k2])
          propValues[k2] = new Set;
        for (const val of v2) {
          propValues[k2].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o2 of opts) {
      const values2 = o2._zod.propValues?.[def.discriminator];
      if (!values2 || values2.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);
      for (const v2 of values2) {
        if (map.has(v2)) {
          throw new Error(`Duplicate discriminator value "${String(v2)}"`);
        }
        map.set(v2, o2);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b) {
  if (a2 === b) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b instanceof Date && +a2 === +b) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject2(a2) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b)) {
    if (a2.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index4 = 0;index4 < a2.length; index4++) {
      const itemA = a2[index4];
      const itemB = b[index4];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index4, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i2],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index4) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index4, result.issues));
  }
  final.value[index4] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values2 = def.keyType._zod.values;
      payload.value = {};
      for (const key of values2) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values2.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values2 = getEnumValues(def.entries);
  inst._zod.values = new Set(values2);
  inst._zod.pattern = new RegExp(`^(${values2.filter((k2) => propertyKeyTypes.has(typeof k2)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: values2,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? o2.toString() : String(o2)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([...v2].filter((x2) => x2 !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r3 = def.fn(input);
    if (r3 instanceof Promise) {
      return r3.then((r4) => handleRefineResult(r4, payload, input, inst));
    }
    handleRefineResult(r3, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  vi: () => vi_default,
  ur: () => ur_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  ko: () => ko_default,
  kh: () => kh_default,
  ja: () => ja_default,
  it: () => it_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  cs: () => cs_default,
  ca: () => ca_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${issue2.expected}، ولكن تم إدخال ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive(issue2.values[0])}`;
        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
        return `أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `نَص غير مقبول: يجب أن يبدأ بـ "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue2.divisor}`;
      case "unrecognized_keys":
        return `معرف${issue2.keys.length > 1 ? "ات" : ""} غريب${issue2.keys.length > 1 ? "ة" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${issue2.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${issue2.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanlış dəyər: gözlənilən ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
        if (_issue.format === "ends_with")
          return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
        if (_issue.format === "includes")
          return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
        if (_issue.format === "regex")
          return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
        return `Yanlış ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${issue2.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${issue2.origin} daxilində yanlış dəyər`;
      default:
        return `Yanlış dəyər`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count2, one, few, many) {
  const absCount = Math.abs(count2);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "лік";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масіў";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${issue2.expected}, атрымана ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Няправільны ўвод: чакалася ${stringifyPrimitive(issue2.values[0])}`;
        return `Няправільны варыянт: чакаўся адзін з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна быць ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта малы: чакалася, што ${issue2.origin} павінна ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Занадта малы: чакалася, што ${issue2.origin} павінна быць ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
        return `Няправільны ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${issue2.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${issue2.origin}`;
      default:
        return `Няправільны ўвод`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invàlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opció invàlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a màxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingués ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mínim" : "més de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingués ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invàlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
        return `Format invàlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      case "invalid_element":
        return `Element invàlid a ${issue2.origin}`;
      default:
        return `Entrada invàlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "číslo";
      }
      case "string": {
        return "řetězec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${issue2.expected}, obdrženo ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatný vstup: očekáváno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatná možnost: očekávána jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
        return `Neplatný formát ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${issue2.origin}`;
      default:
        return `Neplatný vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/de.js
var error6 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungültige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungültige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungültiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungültig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${issue2.origin}`;
      default:
        return `Ungültige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error7 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${issue2.expected}, riceviĝis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiĝis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiĝis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiĝis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiĝis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} ŝlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/es.js
var error9 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${issue2.expected}, recibido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opción inválida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado pequeño: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeño: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inválida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
        return `Inválido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${issue2.origin}`;
      default:
        return `Entrada inválida`;
    }
  };
};
function es_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/fa.js
var error10 = () => {
  const Sizable = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرایه";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${issue2.expected} می‌بود، ${parsedType3(issue2.input)} دریافت شد`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive(issue2.values[0])} می‌بود`;
        }
        return `گزینه نامعتبر: می‌بایست یکی از ${joinValues(issue2.values, "|")} می‌بود`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
        }
        return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} باشد`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} باشد`;
        }
        return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
        }
        if (_issue.format === "ends_with") {
          return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
        }
        if (_issue.format === "includes") {
          return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
        }
        if (_issue.format === "regex") {
          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${issue2.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${issue2.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${issue2.origin}`;
      case "invalid_union":
        return `ورودی نامعتبر`;
      case "invalid_element":
        return `مقدار نامعتبر در ${issue2.origin}`;
      default:
        return `ورودی نامعتبر`;
    }
  };
};
function fa_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/fi.js
var error11 = () => {
  const Sizable = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syöte: täytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon täytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon täytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syöte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fr.js
var error12 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : ${issue2.expected} attendu, ${parsedType3(issue2.input)} reçu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit être ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit être ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${issue2.expected}, reçu ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "≤" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "≥" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/he.js
var error14 = () => {
  const Sizable = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${issue2.expected}, התקבל ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `קלט לא תקין: צריך ${stringifyPrimitive(issue2.values[0])}`;
        return `קלט לא תקין: צריך אחת מהאפשרויות  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${issue2.divisor}`;
      case "unrecognized_keys":
        return `מפתח${issue2.keys.length > 1 ? "ות" : ""} לא מזוה${issue2.keys.length > 1 ? "ים" : "ה"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${issue2.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${issue2.origin}`;
      default:
        return `קלט לא תקין`;
    }
  };
};
function he_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/hu.js
var error15 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szám";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tömb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${issue2.expected}, a kapott érték ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive(issue2.values[0])}`;
        return `Érvénytelen opció: valamelyik érték várt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Túl nagy: ${issue2.origin ?? "érték"} mérete túl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Túl nagy: a bemeneti érték ${issue2.origin ?? "érték"} túl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Túl kicsi: a bemeneti érték ${issue2.origin} mérete túl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Túl kicsi: a bemeneti érték ${issue2.origin} túl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
        if (_issue.format === "ends_with")
          return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
        if (_issue.format === "includes")
          return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
        return `Érvénytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${issue2.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${issue2.origin}`;
      default:
        return `Érvénytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/id.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/it.js
var error17 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/ja.js
var error18 = () => {
  const Sizable = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "数値";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "配列";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無効な入力: ${issue2.expected}が期待されましたが、${parsedType3(issue2.input)}が入力されました`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無効な入力: ${stringifyPrimitive(issue2.values[0])}が期待されました`;
        return `無効な選択: ${joinValues(issue2.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const adj = issue2.inclusive ? "以下である" : "より小さい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
        return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${adj}必要があります`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "以上である" : "より大きい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${sizing.unit}${adj}必要があります`;
        return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${adj}必要があります`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
        if (_issue.format === "ends_with")
          return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
        if (_issue.format === "includes")
          return `無効な文字列: "${_issue.includes}"を含む必要があります`;
        if (_issue.format === "regex")
          return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
        return `無効な${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${issue2.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${issue2.keys.length > 1 ? "群" : ""}: ${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${issue2.origin}内の無効な値`;
      default:
        return `無効な入力`;
    }
  };
};
function ja_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/kh.js
var error19 = () => {
  const Sizable = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "អារេ (Array)";
        }
        if (data === null) {
          return "គ្មានតម្លៃ (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue2.expected} ប៉ុន្តែទទួលបាន ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${stringifyPrimitive(issue2.values[0])}`;
        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
        return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
        return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue2.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      case "invalid_union":
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      default:
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
    }
  };
};
function kh_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/ko.js
var error20 = () => {
  const Sizable = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${issue2.expected}, 받은 타입은 ${parsedType3(issue2.input)}입니다`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `잘못된 입력: 값은 ${stringifyPrimitive(issue2.values[0])} 이어야 합니다`;
        return `잘못된 옵션: ${joinValues(issue2.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const adj = issue2.inclusive ? "이하" : "미만";
        const suffix2 = adj === "미만" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing)
          return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()}${unit} ${adj}${suffix2}`;
        return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()} ${adj}${suffix2}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "이상" : "초과";
        const suffix2 = adj === "이상" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing) {
          return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()}${unit} ${adj}${suffix2}`;
        }
        return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()} ${adj}${suffix2}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
        }
        if (_issue.format === "ends_with")
          return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
        if (_issue.format === "includes")
          return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
        if (_issue.format === "regex")
          return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
        return `잘못된 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${issue2.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${issue2.origin}`;
      case "invalid_union":
        return `잘못된 입력`;
      case "invalid_element":
        return `잘못된 값: ${issue2.origin}`;
      default:
        return `잘못된 입력`;
    }
  };
};
function ko_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/mk.js
var error21 = () => {
  const Sizable = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "број";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "низа";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${issue2.expected}, примено ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Грешана опција: се очекува една ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да има ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементи"}`;
        return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да биде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Премногу мал: се очекува ${issue2.origin} да има ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Премногу мал: се очекува ${issue2.origin} да биде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${issue2.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${issue2.origin}`;
      default:
        return `Грешен внес`;
    }
  };
};
function mk_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/ms.js
var error22 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error22()
  };
}
// node_modules/zod/v4/locales/nl.js
var error23 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht één van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/no.js
var error24 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: må starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: må ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: må inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error24()
  };
}
// node_modules/zod/v4/locales/ota.js
var error25 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${issue2.expected}, alınan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fâsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fâsit tercih: mûteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
        return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
        }
        return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
        if (_issue.format === "ends_with")
          return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
        if (_issue.format === "regex")
          return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
        return `Fâsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${issue2.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${issue2.origin} için tanınmayan kıymet var.`;
      default:
        return `Kıymet tanınamadı.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/ps.js
var error26 = () => {
  const Sizable = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "ارې";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${issue2.expected} وای, مګر ${parsedType3(issue2.input)} ترلاسه شو`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ناسم ورودي: باید ${stringifyPrimitive(issue2.values[0])} وای`;
        }
        return `ناسم انتخاب: باید یو له ${joinValues(issue2.values, "|")} څخه وای`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
        }
        return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} وي`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} ولري`;
        }
        return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
        }
        if (_issue.format === "ends_with") {
          return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
        }
        if (_issue.format === "includes") {
          return `ناسم متن: باید "${_issue.includes}" ولري`;
        }
        if (_issue.format === "regex") {
          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${issue2.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${issue2.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${issue2.origin} کې`;
      case "invalid_union":
        return `ناسمه ورودي`;
      case "invalid_element":
        return `ناسم عنصر په ${issue2.origin} کې`;
      default:
        return `ناسمه ورودي`;
    }
  };
};
function ps_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/pl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za duża wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt duż(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za mała wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt mał(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
        return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${issue2.origin}`;
      default:
        return `Nieprawidłowe dane wejściowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/pt.js
var error28 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${issue2.expected}, recebido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opção inválida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inválido: deve começar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inválido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inválido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${issue2.origin}`;
      default:
        return `Campo inválido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count2, one, few, many) {
  const absCount = Math.abs(count2);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error29 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "массив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${issue2.expected}, получено ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неверный ввод: ожидалось ${stringifyPrimitive(issue2.values[0])}`;
        return `Неверный вариант: ожидалось одно из ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет иметь ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет иметь ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неверная строка: должна содержать "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
        return `Неверный ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${issue2.keys.length > 1 ? "ые" : "ый"} ключ${issue2.keys.length > 1 ? "и" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${issue2.origin}`;
      default:
        return `Неверные входные данные`;
    }
  };
};
function ru_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/sl.js
var error30 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "število";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${issue2.expected}, prejeto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pričakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna možnost: pričakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pričakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pričakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/sv.js
var error31 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${issue2.expected}, fick ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: förväntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: förväntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För stor(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `För stor(t): förväntat ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${issue2.origin ?? "värdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/ta.js
var error32 = () => {
  const Sizable = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "எண் அல்லாதது" : "எண்";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "அணி";
        }
        if (data === null) {
          return "வெறுமை";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue2.expected}, பெறப்பட்டது ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive(issue2.values[0])}`;
        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues(issue2.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
        }
        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
        }
        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
        if (_issue.format === "ends_with")
          return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
        if (_issue.format === "includes")
          return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
        if (_issue.format === "regex")
          return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
        return `தவறான ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${issue2.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${issue2.keys.length > 1 ? "கள்" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${issue2.origin} இல் தவறான மதிப்பு`;
      default:
        return `தவறான உள்ளீடு`;
    }
  };
};
function ta_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/th.js
var error33 = () => {
  const Sizable = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "อาร์เรย์ (Array)";
        }
        if (data === null) {
          return "ไม่มีค่า (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue2.expected} แต่ได้รับ ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive(issue2.values[0])}`;
        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "ไม่เกิน" : "น้อยกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
        return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "อย่างน้อย" : "มากกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
        if (_issue.format === "regex")
          return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
        return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue2.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${issue2.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${issue2.origin}`;
      default:
        return `ข้อมูลไม่ถูกต้อง`;
    }
  };
};
function th_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error34 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${issue2.expected}, alınan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geçersiz değer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "öğe"}`;
        return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
        if (_issue.format === "ends_with")
          return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geçersiz metin: "${_issue.includes}" içermeli`;
        if (_issue.format === "regex")
          return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
        return `Geçersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${issue2.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${issue2.origin} içinde geçersiz değer`;
      default:
        return `Geçersiz değer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/ua.js
var error35 = () => {
  const Sizable = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${issue2.expected}, отримано ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неправильні вхідні дані: очікується ${stringifyPrimitive(issue2.values[0])}`;
        return `Неправильна опція: очікується одне з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементів"}`;
        return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} буде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Занадто мале: очікується, що ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Занадто мале: очікується, що ${issue2.origin} буде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неправильний рядок: повинен містити "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
        return `Неправильний ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${issue2.keys.length > 1 ? "і" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${issue2.origin}`;
      default:
        return `Неправильні вхідні дані`;
    }
  };
};
function ua_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/ur.js
var error36 = () => {
  const Sizable = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "نمبر";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرے";
        }
        if (data === null) {
          return "نل";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${issue2.expected} متوقع تھا، ${parsedType4(issue2.input)} موصول ہوا`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `غلط ان پٹ: ${stringifyPrimitive(issue2.values[0])} متوقع تھا`;
        return `غلط آپشن: ${joinValues(issue2.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کے ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
        return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کا ${adj}${issue2.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `بہت چھوٹا: ${issue2.origin} کے ${adj}${issue2.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
        }
        return `بہت چھوٹا: ${issue2.origin} کا ${adj}${issue2.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
        }
        if (_issue.format === "ends_with")
          return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
        if (_issue.format === "includes")
          return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
        if (_issue.format === "regex")
          return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
        return `غلط ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${issue2.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${issue2.keys.length > 1 ? "ز" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `${issue2.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${issue2.origin} میں غلط ویلیو`;
      default:
        return `غلط ان پٹ`;
    }
  };
};
function ur_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/vi.js
var error37 = () => {
  const Sizable = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "số";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mảng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${issue2.expected}, nhận được ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive(issue2.values[0])}`;
        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
        return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Quá nhỏ: mong đợi ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Quá nhỏ: mong đợi ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${issue2.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${issue2.origin}`;
      default:
        return `Đầu vào không hợp lệ`;
    }
  };
};
function vi_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error38 = () => {
  const Sizable = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "非数字(NaN)" : "数字";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "数组";
        }
        if (data === null) {
          return "空值(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `无效输入：期望 ${issue2.expected}，实际接收 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `无效输入：期望 ${stringifyPrimitive(issue2.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "个元素"}`;
        return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === "ends_with")
          return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === "includes")
          return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${issue2.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${issue2.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error39 = () => {
  const Sizable = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${issue2.expected}，但收到 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無效的輸入值：預期為 ${stringifyPrimitive(issue2.values[0])}`;
        return `無效的選項：預期為以下其中之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "個元素"}`;
        return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
        }
        if (_issue.format === "ends_with")
          return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
        if (_issue.format === "includes")
          return `無效的字串：必須包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `無效的字串：必須符合格式 ${_issue.pattern}`;
        return `無效的 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${issue2.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${issue2.keys.length > 1 ? "們" : ""}：${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${issue2.origin} 中有無效的值`;
      default:
        return `無效的輸入值`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error39()
  };
}
// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new Map;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new Map;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...this.get(p2) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size4, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size: size4
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length2, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length: length2
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix3, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix: prefix3
  });
}
function _endsWith(suffix2, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix: suffix2
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v2) => [v2, v2])) : values2;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue2) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue2 === "function" ? defaultValue2() : defaultValue2;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
    falsyArray = falsyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format2, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format: format2,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/function.js
class $ZodFunction {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse3(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse3(this._def.output, output, undefined, { callee: impl }) : output;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;
    };
    return impl;
  }
  input(...args) {
    const F2 = this.constructor;
    if (Array.isArray(args[0])) {
      return new F2({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F2({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F2 = this.constructor;
    return new F2({
      type: "function",
      input: this._def.input,
      output
    });
  }
}
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
// node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format: format2, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format2) {
              json.format = formatMap[format2] ?? format2;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format: format2, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format2 === "string" && format2.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys2 = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys2].filter((key) => {
              const v2 = def.shape[key]._zod;
              if (this.io === "input") {
                return v2.optin === undefined;
              } else {
                return v2.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x2, i2) => this.process(x2, {
              ...params,
              path: [...params.path, "anyOf", i2]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a2 = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a2) ? a2.allOf : [a2],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x2, i2) => this.process(x2, { ...params, path: [...params.path, "prefixItems", i2] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values2 = getEnumValues(def.entries);
            if (values2.every((v2) => typeof v2 === "number"))
              json.type = "number";
            if (values2.every((v2) => typeof v2 === "string"))
              json.type = "string";
            json.enum = values2;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v2) => typeof v2 === "number"))
                json.type = "number";
              if (vals.every((v2) => typeof v2 === "string"))
                json.type = "string";
              if (vals.every((v2) => typeof v2 === "boolean"))
                json.type = "string";
              if (vals.every((v2) => v2 === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m2) => {
                  const mFile = { ...file, contentMediaType: m2 };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root2 = this.seen.get(schema);
    if (!root2)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root2) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root2.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_2, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse5 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse5(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format2, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format2, fnOrRegex, _params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  exports_util.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set2(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys2 = new Set(Object.keys(def.entries));
  inst.extract = (values2, params) => {
    const newEntries = {};
    for (const value of values2) {
      if (keys2.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values2, params) => {
    const newEntries = { ...def.entries };
    for (const value of values2) {
      if (keys2.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v2) => [v2, v2])) : values2;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size4, params) => inst.check(_minSize(size4, params));
  inst.max = (size4, params) => inst.check(_maxSize(size4, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue2) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue2 === "function" ? defaultValue2() : defaultValue2;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue2) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue2 === "function" ? defaultValue2() : defaultValue2;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// src/utils/smartCrop/smartCrop.types.ts
class InvalidCropMetadataError extends Error {
  type = "InvalidCropMetadataError";
  cropData = "string";
  constructor(message, cropData) {
    super(message);
    this.cropData = cropData;
  }
}
function verifyCropMetadata(metadata) {
  const PointOfInterestSchema = exports_external.object({
    x: exports_external.number(),
    y: exports_external.number()
  });
  const SubjectAreaSchema = exports_external.object({
    x: exports_external.number(),
    y: exports_external.number(),
    width: exports_external.number(),
    height: exports_external.number()
  });
  const DetectedObjectSchema = exports_external.object({
    class: exports_external.array(exports_external.string()),
    confidence: exports_external.number(),
    subjectArea: SubjectAreaSchema
  });
  const ManualCropMetadataSchema = exports_external.object({
    manualCropMetadata: exports_external.object({
      pointOfInterest: PointOfInterestSchema,
      subjectArea: SubjectAreaSchema
    })
  });
  const VisionCropMetadataSchema = exports_external.object({
    manualCropMetadata: exports_external.null(),
    visionCropMetadata: exports_external.object({
      category: exports_external.string(),
      pointOfInterest: PointOfInterestSchema,
      subjectArea: SubjectAreaSchema,
      detectedObjects: exports_external.array(DetectedObjectSchema),
      version: exports_external.string()
    })
  });
  const manualResult = ManualCropMetadataSchema.safeParse(metadata);
  if (manualResult.success) {
    return Result.ok(manualResult.data);
  }
  const visionResult = VisionCropMetadataSchema.safeParse(metadata);
  if (visionResult.success) {
    return Result.ok(visionResult.data);
  }
  return Result.error(new InvalidCropMetadataError("Invalid crop metadata format", JSON.stringify(metadata)));
}
function convertVisionToManualCropMetadata(visionMetadata) {
  return {
    manualCropMetadata: {
      pointOfInterest: visionMetadata.visionCropMetadata.pointOfInterest,
      subjectArea: visionMetadata.visionCropMetadata.subjectArea
    }
  };
}

// src/utils/smartCrop/getVision.ts
class VisionNotFoundError extends Error {
  type = "VisionNotFoundError";
}
class AuthorizationError extends Error {
  type = "AuthorizationError";
}
async function getVision({
  baseUrl,
  connectorId,
  asset,
  authorization
}) {
  try {
    const url2 = `${baseUrl}external-media/${await sha256Concat(connectorId, asset)}/vision`;
    const response = await fetch(url2, {
      headers: {
        Authorization: "Bearer " + authorization
      }
    });
    if (!response.ok) {
      if (response.status === 401) {
        throw new AuthorizationError(`Authorization failed for ${baseUrl}`);
      }
      if (response.status === 404) {
        throw new VisionNotFoundError(`Vision not found for ${asset}`);
      }
      throw new Error(`HTTP error! status: ${response.status} on ${url2}`);
    }
    const data = await response.json();
    return verifyCropMetadata(data);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error(`Unknown error occurred for ${baseUrl}`));
  }
}

// src/utils/smartCrop/setVision.ts
init_dist();
class SettingVisonBotFoundError extends Error {
  requestBody;
  responseBody;
  url;
  type = "SettingVisonBotFoundError";
  constructor(message, requestBody, responseBody, url2) {
    super(message);
    this.requestBody = requestBody;
    this.responseBody = responseBody;
    this.url = url2;
  }
}

class AuthorizationError2 extends Error {
  type = "AuthorizationError";
}

class BadRequestError extends Error {
  responseBody;
  requestBody;
  type = "BadRequestError";
  constructor(message, responseBody, requestBody) {
    super(message);
    this.responseBody = responseBody;
    this.requestBody = requestBody;
  }
}
async function setVision({
  baseUrl,
  connectorId,
  asset,
  authorization,
  metadata,
  skipUpload = false
}) {
  try {
    const url2 = `${baseUrl}external-media/${await sha256Concat(connectorId, asset)}/vision`;
    const response = await fetch(url2, {
      method: "PUT",
      headers: {
        Authorization: "Bearer " + authorization,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(metadata.manualCropMetadata == null ? convertVisionToManualCropMetadata(metadata) : metadata)
    });
    if (!response.ok) {
      if (response.status === 400) {
        throw new BadRequestError(`Bad request for ${baseUrl}`, await response.text(), JSON.stringify(metadata.manualCropMetadata == null ? convertVisionToManualCropMetadata(metadata) : metadata));
      }
      if (response.status === 401) {
        throw new AuthorizationError2(`Authorization failed for ${baseUrl}`);
      }
      if (response.status === 404) {
        if (skipUpload) {
          throw new SettingVisonBotFoundError(`Not found for ${asset} after upload attempt`, JSON.stringify({
            url: url2,
            headers: {
              Authorization: "Bearer " + authorization,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(metadata)
          }), await response.text(), url2);
        }
        const uploadResult = await uploadImage({
          baseUrl,
          connectorId,
          asset,
          authorization
        });
        return uploadResult.map(async () => {
          return await setVision({
            baseUrl,
            connectorId,
            asset,
            authorization,
            metadata,
            skipUpload: true
          });
        });
      }
      throw new Error(`HTTP error! status: ${response.status} on ${url2}`);
    }
    return Result.ok(undefined);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error(`Unknown error occurred for ${baseUrl}`));
  }
}
function base64ToBlob(base64Data, contentType = "") {
  const byteCharacters = atob(base64Data);
  const byteNumbers = new Array(byteCharacters.length);
  for (let i2 = 0;i2 < byteCharacters.length; i2++) {
    byteNumbers[i2] = byteCharacters.charCodeAt(i2);
  }
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: contentType });
}
async function uploadImage({
  baseUrl,
  connectorId,
  asset,
  authorization
}) {
  try {
    const url2 = `${baseUrl}external-media/${await sha256Concat(connectorId, asset)}/vision`;
    const base64Image = "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAADtJREFUKFNjZGBg+M9ABGAkS+EnLi642XzfvqHYAzcRWRFMBbJisEJsitAV00ghyBri3AhzD1G+JhTmAJCTHwEL6mXhAAAAAElFTkSuQmCC";
    const imageBlob = base64ToBlob(base64Image, "image/png");
    const imageFile = new File([imageBlob], "image.png", { type: "image/png" });
    const formData = new FormData;
    formData.append("file", imageFile);
    const response = await fetch(url2, {
      method: "POST",
      headers: {
        Authorization: "Bearer " + authorization
      },
      body: formData
    });
    if (!response.ok) {
      if (response.status === 401) {
        throw new AuthorizationError2(`Authorization failed for ${baseUrl}`);
      }
      throw new Error(`HTTP error! status: ${response.status} on ${url2}`);
    }
    return Result.ok(undefined);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error(`Unknown error occurred during image upload for ${baseUrl}`));
  }
}

// src/utils/getMediaConnectorsAPI.ts
init_dist();
async function getMediaConnectorsAPI(baseUrl, authToken) {
  try {
    const response = await fetch(`${baseUrl}connectors`, {
      headers: {
        Authorization: `Bearer ${authToken}`,
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) {
      return Result.error(new Error(`Failed to fetch connectors: ${response.statusText}`));
    }
    const connectorResponse = await response.json();
    return Result.ok(connectorResponse);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error(`Unknown error occurred: ${String(error40)}`));
  }
}

// src/components/DownloadModalNew.tsx
init_documentHandler();

// src/components/ImageBrowser.tsx
var import_react268 = __toESM(require_react(), 1);

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (e === undefined)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o2) {
  t.prototype = Object.create(o2.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o2);
}

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0;i2 < newInputs.length; i2++) {
    if (!isEqual(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === undefined) {
    isEqual2 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// node_modules/react-window/dist/index.esm.js
var import_react267 = __toESM(require_react(), 1);
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now2 = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout2(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start = now2();
  function tick() {
    if (now2() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var size4 = -1;
function getScrollbarSize(recalculate) {
  if (recalculate === undefined) {
    recalculate = false;
  }
  if (size4 === -1 || recalculate) {
    var div = document.createElement("div");
    var style2 = div.style;
    style2.width = "50px";
    style2.height = "50px";
    style2.overflow = "scroll";
    document.body.appendChild(div);
    size4 = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }
  return size4;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === undefined) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
if (false) {
}
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = function defaultItemKey(index4, data) {
  return index4;
};
if (false) {
}
function createListComponent(_ref) {
  var _class;
  var { getItemOffset, getEstimatedTotalSize, getItemSize, getOffsetForIndexAndAlignment, getStartIndexForOffset, getStopIndexForStartIndex, initInstanceProps, shouldResetStyleCacheOnItemSizeChange, validateProps } = _ref;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(List2, _PureComponent);
    function List2(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
      _this._outerRef = undefined;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized(_this),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = undefined;
      _this._callOnItemsRendered = memoize_one_esm_default(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this._callOnScroll = undefined;
      _this._callOnScroll = memoize_one_esm_default(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = undefined;
      _this._getItemStyle = function(index4) {
        var _this$props = _this.props, direction = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);
        var style2;
        if (itemStyleCache.hasOwnProperty(index4)) {
          style2 = itemStyleCache[index4];
        } else {
          var _offset = getItemOffset(_this.props, index4, _this._instanceProps);
          var size5 = getItemSize(_this.props, index4, _this._instanceProps);
          var isHorizontal = direction === "horizontal" || layout === "horizontal";
          var isRtl = direction === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index4] = style2 = {
            position: "absolute",
            left: isRtl ? undefined : offsetHorizontal,
            right: isRtl ? offsetHorizontal : undefined,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size5 : "100%",
            width: isHorizontal ? size5 : "100%"
          };
        }
        return style2;
      };
      _this._getItemStyleCache = undefined;
      _this._getItemStyleCache = memoize_one_esm_default(function(_2, __, ___) {
        return {};
      });
      _this._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            return null;
          }
          var direction = _this.props.direction;
          var scrollOffset = scrollLeft;
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout2(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1, null);
        });
      };
      return _this;
    }
    List2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps(nextProps);
      return null;
    };
    var _proto = List2.prototype;
    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(index4, align) {
      if (align === undefined) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index4 = Math.max(0, Math.min(index4, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index4, align, scrollOffset, this._instanceProps, scrollbarSize));
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, direction = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props, direction = _this$props4.direction, layout = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout === "horizontal") {
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var { clientWidth, scrollWidth } = outerRef;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout2(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === undefined ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style2 = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction === "horizontal" || layout === "horizontal";
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items = [];
      if (itemCount > 0) {
        for (var _index = startIndex;_index <= stopIndex; _index++) {
          items.push(import_react267.createElement(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : undefined,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
      return import_react267.createElement(outerElementType || outerTagName || "div", {
        className,
        onScroll,
        ref: this._outerRefSetter,
        style: _extends({
          position: "relative",
          height,
          width,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction
        }, style2)
      }, import_react267.createElement(innerElementType || innerTagName || "div", {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : undefined,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    };
    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return List2;
  }(import_react267.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: undefined,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
  var { children, direction, height, layout, innerTagName, outerTagName, width } = _ref2;
  var instance = _ref3.instance;
  if (false) {
    var isHorizontal;
    switch (direction) {
      case "horizontal":
      case "vertical":
      case "ltr":
      case "rtl":
      default:
    }
    switch (layout) {
      case "horizontal":
      case "vertical":
      default:
    }
  }
};
var FixedSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: function getItemOffset(_ref, index4) {
    var itemSize = _ref.itemSize;
    return index4 * itemSize;
  },
  getItemSize: function getItemSize(_ref2, index4) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
    var { itemCount, itemSize } = _ref3;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index4, align, scrollOffset, instanceProps, scrollbarSize) {
    var { direction, height, itemCount, itemSize, layout, width } = _ref4;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var size5 = isHorizontal ? width : height;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size5);
    var maxOffset = Math.min(lastItemOffset, index4 * itemSize);
    var minOffset = Math.max(0, index4 * itemSize - size5 + itemSize + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size5 && scrollOffset <= maxOffset + size5) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center": {
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size5 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size5 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset4) {
    var { itemCount, itemSize } = _ref5;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset4 / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
    var { direction, height, itemCount, itemSize, layout, width } = _ref6;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var offset4 = startIndex * itemSize;
    var size5 = isHorizontal ? width : height;
    var numVisibleItems = Math.ceil((size5 + scrollOffset - offset4) / itemSize);
    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1));
  },
  initInstanceProps: function initInstanceProps(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps(_ref7) {
    var itemSize = _ref7.itemSize;
    if (false) {
    }
  }
});

// src/components/DownloadModal/DownloadTasksScreen.tsx
var jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function DownloadTasksScreen({
  downloadFiles,
  tasks,
  uploadTasks,
  onClose
}) {
  const allTasks = [
    ...downloadFiles.map((file2) => ({
      id: file2.id,
      name: `Downloading: ${file2.name}`,
      type: "download",
      status: file2.status === "downloading" ? "processing" : file2.status,
      error: file2.error
    })),
    ...tasks,
    ...uploadTasks
  ];
  const allComplete = allTasks.every((task) => task.status === "complete" || task.status === "error" || task.status === "info");
  return /* @__PURE__ */ jsx_runtime20.jsxs(Stack, {
    gap: "xl",
    children: [
      /* @__PURE__ */ jsx_runtime20.jsx(Text, {
        size: "md",
        style: { textAlign: "center", marginBottom: "1rem" },
        children: "Processing Tasks"
      }),
      /* @__PURE__ */ jsx_runtime20.jsx(List, {
        spacing: "md",
        size: "sm",
        children: allTasks.map((task) => /* @__PURE__ */ jsx_runtime20.jsx(List.Item, {
          icon: task.status === "pending" || task.status === "processing" ? /* @__PURE__ */ jsx_runtime20.jsx(Loader, {
            size: "sm"
          }) : task.status === "complete" ? /* @__PURE__ */ jsx_runtime20.jsx(Tooltip, {
            label: "Successfully completed",
            children: /* @__PURE__ */ jsx_runtime20.jsx(IconCircleCheckFilled, {
              size: 20,
              color: "green"
            })
          }) : task.status === "info" ? /* @__PURE__ */ jsx_runtime20.jsx(Tooltip, {
            label: task.tooltip || "Information",
            children: /* @__PURE__ */ jsx_runtime20.jsx(IconInfoCircleFilled, {
              size: 20,
              color: "blue"
            })
          }) : /* @__PURE__ */ jsx_runtime20.jsx(Tooltip, {
            label: task.error || "Task failed",
            children: /* @__PURE__ */ jsx_runtime20.jsx(IconExclamationCircle, {
              size: 20,
              color: "red"
            })
          }),
          children: /* @__PURE__ */ jsx_runtime20.jsx(Text, {
            size: "sm",
            children: task.name
          })
        }, task.id))
      }),
      allComplete && /* @__PURE__ */ jsx_runtime20.jsx(Group, {
        justify: "center",
        mt: "xl",
        children: /* @__PURE__ */ jsx_runtime20.jsx(Button, {
          onClick: onClose,
          color: "blue",
          children: "Close"
        })
      })
    ]
  });
}

// src/components/ImageBrowser.tsx
var jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function ImageBrowser({
  opened,
  mode,
  onClose,
  initialSelection = null
}) {
  const raiseError2 = appStore((store) => store.raiseError);
  const [browserState, setBrowserState] = import_react268.useState("loading");
  const [connectors, setConnectors] = import_react268.useState([]);
  const [selectedConnectorId, setSelectedConnectorId] = import_react268.useState(null);
  const [displayMode, setDisplayMode] = import_react268.useState("list");
  const [localConnectorId, setLocalConnectorId] = import_react268.useState(null);
  const [currentPath, setCurrentPath] = import_react268.useState("/");
  const [folders, setFolders] = import_react268.useState([]);
  const [files, setFiles] = import_react268.useState([]);
  const [selectedFolders, setSelectedFolders] = import_react268.useState(new Set);
  const [selectedFile, setSelectedFile] = import_react268.useState(null);
  const [persistentSelections, setPersistentSelections] = import_react268.useState(new Set);
  const [smartCropMode, setSmartCropMode] = import_react268.useState(false);
  const [sourceFile, setSourceFile] = import_react268.useState(null);
  const [targetSelectedFiles, setTargetSelectedFiles] = import_react268.useState(new Set);
  const [isLoadingFolders, setIsLoadingFolders] = import_react268.useState(false);
  const [error40, setError] = import_react268.useState(null);
  const [thumbnailUrls, setThumbnailUrls] = import_react268.useState(new Map);
  const [thumbnailErrors, setThumbnailErrors] = import_react268.useState(new Map);
  const [loadingThumbnails, setLoadingThumbnails] = import_react268.useState(new Set);
  const [visionDataCache, setVisionDataCache] = import_react268.useState(new Map);
  const [loadingVisionData, setLoadingVisionData] = import_react268.useState(new Set);
  const [copyTasks, setCopyTasks] = import_react268.useState([]);
  const [showTaskModal, setShowTaskModal] = import_react268.useState(false);
  const [hasMorePages, setHasMorePages] = import_react268.useState(false);
  const [nextPageToken, setNextPageToken] = import_react268.useState("");
  const [isLoadingMore, setIsLoadingMore] = import_react268.useState(false);
  const [cleanupTimeoutId, setCleanupTimeoutId] = import_react268.useState(null);
  const [settings, setSettings] = import_react268.useState({
    iconSize: 24
  });
  const [tempSettings, setTempSettings] = import_react268.useState({
    iconSize: 24
  });
  const [isSettingsDrawerOpen, setIsSettingsDrawerOpen] = import_react268.useState(false);
  const itemSize = import_react268.useMemo(() => Math.max(60, settings.iconSize + 32), [settings.iconSize]);
  const CONNECTOR_SESSION_KEY = "tempDownloadModal_connectorId";
  const SETTINGS_STORAGE_KEY = "tempImageBrowserSettings";
  import_react268.useEffect(() => {
    const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
    if (savedSettings) {
      try {
        const parsedSettings = JSON.parse(savedSettings);
        setSettings(parsedSettings);
        setTempSettings(parsedSettings);
      } catch (error41) {
        console.warn("Failed to parse ImageBrowser settings:", error41);
      }
    }
  }, []);
  import_react268.useEffect(() => {
    return () => {
      if (cleanupTimeoutId) {
        clearTimeout(cleanupTimeoutId);
      }
      thumbnailUrls.forEach((url2) => {
        URL.revokeObjectURL(url2);
      });
    };
  }, []);
  import_react268.useEffect(() => {
    if (opened) {
      if (mode === 0 /* FolderSelection */) {
        const folderSelection = initialSelection;
        const selectedPaths = folderSelection?.selectedFolders || [];
        setPersistentSelections(new Set(selectedPaths));
      } else {
        const fileSelection = initialSelection;
        if (fileSelection?.selectedFile) {
          setSelectedFile(fileSelection.selectedFile);
          setCurrentPath(fileSelection.folderPath);
        }
      }
      if (initialSelection?.connectorId) {
        setSelectedConnectorId(initialSelection.connectorId);
      }
      loadConnectors();
    } else {
      cleanupAndResetState();
    }
  }, [opened]);
  import_react268.useEffect(() => {
    if (browserState === "connectorSelection") {
      const savedConnectorId = sessionStorage.getItem(CONNECTOR_SESSION_KEY);
      if (savedConnectorId && connectors.some((c2) => c2.id === savedConnectorId)) {
        setSelectedConnectorId(savedConnectorId);
      }
    }
  }, [browserState, connectors]);
  const resetState = () => {
    setBrowserState("loading");
    setConnectors([]);
    setLocalConnectorId(null);
    setFolders([]);
    setSelectedFolders(new Set);
    setPersistentSelections(new Set);
    setIsLoadingFolders(false);
    setError(null);
    setSmartCropMode(false);
    setSourceFile(null);
    setTargetSelectedFiles(new Set);
    setHasMorePages(false);
    setNextPageToken("");
    setIsLoadingMore(false);
    setThumbnailErrors(new Map);
    setLoadingThumbnails(new Set);
    setVisionDataCache(new Map);
    setLoadingVisionData(new Set);
  };
  const cleanupAndResetState = async () => {
    if (localConnectorId) {
      try {
        const studioResult = await getStudio();
        if (studioResult.isOk()) {
          const unregisterResult = await unregisterConnector(studioResult.value, localConnectorId);
          if (!unregisterResult.isOk()) {
            raiseError2(new Error(unregisterResult.error?.message || "Failed to unregister connector"));
          }
        }
      } catch (error41) {
        raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
      }
    }
    thumbnailUrls.forEach((url2, key) => {
      console.log(`[Cleanup] Timeout revoking URL for ${key}: ${url2}`);
      URL.revokeObjectURL(url2);
    });
    setThumbnailUrls(new Map);
    resetState();
  };
  const loadConnectors = async () => {
    try {
      setError(null);
      setBrowserState("loading");
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        throw new Error(studioResult.error?.message || "Failed to get studio");
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      const connectorsResult = await getMediaConnectorsAPI(baseUrl, token2);
      if (!connectorsResult.isOk()) {
        throw new Error(connectorsResult.error?.message || "Failed to fetch connectors");
      }
      const connectorResponse = connectorsResult.value;
      const mediaConnectors = connectorResponse.data.filter((connector) => connector.type === "media" && connector.enabled);
      setConnectors(mediaConnectors);
      if (selectedConnectorId && mediaConnectors.some((c2) => c2.id === selectedConnectorId)) {
        await proceedWithConnector(selectedConnectorId, studioResult.value);
      } else {
        setBrowserState("connectorSelection");
      }
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      setError(errorMessage);
      raiseError2(new Error(errorMessage));
    }
  };
  const proceedWithConnector = async (connectorId, studio2) => {
    try {
      setError(null);
      setIsLoadingFolders(true);
      sessionStorage.setItem(CONNECTOR_SESSION_KEY, connectorId);
      const registerResult = await registerConnector(studio2, connectorId);
      if (!registerResult.isOk()) {
        throw new Error(registerResult.error?.message || "Failed to register connector");
      }
      const localId = registerResult.value;
      setLocalConnectorId(localId);
      setBrowserState("folderBrowsing");
      await loadFolders(localId, selectedConnectorId, "/", "");
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      setError(errorMessage);
      raiseError2(new Error(errorMessage));
      setIsLoadingFolders(false);
    }
  };
  const setSelectedConnectorIdWithReset = (connectorId) => {
    setSelectedConnectorId(connectorId);
    setCurrentPath("/");
    setSelectedFolders(new Set);
    setSelectedFile(null);
    setPersistentSelections(new Set);
    setHasMorePages(false);
    setNextPageToken("");
    setIsLoadingMore(false);
    setThumbnailErrors(new Map);
    setLoadingThumbnails(new Set);
    setVisionDataCache(new Map);
    setLoadingVisionData(new Set);
  };
  const loadVisionData = async (file2, localConnectorId2, connectorId) => {
    if (!(file2.type === "file" || file2.type == 0)) {
      return;
    }
    const fileKey = `${localConnectorId2}-${file2.id}`;
    if (loadingVisionData.has(fileKey) || visionDataCache.has(fileKey)) {
      return;
    }
    setLoadingVisionData((prev2) => new Set(prev2).add(fileKey));
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        throw new Error(studioResult.error?.message || "Failed to get studio");
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      const visionResult = await getVision({
        baseUrl,
        connectorId,
        asset: file2.id,
        authorization: token2
      });
      if (visionResult.isOk()) {
        setVisionDataCache((prev2) => {
          const newMap = new Map(prev2);
          newMap.set(fileKey, true);
          return newMap;
        });
      } else {
        if (visionResult.error?.type === "VisionNotFoundError") {
          setVisionDataCache((prev2) => {
            const newMap = new Map(prev2);
            newMap.set(fileKey, false);
            return newMap;
          });
        } else {
          console.warn(`Failed to load vision data for ${file2.name}:`, visionResult.error?.message);
        }
      }
    } catch (error41) {
      console.warn(`Failed to load vision data for ${file2.name}:`, error41);
    } finally {
      setLoadingVisionData((prev2) => {
        const newSet = new Set(prev2);
        newSet.delete(fileKey);
        return newSet;
      });
    }
  };
  const loadThumbnail = async (file2, connectorId) => {
    const fileKey = `${connectorId}-${file2.id}`;
    if (loadingThumbnails.has(fileKey) || thumbnailUrls.has(fileKey) || thumbnailErrors.has(fileKey)) {
      return;
    }
    setLoadingThumbnails((prev2) => new Set(prev2).add(fileKey));
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        throw new Error(studioResult.error?.message || "Failed to get studio");
      }
      const downloadResult = await downloadMediaConnector({
        studio: studioResult.value,
        connectorId,
        assetId: file2.id,
        downloadType: "thumbnail",
        metadata: {}
      });
      if (!downloadResult.isOk()) {
        throw new Error(downloadResult.error?.message || "Failed to download thumbnail");
      }
      const uint8Array = downloadResult.value;
      console.log(`[Thumbnail] Downloaded ${file2.name}: ${uint8Array.length} bytes`);
      let contentType = "image/jpeg";
      if (uint8Array.length > 4) {
        const header = Array.from(uint8Array.slice(0, 4)).map((b) => b.toString(16).padStart(2, "0")).join("");
        if (header.startsWith("ffd8"))
          contentType = "image/jpeg";
        else if (header.startsWith("8950"))
          contentType = "image/png";
        else if (header.startsWith("4749"))
          contentType = "image/gif";
        else if (header.startsWith("5249"))
          contentType = "image/webp";
        console.log(`[Thumbnail] Detected content type for ${file2.name}: ${contentType} (header: ${header})`);
      }
      const blob = new Blob([uint8Array], { type: contentType });
      const thumbnailUrl = URL.createObjectURL(blob);
      console.log(`[Thumbnail] Created blob URL for ${file2.name}: ${thumbnailUrl}`);
      setThumbnailUrls((prev2) => {
        const newMap = new Map(prev2);
        newMap.set(fileKey, thumbnailUrl);
        console.log(`[Thumbnail] Stored URL for ${fileKey}: ${thumbnailUrl}`);
        return newMap;
      });
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      setThumbnailErrors((prev2) => new Map(prev2).set(fileKey, errorMessage));
    } finally {
      setLoadingThumbnails((prev2) => {
        const newSet = new Set(prev2);
        newSet.delete(fileKey);
        return newSet;
      });
    }
  };
  const handleConnectorSelect = async () => {
    if (!selectedConnectorId)
      return;
    const studioResult = await getStudio();
    if (!studioResult.isOk()) {
      setError(studioResult.error?.message || "Failed to get studio");
      raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
      return;
    }
    await proceedWithConnector(selectedConnectorId, studioResult.value);
  };
  const updateSelectedFoldersForCurrentPath = (folderData, path) => {
    const currentPathSelections = new Set;
    folderData.forEach((folder) => {
      const folderPath = path === "/" ? `/${folder.name}` : `${path}/${folder.name}`;
      if (persistentSelections.has(folderPath)) {
        currentPathSelections.add(folderPath);
      }
    });
    setSelectedFolders(currentPathSelections);
  };
  const loadFolders = async (connectorId, selectedConnectorId2, path, pageToken = "", append2 = false) => {
    try {
      if (selectedConnectorId2 == null) {
        setError("Connector not selected.");
        raiseError2(new Error("Connector not selected."));
        return;
      }
      if (append2) {
        setIsLoadingMore(true);
      } else {
        setIsLoadingFolders(true);
      }
      setError(null);
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        throw new Error(studioResult.error?.message || "Failed to get studio");
      }
      const queryResult = await queryMediaConnectorSimple(studioResult.value, connectorId, path, pageToken);
      if (!queryResult.isOk()) {
        throw new Error(queryResult.error?.message || "Failed to query media connector");
      }
      const queryPage = queryResult.value;
      const folderData = queryPage.data.filter((item) => item.type === "folder" || item.type == 1);
      const fileData = queryPage.data.filter((item) => item.type === "file" || item.type == 0);
      if (append2) {
        setFolders((prev2) => {
          const newFolders = [...prev2, ...folderData];
          if (mode === 0 /* FolderSelection */) {
            updateSelectedFoldersForCurrentPath(newFolders, path);
          }
          return newFolders;
        });
        setFiles((prev2) => [...prev2, ...fileData]);
        fileData.forEach((file2) => {
          loadThumbnail(file2, connectorId);
          if (mode === 1 /* FileSelection */) {
            loadVisionData(file2, connectorId, selectedConnectorId2);
          }
        });
      } else {
        setFolders(folderData);
        setFiles(fileData);
        if (mode === 0 /* FolderSelection */) {
          updateSelectedFoldersForCurrentPath(folderData, path);
        }
        fileData.forEach((file2) => {
          loadThumbnail(file2, connectorId);
          if (mode === 1 /* FileSelection */) {
            loadVisionData(file2, connectorId, selectedConnectorId2);
          }
        });
      }
      if (queryPage.nextPageToken) {
        setHasMorePages(true);
        setNextPageToken(queryPage.nextPageToken);
      } else {
        setHasMorePages(false);
        setNextPageToken("");
      }
      setIsLoadingFolders(false);
      setIsLoadingMore(false);
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      setError(errorMessage);
      raiseError2(new Error(errorMessage));
      setIsLoadingFolders(false);
      setIsLoadingMore(false);
    }
  };
  const loadMoreItems = async () => {
    if (!localConnectorId || !hasMorePages || isLoadingMore || nextPageToken === "") {
      return;
    }
    await loadFolders(localConnectorId, selectedConnectorId, currentPath, nextPageToken, true);
  };
  const ListItem2 = ({
    index: index4,
    style: style2
  }) => {
    const allItems = [
      ...folders,
      ...files
    ];
    const item = allItems[index4];
    if (!item)
      return null;
    const isFolder = item.type === "folder" || item.type == 1;
    const isFile = item.type === "file" || item.type == 0;
    if (isFolder) {
      const folderPath = currentPath === "/" ? `/${item.name}` : `${currentPath}/${item.name}`;
      const isSelected = selectedFolders.has(folderPath);
      return /* @__PURE__ */ jsx_runtime21.jsx("div", {
        style: style2,
        children: /* @__PURE__ */ jsx_runtime21.jsx(Card, {
          shadow: "sm",
          padding: "sm",
          radius: "sm",
          style: {
            cursor: "pointer",
            border: isSelected ? "2px solid #228be6" : undefined,
            margin: "2px",
            height: itemSize - 4
          },
          onClick: () => navigateToFolder(item.name),
          children: /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
            gap: "md",
            align: "center",
            children: [
              mode === 0 /* FolderSelection */ && /* @__PURE__ */ jsx_runtime21.jsx(Checkbox, {
                checked: isSelected,
                onChange: () => toggleFolderSelection(item.name),
                onClick: (e) => e.stopPropagation()
              }),
              /* @__PURE__ */ jsx_runtime21.jsx(IconFolder, {
                size: settings.iconSize
              }),
              /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                size: "sm",
                style: { flex: 1 },
                children: item.name
              })
            ]
          })
        })
      });
    }
    if (isFile) {
      const isSelected = selectedFile === item.name;
      const isSourceFile = smartCropMode && sourceFile === item.name;
      const isTargetSelected = smartCropMode && targetSelectedFiles.has(item.name);
      const isFileSelectable = mode === 1 /* FileSelection */;
      return /* @__PURE__ */ jsx_runtime21.jsx("div", {
        style: style2,
        children: /* @__PURE__ */ jsx_runtime21.jsx(Card, {
          shadow: "sm",
          padding: "sm",
          radius: "sm",
          style: {
            cursor: !isFileSelectable ? "default" : smartCropMode && isSourceFile ? "default" : "pointer",
            border: isFileSelectable && isSelected ? "2px solid #228be6" : isFileSelectable && isTargetSelected ? "2px solid #40c057" : undefined,
            margin: "2px",
            height: itemSize - 4,
            opacity: !isFileSelectable ? 0.6 : isSourceFile ? 0.5 : 1,
            backgroundColor: !isFileSelectable ? "#f8f9fa" : isSourceFile ? "#f8f9fa" : undefined
          },
          onClick: () => {
            if (!isFileSelectable) {
              return;
            }
            if (smartCropMode) {
              if (!isSourceFile) {
                handleTargetFileToggle(item.name);
              }
            } else {
              handleFileSelection(item.name);
            }
          },
          children: /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
            gap: "md",
            align: "center",
            children: [
              isFileSelectable && smartCropMode && !isSourceFile && /* @__PURE__ */ jsx_runtime21.jsx(Checkbox, {
                checked: isTargetSelected,
                onChange: () => handleTargetFileToggle(item.name),
                onClick: (e) => e.stopPropagation()
              }),
              renderFileIcon(item),
              /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                gap: "md",
                justify: "flex-start",
                children: [
                  /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                    size: "sm",
                    style: { flex: 1, userSelect: "text" },
                    children: item.name
                  }),
                  isFileSelectable && renderVisionIcon(item)
                ]
              })
            ]
          })
        })
      });
    }
    return null;
  };
  const handleItemsRendered = ({
    visibleStopIndex
  }) => {
    const allItems = [
      ...folders,
      ...files
    ];
    const totalItems = allItems.length;
    if (visibleStopIndex >= totalItems - 5 && hasMorePages && !isLoadingMore) {
      loadMoreItems();
    }
  };
  const navigateToFolder = async (folderName) => {
    if (!localConnectorId)
      return;
    const newPath = currentPath === "/" ? `/${folderName}` : `${currentPath}/${folderName}`;
    setCurrentPath(newPath);
    setFolders([]);
    if (mode === 1 /* FileSelection */ && !smartCropMode) {
      setSelectedFile(null);
    }
    await loadFolders(localConnectorId, selectedConnectorId, newPath, "");
  };
  const navigateBack = async () => {
    if (!localConnectorId || currentPath === "/")
      return;
    const pathParts = currentPath.split("/").filter(Boolean);
    pathParts.pop();
    const newPath = pathParts.length === 0 ? "/" : `/${pathParts.join("/")}`;
    setCurrentPath(newPath);
    setFolders([]);
    if (mode === 1 /* FileSelection */ && !smartCropMode) {
      setSelectedFile(null);
    }
    await loadFolders(localConnectorId, selectedConnectorId, newPath, "");
  };
  const toggleFolderSelection = (folderName) => {
    const folderPath = currentPath === "/" ? `/${folderName}` : `${currentPath}/${folderName}`;
    const newSelected = new Set(selectedFolders);
    const newPersistent = new Set(persistentSelections);
    if (newSelected.has(folderPath)) {
      newSelected.delete(folderPath);
      newPersistent.delete(folderPath);
    } else {
      newSelected.add(folderPath);
      newPersistent.add(folderPath);
    }
    setSelectedFolders(newSelected);
    setPersistentSelections(newPersistent);
  };
  const toggleCurrentFolderSelection = () => {
    const newPersistent = new Set(persistentSelections);
    if (newPersistent.has(currentPath)) {
      newPersistent.delete(currentPath);
    } else {
      newPersistent.add(currentPath);
    }
    setPersistentSelections(newPersistent);
  };
  const clearAllFolderSelections = () => {
    setPersistentSelections(new Set);
    setSelectedFolders(new Set);
  };
  const handleFileSelection = (fileName) => {
    setSelectedFile(fileName);
  };
  const handleEnterSmartCropMode = () => {
    if (selectedFile) {
      setSmartCropMode(true);
      setSourceFile(selectedFile);
      setTargetSelectedFiles(new Set);
    }
  };
  const handleExitSmartCropMode = () => {
    setSmartCropMode(false);
    setSourceFile(null);
    setTargetSelectedFiles(new Set);
  };
  const handleTargetFileToggle = (fileName) => {
    const newTargetFiles = new Set(targetSelectedFiles);
    if (newTargetFiles.has(fileName)) {
      newTargetFiles.delete(fileName);
    } else {
      newTargetFiles.add(fileName);
    }
    setTargetSelectedFiles(newTargetFiles);
  };
  const handleOpenSettings = () => {
    setTempSettings({ ...settings });
    setIsSettingsDrawerOpen(true);
  };
  const handleSaveSettings = () => {
    setSettings(tempSettings);
    localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(tempSettings));
    setIsSettingsDrawerOpen(false);
  };
  const handleCancelSettings = () => {
    setTempSettings({ ...settings });
    setIsSettingsDrawerOpen(false);
  };
  const handleCopyVisionData = async () => {
    if (!sourceFile || !localConnectorId || targetSelectedFiles.size === 0) {
      return;
    }
    try {
      setCopyTasks([]);
      setShowTaskModal(true);
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        throw new Error(studioResult.error?.message || "Failed to get studio");
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      const sourceFileObj = files.find((f2) => f2.name === sourceFile);
      if (!sourceFileObj) {
        throw new Error(`Source file ${sourceFile} not found`);
      }
      const getVisionTaskId = `get-vision-${sourceFileObj.id}`;
      setCopyTasks([
        {
          id: getVisionTaskId,
          name: `Getting vision data from: ${sourceFile}`,
          type: "get_vision",
          status: "processing"
        }
      ]);
      const visionResult = await getVision({
        baseUrl,
        connectorId: selectedConnectorId,
        asset: sourceFileObj.id,
        authorization: token2
      });
      if (!visionResult.isOk()) {
        setCopyTasks((prev2) => prev2.map((task) => task.id === getVisionTaskId ? {
          ...task,
          status: "error",
          error: visionResult.error?.message || "Failed to get vision data"
        } : task));
        return;
      }
      setCopyTasks((prev2) => prev2.map((task) => task.id === getVisionTaskId ? { ...task, status: "complete" } : task));
      const sourceVisionData = visionResult.value;
      for (const targetFileName of targetSelectedFiles) {
        const targetFileObj = files.find((f2) => f2.name === targetFileName);
        if (!targetFileObj) {
          continue;
        }
        const setVisionTaskId = `set-vision-${targetFileObj.id}`;
        setCopyTasks((prev2) => [
          ...prev2,
          {
            id: setVisionTaskId,
            name: `Copying vision data to: ${targetFileName}`,
            type: "smart_crop_upload",
            status: "processing"
          }
        ]);
        try {
          const setResult = await setVision({
            baseUrl,
            connectorId: selectedConnectorId,
            asset: targetFileObj.id,
            authorization: token2,
            metadata: sourceVisionData
          });
          if (setResult.isOk()) {
            setCopyTasks((prev2) => prev2.map((task) => task.id === setVisionTaskId ? { ...task, status: "complete" } : task));
            const fileKey = `${localConnectorId}-${targetFileObj.id}`;
            setVisionDataCache((prev2) => {
              const newMap = new Map(prev2);
              newMap.set(fileKey, true);
              return newMap;
            });
          } else {
            setCopyTasks((prev2) => prev2.map((task) => task.id === setVisionTaskId ? {
              ...task,
              status: "error",
              error: setResult.error?.message || "Failed to set vision data"
            } : task));
          }
        } catch (error41) {
          setCopyTasks((prev2) => prev2.map((task) => task.id === setVisionTaskId ? {
            ...task,
            status: "error",
            error: error41 instanceof Error ? error41.message : String(error41)
          } : task));
        }
      }
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
  };
  const handleSelection = async () => {
    if (localConnectorId) {
      try {
        const studioResult = await getStudio();
        if (studioResult.isOk()) {
          const unregisterResult = await unregisterConnector(studioResult.value, localConnectorId);
          if (!unregisterResult.isOk()) {
            raiseError2(new Error(unregisterResult.error?.message || "Failed to unregister connector"));
          }
        }
      } catch (error41) {
        raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
      }
    }
    const selectedConnector = connectors.find((c2) => c2.id === selectedConnectorId);
    const connectorName = selectedConnector?.name || "";
    if (mode === 0 /* FolderSelection */) {
      const selectedPaths = Array.from(persistentSelections);
      const selection = {
        selectedFolders: selectedPaths,
        connectorId: selectedConnectorId || "",
        connectorName
      };
      resetState();
      onClose(selection);
    } else {
      if (selectedFile) {
        const selection = {
          selectedFile,
          folderPath: currentPath,
          connectorId: selectedConnectorId || "",
          connectorName
        };
        resetState();
        onClose(selection);
      } else {
        resetState();
        onClose(null);
      }
    }
  };
  const renderBreadcrumbs = () => {
    const pathParts = currentPath.split("/").filter(Boolean);
    const breadcrumbItems = [
      /* @__PURE__ */ jsx_runtime21.jsx(Anchor, {
        onClick: () => {
          if (localConnectorId) {
            setCurrentPath("/");
            setFolders([]);
            if (mode === 1 /* FileSelection */ && !smartCropMode) {
              setSelectedFile(null);
            }
            loadFolders(localConnectorId, selectedConnectorId, "/", "");
          }
        },
        children: "Root"
      }, "root")
    ];
    pathParts.forEach((part, index4) => {
      const partPath = `/${pathParts.slice(0, index4 + 1).join("/")}`;
      breadcrumbItems.push(/* @__PURE__ */ jsx_runtime21.jsx(Anchor, {
        onClick: () => {
          if (localConnectorId) {
            setCurrentPath(partPath);
            setFolders([]);
            if (mode === 1 /* FileSelection */ && !smartCropMode) {
              setSelectedFile(null);
            }
            loadFolders(localConnectorId, selectedConnectorId, partPath, "");
          }
        },
        children: part
      }, partPath));
    });
    return /* @__PURE__ */ jsx_runtime21.jsx(Breadcrumbs, {
      children: breadcrumbItems
    });
  };
  const renderVisionIcon = (file2) => {
    if (!localConnectorId)
      return null;
    const fileKey = `${localConnectorId}-${file2.id}`;
    const hasVisionData = visionDataCache.get(fileKey);
    const isLoadingVision = loadingVisionData.has(fileKey);
    if (isLoadingVision) {
      return /* @__PURE__ */ jsx_runtime21.jsx(Loader, {
        size: 16
      });
    }
    if (hasVisionData) {
      return /* @__PURE__ */ jsx_runtime21.jsx(Tooltip, {
        label: "Smart Crop (vision data) exist",
        children: /* @__PURE__ */ jsx_runtime21.jsx(IconEyeCheck, {
          size: 16,
          color: "green"
        })
      });
    }
    return null;
  };
  const renderFileIcon = (file2, size5 = settings.iconSize) => {
    if (!localConnectorId)
      return /* @__PURE__ */ jsx_runtime21.jsx(IconFile, {
        size: size5
      });
    const fileKey = `${localConnectorId}-${file2.id}`;
    const thumbnailUrl = thumbnailUrls.get(fileKey);
    const thumbnailError = thumbnailErrors.get(fileKey);
    const isLoading = loadingThumbnails.has(fileKey);
    if (isLoading) {
      return /* @__PURE__ */ jsx_runtime21.jsx(Loader, {
        size: size5
      });
    }
    if (thumbnailError) {
      return /* @__PURE__ */ jsx_runtime21.jsx(Tooltip, {
        label: thumbnailError,
        children: /* @__PURE__ */ jsx_runtime21.jsx(IconExclamationCircle, {
          size: size5,
          color: "red"
        })
      });
    }
    if (thumbnailUrl) {
      console.log(`[Render] Using thumbnail URL for ${file2.name}: ${thumbnailUrl}`);
      return /* @__PURE__ */ jsx_runtime21.jsx("img", {
        src: thumbnailUrl,
        alt: file2.name,
        style: {
          width: size5,
          height: size5,
          objectFit: "cover",
          borderRadius: "4px"
        },
        onLoad: () => console.log(`[Image] Successfully loaded: ${thumbnailUrl}`),
        onError: (e) => {
          console.error(`[Image] Failed to load: ${thumbnailUrl}`, e);
          console.log(`[Image] Current thumbnailUrls map:`, thumbnailUrls);
        }
      });
    }
    return /* @__PURE__ */ jsx_runtime21.jsx(IconFile, {
      size: size5
    });
  };
  const renderGridView = () => {
    return /* @__PURE__ */ jsx_runtime21.jsxs(SimpleGrid, {
      cols: 4,
      spacing: "md",
      children: [
        folders.map((folder) => {
          const folderPath = currentPath === "/" ? `/${folder.name}` : `${currentPath}/${folder.name}`;
          const isSelected = selectedFolders.has(folderPath);
          return /* @__PURE__ */ jsx_runtime21.jsxs(Card, {
            shadow: "sm",
            padding: "md",
            radius: "md",
            style: {
              cursor: "pointer",
              position: "relative",
              border: isSelected ? "2px solid #228be6" : undefined,
              minHeight: Math.max(120, settings.iconSize + 80)
            },
            onClick: () => navigateToFolder(folder.name),
            children: [
              mode === 0 /* FolderSelection */ && /* @__PURE__ */ jsx_runtime21.jsx(Checkbox, {
                checked: isSelected,
                onChange: () => toggleFolderSelection(folder.name),
                style: {
                  position: "absolute",
                  top: "8px",
                  right: "8px"
                },
                onClick: (e) => e.stopPropagation()
              }),
              /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
                align: "center",
                gap: "xs",
                children: [
                  /* @__PURE__ */ jsx_runtime21.jsx(IconFolder, {
                    size: settings.iconSize
                  }),
                  /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                    size: "sm",
                    ta: "center",
                    lineClamp: 2,
                    children: folder.name
                  })
                ]
              })
            ]
          }, folder.id);
        }),
        files.map((file2) => {
          const isSelected = selectedFile === file2.name;
          const isSourceFile = smartCropMode && sourceFile === file2.name;
          const isTargetSelected = smartCropMode && targetSelectedFiles.has(file2.name);
          const isFileSelectable = mode === 1 /* FileSelection */;
          return /* @__PURE__ */ jsx_runtime21.jsxs(Card, {
            shadow: "sm",
            padding: "md",
            radius: "md",
            style: {
              cursor: !isFileSelectable ? "default" : smartCropMode && isSourceFile ? "default" : "pointer",
              position: "relative",
              border: isFileSelectable && isSelected ? "2px solid #228be6" : isFileSelectable && isTargetSelected ? "2px solid #40c057" : undefined,
              opacity: !isFileSelectable ? 0.6 : isSourceFile ? 0.5 : 1,
              backgroundColor: !isFileSelectable ? "#f8f9fa" : isSourceFile ? "#f8f9fa" : undefined,
              minHeight: Math.max(120, settings.iconSize + 80)
            },
            onClick: () => {
              if (!isFileSelectable) {
                return;
              }
              if (smartCropMode) {
                if (!isSourceFile) {
                  handleTargetFileToggle(file2.name);
                }
              } else {
                handleFileSelection(file2.name);
              }
            },
            children: [
              isFileSelectable && smartCropMode && !isSourceFile && /* @__PURE__ */ jsx_runtime21.jsx(Checkbox, {
                checked: isTargetSelected,
                onChange: () => handleTargetFileToggle(file2.name),
                style: {
                  position: "absolute",
                  top: "8px",
                  right: "8px"
                },
                onClick: (e) => e.stopPropagation()
              }),
              /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
                align: "center",
                gap: "xs",
                children: [
                  renderFileIcon(file2),
                  /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                    gap: "xs",
                    justify: "flex-end",
                    children: [
                      /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                        size: "sm",
                        ta: "center",
                        lineClamp: 2,
                        children: file2.name
                      }),
                      isFileSelectable && renderVisionIcon(file2)
                    ]
                  })
                ]
              })
            ]
          }, file2.id);
        }),
        isLoadingMore && /* @__PURE__ */ jsx_runtime21.jsx(Card, {
          shadow: "sm",
          padding: "md",
          radius: "md",
          style: { opacity: 0.7 },
          children: /* @__PURE__ */ jsx_runtime21.jsx(Center, {
            h: "100%",
            children: /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
              align: "center",
              gap: "xs",
              children: [
                /* @__PURE__ */ jsx_runtime21.jsx(Loader, {
                  size: "sm"
                }),
                /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  children: "Loading more..."
                })
              ]
            })
          })
        })
      ]
    });
  };
  return /* @__PURE__ */ jsx_runtime21.jsxs(jsx_runtime21.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime21.jsx(Modal, {
        opened,
        onClose: async () => {
          await cleanupAndResetState();
          onClose(null);
        },
        title: mode === 0 /* FolderSelection */ ? "Select Folders for Smart Crops" : "Select File",
        fullScreen: true,
        styles: {
          content: {
            height: "100vh"
          },
          body: {
            padding: "1rem",
            height: "calc(100vh - 80px)",
            display: "flex",
            flexDirection: "column"
          },
          header: {
            padding: "1.5rem 2rem 1rem 2rem"
          },
          title: {
            fontSize: "1.5rem",
            fontWeight: 600
          }
        },
        children: /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
          gap: "sm",
          children: [
            error40 && /* @__PURE__ */ jsx_runtime21.jsx(Alert, {
              icon: /* @__PURE__ */ jsx_runtime21.jsx(IconAlertCircle, {
                size: "1rem"
              }),
              title: "Error",
              color: "red",
              children: error40
            }),
            browserState === "loading" && /* @__PURE__ */ jsx_runtime21.jsx(Center, {
              children: /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
                align: "center",
                gap: "md",
                children: [
                  /* @__PURE__ */ jsx_runtime21.jsx(Loader, {
                    size: "lg"
                  }),
                  /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                    children: "Loading connectors..."
                  })
                ]
              })
            }),
            browserState === "connectorSelection" && /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
              gap: "md",
              align: "center",
              children: [
                /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                  size: "md",
                  ta: "center",
                  children: mode === 0 /* FolderSelection */ ? "Choose a connector to browse folders" : "Choose a connector to browse files"
                }),
                /* @__PURE__ */ jsx_runtime21.jsx(Select, {
                  label: "Choose Connector",
                  placeholder: "Select a connector",
                  data: connectors.map((c2) => ({ value: c2.id, label: c2.name })),
                  value: selectedConnectorId,
                  onChange: setSelectedConnectorId,
                  style: { width: "300px" }
                }),
                /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                  onClick: handleConnectorSelect,
                  disabled: !selectedConnectorId,
                  loading: isLoadingFolders,
                  style: { marginLeft: "-50px" },
                  children: "Select"
                })
              ]
            }),
            browserState === "folderBrowsing" && /* @__PURE__ */ jsx_runtime21.jsxs(jsx_runtime21.Fragment, {
              children: [
                /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                      gap: "md",
                      children: [
                        /* @__PURE__ */ jsx_runtime21.jsx(ActionIcon, {
                          variant: "subtle",
                          onClick: navigateBack,
                          disabled: currentPath === "/",
                          children: /* @__PURE__ */ jsx_runtime21.jsx(IconArrowBigLeftFilled, {
                            size: 20
                          })
                        }),
                        renderBreadcrumbs()
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                      gap: "md",
                      align: "flex-end",
                      children: [
                        /* @__PURE__ */ jsx_runtime21.jsx(ActionIcon, {
                          variant: "subtle",
                          onClick: handleOpenSettings,
                          "aria-label": "Image Browser Settings",
                          children: /* @__PURE__ */ jsx_runtime21.jsx(IconSettings, {
                            size: 20
                          })
                        }),
                        /* @__PURE__ */ jsx_runtime21.jsx(Select, {
                          label: "Change Connector",
                          placeholder: "Select a connector",
                          data: connectors.map((c2) => ({
                            value: c2.id,
                            label: c2.name
                          })),
                          value: selectedConnectorId,
                          onChange: async (value) => {
                            if (value && value !== selectedConnectorId) {
                              setSelectedConnectorIdWithReset(value);
                              if (localConnectorId) {
                                try {
                                  const studioResult2 = await getStudio();
                                  if (studioResult2.isOk()) {
                                    await unregisterConnector(studioResult2.value, localConnectorId);
                                  }
                                } catch (error41) {
                                  raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
                                }
                              }
                              const studioResult = await getStudio();
                              if (studioResult.isOk()) {
                                await proceedWithConnector(value, studioResult.value);
                              }
                            }
                          },
                          style: { width: "250px" }
                        })
                      ]
                    })
                  ]
                }),
                mode === 1 /* FileSelection */ && selectedFile && !smartCropMode && /* @__PURE__ */ jsx_runtime21.jsx(Group, {
                  gap: "md",
                  children: /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                    variant: "outline",
                    size: "sm",
                    onClick: handleEnterSmartCropMode,
                    children: "Copy Smart Crop"
                  })
                }),
                smartCropMode && /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                  gap: "md",
                  children: [
                    /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                      variant: "filled",
                      size: "sm",
                      disabled: targetSelectedFiles.size === 0,
                      onClick: handleCopyVisionData,
                      children: "Paste"
                    }),
                    /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                      variant: "outline",
                      size: "sm",
                      onClick: handleExitSmartCropMode,
                      children: "Cancel"
                    })
                  ]
                }),
                mode === 0 /* FolderSelection */ && persistentSelections.size > 0 && /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                  justify: "space-between",
                  children: [
                    /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                      variant: "default",
                      size: "sm",
                      onClick: clearAllFolderSelections,
                      children: "Cancel"
                    }),
                    /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                      gap: "md",
                      children: [
                        currentPath !== "/" && /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                          variant: "outline",
                          size: "sm",
                          onClick: toggleCurrentFolderSelection,
                          children: persistentSelections.has(currentPath) ? "Remove Current Folder" : "Add Current Folder"
                        }),
                        /* @__PURE__ */ jsx_runtime21.jsxs(Button, {
                          size: "sm",
                          onClick: handleSelection,
                          disabled: persistentSelections.size === 0,
                          children: [
                            "Select (",
                            persistentSelections.size,
                            ")"
                          ]
                        })
                      ]
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime21.jsx("div", {
                  style: { flex: 1, minHeight: "500px" },
                  children: folders.length === 0 && isLoadingFolders ? /* @__PURE__ */ jsx_runtime21.jsx(Center, {
                    h: 200,
                    children: /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
                      align: "center",
                      gap: "md",
                      children: [
                        /* @__PURE__ */ jsx_runtime21.jsx(Loader, {
                          size: "lg"
                        }),
                        /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                          c: "dimmed",
                          children: "Loading folders..."
                        })
                      ]
                    })
                  }) : folders.length === 0 && files.length === 0 && !isLoadingFolders ? /* @__PURE__ */ jsx_runtime21.jsx(Center, {
                    h: 200,
                    children: /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                      c: "dimmed",
                      children: mode === 0 /* FolderSelection */ ? "No folders found" : "No folders or files found"
                    })
                  }) : displayMode === "list" ? /* @__PURE__ */ jsx_runtime21.jsxs("div", {
                    style: { height: "800px", minHeight: "500px" },
                    children: [
                      /* @__PURE__ */ jsx_runtime21.jsx(FixedSizeList, {
                        height: 800,
                        width: "100%",
                        itemCount: folders.length + files.length,
                        itemSize,
                        onItemsRendered: handleItemsRendered,
                        children: ListItem2
                      }),
                      isLoadingMore && /* @__PURE__ */ jsx_runtime21.jsx(Card, {
                        shadow: "sm",
                        padding: "md",
                        radius: "md",
                        style: { opacity: 0.7, margin: "2px" },
                        children: /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
                          gap: "md",
                          align: "center",
                          children: [
                            /* @__PURE__ */ jsx_runtime21.jsx(Loader, {
                              size: "sm"
                            }),
                            /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                              size: "sm",
                              c: "dimmed",
                              children: "Loading more..."
                            })
                          ]
                        })
                      })
                    ]
                  }) : renderGridView()
                }),
                mode === 0 /* FolderSelection */ && persistentSelections.size > 0 && /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                      size: "sm",
                      fw: 500,
                      children: "Selected folders:"
                    }),
                    /* @__PURE__ */ jsx_runtime21.jsx(ScrollArea, {
                      h: 80,
                      children: /* @__PURE__ */ jsx_runtime21.jsx(Stack, {
                        gap: "xs",
                        children: Array.from(persistentSelections).map((path) => /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                          size: "xs",
                          c: "dimmed",
                          children: path
                        }, path))
                      })
                    })
                  ]
                }),
                mode === 1 /* FileSelection */ && selectedFile && /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                      size: "sm",
                      fw: 500,
                      children: "Selected file:"
                    }),
                    /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                      size: "xs",
                      c: "dimmed",
                      children: selectedFile
                    })
                  ]
                })
              ]
            })
          ]
        })
      }),
      /* @__PURE__ */ jsx_runtime21.jsx(Modal, {
        opened: showTaskModal,
        onClose: () => {
          const allComplete = copyTasks.every((task) => task.status === "complete" || task.status === "error" || task.status === "info");
          if (allComplete) {
            setShowTaskModal(false);
            setCopyTasks([]);
            handleExitSmartCropMode();
          }
        },
        title: "Copying Vision Data",
        size: "lg",
        closeOnClickOutside: false,
        closeOnEscape: false,
        children: /* @__PURE__ */ jsx_runtime21.jsx(DownloadTasksScreen, {
          downloadFiles: [],
          tasks: copyTasks,
          uploadTasks: [],
          onClose: () => {
            setShowTaskModal(false);
            setCopyTasks([]);
            handleExitSmartCropMode();
          }
        })
      }),
      /* @__PURE__ */ jsx_runtime21.jsx(Drawer, {
        opened: isSettingsDrawerOpen,
        onClose: handleCancelSettings,
        title: "Image Browser Settings",
        position: "right",
        size: "md",
        padding: "md",
        children: /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
          gap: "lg",
          children: [
            /* @__PURE__ */ jsx_runtime21.jsxs(Stack, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime21.jsx(Text, {
                  size: "sm",
                  fw: 500,
                  children: "File and Folder Icon Size"
                }),
                /* @__PURE__ */ jsx_runtime21.jsx(Slider, {
                  value: tempSettings.iconSize,
                  onChange: (value) => setTempSettings({ ...tempSettings, iconSize: value }),
                  min: 24,
                  max: 192,
                  step: 24,
                  marks: [
                    { value: 24, label: "sm" },
                    { value: 48, label: "md" },
                    { value: 96, label: "lg" },
                    { value: 192, label: "xl" }
                  ],
                  style: { marginTop: "1rem", marginBottom: "1rem" }
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime21.jsxs(Group, {
              justify: "flex-end",
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                  variant: "outline",
                  onClick: handleCancelSettings,
                  children: "Cancel"
                }),
                /* @__PURE__ */ jsx_runtime21.jsx(Button, {
                  onClick: handleSaveSettings,
                  children: "Save"
                })
              ]
            })
          ]
        })
      })
    ]
  });
}

// src/components/ConnectorSelectionModal.tsx
var import_react269 = __toESM(require_react(), 1);
var jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function ConnectorSelectionModal({
  opened,
  onClose,
  connectors,
  smartCropsConnectorName,
  onSelect
}) {
  const [selectedConnectorId, setSelectedConnectorId] = import_react269.useState("");
  import_react269.useEffect(() => {
    if (opened && smartCropsConnectorName) {
      const matchingConnector = connectors.find((connector) => connector.name === smartCropsConnectorName);
      if (matchingConnector) {
        setSelectedConnectorId(matchingConnector.id);
      }
    }
  }, [opened, smartCropsConnectorName, connectors]);
  import_react269.useEffect(() => {
    if (!opened) {
      setSelectedConnectorId("");
    }
  }, [opened]);
  const handleContinue = () => {
    if (selectedConnectorId) {
      onSelect(selectedConnectorId);
      onClose();
    }
  };
  const handleClose = () => {
    setSelectedConnectorId("");
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime22.jsx(Modal, {
    opened,
    onClose: handleClose,
    title: "Select Connector for Smart Crops",
    centered: true,
    size: "md",
    styles: {
      content: {
        minHeight: "300px"
      },
      body: {
        padding: "2rem"
      },
      header: {
        padding: "1.5rem 2rem 1rem 2rem"
      },
      title: {
        fontSize: "1.5rem",
        fontWeight: 600
      }
    },
    children: /* @__PURE__ */ jsx_runtime22.jsxs(Stack, {
      gap: "xl",
      children: [
        /* @__PURE__ */ jsx_runtime22.jsx(Text, {
          size: "md",
          children: "Select the connector where you want to upload the smart crops data:"
        }),
        /* @__PURE__ */ jsx_runtime22.jsx(Select, {
          label: "Connector",
          placeholder: "Choose a connector",
          data: connectors.map((connector) => ({
            value: connector.id,
            label: connector.name
          })),
          value: selectedConnectorId,
          onChange: (value) => setSelectedConnectorId(value || ""),
          searchable: true,
          required: true
        }),
        /* @__PURE__ */ jsx_runtime22.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime22.jsx(Button, {
              variant: "outline",
              onClick: handleClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime22.jsx(Button, {
              onClick: handleContinue,
              disabled: !selectedConnectorId,
              color: "blue",
              children: "Continue"
            })
          ]
        })
      ]
    })
  });
}

// src/components/DownloadModal/ReplaceConnectorsModal.tsx
var import_react270 = __toESM(require_react(), 1);
var jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
function ReplaceConnectorsModal({
  opened,
  onClose,
  connectorsToReplace,
  availableConnectors,
  onReplace
}) {
  const [replacements, setReplacements] = import_react270.useState({});
  const [replacementMap, setReplacementMap] = import_react270.useState(new Map);
  import_react270.useEffect(() => {
    if (opened && connectorsToReplace.length > 0) {
      const connectorsSources = new Map;
      for (const connector of connectorsToReplace) {
        connectorsSources.set(connector.source.id, connector.name);
      }
      const newReplacementMap = new Map;
      for (const [sourceId, name] of connectorsSources) {
        const matchingConnector = availableConnectors.find((connector) => connector.name === name);
        if (matchingConnector) {
          newReplacementMap.set(sourceId, {
            name,
            replacementId: matchingConnector.id
          });
        } else {
          newReplacementMap.set(sourceId, { name, replacementId: null });
        }
      }
      setReplacementMap(newReplacementMap);
    }
  }, [opened, connectorsToReplace, availableConnectors]);
  import_react270.useEffect(() => {
    if (!opened) {
      setReplacements({});
      setReplacementMap(new Map);
    }
  }, [opened]);
  const allSelected = Array.from(replacementMap.values()).every((connector) => connector.replacementId !== null);
  const handleReplacementChange = (connectorId, name, replacementId) => {
    setReplacementMap((prev2) => {
      const updated = new Map(prev2);
      if (replacementId) {
        updated.set(connectorId, { name, replacementId });
      } else {
        updated.delete(connectorId);
      }
      return updated;
    });
  };
  const handleContinue = () => {
    const newReplacementMap = new Map;
    for (const [sourceId, connector] of replacementMap.entries()) {
      if (connector.replacementId) {
        newReplacementMap.set(sourceId, connector.replacementId);
      }
    }
    onReplace(newReplacementMap);
    onClose();
  };
  const handleClose = () => {
    setReplacements({});
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime23.jsx(Modal, {
    opened,
    onClose: handleClose,
    title: "Replace Connectors",
    centered: true,
    size: "lg",
    styles: {
      content: {
        minHeight: "400px"
      },
      body: {
        padding: "2rem"
      },
      header: {
        padding: "1.5rem 2rem 1rem 2rem"
      },
      title: {
        fontSize: "1.5rem",
        fontWeight: 600
      }
    },
    children: /* @__PURE__ */ jsx_runtime23.jsxs(Stack, {
      gap: "xl",
      children: [
        /* @__PURE__ */ jsx_runtime23.jsx(Text, {
          size: "md",
          children: "The following connectors from the document need to be replaced with available connectors:"
        }),
        /* @__PURE__ */ jsx_runtime23.jsxs(Table, {
          children: [
            /* @__PURE__ */ jsx_runtime23.jsx(Table.Thead, {
              children: /* @__PURE__ */ jsx_runtime23.jsxs(Table.Tr, {
                children: [
                  /* @__PURE__ */ jsx_runtime23.jsx(Table.Th, {
                    children: "Document Connector"
                  }),
                  /* @__PURE__ */ jsx_runtime23.jsx(Table.Th, {
                    children: "Original ID"
                  }),
                  /* @__PURE__ */ jsx_runtime23.jsx(Table.Th, {
                    children: "Replace With"
                  })
                ]
              })
            }),
            /* @__PURE__ */ jsx_runtime23.jsx(Table.Tbody, {
              children: Array.from(replacementMap.entries()).map(([connectorId, connector]) => /* @__PURE__ */ jsx_runtime23.jsxs(Table.Tr, {
                children: [
                  /* @__PURE__ */ jsx_runtime23.jsx(Table.Td, {
                    children: connector.name
                  }),
                  /* @__PURE__ */ jsx_runtime23.jsx(Table.Td, {
                    style: { fontFamily: "monospace", fontSize: "0.8rem" },
                    children: connectorId
                  }),
                  /* @__PURE__ */ jsx_runtime23.jsx(Table.Td, {
                    children: /* @__PURE__ */ jsx_runtime23.jsx(Select, {
                      data: availableConnectors.map((c2) => ({
                        value: c2.id,
                        label: c2.name
                      })),
                      placeholder: "Select a connector",
                      value: connector.replacementId || null,
                      onChange: (value) => handleReplacementChange(connectorId, connector.name, value),
                      searchable: true,
                      required: true
                    })
                  })
                ]
              }, connectorId))
            })
          ]
        }),
        /* @__PURE__ */ jsx_runtime23.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime23.jsx(Button, {
              variant: "outline",
              onClick: handleClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime23.jsx(Button, {
              onClick: handleContinue,
              disabled: !allSelected,
              color: "blue",
              children: "Continue"
            })
          ]
        })
      ]
    })
  });
}

// src/components/DownloadModal/DefaultSettingsModal.tsx
var import_react271 = __toESM(require_react(), 1);
var jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
function DefaultSettingsModal({
  opened,
  onClose
}) {
  const raiseError2 = appStore((store) => store.raiseError);
  const [error40, setError] = import_react271.useState(null);
  const [isLoading, setIsLoading] = import_react271.useState(false);
  const [isSaving, setIsSaving] = import_react271.useState(false);
  const [folderBrowserOpened, setFolderBrowserOpened] = import_react271.useState(false);
  const [defaultSettings, setDefaultSettings] = import_react271.useState({
    includeFonts: true,
    includeGrafxMedia: false,
    includeSmartCrops: false,
    removeToolbarData: false,
    removeUnusedConnectors: false,
    useOriginalFontFileNames: false,
    addTimestamp: true
  });
  import_react271.useEffect(() => {
    if (opened) {
      loadDefaultSettings();
    }
  }, [opened]);
  const loadDefaultSettings = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const toolbarDataResult = await loadToolbarDataFromDoc();
      if (toolbarDataResult.isOk()) {
        const toolbarData = toolbarDataResult.value;
        if (toolbarData.defaultDownloadSettings) {
          setDefaultSettings(toolbarData.defaultDownloadSettings);
        }
      } else {
        console.warn("Failed to load toolbar data, using defaults");
      }
    } catch (error41) {
      console.warn("Error loading default settings:", error41);
    } finally {
      setIsLoading(false);
    }
  };
  const handleSettingChange = (setting, value) => {
    setDefaultSettings((prev2) => ({
      ...prev2,
      [setting]: value
    }));
    if (setting === "includeSmartCrops" && !value) {
      setDefaultSettings((prev2) => ({
        ...prev2,
        smartCropsConnectorSelection: undefined
      }));
    }
  };
  const handleFolderSelection = (selection) => {
    setDefaultSettings((prev2) => ({
      ...prev2,
      smartCropsConnectorSelection: selection || undefined
    }));
    setFolderBrowserOpened(false);
  };
  const handleRemoveFolderPath = (pathToRemove) => {
    setDefaultSettings((prev2) => {
      if (!prev2.smartCropsConnectorSelection)
        return prev2;
      const updatedFolders = prev2.smartCropsConnectorSelection.selectedFolders.filter((path) => path !== pathToRemove);
      if (updatedFolders.length === 0) {
        return {
          ...prev2,
          smartCropsConnectorSelection: undefined
        };
      }
      return {
        ...prev2,
        smartCropsConnectorSelection: {
          ...prev2.smartCropsConnectorSelection,
          selectedFolders: updatedFolders
        }
      };
    });
  };
  const handleSave = async () => {
    setIsSaving(true);
    setError(null);
    try {
      const saveResult = await saveToolbarDataToDoc("defaultDownloadSettings", defaultSettings);
      if (saveResult.isOk()) {
        onClose();
      } else {
        setError(saveResult.error?.message || "Failed to save default settings");
      }
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      setError(errorMessage);
      raiseError2(error41 instanceof Error ? error41 : new Error(errorMessage));
    } finally {
      setIsSaving(false);
    }
  };
  const handleClose = () => {
    setError(null);
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime24.jsxs(jsx_runtime24.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime24.jsx(Modal, {
        opened,
        onClose: handleClose,
        title: "Default Download Settings for Template",
        size: "lg",
        styles: {
          title: {
            fontSize: "1.5rem",
            fontWeight: 600
          }
        },
        children: /* @__PURE__ */ jsx_runtime24.jsxs(Stack, {
          gap: "xl",
          children: [
            /* @__PURE__ */ jsx_runtime24.jsx(Text, {
              size: "md",
              style: { textAlign: "center", marginBottom: "1rem" },
              children: "Configure default settings for downloads with this template. These settings will be used as defaults when you start a new download with this template."
            }),
            error40 && /* @__PURE__ */ jsx_runtime24.jsx(Alert, {
              icon: /* @__PURE__ */ jsx_runtime24.jsx(IconAlertCircle, {
                size: "1rem"
              }),
              title: "Error",
              color: "red",
              style: { marginBottom: "1rem" },
              children: error40
            }),
            isLoading ? /* @__PURE__ */ jsx_runtime24.jsx(Text, {
              size: "sm",
              c: "dimmed",
              style: { textAlign: "center" },
              children: "Loading current settings..."
            }) : /* @__PURE__ */ jsx_runtime24.jsxs(Stack, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                  label: "Include fonts",
                  checked: defaultSettings.includeFonts,
                  onChange: (event) => handleSettingChange("includeFonts", event.currentTarget.checked)
                }),
                defaultSettings.includeFonts && /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                  label: "Use original font file names (Default: unchecked because duplicate font names will cause false positives of missing files during upload)",
                  checked: defaultSettings.useOriginalFontFileNames,
                  onChange: (event) => handleSettingChange("useOriginalFontFileNames", event.currentTarget.checked),
                  style: { marginLeft: "40px" }
                }),
                /* @__PURE__ */ jsx_runtime24.jsxs(Group, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                      label: "Include GraFx Media",
                      checked: defaultSettings.includeGrafxMedia,
                      onChange: (event) => handleSettingChange("includeGrafxMedia", event.currentTarget.checked)
                    }),
                    defaultSettings.includeGrafxMedia && /* @__PURE__ */ jsx_runtime24.jsx(Text, {
                      size: "sm",
                      c: "red",
                      children: "Not implemented"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime24.jsxs(Stack, {
                  gap: "xs",
                  children: [
                    /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                      label: "Include smart crops",
                      checked: defaultSettings.includeSmartCrops,
                      onChange: (event) => handleSettingChange("includeSmartCrops", event.currentTarget.checked)
                    }),
                    defaultSettings.includeSmartCrops && /* @__PURE__ */ jsx_runtime24.jsxs(Stack, {
                      gap: "xs",
                      style: { marginLeft: "1.5rem" },
                      children: [
                        /* @__PURE__ */ jsx_runtime24.jsx(Button, {
                          variant: "outline",
                          size: "sm",
                          style: { width: "fit-content" },
                          onClick: () => setFolderBrowserOpened(true),
                          children: "Add folders"
                        }),
                        defaultSettings.smartCropsConnectorSelection && defaultSettings.smartCropsConnectorSelection.selectedFolders.length > 0 && /* @__PURE__ */ jsx_runtime24.jsxs(Stack, {
                          gap: "xs",
                          children: [
                            /* @__PURE__ */ jsx_runtime24.jsx(Text, {
                              size: "xs",
                              fw: 500,
                              children: "Selected folders:"
                            }),
                            defaultSettings.smartCropsConnectorSelection.selectedFolders.map((path, index4) => /* @__PURE__ */ jsx_runtime24.jsxs(Group, {
                              gap: "xs",
                              style: { marginLeft: "0.5rem" },
                              children: [
                                /* @__PURE__ */ jsx_runtime24.jsx(ActionIcon, {
                                  size: "xs",
                                  variant: "subtle",
                                  color: "red",
                                  onClick: () => handleRemoveFolderPath(path),
                                  children: /* @__PURE__ */ jsx_runtime24.jsx(IconCircleX, {
                                    size: 12
                                  })
                                }),
                                /* @__PURE__ */ jsx_runtime24.jsx(Text, {
                                  size: "xs",
                                  c: "dimmed",
                                  style: { flex: 1 },
                                  children: path
                                })
                              ]
                            }, index4))
                          ]
                        })
                      ]
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                  label: "Add timestamp to folder name",
                  checked: defaultSettings.addTimestamp,
                  onChange: (event) => handleSettingChange("addTimestamp", event.currentTarget.checked)
                }),
                /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                  label: "Remove Toolbar data",
                  checked: defaultSettings.removeToolbarData,
                  onChange: (event) => handleSettingChange("removeToolbarData", event.currentTarget.checked)
                }),
                /* @__PURE__ */ jsx_runtime24.jsx(Title, {
                  order: 5,
                  children: "Experimental"
                }),
                /* @__PURE__ */ jsx_runtime24.jsx(Tooltip, {
                  label: "Experimental: May cause issues with your document",
                  position: "right",
                  withArrow: true,
                  children: /* @__PURE__ */ jsx_runtime24.jsx(Checkbox, {
                    label: "Remove unused Connectors",
                    color: "red",
                    checked: defaultSettings.removeUnusedConnectors,
                    onChange: (event) => handleSettingChange("removeUnusedConnectors", event.currentTarget.checked)
                  })
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime24.jsxs(Group, {
              justify: "space-between",
              mt: "xl",
              children: [
                /* @__PURE__ */ jsx_runtime24.jsx(Button, {
                  variant: "default",
                  onClick: handleClose,
                  disabled: isSaving,
                  children: "Cancel"
                }),
                /* @__PURE__ */ jsx_runtime24.jsx(Button, {
                  onClick: handleSave,
                  color: "blue",
                  loading: isSaving,
                  disabled: isLoading,
                  children: "Save Default Settings"
                })
              ]
            })
          ]
        })
      }),
      /* @__PURE__ */ jsx_runtime24.jsx(ImageBrowser, {
        opened: folderBrowserOpened,
        mode: 0 /* FolderSelection */,
        initialSelection: defaultSettings.smartCropsConnectorSelection,
        onClose: handleFolderSelection
      })
    ]
  });
}

// src/components/DownloadModal/InitialScreen.tsx
var jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function InitialScreen({
  error: error40,
  onDownload,
  onUpload,
  onJsonDownload,
  onJsonUpload,
  onDefaultSettings
}) {
  return /* @__PURE__ */ jsx_runtime25.jsxs(Stack, {
    gap: "xl",
    children: [
      /* @__PURE__ */ jsx_runtime25.jsx(Text, {
        size: "md",
        style: { textAlign: "center", marginBottom: "1rem" },
        children: "Choose an action for document management."
      }),
      error40 && /* @__PURE__ */ jsx_runtime25.jsx(Alert, {
        icon: /* @__PURE__ */ jsx_runtime25.jsx(IconAlertCircle, {
          size: "1rem"
        }),
        title: "Error",
        color: "red",
        style: { marginBottom: "1rem" },
        children: error40
      }),
      /* @__PURE__ */ jsx_runtime25.jsxs(SimpleGrid, {
        cols: 2,
        spacing: "xl",
        style: { marginTop: "1rem" },
        children: [
          /* @__PURE__ */ jsx_runtime25.jsx(Button, {
            onClick: onDownload,
            color: "blue",
            fullWidth: true,
            size: "lg",
            style: {
              height: "80px",
              fontSize: "1rem",
              fontWeight: 500
            },
            children: /* @__PURE__ */ jsx_runtime25.jsxs(Group, {
              gap: "md",
              style: { flexDirection: "column" },
              children: [
                /* @__PURE__ */ jsx_runtime25.jsx(IconDownload, {
                  size: 28
                }),
                /* @__PURE__ */ jsx_runtime25.jsx("span", {
                  children: "Download"
                })
              ]
            })
          }),
          /* @__PURE__ */ jsx_runtime25.jsx(Button, {
            onClick: onUpload,
            color: "green",
            fullWidth: true,
            size: "lg",
            style: {
              height: "80px",
              fontSize: "1rem",
              fontWeight: 500
            },
            children: /* @__PURE__ */ jsx_runtime25.jsxs(Group, {
              gap: "md",
              style: { flexDirection: "column" },
              children: [
                /* @__PURE__ */ jsx_runtime25.jsx(IconUpload, {
                  size: 28
                }),
                /* @__PURE__ */ jsx_runtime25.jsx("span", {
                  children: "Upload"
                })
              ]
            })
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime25.jsxs(Stack, {
        gap: "xs",
        mt: "md",
        children: [
          /* @__PURE__ */ jsx_runtime25.jsx(Text, {
            size: "sm",
            fw: 500,
            c: "dimmed",
            children: "Quick Actions:"
          }),
          /* @__PURE__ */ jsx_runtime25.jsxs(Group, {
            justify: "space-between",
            children: [
              /* @__PURE__ */ jsx_runtime25.jsxs(Group, {
                justify: "flex-start",
                children: [
                  /* @__PURE__ */ jsx_runtime25.jsx(Tooltip, {
                    label: "Download document JSON",
                    children: /* @__PURE__ */ jsx_runtime25.jsx(ActionIcon, {
                      onClick: onJsonDownload,
                      color: "gray",
                      variant: "subtle",
                      size: "lg",
                      children: /* @__PURE__ */ jsx_runtime25.jsx(IconFileDownload, {
                        size: 20
                      })
                    })
                  }),
                  /* @__PURE__ */ jsx_runtime25.jsx(Tooltip, {
                    label: "Upload document JSON",
                    children: /* @__PURE__ */ jsx_runtime25.jsx(ActionIcon, {
                      onClick: onJsonUpload,
                      color: "gray",
                      variant: "subtle",
                      size: "lg",
                      children: /* @__PURE__ */ jsx_runtime25.jsx(IconFileUpload, {
                        size: 20
                      })
                    })
                  })
                ]
              }),
              /* @__PURE__ */ jsx_runtime25.jsx(Tooltip, {
                label: "Default Settings",
                children: /* @__PURE__ */ jsx_runtime25.jsx(ActionIcon, {
                  onClick: onDefaultSettings,
                  color: "gray",
                  variant: "subtle",
                  size: "lg",
                  children: /* @__PURE__ */ jsx_runtime25.jsx(IconSettings, {
                    size: 20
                  })
                })
              })
            ]
          })
        ]
      })
    ]
  });
}

// src/components/DownloadModal/DownloadSettingsScreen.tsx
var jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
function DownloadSettingsScreen({
  error: error40,
  folderName,
  folderNameError,
  downloadSettings,
  fontStylesCount,
  connectorSelection,
  onFolderNameChange,
  onSettingChange,
  onAddFolder,
  onRemoveFolderPath,
  onBack,
  onDownload
}) {
  return /* @__PURE__ */ jsx_runtime26.jsxs(Stack, {
    gap: "xl",
    children: [
      /* @__PURE__ */ jsx_runtime26.jsx(Text, {
        size: "md",
        style: { textAlign: "center", marginBottom: "1rem" },
        children: "Download Settings"
      }),
      error40 && /* @__PURE__ */ jsx_runtime26.jsx(Alert, {
        icon: /* @__PURE__ */ jsx_runtime26.jsx(IconAlertCircle, {
          size: "1rem"
        }),
        title: "Error",
        color: "red",
        style: { marginBottom: "1rem" },
        children: error40
      }),
      /* @__PURE__ */ jsx_runtime26.jsxs(Stack, {
        gap: "md",
        children: [
          /* @__PURE__ */ jsx_runtime26.jsx(TextInput, {
            label: "Folder Name",
            value: folderName,
            onChange: (event) => onFolderNameChange(event.currentTarget.value),
            error: folderNameError,
            placeholder: "Enter folder name",
            description: "Only letters, numbers, hyphens, and underscores are allowed"
          }),
          /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
            label: "Add Timestamp",
            checked: downloadSettings.addTimestamp,
            onChange: (event) => onSettingChange("addTimestamp", event.currentTarget.checked)
          }),
          /* @__PURE__ */ jsx_runtime26.jsxs(Stack, {
            gap: "xs",
            children: [
              /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
                label: `Include fonts${downloadSettings.includeFonts && fontStylesCount > 0 ? ` (${fontStylesCount} styles)` : ""}`,
                checked: downloadSettings.includeFonts,
                onChange: (event) => onSettingChange("includeFonts", event.currentTarget.checked)
              }),
              downloadSettings.includeFonts && /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
                label: "Use original font file names (Default: unchecked because duplicate font names will cause false positives of missing files during upload)",
                checked: downloadSettings.useOriginalFontFileNames,
                onChange: (event) => onSettingChange("useOriginalFontFileNames", event.currentTarget.checked),
                style: { marginLeft: "40px" }
              })
            ]
          }),
          /* @__PURE__ */ jsx_runtime26.jsxs(Group, {
            gap: "xs",
            children: [
              /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
                label: "Include GraFx Media",
                checked: downloadSettings.includeGrafxMedia,
                onChange: (event) => onSettingChange("includeGrafxMedia", event.currentTarget.checked)
              }),
              downloadSettings.includeGrafxMedia && /* @__PURE__ */ jsx_runtime26.jsx(Text, {
                size: "sm",
                c: "red",
                children: "Not implemented"
              })
            ]
          }),
          /* @__PURE__ */ jsx_runtime26.jsxs(Stack, {
            gap: "xs",
            children: [
              /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
                label: "Include smart crops",
                checked: downloadSettings.includeSmartCrops,
                onChange: (event) => onSettingChange("includeSmartCrops", event.currentTarget.checked)
              }),
              downloadSettings.includeSmartCrops && /* @__PURE__ */ jsx_runtime26.jsxs(Stack, {
                gap: "xs",
                style: { marginLeft: "1.5rem" },
                children: [
                  /* @__PURE__ */ jsx_runtime26.jsx(Button, {
                    variant: "outline",
                    size: "sm",
                    style: { width: "fit-content" },
                    onClick: onAddFolder,
                    children: "Add folders"
                  }),
                  connectorSelection && connectorSelection.selectedFolders.length > 0 && /* @__PURE__ */ jsx_runtime26.jsxs(Stack, {
                    gap: "xs",
                    children: [
                      /* @__PURE__ */ jsx_runtime26.jsx(Text, {
                        size: "xs",
                        fw: 500,
                        children: "Selected folders:"
                      }),
                      connectorSelection.selectedFolders.map((path, index4) => /* @__PURE__ */ jsx_runtime26.jsxs(Group, {
                        gap: "xs",
                        style: { marginLeft: "0.5rem" },
                        children: [
                          /* @__PURE__ */ jsx_runtime26.jsx(ActionIcon, {
                            size: "xs",
                            variant: "subtle",
                            color: "red",
                            onClick: () => onRemoveFolderPath(path),
                            children: /* @__PURE__ */ jsx_runtime26.jsx(IconCircleX, {
                              size: 12
                            })
                          }),
                          /* @__PURE__ */ jsx_runtime26.jsx(Text, {
                            size: "xs",
                            c: "dimmed",
                            style: { flex: 1 },
                            children: path
                          })
                        ]
                      }, index4))
                    ]
                  })
                ]
              })
            ]
          }),
          /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
            label: "Remove Toolbar data",
            checked: downloadSettings.removeToolbarData,
            onChange: (event) => onSettingChange("removeToolbarData", event.currentTarget.checked)
          }),
          /* @__PURE__ */ jsx_runtime26.jsx(Title, {
            order: 5,
            children: "Experimental"
          }),
          /* @__PURE__ */ jsx_runtime26.jsx(Tooltip, {
            label: "Experimental: May cause issues with your document",
            position: "right",
            withArrow: true,
            children: /* @__PURE__ */ jsx_runtime26.jsx(Checkbox, {
              label: "Remove unused Connectors",
              color: "red",
              checked: downloadSettings.removeUnusedConnectors,
              onChange: (event) => onSettingChange("removeUnusedConnectors", event.currentTarget.checked)
            })
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime26.jsxs(Group, {
        justify: "space-between",
        mt: "xl",
        children: [
          /* @__PURE__ */ jsx_runtime26.jsx(Button, {
            variant: "default",
            onClick: onBack,
            children: "Back"
          }),
          /* @__PURE__ */ jsx_runtime26.jsx(Button, {
            onClick: onDownload,
            color: "blue",
            children: "Download"
          })
        ]
      })
    ]
  });
}

// src/components/DownloadModal/UploadTasksScreen.tsx
var import_react272 = __toESM(require_react(), 1);
var jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
function UploadTasksScreen({
  error: error40,
  onBack,
  onContinue
}) {
  const [dontShowAgain, setDontShowAgain] = import_react272.useState(false);
  const handleContinue = () => {
    if (dontShowAgain) {
      localStorage.setItem("tempSlowUploadInstructions", "true");
    }
    onContinue();
  };
  return /* @__PURE__ */ jsx_runtime27.jsxs(Stack, {
    gap: "xl",
    children: [
      /* @__PURE__ */ jsx_runtime27.jsx(Text, {
        size: "md",
        style: { textAlign: "center", marginBottom: "1rem" },
        children: "Upload Instructions"
      }),
      error40 && /* @__PURE__ */ jsx_runtime27.jsx(Alert, {
        icon: /* @__PURE__ */ jsx_runtime27.jsx(IconAlertCircle, {
          size: "1rem"
        }),
        title: "Error",
        color: "red",
        style: { marginBottom: "1rem" },
        children: error40
      }),
      /* @__PURE__ */ jsx_runtime27.jsx(Text, {
        size: "md",
        style: { textAlign: "center" },
        children: "Please choose the folder that contains your package.json."
      }),
      /* @__PURE__ */ jsx_runtime27.jsx(Checkbox, {
        label: "Don't show this message again",
        checked: dontShowAgain,
        onChange: (event) => setDontShowAgain(event.currentTarget.checked)
      }),
      /* @__PURE__ */ jsx_runtime27.jsxs(Group, {
        justify: "space-between",
        mt: "xl",
        children: [
          /* @__PURE__ */ jsx_runtime27.jsx(Button, {
            variant: "default",
            onClick: onBack,
            children: "Back"
          }),
          /* @__PURE__ */ jsx_runtime27.jsx(Button, {
            onClick: handleContinue,
            color: "green",
            children: "Continue"
          })
        ]
      })
    ]
  });
}

// src/components/DownloadModal/types.ts
class InvalidPackageJsonError extends Error {
  _tag = "InvalidPackageJsonError";
  constructor(message) {
    super(message);
    this.name = "InvalidPackageJsonError";
  }
}

class NoPackageJsonError extends Error {
  _tag = "NoPackageJsonError";
  constructor(message) {
    super(message);
    this.name = "NoPackageJsonError";
  }
}

class MissingDocumentFileError extends Error {
  _tag = "MissingDocumentFileError";
  constructor(message) {
    super(message);
    this.name = "MissingDocumentFileError";
  }
}

class InvalidDocumentJsonError extends Error {
  _tag = "InvalidDocumentJsonError";
  constructor(message) {
    super(message);
    this.name = "InvalidDocumentJsonError";
  }
}

class MissingFontFileError extends Error {
  _tag = "MissingFontFileError";
  constructor(message) {
    super(message);
    this.name = "MissingFontFileError";
  }
}

class FontAlreadyExistsError extends Error {
  _tag = "FontAlreadyExistsError";
  constructor(message) {
    super(message);
    this.name = "FontAlreadyExistsError";
  }
}

class MissingSmartCropsFileError extends Error {
  _tag = "MissingSmartCropsFileError";
  constructor(message) {
    super(message);
    this.name = "MissingSmartCropsFileError";
  }
}

class InvalidSmartCropsJsonError extends Error {
  _tag = "InvalidSmartCropsJsonError";
  constructor(message) {
    super(message);
    this.name = "InvalidSmartCropsJsonError";
  }
}

class FailedToFetchConnectorsError extends Error {
  _tag = "FailedToFetchConnectorsError";
  constructor(message) {
    super(message);
    this.name = "FailedToFetchConnectorsError";
  }
}

// src/components/DownloadModal/utils.ts
init_dist();
var FontDataSchema = exports_external.object({
  filePath: exports_external.string(),
  details: exports_external.object({
    id: exports_external.string(),
    name: exports_external.string(),
    familyId: exports_external.string(),
    familyName: exports_external.string(),
    dateCreated: exports_external.string(),
    extension: exports_external.string(),
    fileName: exports_external.string(),
    fileSize: exports_external.number()
  })
});
var DocumentSchema = exports_external.object({
  id: exports_external.string(),
  name: exports_external.string().nullable(),
  filePath: exports_external.string(),
  smartCrops: exports_external.object({
    filePath: exports_external.string()
  }).optional(),
  fonts: exports_external.array(FontDataSchema)
});
var StudioPackageSchema = exports_external.object({
  engineVersion: exports_external.string(),
  source: exports_external.string(),
  documents: exports_external.array(DocumentSchema)
});
function verifyStudioPackage(packageData) {
  try {
    const result = StudioPackageSchema.safeParse(packageData);
    if (result.success) {
      return Result.ok(result.data);
    } else {
      return Result.error(new InvalidPackageJsonError(`Invalid package.json structure: ${result.error.message}`));
    }
  } catch (error40) {
    return Result.error(new InvalidPackageJsonError(`Failed to parse package.json: ${error40 instanceof Error ? error40.message : String(error40)}`));
  }
}
async function loadFilesFromDirectory(directoryHandle) {
  try {
    const files = [];
    async function collectFiles(dirHandle, path = "") {
      for await (const [name, handle] of dirHandle.entries()) {
        const currentPath = path ? `${path}/${name}` : name;
        if (handle.kind === "file") {
          const fileHandle = handle;
          const file2 = await fileHandle.getFile();
          const fileWithPath = new File([file2], currentPath, {
            type: file2.type,
            lastModified: file2.lastModified
          });
          files.push(fileWithPath);
        } else if (handle.kind === "directory") {
          const subDirHandle = handle;
          await collectFiles(subDirHandle, currentPath);
        }
      }
    }
    await collectFiles(directoryHandle);
    const packageJsonFile = files.find((file2) => file2.name === "package.json");
    if (!packageJsonFile) {
      return Result.error(new NoPackageJsonError("package.json file not found in the selected directory"));
    }
    try {
      const packageJsonText = await packageJsonFile.text();
      const packageJsonData = JSON.parse(packageJsonText);
      const validationResult = verifyStudioPackage(packageJsonData);
      if (!validationResult.isOk()) {
        return Result.error(validationResult.error || new Error("Unknown validation error"));
      }
      const studioPackage = validationResult.value;
      for (const document2 of studioPackage.documents) {
        const documentFile = files.find((file2) => file2.name === document2.filePath);
        if (!documentFile) {
          return Result.error(new MissingDocumentFileError(`Document file not found: ${document2.filePath}`));
        }
        try {
          const documentText = await documentFile.text();
          JSON.parse(documentText);
        } catch (error40) {
          return Result.error(new InvalidDocumentJsonError(`Invalid JSON in document file ${document2.filePath}: ${error40 instanceof Error ? error40.message : String(error40)}`));
        }
      }
      for (const document2 of studioPackage.documents) {
        for (const font of document2.fonts) {
          const fontFile = files.find((file2) => file2.name === font.filePath);
          if (!fontFile) {
            return Result.error(new MissingFontFileError(`Font file not found: ${font.filePath}`));
          }
        }
      }
      return Result.ok(files);
    } catch (error40) {
      return Result.error(new InvalidPackageJsonError(`Failed to parse package.json: ${error40 instanceof Error ? error40.message : String(error40)}`));
    }
  } catch (error40) {
    return Result.error(new Error(`Failed to read directory: ${error40 instanceof Error ? error40.message : String(error40)}`));
  }
}
var sanitizeFolderName = (name) => {
  return name.replace(/[^a-zA-Z0-9\-_]/g, "");
};
var generateTimestamp = () => {
  const now3 = new Date;
  const isoString = now3.toISOString();
  const sanitizedFolderName = isoString.replace(/[-:.]/g, "_").replace("Z", "");
  return sanitizedFolderName;
};
var validateFolderName = (name) => {
  const illegalChars = name.match(/[^a-zA-Z0-9\-_]/g);
  if (illegalChars) {
    const uniqueChars = [...new Set(illegalChars)];
    return `Illegal characters: ${uniqueChars.join(", ")}`;
  }
  return "";
};
var getDocumentId = () => {
  const urlPath = window.location.href;
  const templateIdMatch = urlPath.match(/templates\/([\w-]+)/);
  return templateIdMatch ? templateIdMatch[1] : "document";
};

// src/components/DownloadModalNew.tsx
var jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
function DownloadModalNew({ opened, onClose }) {
  const fileInputRef = import_react273.useRef(null);
  const raiseError2 = appStore((store) => store.raiseError);
  const [modalState, setModalState] = import_react273.useState("initial");
  const [error40, setError] = import_react273.useState(null);
  const [downloadSettings, setDownloadSettings] = import_react273.useState({
    includeFonts: false,
    includeGrafxMedia: false,
    includeSmartCrops: false,
    removeToolbarData: false,
    removeUnusedConnectors: false,
    useOriginalFontFileNames: false,
    addTimestamp: false
  });
  const [folderName, setFolderName] = import_react273.useState("");
  const [folderNameError, setFolderNameError] = import_react273.useState("");
  const [downloadFiles, setDownloadFiles] = import_react273.useState([]);
  const [tasks, setTasks] = import_react273.useState([]);
  const [fontFamilies, setFontFamilies] = import_react273.useState(null);
  const [fontStylesCount, setFontStylesCount] = import_react273.useState(0);
  const [folderBrowserOpened, setFolderBrowserOpened] = import_react273.useState(false);
  const [connectorSelection, setConnectorSelection] = import_react273.useState(null);
  const [uploadTasks, setUploadTasks] = import_react273.useState([]);
  const [connectorSelectionModalOpened, setConnectorSelectionModalOpened] = import_react273.useState(false);
  const [replaceConnectorsModalOpened, setReplaceConnectorsModalOpened] = import_react273.useState(false);
  const [availableConnectors, setAvailableConnectors] = import_react273.useState([]);
  const [connectorsToReplace, setConnectorsToReplace] = import_react273.useState([]);
  const [selectedVisionConnector, setSelectedVisionConnector] = import_react273.useState("");
  const [smartCropsData, setSmartCropsData] = import_react273.useState(null);
  const [documentData, setDocumentData] = import_react273.useState(null);
  const [packageJsonTaskId, setPackageJsonTaskId] = import_react273.useState("");
  const [currentFiles, setCurrentFiles] = import_react273.useState([]);
  const [currentStudioPackage, setCurrentStudioPackage] = import_react273.useState(null);
  const [currentStudio, setCurrentStudio] = import_react273.useState(null);
  const [currentToken, setCurrentToken] = import_react273.useState("");
  const [currentBaseUrl, setCurrentBaseUrl] = import_react273.useState("");
  const [isDefaultSettingsModalOpen, setIsDefaultSettingsModalOpen] = import_react273.useState(false);
  import_react273.useEffect(() => {
    const messageListener = (event) => {
      if (event.source !== window)
        return;
      if (event.data.type === "DOWNLOAD_COMPLETE") {
        const { downloadId, success: success2, error: error41 } = event.data.data;
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === downloadId ? {
          ...f2,
          status: success2 ? "complete" : "error",
          error: error41 || undefined
        } : f2));
      }
    };
    window.addEventListener("message", messageListener);
    return () => {
      window.removeEventListener("message", messageListener);
    };
  }, []);
  import_react273.useEffect(() => {
    const fetchFontFamilies = async () => {
      if (!downloadSettings.includeFonts) {
        setFontFamilies(null);
        setFontStylesCount(0);
        return;
      }
      try {
        const studioResult = await getStudio();
        if (!studioResult.isOk()) {
          raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
          return;
        }
        const fontFamiliesResult = await getFontFamilies(studioResult.value);
        if (!fontFamiliesResult.isOk()) {
          raiseError2(new Error(fontFamiliesResult.error?.message || "Failed to get font families"));
          return;
        }
        const families = fontFamiliesResult.value;
        setFontFamilies(families);
        const totalStyles = families.reduce((total, family) => total + family.fontStyles.length, 0);
        setFontStylesCount(totalStyles);
      } catch (error41) {
        raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
      }
    };
    fetchFontFamilies();
  }, [downloadSettings.includeFonts, raiseError2]);
  const processDocumentForDownload = (documentData2, settings) => {
    let processedDocument = JSON.parse(JSON.stringify(documentData2));
    if (settings.removeToolbarData) {
      processedDocument = removeToolbarData(processedDocument);
    }
    if (settings.removeUnusedConnectors) {
      processedDocument = removeUnusedConnectors(processedDocument);
    }
    return processedDocument;
  };
  const removeToolbarData = (documentData2) => {
    if (documentData2.layouts && documentData2.layouts.length > 0 && documentData2.layouts[0].privateData && documentData2.layouts[0].privateData.toolbar) {
      const processedDocument = { ...documentData2 };
      processedDocument.layouts = [...documentData2.layouts];
      processedDocument.layouts[0] = {
        ...documentData2.layouts[0],
        privateData: { ...documentData2.layouts[0].privateData }
      };
      delete processedDocument.layouts[0].privateData.toolbar;
      return processedDocument;
    }
    return documentData2;
  };
  const removeUnusedConnectors = (documentData2) => {
    if (!documentData2.connectors || !Array.isArray(documentData2.connectors)) {
      return documentData2;
    }
    const grafxConnectors = documentData2.connectors.filter((connector) => connector.source && connector.source.source === "grafx" && connector.source.id != null);
    if (grafxConnectors.length === 0) {
      return documentData2;
    }
    const documentWithoutConnectors = { ...documentData2 };
    delete documentWithoutConnectors.connectors;
    const searchableJsonString = JSON.stringify(documentWithoutConnectors);
    const usedConnectorIds = new Set;
    for (const connector of grafxConnectors) {
      if (searchableJsonString.includes(connector.id)) {
        usedConnectorIds.add(connector.id);
      }
    }
    const processedDocument = { ...documentData2 };
    processedDocument.connectors = documentData2.connectors.filter((connector) => {
      if (!connector.source || connector.source.source !== "grafx" || connector.source.id == null) {
        return true;
      }
      return usedConnectorIds.has(connector.id);
    });
    return processedDocument;
  };
  const getDocumentName = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        return "document";
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      const urlPath = window.location.href;
      const templateIdMatch = urlPath.match(/templates\/([\w-]+)/);
      if (templateIdMatch && templateIdMatch[1]) {
        const templateId = templateIdMatch[1];
        try {
          const templateResponse = await fetch(`${baseUrl}templates/${templateId}`, {
            headers: {
              Authorization: `Bearer ${token2}`,
              "Content-Type": "application/json"
            }
          });
          if (templateResponse.ok) {
            const templateData = await templateResponse.json();
            if (templateData && templateData.data && templateData.data.name) {
              return templateData.data.name;
            }
          }
        } catch (error41) {
        }
        return templateId;
      }
      return "document";
    } catch (error41) {
      return "document";
    }
  };
  const handleClose = () => {
    createdBlobUrls.forEach((url2) => {
      URL.revokeObjectURL(url2);
    });
    setCreatedBlobUrls([]);
    setTasks([]);
    setUploadTasks([]);
    setModalState("initial");
    setError(null);
    setFolderName("");
    setFolderNameError("");
    setDownloadFiles([]);
    setConnectorSelection(null);
    onClose();
  };
  const handleDownload = async () => {
    setError(null);
    try {
      const { settings, connectorSelection: connectorSelection2 } = await loadDefaultSettings();
      setDownloadSettings(settings);
      setConnectorSelection(connectorSelection2);
    } catch (error41) {
      console.warn("Failed to load default settings:", error41);
    }
    try {
      const documentName = await getDocumentName();
      const sanitizedName = sanitizeFolderName(documentName);
      setFolderName(sanitizedName);
      setFolderNameError("");
    } catch (error41) {
      setFolderName("document");
      setFolderNameError("");
    }
    setModalState("downloadSettings");
  };
  const handleUpload = () => {
    const skipInstructions = localStorage.getItem("tempSlowUploadInstructions");
    if (skipInstructions === "true") {
      handleDirectoryPicker();
    } else {
      setModalState("uploadInstructions");
    }
  };
  const handleDefaultSettings = () => {
    setIsDefaultSettingsModalOpen(true);
  };
  const loadDefaultSettings = async () => {
    const defaultFallback = {
      includeFonts: true,
      includeGrafxMedia: false,
      includeSmartCrops: false,
      removeToolbarData: false,
      removeUnusedConnectors: false,
      useOriginalFontFileNames: false,
      addTimestamp: true
    };
    try {
      const toolbarDataResult = await loadToolbarDataFromDoc();
      if (toolbarDataResult.isOk()) {
        const toolbarData = toolbarDataResult.value;
        if (toolbarData.defaultDownloadSettings) {
          const { smartCropsConnectorSelection, ...settings } = toolbarData.defaultDownloadSettings;
          return {
            settings,
            connectorSelection: smartCropsConnectorSelection || null
          };
        }
      }
    } catch (error41) {
      console.warn("Failed to load default settings, using fallback:", error41);
    }
    return {
      settings: defaultFallback,
      connectorSelection: null
    };
  };
  const handleDirectoryPicker = async () => {
    try {
      if (!window.showDirectoryPicker) {
        raiseError2(new Error("File System Access API is not supported in this browser"));
        return;
      }
      const directoryHandle = await window.showDirectoryPicker();
      setModalState("uploading");
      const filesResult = await loadFilesFromDirectory(directoryHandle);
      if (!filesResult.isOk()) {
        setError(filesResult.error?.message || "Failed to load files from directory");
        setModalState("uploadInstructions");
        return;
      }
      await processUploadFiles(filesResult.value);
    } catch (error41) {
      if (error41 instanceof Error && error41.name === "AbortError") {
        setModalState("initial");
        return;
      }
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
      setModalState("initial");
    }
  };
  const processUploadFiles = async (files) => {
    try {
      const packageJsonFile = files.find((file2) => file2.name === "package.json");
      if (!packageJsonFile) {
        raiseError2(new NoPackageJsonError("package.json not found"));
        return;
      }
      const packageJsonText = await packageJsonFile.text();
      const packageJsonData = JSON.parse(packageJsonText);
      const validationResult = verifyStudioPackage(packageJsonData);
      if (!validationResult.isOk()) {
        raiseError2(validationResult.error || new Error("Package validation failed"));
        return;
      }
      const studioPackage = validationResult.value;
      setUploadTasks([]);
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const studio2 = studioResult.value;
      const token2 = (await studio2.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studio2.configuration.getValue("ENVIRONMENT_API")).parsedData;
      if (!token2 || !baseUrl) {
        raiseError2(new Error("Failed to get authentication token or base URL"));
        return;
      }
      const packageTaskId = "package-processing";
      setPackageJsonTaskId(packageTaskId);
      setUploadTasks([
        {
          id: packageTaskId,
          name: "Processing package.json",
          type: "package_processing",
          status: "processing"
        }
      ]);
      setCurrentFiles(files);
      setCurrentStudioPackage(studioPackage);
      setCurrentStudio(studio2);
      setCurrentToken(token2);
      setCurrentBaseUrl(baseUrl);
      await processPackageJsonWorkflow(files, studioPackage, studio2, token2, baseUrl, packageTaskId);
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
  };
  const processPackageJsonWorkflow = async (files, studioPackage, studio2, token2, baseUrl, packageTaskId) => {
    try {
      const updatePackageTaskStatus = (status, error41) => {
        setUploadTasks((prev2) => prev2.map((task) => task.id === packageTaskId ? { ...task, status, error: error41 } : task));
      };
      let smartCropsFileData = null;
      for (const document2 of studioPackage.documents) {
        if (document2.smartCrops) {
          const smartCropsFile = files.find((file2) => file2.name === document2.smartCrops.filePath);
          if (!smartCropsFile) {
            const error41 = new MissingSmartCropsFileError(`Smart crops file not found: ${document2.smartCrops.filePath}`);
            raiseError2(error41);
            updatePackageTaskStatus("error", error41.message);
            return;
          }
          try {
            const smartCropsText = await smartCropsFile.text();
            smartCropsFileData = JSON.parse(smartCropsText);
            setSmartCropsData(smartCropsFileData);
          } catch (parseError) {
            const error41 = new InvalidSmartCropsJsonError(`Invalid smart crops JSON: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
            raiseError2(error41);
            updatePackageTaskStatus("error", error41.message);
            return;
          }
        }
      }
      if (smartCropsFileData && smartCropsFileData.crops && smartCropsFileData.crops.length > 0) {
        const connectorsResult = await getMediaConnectorsAPI(baseUrl, token2);
        if (!connectorsResult.isOk()) {
          const error41 = new FailedToFetchConnectorsError(`Failed to fetch connectors: ${connectorsResult.error?.message}`);
          raiseError2(error41);
          updatePackageTaskStatus("error", error41.message);
          return;
        }
        const mediaConnectors = connectorsResult.value.data.filter((connector) => connector.enabled && connector.type === "media");
        setAvailableConnectors(mediaConnectors);
        setConnectorSelectionModalOpened(true);
        return;
      }
      await continuePackageProcessing(files, studioPackage, studio2, token2, baseUrl, packageTaskId);
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      raiseError2(error41 instanceof Error ? error41 : new Error(errorMessage));
      setUploadTasks((prev2) => prev2.map((task) => task.id === packageTaskId ? { ...task, status: "error", error: errorMessage } : task));
    }
  };
  const continuePackageProcessing = async (files, studioPackage, studio2, token2, baseUrl, packageTaskId) => {
    try {
      const updatePackageTaskStatus = (status, error41) => {
        setUploadTasks((prev2) => prev2.map((task) => task.id === packageTaskId ? { ...task, status, error: error41 } : task));
      };
      let parsedDocumentData = null;
      for (const document2 of studioPackage.documents) {
        const documentFile = files.find((file2) => file2.name === document2.filePath);
        if (!documentFile) {
          const error41 = new MissingDocumentFileError(`Document file not found: ${document2.filePath}`);
          raiseError2(error41);
          updatePackageTaskStatus("error", error41.message);
          return;
        }
        try {
          const documentText = await documentFile.text();
          parsedDocumentData = JSON.parse(documentText);
          setDocumentData(parsedDocumentData);
        } catch (parseError) {
          const error41 = new InvalidDocumentJsonError(`Invalid document JSON: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
          raiseError2(error41);
          updatePackageTaskStatus("error", error41.message);
          return;
        }
      }
      const connectorsResult = await getMediaConnectorsAPI(baseUrl, token2);
      if (!connectorsResult.isOk()) {
        const error41 = new FailedToFetchConnectorsError(`Failed to fetch connectors: ${connectorsResult.error?.message}`);
        raiseError2(error41);
        updatePackageTaskStatus("error", error41.message);
        return;
      }
      const mediaConnectors = connectorsResult.value.data.filter((connector) => connector.enabled && connector.type === "media");
      setAvailableConnectors(mediaConnectors);
      const currentDocumentData = documentData || parsedDocumentData;
      if (currentDocumentData && currentDocumentData.connectors) {
        const documentConnectors = currentDocumentData.connectors;
        const connectorsNeedingReplacement = documentConnectors.filter((connector) => connector.source.source === "grafx" && connector.source.id);
        if (connectorsNeedingReplacement.length > 0) {
          setConnectorsToReplace(connectorsNeedingReplacement);
          setReplaceConnectorsModalOpened(true);
          return;
        }
      }
      updatePackageTaskStatus("complete");
      await startTaskProcessing(files, studioPackage, studio2, token2, baseUrl);
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      raiseError2(error41 instanceof Error ? error41 : new Error(errorMessage));
      setUploadTasks((prev2) => prev2.map((task) => task.id === packageTaskId ? { ...task, status: "error", error: errorMessage } : task));
    }
  };
  const handleConnectorSelection = async (connectorId) => {
    setSelectedVisionConnector(connectorId);
    setConnectorSelectionModalOpened(false);
    if (currentFiles.length > 0 && currentStudioPackage && currentStudio && currentToken && currentBaseUrl) {
      await continuePackageProcessing(currentFiles, currentStudioPackage, currentStudio, currentToken, currentBaseUrl, packageJsonTaskId);
    }
  };
  const handleConnectorReplacement = async (replacementMap) => {
    setReplaceConnectorsModalOpened(false);
    console.log(replacementMap);
    if (documentData) {
      console.log("HELLO");
      console.log(documentData);
      const newDocumentData = JSON.parse(JSON.stringify(documentData));
      for (const connector of newDocumentData.connectors) {
        if (connector.source.source === "grafx" && connector.source.id) {
          const replacementId = replacementMap.get(connector.source.id);
          if (replacementId) {
            connector.source.id = replacementId;
          }
        }
      }
      setDocumentData(newDocumentData);
      console.log(newDocumentData);
      setUploadTasks((prev2) => prev2.map((task) => task.id === packageJsonTaskId ? { ...task, status: "complete" } : task));
      setUploadTasks((prev2) => [
        ...prev2,
        {
          id: "document-load",
          name: "Loading document",
          type: "document_load",
          status: "pending"
        }
      ]);
      if (currentFiles.length > 0 && currentStudioPackage && currentStudio && currentToken && currentBaseUrl) {
        await startTaskProcessing(currentFiles, currentStudioPackage, currentStudio, currentToken, currentBaseUrl, newDocumentData);
      }
    }
  };
  const startTaskProcessing = async (files, studioPackage, studio2, token2, baseUrl, currentDocumentData) => {
    try {
      for (const document2 of studioPackage.documents) {
        for (const fontInfo of document2.fonts) {
          const fontFile = files.find((file2) => file2.name === fontInfo.filePath);
          if (!fontFile) {
            const taskId2 = `font-upload-${fontInfo.details.id}`;
            setUploadTasks((prev2) => [
              ...prev2,
              {
                id: taskId2,
                name: `Font missing: ${fontInfo.details.familyName} ${fontInfo.details.name}`,
                type: "font_upload",
                status: "error",
                error: `Font file not found: ${fontInfo.filePath}`
              }
            ]);
            continue;
          }
          const taskId = `font-upload-${fontInfo.details.id}`;
          setUploadTasks((prev2) => [
            ...prev2,
            {
              id: taskId,
              name: `Uploading font: ${fontInfo.details.familyName} ${fontInfo.details.name}`,
              type: "font_upload",
              status: "processing"
            }
          ]);
          try {
            await uploadFont(fontFile, fontInfo.details, token2, baseUrl, taskId);
          } catch (error41) {
          }
        }
      }
      if (smartCropsData && smartCropsData.crops && selectedVisionConnector) {
        for (const crop of smartCropsData.crops) {
          const taskId = `smart-crop-${crop.assetId}`;
          setUploadTasks((prev2) => [
            ...prev2,
            {
              id: taskId,
              name: `Uploading smart crop: ${crop.assetId}`,
              type: "smart_crop_upload",
              status: "processing"
            }
          ]);
          try {
            const visionResult = await setVision({
              baseUrl,
              connectorId: selectedVisionConnector,
              asset: crop.assetId,
              authorization: token2,
              metadata: crop.metadata
            });
            if (visionResult.isOk()) {
              setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? { ...task, status: "complete" } : task));
            } else {
              setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? {
                ...task,
                status: "error",
                error: visionResult.error?.message || "Failed to set vision data"
              } : task));
            }
          } catch (error41) {
            setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? {
              ...task,
              status: "error",
              error: error41 instanceof Error ? error41.message : String(error41)
            } : task));
          }
        }
      }
      if (currentDocumentData) {
        setUploadTasks((prev2) => prev2.map((task) => task.id === "document-load" ? { ...task, status: "processing" } : task));
        console.log(currentDocumentData);
        try {
          const loadResult = await loadDocumentFromJsonStr(studio2, JSON.stringify(currentDocumentData));
          if (loadResult.isOk()) {
            setUploadTasks((prev2) => prev2.map((task) => task.id === "document-load" ? { ...task, status: "complete" } : task));
          } else {
            setUploadTasks((prev2) => prev2.map((task) => task.id === "document-load" ? {
              ...task,
              status: "error",
              error: loadResult.error?.message || "Failed to load document"
            } : task));
          }
        } catch (error41) {
          setUploadTasks((prev2) => prev2.map((task) => task.id === "document-load" ? {
            ...task,
            status: "error",
            error: error41 instanceof Error ? error41.message : String(error41)
          } : task));
        }
      }
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
  };
  const uploadFont = async (fontFile, fontDetails, token2, baseUrl, taskId) => {
    try {
      const fontFamiliesResponse = await fetch(`${baseUrl}font-families?sortBy=Name&sortOrder=asc`, {
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        }
      });
      if (!fontFamiliesResponse.ok) {
        throw new Error(`Failed to fetch font families: ${fontFamiliesResponse.statusText}`);
      }
      const fontFamiliesData = await fontFamiliesResponse.json();
      const targetFamily = fontFamiliesData.data.find((tf) => tf.name === fontDetails.familyName);
      if (targetFamily) {
        const targetStylesResponse = await fetch(`${baseUrl}font-families/${targetFamily.id}/styles`, {
          headers: {
            Authorization: `Bearer ${token2}`,
            "Content-Type": "application/json"
          }
        });
        if (targetStylesResponse.ok) {
          const targetStylesData = await targetStylesResponse.json();
          const targetStyle = targetStylesData.data.find((ts) => ts.name === fontDetails.name);
          if (targetStyle) {
            setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? {
              ...task,
              status: "info",
              tooltip: "Font already exists, skipping"
            } : task));
            return;
          }
        }
      }
      const formData = new FormData;
      const renamedFile = new File([fontFile], fontDetails.fileName, {
        type: fontFile.type,
        lastModified: fontFile.lastModified
      });
      formData.append("file", renamedFile);
      const uploadResponse = await fetch(`${baseUrl}font-styles/temp`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token2}`
        },
        body: formData
      });
      if (!uploadResponse.ok) {
        throw new Error(`Failed to upload font: ${uploadResponse.statusText}`);
      }
      const uploadData = await uploadResponse.json();
      if (!uploadData.data.preloadedData.length) {
        throw new Error("No preloaded font data received");
      }
      const preloadedFont = uploadData.data.preloadedData[0];
      const patchResponse = await fetch(`${baseUrl}font-styles/temp/${uploadData.batchId}`, {
        method: "PATCH",
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify([
          {
            fontStyleId: preloadedFont.id,
            familyName: fontDetails.familyName,
            styleName: fontDetails.name
          }
        ])
      });
      if (!patchResponse.ok) {
        throw new Error(`Failed to patch font: ${patchResponse.statusText}`);
      }
      const confirmResponse = await fetch(`${baseUrl}font-styles/temp/${uploadData.batchId}/confirm`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token2}`
        }
      });
      if (!confirmResponse.ok) {
        throw new Error(`Failed to confirm font upload: ${confirmResponse.statusText}`);
      }
      setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? { ...task, status: "complete" } : task));
    } catch (error41) {
      const errorMessage = error41 instanceof Error ? error41.message : String(error41);
      if (error41 instanceof FontAlreadyExistsError) {
        setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? {
          ...task,
          status: "info",
          tooltip: "Font already exists, skipping"
        } : task));
      } else {
        setUploadTasks((prev2) => prev2.map((task) => task.id === taskId ? {
          ...task,
          status: "error",
          error: errorMessage
        } : task));
      }
    }
  };
  const handleJsonDownload = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const documentResult = await getCurrentDocumentState(studioResult.value);
      if (!documentResult.isOk()) {
        raiseError2(new Error(documentResult.error?.message || "Failed to get document state"));
        return;
      }
      const documentData2 = documentResult.value;
      const documentName = await getDocumentName();
      const jsonStr = JSON.stringify(documentData2, null, 2);
      const blob = new Blob([jsonStr], { type: "application/json" });
      const url2 = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = `${documentName}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
  };
  const collectSmartCropsDataWithTasks = async (studio2, connectorSelection2) => {
    const smartCropsData2 = {
      connectorId: connectorSelection2.connectorId,
      connectorName: connectorSelection2.connectorName,
      crops: []
    };
    const token2 = (await studio2.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
    const baseUrl = (await studio2.configuration.getValue("ENVIRONMENT_API")).parsedData;
    if (!token2 || !baseUrl) {
      throw new Error("Failed to get authentication token or base URL");
    }
    const registerResult = await registerConnector(studio2, connectorSelection2.connectorId);
    if (!registerResult.isOk()) {
      throw new Error(`Failed to register connector: ${registerResult.error?.message}`);
    }
    const localConnectorId = registerResult.value;
    let hasErrors = false;
    try {
      for (const folderPath of connectorSelection2.selectedFolders) {
        const folderTaskId = `query-folder-${folderPath.replace(/[^a-zA-Z0-9]/g, "-")}`;
        setTasks((prev2) => [
          ...prev2,
          {
            id: folderTaskId,
            name: `Getting files: ${folderPath}`,
            type: "query_folder",
            status: "processing"
          }
        ]);
        try {
          const queryResult = await queryMediaConnectorSimple(studio2, localConnectorId, folderPath, "");
          if (!queryResult.isOk()) {
            hasErrors = true;
            setTasks((prev2) => prev2.map((task) => task.id === folderTaskId ? {
              ...task,
              status: "error",
              error: `Failed to query folder: ${queryResult.error?.message}`
            } : task));
            continue;
          }
          setTasks((prev2) => prev2.map((task) => task.id === folderTaskId ? { ...task, status: "complete" } : task));
          const queryPage = queryResult.value;
          const files = queryPage.data.filter((item) => item.type === "file" || item.type === 0);
          for (const file2 of files) {
            const visionTaskId = `vision-${file2.id}`;
            setTasks((prev2) => [
              ...prev2,
              {
                id: visionTaskId,
                name: `Getting Vision Data: ${file2.name || file2.id}`,
                type: "get_vision",
                status: "processing"
              }
            ]);
            try {
              const visionResult = await getVision({
                baseUrl,
                connectorId: connectorSelection2.connectorId,
                asset: file2.id,
                authorization: token2
              });
              if (visionResult.isOk()) {
                smartCropsData2.crops.push({
                  assetId: file2.id,
                  metadata: visionResult.value
                });
                setTasks((prev2) => prev2.map((task) => task.id === visionTaskId ? { ...task, status: "complete" } : task));
              } else {
                const error41 = visionResult.error;
                if (error41 && error41.type === "VisionNotFoundError") {
                  setTasks((prev2) => prev2.map((task) => task.id === visionTaskId ? {
                    ...task,
                    status: "info",
                    tooltip: "Skipped no vision data"
                  } : task));
                } else {
                  hasErrors = true;
                  setTasks((prev2) => prev2.map((task) => task.id === visionTaskId ? {
                    ...task,
                    status: "error",
                    error: error41?.message || "Failed to get vision data"
                  } : task));
                }
              }
            } catch (error41) {
              hasErrors = true;
              setTasks((prev2) => prev2.map((task) => task.id === visionTaskId ? {
                ...task,
                status: "error",
                error: error41 instanceof Error ? error41.message : String(error41)
              } : task));
            }
          }
        } catch (error41) {
          hasErrors = true;
          setTasks((prev2) => prev2.map((task) => task.id === folderTaskId ? {
            ...task,
            status: "error",
            error: error41 instanceof Error ? error41.message : String(error41)
          } : task));
        }
      }
    } finally {
      try {
        await unregisterConnector(studio2, localConnectorId);
      } catch (error41) {
        console.warn("Failed to unregister connector:", error41);
      }
    }
    if (hasErrors) {
      throw new Error("Smart crops data collection failed due to errors in folder querying or vision data retrieval");
    }
    return smartCropsData2;
  };
  const onJsonUpload = async () => {
    try {
      if (fileInputRef.current) {
        fileInputRef.current.click();
      }
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
  };
  const handleFileChange = async (event) => {
    const file2 = event.target.files?.[0];
    if (!file2)
      return;
    try {
      if (!file2.name.toLowerCase().endsWith(".json")) {
        raiseError2(new Error("Please select a valid JSON file"));
        return;
      }
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const reader = new FileReader;
      reader.onload = async (e) => {
        try {
          const content = e.target?.result;
          if (!content) {
            raiseError2(new Error("Failed to read file content"));
            return;
          }
          try {
            JSON.parse(content);
          } catch (parseError) {
            raiseError2(new Error(`Invalid JSON format: ${parseError instanceof Error ? parseError.message : String(parseError)}`));
            return;
          }
          const loadResult = await loadDocumentFromJsonStr(studioResult.value, content);
          if (!loadResult.isOk()) {
            raiseError2(new Error(loadResult.error?.message || "Failed to load document from JSON"));
            return;
          }
          onClose();
        } catch (error41) {
          raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
        }
      };
      reader.onerror = () => {
        raiseError2(new Error("Failed to read the selected file"));
      };
      reader.readAsText(file2);
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
    if (event.target) {
      event.target.value = "";
    }
  };
  const handleFolderNameChange = (value) => {
    setFolderName(value);
    const error41 = validateFolderName(value);
    setFolderNameError(error41);
  };
  const [createdBlobUrls, setCreatedBlobUrls] = import_react273.useState([]);
  import_react273.useEffect(() => {
    return () => {
      createdBlobUrls.forEach((url2) => {
        URL.revokeObjectURL(url2);
      });
    };
  }, [createdBlobUrls]);
  const downloadFontFile = async (fontStyleId, file2, folder, fontDataForPackage, useOriginalFontFileNames) => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        throw new Error(studioResult.error?.message || "Failed to get studio");
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      let fontFamily;
      let fontStyle;
      if (fontFamilies) {
        for (const family of fontFamilies) {
          const style2 = family.fontStyles.find((s2) => s2.fontStyleId === fontStyleId);
          if (style2) {
            fontFamily = family;
            fontStyle = style2;
            break;
          }
        }
      }
      if (!fontFamily || !fontStyle) {
        throw new Error(`Font style ${fontStyleId} not found`);
      }
      const fontStyleResponse = await fetch(`${baseUrl}font-families/${fontFamily.fontFamilyId}/styles`, {
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        }
      });
      if (!fontStyleResponse.ok) {
        throw new Error(`Failed to fetch font style details: ${fontStyleResponse.statusText}`);
      }
      const fontStylesData = await fontStyleResponse.json();
      const fontStyleDetails = fontStylesData.data.find((fs) => fs.id === fontStyleId);
      if (!fontStyleDetails) {
        throw new Error(`Font style details not found for ${fontStyleId}`);
      }
      const fontDownloadResponse = await fetch(`${baseUrl}font-styles/${fontStyleId}/download`, {
        headers: {
          Authorization: `Bearer ${token2}`
        }
      });
      if (!fontDownloadResponse.ok) {
        throw new Error(`Failed to download font: ${fontDownloadResponse.statusText}`);
      }
      const fontBlob = await fontDownloadResponse.blob();
      const blobUrl = URL.createObjectURL(fontBlob);
      setCreatedBlobUrls((prev2) => [...prev2, blobUrl]);
      const actualFileName = useOriginalFontFileNames ? `fonts/${fontStyleDetails.fileName}` : `fonts/${fontStyleDetails.id}`;
      setDownloadFiles((prev2) => prev2.map((f2) => f2.id === file2.id ? { ...f2, name: actualFileName } : f2));
      fontDataForPackage.push({
        filePath: actualFileName,
        details: fontStyleDetails
      });
      await sendDownloadRequest(blobUrl, `Bearer ${token2}`, folder, actualFileName, file2.id);
    } catch (error41) {
      throw error41;
    }
  };
  const startDownloadProcess = async (files, documentData2, documentId, documentName, folder, connectorSelection2) => {
    const fontDataForPackage = [];
    let smartCropsFilePath;
    const documentJsonFile = files.find((f2) => f2.id === "document-json");
    const fontFiles = files.filter((f2) => f2.id.startsWith("font-"));
    const smartCropsFile = files.find((f2) => f2.id === "smart-crops");
    const packageFile = files.find((f2) => f2.id === "studio-package");
    if (documentJsonFile) {
      try {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === documentJsonFile.id ? { ...f2, status: "downloading" } : f2));
        const processedDocumentData = processDocumentForDownload(documentData2, downloadSettings);
        const jsonStr = JSON.stringify(processedDocumentData, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const blobUrl = URL.createObjectURL(blob);
        setCreatedBlobUrls((prev2) => [...prev2, blobUrl]);
        await sendDownloadRequest(blobUrl, "", folder, documentJsonFile.name, documentJsonFile.id);
      } catch (error41) {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === documentJsonFile.id ? {
          ...f2,
          status: "error",
          error: error41 instanceof Error ? error41.message : String(error41)
        } : f2));
      }
    }
    for (const file2 of fontFiles) {
      try {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === file2.id ? { ...f2, status: "downloading" } : f2));
        const fontStyleId = file2.id.replace("font-", "");
        await downloadFontFile(fontStyleId, file2, folder, fontDataForPackage, downloadSettings.useOriginalFontFileNames);
      } catch (error41) {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === file2.id ? {
          ...f2,
          status: "error",
          error: error41 instanceof Error ? error41.message : String(error41)
        } : f2));
      }
    }
    if (smartCropsFile && connectorSelection2) {
      try {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === smartCropsFile.id ? { ...f2, status: "downloading" } : f2));
        const studioResult = await getStudio();
        if (!studioResult.isOk()) {
          throw new Error("Failed to get studio for smart crops collection");
        }
        const smartCropsData2 = await collectSmartCropsDataWithTasks(studioResult.value, connectorSelection2);
        const smartCropsStr = JSON.stringify(smartCropsData2, null, 2);
        const blob = new Blob([smartCropsStr], { type: "application/json" });
        const blobUrl = URL.createObjectURL(blob);
        setCreatedBlobUrls((prev2) => [...prev2, blobUrl]);
        smartCropsFilePath = smartCropsFile.name;
        await sendDownloadRequest(blobUrl, "", folder, smartCropsFile.name, smartCropsFile.id);
      } catch (error41) {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === smartCropsFile.id ? {
          ...f2,
          status: "error",
          error: error41 instanceof Error ? error41.message : String(error41)
        } : f2));
      }
    }
    if (packageFile) {
      try {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === packageFile.id ? { ...f2, status: "downloading" } : f2));
        const documentEntry = {
          id: documentId,
          name: documentName,
          filePath: `${documentId}.json`,
          fonts: fontDataForPackage
        };
        if (smartCropsFilePath) {
          documentEntry.smartCrops = {
            filePath: smartCropsFilePath
          };
        }
        const manifest = {
          engineVersion: documentData2.engineVersion || "unknown",
          source: window.location.href,
          documents: [documentEntry]
        };
        const manifestStr = JSON.stringify(manifest, null, 2);
        const blob = new Blob([manifestStr], { type: "application/json" });
        const blobUrl = URL.createObjectURL(blob);
        setCreatedBlobUrls((prev2) => [...prev2, blobUrl]);
        await sendDownloadRequest(blobUrl, "", folder, packageFile.name, packageFile.id);
      } catch (error41) {
        setDownloadFiles((prev2) => prev2.map((f2) => f2.id === packageFile.id ? {
          ...f2,
          status: "error",
          error: error41 instanceof Error ? error41.message : String(error41)
        } : f2));
      }
    }
  };
  const sendDownloadRequest = async (url2, authorization, folder, filename, downloadId) => {
    return new Promise((resolve, reject) => {
      const requestId = `download_${Date.now()}_${Math.random()}`;
      const responseListener = (event) => {
        if (event.source !== window)
          return;
        if (event.data.type === "DOWNLOAD_RESPONSE" && event.data.requestId === requestId) {
          window.removeEventListener("message", responseListener);
          if (event.data.response.success) {
            resolve();
          } else {
            reject(new Error(event.data.response.error));
          }
        }
      };
      window.addEventListener("message", responseListener);
      window.postMessage({
        type: "START_DOWNLOAD",
        requestId,
        data: {
          url: url2,
          authorization,
          folder,
          filename,
          downloadId
        }
      }, "*");
      setTimeout(() => {
        window.removeEventListener("message", responseListener);
        reject(new Error("Download request timeout"));
      }, 30000);
    });
  };
  const handleSettingChange = (setting, value) => {
    setDownloadSettings((prev2) => ({
      ...prev2,
      [setting]: value
    }));
    if (setting === "includeSmartCrops" && !value) {
      setConnectorSelection(null);
    }
  };
  const handleDownloadWithSettings = async () => {
    if (folderNameError) {
      setError("Please fix folder name errors before downloading");
      return;
    }
    if (!folderName.trim()) {
      setError("Folder name is required");
      return;
    }
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const documentResult = await getCurrentDocumentState(studioResult.value);
      if (!documentResult.isOk()) {
        raiseError2(new Error(documentResult.error?.message || "Failed to get document state"));
        return;
      }
      const documentData2 = documentResult.value;
      const documentId = getDocumentId();
      const documentName = await getDocumentName();
      const finalFolderName = downloadSettings.addTimestamp ? `${folderName}_${generateTimestamp()}` : folderName;
      const filesToDownload = [
        {
          id: "document-json",
          name: `${documentId}.json`,
          status: "pending"
        },
        {
          id: "studio-package",
          name: "package.studio",
          status: "pending"
        }
      ];
      if (downloadSettings.includeFonts && fontFamilies && fontFamilies.length > 0) {
        for (const family of fontFamilies) {
          for (const style2 of family.fontStyles) {
            filesToDownload.push({
              id: `font-${style2.fontStyleId}`,
              name: `fonts/${style2.name}.ttf`,
              status: "pending"
            });
          }
        }
      }
      if (downloadSettings.includeSmartCrops && connectorSelection && connectorSelection.selectedFolders.length > 0) {
        filesToDownload.push({
          id: "smart-crops",
          name: "smart-crops.json",
          status: "pending"
        });
      }
      setDownloadFiles(filesToDownload);
      setTasks([]);
      setModalState("tasks");
      await startDownloadProcess(filesToDownload, documentData2, documentId, documentName, finalFolderName, connectorSelection);
    } catch (error41) {
      raiseError2(error41 instanceof Error ? error41 : new Error(String(error41)));
    }
  };
  const handleFolderSelection = (selection) => {
    setConnectorSelection(selection);
    setFolderBrowserOpened(false);
  };
  const handleRemoveFolderPath = (pathToRemove) => {
    setConnectorSelection((prev2) => {
      if (!prev2)
        return null;
      const updatedFolders = prev2.selectedFolders.filter((path) => path !== pathToRemove);
      if (updatedFolders.length === 0)
        return null;
      return {
        ...prev2,
        selectedFolders: updatedFolders
      };
    });
  };
  return /* @__PURE__ */ jsx_runtime28.jsxs(jsx_runtime28.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime28.jsx(Modal, {
        opened,
        onClose: handleClose,
        title: modalState === "initial" ? "Document Upload/Download" : modalState === "downloadSettings" ? "Download Settings" : modalState === "tasks" ? "Tasks Processing" : modalState === "uploadInstructions" ? "Upload Instructions" : modalState === "uploading" ? "Uploading Files" : "Downloading Files",
        centered: true,
        size: "50%",
        styles: {
          content: {
            minHeight: "400px"
          },
          body: {
            padding: "2rem"
          },
          header: {
            padding: "1.5rem 2rem 1rem 2rem"
          },
          title: {
            fontSize: "1.5rem",
            fontWeight: 600
          }
        },
        children: modalState === "initial" ? /* @__PURE__ */ jsx_runtime28.jsx(InitialScreen, {
          error: error40,
          onDownload: handleDownload,
          onUpload: handleUpload,
          onJsonDownload: handleJsonDownload,
          onJsonUpload,
          onDefaultSettings: handleDefaultSettings
        }) : modalState === "downloadSettings" ? /* @__PURE__ */ jsx_runtime28.jsx(DownloadSettingsScreen, {
          error: error40,
          folderName,
          folderNameError,
          downloadSettings,
          fontStylesCount,
          connectorSelection,
          onFolderNameChange: handleFolderNameChange,
          onSettingChange: handleSettingChange,
          onAddFolder: () => setFolderBrowserOpened(true),
          onRemoveFolderPath: handleRemoveFolderPath,
          onBack: () => setModalState("initial"),
          onDownload: handleDownloadWithSettings
        }) : modalState === "tasks" || modalState === "uploading" ? /* @__PURE__ */ jsx_runtime28.jsx(DownloadTasksScreen, {
          downloadFiles,
          tasks,
          uploadTasks,
          onClose: handleClose
        }) : modalState === "uploadInstructions" ? /* @__PURE__ */ jsx_runtime28.jsx(UploadTasksScreen, {
          error: error40,
          onBack: () => setModalState("initial"),
          onContinue: handleDirectoryPicker
        }) : null
      }),
      /* @__PURE__ */ jsx_runtime28.jsx("input", {
        type: "file",
        ref: fileInputRef,
        style: { display: "none" },
        accept: ".json",
        onChange: handleFileChange
      }),
      /* @__PURE__ */ jsx_runtime28.jsx(ImageBrowser, {
        opened: folderBrowserOpened,
        mode: 0 /* FolderSelection */,
        initialSelection: connectorSelection,
        onClose: (selection) => {
          handleFolderSelection(selection);
          setFolderBrowserOpened(false);
        }
      }),
      /* @__PURE__ */ jsx_runtime28.jsx(ConnectorSelectionModal, {
        opened: connectorSelectionModalOpened,
        onClose: () => setConnectorSelectionModalOpened(false),
        connectors: availableConnectors,
        smartCropsConnectorName: smartCropsData?.connectorName,
        onSelect: handleConnectorSelection
      }),
      /* @__PURE__ */ jsx_runtime28.jsx(ReplaceConnectorsModal, {
        opened: replaceConnectorsModalOpened,
        onClose: () => setReplaceConnectorsModalOpened(false),
        connectorsToReplace,
        availableConnectors,
        onReplace: (replacementMap) => {
          handleConnectorReplacement(replacementMap);
        }
      }),
      /* @__PURE__ */ jsx_runtime28.jsx(DefaultSettingsModal, {
        opened: isDefaultSettingsModalOpen,
        onClose: () => setIsDefaultSettingsModalOpen(false)
      })
    ]
  });
}

// src/components/MagicLayoutsModal.tsx
var import_react274 = __toESM(require_react(), 1);
var import_studio_sdk3 = __toESM(require_main(), 1);

// src/studio/actions/magicLayout.js
function magicLayoutScript(debug = false) {
  const version3 = 1;
  const layoutSizingData = "%DATA1%";
  const layoutFramesData = "%DATA2%";
  const muggleToVariableMagic = "%DATA3%";
  const currentLayoutName = getSelectedLayoutName();
  const variableMagicName = muggleToVariableMagic[currentLayoutName];
  if (!variableMagicName)
    return;
  const magicLayoutName = getSelectedItemFromListVariable(variableMagicName);
  const magicLayoutSize = layoutSizingData[magicLayoutName];
  const magicLayoutFrames = layoutFramesData[magicLayoutName];
  if (!magicLayoutSize || !magicLayoutFrames)
    return;
  const currentLayout = {
    name: getSelectedLayoutName(),
    height: getPageHeight(),
    width: getPageWidth()
  };
  setPageSize(magicLayoutSize.w, magicLayoutSize.h);
  studio.frames.all().forEach((frame) => {
    frame.setVisible(false);
  });
  magicLayoutFrames.forEach((frameData) => {
    const name = frameData.name;
    setFrameVisible(name, true);
    setFrameX(name, frameData.x);
    setFrameY(name, frameData.y);
    setFrameWidth(name, frameData.width);
    setFrameHeight(name, frameData.height);
    setFrameRotation(name, frameData.rotationDegrees);
  });
  setPageSize(currentLayout.width, currentLayout.height);
}

// src/components/MagicLayoutsModal.tsx
var jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
function MagicLayoutsModal({ opened, onClose }) {
  const [isProcessing, setIsProcessing] = import_react274.useState(true);
  const [isComplete, setIsComplete] = import_react274.useState(false);
  const raiseError2 = appStore((store) => store.raiseError);
  const gatherAllChildren = async (childrenLayoutIds, onlyLeafs, skipUnavailable = true, recur = 0) => {
    const leafNames = [];
    const leafIds = [];
    if (childrenLayoutIds.length === 0) {
      return { names: [], ids: [] };
    }
    const childLayouts = await Promise.all(childrenLayoutIds.map(async (id) => {
      const layoutResult = await getLayoutById(window.SDK, id);
      if (layoutResult.isError()) {
        raiseError2(new Error(`Failed to get layout with id ${id}`));
        throw new Error(`Failed to get layout with id ${id}`);
      }
      return layoutResult.value;
    }));
    console.log({
      recur,
      childrenIds: childrenLayoutIds,
      children: childLayouts
    });
    for (const child of childLayouts) {
      if (onlyLeafs) {
        const hasChildren = child.childLayouts.length > 0;
        if (!hasChildren) {
          if (!skipUnavailable || child.availableForUser) {
            leafNames.push(child.name);
            leafIds.push(child.id);
            console.log({
              skipping: false,
              child: child.name,
              childLeaves: []
            });
          }
        } else {
          const childLeaves = await gatherAllChildren(child.childLayouts, onlyLeafs, skipUnavailable, recur + 1);
          console.log({
            skipping: true,
            child: child.name,
            childLeaves
          });
          leafNames.push(...childLeaves.names);
          leafIds.push(...childLeaves.ids);
        }
        console.log("afterPush", leafNames, leafIds);
      } else {
        if (!skipUnavailable || child.availableForUser) {
          leafNames.push(child.name);
          leafIds.push(child.id);
        }
        const childLeaves = await gatherAllChildren(child.childLayouts, onlyLeafs, skipUnavailable, recur + 1);
        leafNames.push(...childLeaves.names);
        leafIds.push(...childLeaves.ids);
      }
    }
    console.log("FINAL", { names: leafNames, ids: leafIds, recur });
    return { names: leafNames, ids: leafIds };
  };
  const runMagicProcess = async () => {
    const layoutsResult = await getAllLayouts(window.SDK);
    if (layoutsResult.isError()) {
      raiseError2(new Error("Failed to get layouts"));
      throw new Error("Failed to get layouts");
    }
    const layouts = layoutsResult.value;
    if (!layouts) {
      raiseError2(new Error("Layouts data is undefined"));
      throw new Error("Layouts data is undefined");
    }
    const magicLayouts = layouts.filter((layout) => layout.name.startsWith("✨"));
    const muggleToMagicLayouts = magicLayouts.reduce((acc, magicLayout) => {
      const normalLayoutName = magicLayout.name.replace("✨", "");
      const normalLayout = layouts.find((layout) => layout.name === normalLayoutName);
      if (normalLayout) {
        acc[normalLayout.name] = magicLayout.name;
      }
      return acc;
    }, {});
    for (const [normalLayoutName, magicLayoutName] of Object.entries(muggleToMagicLayouts)) {
      const normalLayout = layouts.find((layout) => layout.name === normalLayoutName);
      if (normalLayout) {
        const allChildren = await gatherAllChildren(normalLayout.childLayouts, false);
        allChildren.names.forEach((childName) => {
          muggleToMagicLayouts[childName] = magicLayoutName;
        });
      }
    }
    const childrenIds = [];
    const result = await getAllVariables(window.SDK);
    if (result.isOk()) {
      const variables = result.value;
      const idsToDelete = variables.filter((variable) => variable.name.startsWith("✨")).map((variable) => variable.id);
      await deleteVariables(window.SDK, idsToDelete);
    }
    for (const magicLayout of magicLayouts) {
      const leafChildren = await gatherAllChildren(magicLayout.childLayouts, true, false);
      console.log("LEAF CHILDREN", leafChildren);
      const childrenNames = leafChildren.names;
      childrenIds.push(...leafChildren.ids);
      (await gatherAllChildren(magicLayout.childLayouts, false)).ids.forEach((id) => setLayoutAvailable(window.SDK, id, false));
      setLayoutAvailable(window.SDK, magicLayout.id, false);
      await setOrCreateVariableValue({
        studio: window.SDK,
        name: magicLayout.name,
        variableType: import_studio_sdk3.VariableType.list,
        value: childrenNames
      });
      const visibilityResult = await setVariableVisblityWithName({
        studio: window.SDK,
        name: magicLayout.name,
        visible: { type: import_studio_sdk3.VariableVisibilityType.invisible }
      });
      if (visibilityResult.isError()) {
        raiseError2(new Error(`Failed to set visibility for variable ${magicLayout.name}`));
      }
    }
    const allVariablesResult = await getAllVariables(window.SDK);
    if (allVariablesResult.isError()) {
      raiseError2(new Error("Failed to get all variables"));
      throw new Error("Failed to get all variables");
    }
    const allVariables = allVariablesResult.value;
    if (!allVariables) {
      raiseError2(new Error("Variables data is undefined"));
      throw new Error("Variables data is undefined");
    }
    let autoGenMagicId;
    const existingAutoGenMagic = allVariables.find((variable) => variable.name === "AUTO_GEN_MAGIC");
    if (existingAutoGenMagic) {
      autoGenMagicId = existingAutoGenMagic.id;
    } else {
      const createGroupResult = await groupVariables({
        studio: window.SDK,
        name: "AUTO_GEN_MAGIC",
        variableIds: []
      });
      if (createGroupResult.isError()) {
        raiseError2(new Error("Failed to create AUTO_GEN_MAGIC group"));
        throw new Error("Failed to create AUTO_GEN_MAGIC group");
      }
      const getByNameResult = await getByName(window.SDK, "AUTO_GEN_MAGIC");
      if (getByNameResult.isError()) {
        raiseError2(new Error("Failed to get AUTO_GEN_MAGIC by name"));
        throw new Error("Failed to get AUTO_GEN_MAGIC by name");
      }
      if (!getByNameResult.value) {
        raiseError2(new Error("AUTO_GEN_MAGIC variable not found after creation"));
        throw new Error("AUTO_GEN_MAGIC variable not found after creation");
      }
      autoGenMagicId = getByNameResult.value.id;
    }
    const magicVariableNames = magicLayouts.map((layout) => layout.name);
    const magicVariables = allVariables.filter((variable) => magicVariableNames.includes(variable.name));
    for (const magicVariable of magicVariables) {
      if (magicVariable.parentId !== autoGenMagicId) {
        const moveResult = await moveVariable({
          studio: window.SDK,
          id: magicVariable.id,
          newParentId: autoGenMagicId,
          order: 0
        });
        if (moveResult.isError()) {
          raiseError2(new Error(`Failed to move variable ${magicVariable.name}`));
          throw new Error(`Failed to move variable ${magicVariable.name}`);
        }
      }
    }
    const allLayoutsResult = await getAllLayouts(window.SDK);
    if (allLayoutsResult.isError()) {
      raiseError2(new Error("Failed to get layouts for child filtering"));
      throw new Error("Failed to get layouts for child filtering");
    }
    const allLayouts = allLayoutsResult.value;
    if (!allLayouts) {
      raiseError2(new Error("All layouts data is undefined"));
      throw new Error("All layouts data is undefined");
    }
    const childLayouts = allLayouts.filter((layout) => childrenIds.includes(layout.id));
    const childLayoutSizes = {};
    for (const layout of childLayouts) {
      childLayoutSizes[layout.name] = {
        w: layout.width.value,
        h: layout.height.value
      };
    }
    const allFramesResult = await getAll(window.SDK);
    if (allFramesResult.isError()) {
      raiseError2(new Error("Failed to get all frames"));
      throw new Error("Failed to get all frames");
    }
    const allFrames = allFramesResult.value;
    if (!allFrames) {
      raiseError2(new Error("All frames data is undefined"));
      throw new Error("All frames data is undefined");
    }
    const frameIdToNameMap = new Map;
    allFrames.forEach((frame) => {
      frameIdToNameMap.set(frame.id, frame.name);
    });
    const layoutFramesData = {};
    for (const layout of childLayouts) {
      const framePropertiesResult = await getPropertiesOnLayout(window.SDK, layout.id);
      if (framePropertiesResult.isError()) {
        raiseError2(new Error(`Failed to get frame properties for layout ${layout.name}`));
        throw new Error(`Failed to get frame properties for layout ${layout.name}`);
      }
      const frameProperties = framePropertiesResult.value;
      if (!frameProperties || !Array.isArray(frameProperties)) {
        raiseError2(new Error(`Frame properties is not an array for layout ${layout.name}`));
        throw new Error(`Frame properties is not an array for layout ${layout.name}`);
      }
      const visibleFramesWithOverrides = [];
      for (const frameProps of frameProperties) {
        if (!frameProps) {
          raiseError2(new Error(`Frame properties is null or undefined for layout ${layout.name}`));
          throw new Error(`Frame properties is null or undefined for layout ${layout.name}`);
        }
        const isVisible = frameProps.isVisible?.value === true;
        if (isVisible) {
          const frameName = frameIdToNameMap.get(frameProps.id) || null;
          if (!frameName) {
            raiseError2(new Error(`Failed to get frame name for frame ID ${frameProps.id}`));
            throw new Error(`Failed to get frame name for frame ID ${frameProps.id}`);
          }
          visibleFramesWithOverrides.push({
            id: frameProps.id,
            x: frameProps.x.value,
            y: frameProps.y.value,
            width: frameProps.width.value,
            height: frameProps.height.value,
            isVisible: frameProps.isVisible,
            rotationDegrees: frameProps.rotationDegrees.value,
            name: frameName
          });
        }
      }
      if (visibleFramesWithOverrides.length > 0) {
        layoutFramesData[layout.name] = visibleFramesWithOverrides;
      }
    }
    const script = magicLayoutScript.toString().replace('"%DATA1%"', JSON.stringify(childLayoutSizes)).replace('"%DATA2%"', JSON.stringify(layoutFramesData)).replace('"%DATA3%"', JSON.stringify(muggleToMagicLayouts)) + `
magicLayoutScript(false)`;
    const updateResult = await updateAction({
      name: "AUTO_GEN_MAGIC_LAYOUT",
      studio: window.SDK
    }, {
      name: "AUTO_GEN_MAGIC_LAYOUT",
      triggers: [
        ...magicVariables.map((variable) => ({
          event: import_studio_sdk3.ActionEditorEvent.variableValueChanged,
          triggers: [variable.id]
        })),
        { event: import_studio_sdk3.ActionEditorEvent.selectedLayoutChanged },
        { event: import_studio_sdk3.ActionEditorEvent.documentLoaded }
      ],
      script
    });
    return updateResult;
  };
  import_react274.useEffect(() => {
    if (!opened) {
      setIsProcessing(true);
      setIsComplete(false);
      return;
    }
    const executeMagic = async () => {
      try {
        await runMagicProcess();
        setIsProcessing(false);
        setIsComplete(true);
      } catch (error40) {
        console.error("Magic process failed:", error40);
        setIsProcessing(false);
      }
    };
    executeMagic();
  }, [opened]);
  const handleClose = () => {
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime29.jsx(Modal, {
    opened,
    onClose: handleClose,
    title: "Magic Layouts",
    centered: true,
    size: "md",
    closeOnClickOutside: false,
    closeOnEscape: false,
    children: /* @__PURE__ */ jsx_runtime29.jsx(Stack, {
      align: "center",
      gap: "lg",
      p: "lg",
      children: isProcessing ? /* @__PURE__ */ jsx_runtime29.jsxs(jsx_runtime29.Fragment, {
        children: [
          /* @__PURE__ */ jsx_runtime29.jsx(Loader, {
            size: "lg",
            color: "purple"
          }),
          /* @__PURE__ */ jsx_runtime29.jsx(Text, {
            size: "lg",
            fw: 500,
            children: "Creating Magic ✨"
          })
        ]
      }) : /* @__PURE__ */ jsx_runtime29.jsxs(jsx_runtime29.Fragment, {
        children: [
          /* @__PURE__ */ jsx_runtime29.jsx(Text, {
            size: "lg",
            fw: 500,
            c: "green",
            children: "Magic Created ✨"
          }),
          /* @__PURE__ */ jsx_runtime29.jsx(Button, {
            onClick: handleClose,
            color: "purple",
            size: "md",
            disabled: !isComplete,
            children: "Close"
          })
        ]
      })
    })
  });
}

// src/components/ConnectorCleanupModal.tsx
var import_react275 = __toESM(require_react(), 1);
var jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
function ConnectorCleanupModal({
  opened,
  onClose
}) {
  const [connectors, setConnectors] = import_react275.useState([]);
  const [selectedConnectors, setSelectedConnectors] = import_react275.useState(new Set);
  const [isLoading, setIsLoading] = import_react275.useState(false);
  const [isDeleting, setIsDeleting] = import_react275.useState(false);
  const [isMergeModalOpen, setIsMergeModalOpen] = import_react275.useState(false);
  const [mergeTargetId, setMergeTargetId] = import_react275.useState(null);
  const [isMerging, setIsMerging] = import_react275.useState(false);
  const { raiseError: raiseError2 } = useAppStore();
  import_react275.useEffect(() => {
    if (opened) {
      loadConnectors();
    }
  }, [opened]);
  const loadConnectors = async () => {
    setIsLoading(true);
    setSelectedConnectors(new Set);
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const connectorsResult = await getCurrentConnectors(studioResult.value);
      if (!connectorsResult.isOk()) {
        raiseError2(new Error(connectorsResult.error?.message || "Failed to load connectors"));
        return;
      }
      setConnectors(connectorsResult.value);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    } finally {
      setIsLoading(false);
    }
  };
  const handleConnectorToggle = (connectorId) => {
    const newSelected = new Set(selectedConnectors);
    if (newSelected.has(connectorId)) {
      newSelected.delete(connectorId);
    } else {
      newSelected.add(connectorId);
    }
    setSelectedConnectors(newSelected);
  };
  const handleSelectAll = () => {
    if (selectedConnectors.size === connectors.length) {
      setSelectedConnectors(new Set);
    } else {
      setSelectedConnectors(new Set(connectors.map((c2) => c2.id)));
    }
  };
  const handleDeleteSelected = async () => {
    if (selectedConnectors.size === 0)
      return;
    setIsDeleting(true);
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const studio2 = studioResult.value;
      const selectedIds = Array.from(selectedConnectors);
      for (const connectorId of selectedIds) {
        const result = await unregisterConnector(studio2, connectorId);
        if (!result.isOk()) {
          raiseError2(new Error(`Failed to delete connector ${connectorId}: ${result.error?.message}`));
        }
      }
      await loadConnectors();
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    } finally {
      setIsDeleting(false);
    }
  };
  const handleMergeConnectors = () => {
    if (selectedConnectors.size < 2)
      return;
    setMergeTargetId(null);
    setIsMergeModalOpen(true);
  };
  const handleMergeCancel = () => {
    setIsMergeModalOpen(false);
    setMergeTargetId(null);
  };
  const handleMergeConfirm = async () => {
    if (!mergeTargetId || selectedConnectors.size < 2)
      return;
    setIsMerging(true);
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const studio2 = studioResult.value;
      const selectedIds = Array.from(selectedConnectors);
      const result = await mergeConnectors(studio2, mergeTargetId, selectedIds);
      if (!result.isOk()) {
        raiseError2(new Error(result.error?.message || "Failed to merge connectors"));
        return;
      }
      setIsMergeModalOpen(false);
      setMergeTargetId(null);
      await loadConnectors();
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    } finally {
      setIsMerging(false);
    }
  };
  const formatUsageCount = (usage) => {
    const imageCount = usage.images.length;
    const variableCount = usage.variables.length;
    if (imageCount === 0 && variableCount === 0) {
      return "None";
    }
    const parts = [];
    if (imageCount > 0)
      parts.push(`${imageCount} frame${imageCount !== 1 ? "s" : ""}`);
    if (variableCount > 0)
      parts.push(`${variableCount} variable${variableCount !== 1 ? "s" : ""}`);
    return parts.join(", ");
  };
  const hasSelectedConnectors = selectedConnectors.size > 0;
  const isAllSelected = selectedConnectors.size === connectors.length && connectors.length > 0;
  return /* @__PURE__ */ jsx_runtime30.jsxs(jsx_runtime30.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime30.jsx(Modal, {
        opened,
        onClose,
        title: "Connector Cleanup",
        size: "xl",
        centered: true,
        children: /* @__PURE__ */ jsx_runtime30.jsxs(Stack, {
          children: [
            /* @__PURE__ */ jsx_runtime30.jsx(Text, {
              size: "sm",
              c: "dimmed",
              children: "Manage and remove unused connectors from your document."
            }),
            isLoading ? /* @__PURE__ */ jsx_runtime30.jsxs(Group, {
              justify: "center",
              p: "xl",
              children: [
                /* @__PURE__ */ jsx_runtime30.jsx(Loader, {
                  size: "md"
                }),
                /* @__PURE__ */ jsx_runtime30.jsx(Text, {
                  children: "Loading connectors..."
                })
              ]
            }) : /* @__PURE__ */ jsx_runtime30.jsx(jsx_runtime30.Fragment, {
              children: connectors.length === 0 ? /* @__PURE__ */ jsx_runtime30.jsx(Alert, {
                icon: /* @__PURE__ */ jsx_runtime30.jsx(IconAlertCircle, {
                  size: 16
                }),
                color: "blue",
                children: "No connectors found in this document."
              }) : /* @__PURE__ */ jsx_runtime30.jsxs(jsx_runtime30.Fragment, {
                children: [
                  /* @__PURE__ */ jsx_runtime30.jsxs(Group, {
                    justify: "space-between",
                    children: [
                      /* @__PURE__ */ jsx_runtime30.jsxs(Group, {
                        children: [
                          /* @__PURE__ */ jsx_runtime30.jsxs(Button, {
                            onClick: handleDeleteSelected,
                            disabled: !hasSelectedConnectors || isDeleting || isMerging,
                            color: "red",
                            loading: isDeleting,
                            children: [
                              "Delete Selected (",
                              selectedConnectors.size,
                              ")"
                            ]
                          }),
                          /* @__PURE__ */ jsx_runtime30.jsx(Button, {
                            onClick: handleMergeConnectors,
                            disabled: selectedConnectors.size < 2 || isDeleting || isMerging,
                            color: "blue",
                            variant: "outline",
                            children: "Merge Connectors"
                          })
                        ]
                      }),
                      /* @__PURE__ */ jsx_runtime30.jsx(Checkbox, {
                        label: `Select All (${connectors.length})`,
                        checked: isAllSelected,
                        indeterminate: hasSelectedConnectors && !isAllSelected,
                        onChange: handleSelectAll,
                        disabled: isDeleting || isMerging
                      })
                    ]
                  }),
                  /* @__PURE__ */ jsx_runtime30.jsx(ScrollArea, {
                    h: 400,
                    children: /* @__PURE__ */ jsx_runtime30.jsxs(Table, {
                      striped: true,
                      highlightOnHover: true,
                      children: [
                        /* @__PURE__ */ jsx_runtime30.jsx(Table.Thead, {
                          children: /* @__PURE__ */ jsx_runtime30.jsxs(Table.Tr, {
                            children: [
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Th, {
                                w: 50
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Th, {
                                children: "Name"
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Th, {
                                children: "Type"
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Th, {
                                children: "ID"
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Th, {
                                children: "Usage"
                              })
                            ]
                          })
                        }),
                        /* @__PURE__ */ jsx_runtime30.jsx(Table.Tbody, {
                          children: connectors.map((connector) => /* @__PURE__ */ jsx_runtime30.jsxs(Table.Tr, {
                            children: [
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Td, {
                                children: /* @__PURE__ */ jsx_runtime30.jsx(Checkbox, {
                                  checked: selectedConnectors.has(connector.id),
                                  onChange: () => handleConnectorToggle(connector.id),
                                  disabled: isDeleting
                                })
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Td, {
                                children: connector.name
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Td, {
                                children: /* @__PURE__ */ jsx_runtime30.jsx(Text, {
                                  tt: "capitalize",
                                  children: connector.type
                                })
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Td, {
                                children: /* @__PURE__ */ jsx_runtime30.jsx(Text, {
                                  size: "xs",
                                  c: "dimmed",
                                  ff: "monospace",
                                  children: connector.id
                                })
                              }),
                              /* @__PURE__ */ jsx_runtime30.jsx(Table.Td, {
                                children: /* @__PURE__ */ jsx_runtime30.jsx(Text, {
                                  size: "sm",
                                  children: formatUsageCount(connector.usesInTemplate)
                                })
                              })
                            ]
                          }, connector.id))
                        })
                      ]
                    })
                  })
                ]
              })
            }),
            /* @__PURE__ */ jsx_runtime30.jsx(Group, {
              justify: "flex-end",
              children: /* @__PURE__ */ jsx_runtime30.jsx(Button, {
                onClick: onClose,
                variant: "outline",
                children: "Close"
              })
            })
          ]
        })
      }),
      /* @__PURE__ */ jsx_runtime30.jsx(Modal, {
        opened: isMergeModalOpen,
        onClose: handleMergeCancel,
        title: "Merge All Connectors together",
        centered: true,
        size: "md",
        children: /* @__PURE__ */ jsx_runtime30.jsxs(Stack, {
          children: [
            /* @__PURE__ */ jsx_runtime30.jsx(Text, {
              size: "sm",
              c: "dimmed",
              children: "Select the connector to merge all selected connectors into. The other connectors will be removed and all references will be updated."
            }),
            /* @__PURE__ */ jsx_runtime30.jsxs(Stack, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime30.jsx(Text, {
                  fw: 500,
                  children: "Merge into:"
                }),
                /* @__PURE__ */ jsx_runtime30.jsx(Select, {
                  placeholder: "Select target connector",
                  data: Array.from(selectedConnectors).map((id) => {
                    const connector = connectors.find((c2) => c2.id === id);
                    return {
                      value: id,
                      label: connector ? `${connector.name} (${id})` : id
                    };
                  }),
                  value: mergeTargetId,
                  onChange: setMergeTargetId,
                  disabled: isMerging
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime30.jsxs(Group, {
              justify: "flex-end",
              mt: "md",
              children: [
                /* @__PURE__ */ jsx_runtime30.jsx(Button, {
                  onClick: handleMergeCancel,
                  variant: "outline",
                  disabled: isMerging,
                  children: "Cancel"
                }),
                /* @__PURE__ */ jsx_runtime30.jsx(Button, {
                  onClick: handleMergeConfirm,
                  disabled: !mergeTargetId || isMerging,
                  loading: isMerging,
                  color: "blue",
                  children: "Merge"
                })
              ]
            })
          ]
        })
      })
    ]
  });
}

// src/components/ManualCropManager/ManualCropManagerModal.tsx
var import_react281 = __toESM(require_react(), 1);

// src/components/ManualCropManager/LayoutViewer.tsx
var import_react276 = __toESM(require_react(), 1);
init_getManualCropsFromDocByConnector();
var jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
function LayoutViewer({
  selectedLayoutIds,
  onSelectionChange,
  selectedConnectorId,
  onRefreshFunctionReady
}) {
  const [layouts, setLayouts] = import_react276.useState([]);
  const [searchQuery, setSearchQuery] = import_react276.useState("");
  const [isLoading, setIsLoading] = import_react276.useState(true);
  const [expandedLayouts, setExpandedLayouts] = import_react276.useState(new Set);
  const [isInitialized, setIsInitialized] = import_react276.useState(false);
  const [activeFilters, setActiveFilters] = import_react276.useState([]);
  const [isFilterPopoverOpen, setIsFilterPopoverOpen] = import_react276.useState(false);
  const raiseError2 = appStore((store) => store.raiseError);
  import_react276.useEffect(() => {
    const storedExpanded = sessionStorage.getItem("tempManualCropManager_layoutsExpanded");
    if (storedExpanded) {
      try {
        const expandedIds = JSON.parse(storedExpanded);
        setExpandedLayouts(new Set(expandedIds));
      } catch (error40) {
        setExpandedLayouts(new Set);
      }
    }
    setIsInitialized(true);
  }, []);
  import_react276.useEffect(() => {
    const storedFilters = localStorage.getItem("tempManualCropManager_layoutViewerFilters");
    if (storedFilters) {
      try {
        const filters = JSON.parse(storedFilters);
        setActiveFilters(filters);
      } catch (error40) {
        setActiveFilters([]);
      }
    }
  }, []);
  import_react276.useEffect(() => {
    loadLayouts();
  }, []);
  import_react276.useEffect(() => {
    if (isInitialized) {
      const expandedIds = Array.from(expandedLayouts);
      sessionStorage.setItem("tempManualCropManager_layoutsExpanded", JSON.stringify(expandedIds));
    }
  }, [expandedLayouts, isInitialized]);
  import_react276.useEffect(() => {
    localStorage.setItem("tempManualCropManager_layoutViewerFilters", JSON.stringify(activeFilters));
  }, [activeFilters]);
  import_react276.useEffect(() => {
    if (selectedConnectorId) {
      updateManualCropIndicators();
    }
  }, [selectedConnectorId]);
  const loadLayouts = async () => {
    try {
      setIsLoading(true);
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error("Failed to get studio: " + studioResult.error?.message));
        return;
      }
      const layoutsResult = await getAllLayouts(studioResult.value);
      if (!layoutsResult.isOk()) {
        raiseError2(new Error("Failed to load layouts: " + layoutsResult.error?.message));
        return;
      }
      const layoutsData = layoutsResult.value;
      const layoutNodes = buildLayoutTree(layoutsData);
      setLayouts(layoutNodes);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to load layouts"));
    } finally {
      setIsLoading(false);
    }
  };
  const updateManualCropIndicators = import_react276.useCallback(async () => {
    if (!selectedConnectorId)
      return;
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error("Failed to get studio: " + studioResult.error?.message));
        return;
      }
      const cropsResult = await getManualCropsFromDocByConnector(studioResult.value, selectedConnectorId);
      if (cropsResult.isError()) {
        raiseError2(new Error(`Failed to load manual crops: ${cropsResult.error?.message}`));
        return;
      }
      if (!cropsResult.isOk()) {
        raiseError2(new Error("Failed to load manual crops: Invalid result"));
        return;
      }
      const cropsData = cropsResult.value;
      const layoutsWithCrops = new Set(cropsData.layouts.map((l2) => l2.id));
      setLayouts((prevLayouts) => updateLayoutCropIndicators(prevLayouts, layoutsWithCrops));
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to update manual crop indicators"));
    }
  }, [selectedConnectorId, raiseError2]);
  import_react276.useEffect(() => {
    if (onRefreshFunctionReady) {
      onRefreshFunctionReady(updateManualCropIndicators);
    }
  }, [onRefreshFunctionReady, updateManualCropIndicators]);
  const updateLayoutCropIndicators = (layouts2, layoutsWithCrops) => {
    return layouts2.map((layout) => ({
      ...layout,
      hasManualCrops: layoutsWithCrops.has(layout.id),
      children: updateLayoutCropIndicators(layout.children, layoutsWithCrops)
    }));
  };
  const buildLayoutTree = (layouts2) => {
    const layoutMap = new Map;
    const rootLayouts = [];
    layouts2.forEach((layout) => {
      layoutMap.set(layout.id, {
        id: layout.id,
        name: layout.name,
        parentId: layout.parentId,
        children: [],
        isExpanded: false,
        hasManualCrops: false,
        level: 0,
        isVisible: layout.availableForUser !== false,
        isFilteredParent: false
      });
    });
    layouts2.forEach((layout) => {
      const node2 = layoutMap.get(layout.id);
      if (layout.parentId) {
        const parent = layoutMap.get(layout.parentId);
        if (parent) {
          parent.children.push(node2);
          node2.level = parent.level + 1;
        }
      } else {
        rootLayouts.push(node2);
      }
    });
    return rootLayouts;
  };
  const applyFilters = (layouts2, filters) => {
    const hasVisibleFilter = filters.includes("Visible");
    const hasManualCropsFilter = filters.includes("With Manual Crops");
    const filterLayouts = (layouts3) => {
      return layouts3.reduce((acc, layout) => {
        const filteredChildren = filterLayouts(layout.children);
        let matchesFilters = true;
        if (hasVisibleFilter && !layout.isVisible) {
          matchesFilters = false;
        }
        if (hasManualCropsFilter && !layout.hasManualCrops) {
          matchesFilters = false;
        }
        if (matchesFilters || filteredChildren.length > 0) {
          acc.push({
            ...layout,
            children: filteredChildren,
            isFilteredParent: !matchesFilters && filteredChildren.length > 0
          });
        }
        return acc;
      }, []);
    };
    return filterLayouts(layouts2);
  };
  const filteredLayouts = import_react276.useMemo(() => {
    let processedLayouts = layouts;
    if (activeFilters.length > 0) {
      processedLayouts = applyFilters(layouts, activeFilters);
    }
    if (!searchQuery.trim())
      return processedLayouts;
    const filterLayouts = (layouts2) => {
      return layouts2.reduce((acc, layout) => {
        const matchesSearch = layout.name.toLowerCase().includes(searchQuery.toLowerCase());
        const filteredChildren = filterLayouts(layout.children);
        if (matchesSearch || filteredChildren.length > 0) {
          acc.push({
            ...layout,
            children: filteredChildren,
            isExpanded: filteredChildren.length > 0 ? true : layout.isExpanded
          });
        }
        return acc;
      }, []);
    };
    return filterLayouts(processedLayouts);
  }, [layouts, searchQuery, activeFilters]);
  const toggleLayoutExpanded = (layoutId) => {
    setExpandedLayouts((prev2) => {
      const newSet = new Set(prev2);
      if (newSet.has(layoutId)) {
        newSet.delete(layoutId);
      } else {
        newSet.add(layoutId);
      }
      return newSet;
    });
  };
  const expandAll = () => {
    const allLayoutIds = new Set;
    const collectIds = (layouts2) => {
      layouts2.forEach((layout) => {
        if (layout.children.length > 0) {
          allLayoutIds.add(layout.id);
        }
        collectIds(layout.children);
      });
    };
    collectIds(layouts);
    setExpandedLayouts(allLayoutIds);
  };
  const collapseAll = () => {
    setExpandedLayouts(new Set);
  };
  const deselectAll = () => {
    onSelectionChange([]);
  };
  const toggleLayoutSelection = (layoutId) => {
    const newSelection = selectedLayoutIds.includes(layoutId) ? selectedLayoutIds.filter((id) => id !== layoutId) : [...selectedLayoutIds, layoutId];
    onSelectionChange(newSelection);
  };
  const toggleChildrenSelection = (layout) => {
    const allChildIds = getAllChildIds(layout);
    const allChildrenSelected = allChildIds.every((id) => selectedLayoutIds.includes(id));
    if (allChildrenSelected) {
      const newSelection = selectedLayoutIds.filter((id) => !allChildIds.includes(id));
      onSelectionChange(newSelection);
    } else {
      const newSelection = [...new Set([...selectedLayoutIds, ...allChildIds])];
      onSelectionChange(newSelection);
    }
  };
  const getAllChildIds = (layout) => {
    const childIds = [];
    const collectIds = (node2) => {
      childIds.push(node2.id);
      node2.children.forEach(collectIds);
    };
    layout.children.forEach(collectIds);
    return childIds;
  };
  const getCheckboxState = (layout) => {
    if (layout.children.length === 0)
      return "unchecked";
    const allChildIds = getAllChildIds(layout);
    const selectedChildIds = allChildIds.filter((id) => selectedLayoutIds.includes(id));
    if (selectedChildIds.length === 0)
      return "unchecked";
    if (selectedChildIds.length === allChildIds.length)
      return "checked";
    return "indeterminate";
  };
  if (isLoading) {
    return /* @__PURE__ */ jsx_runtime31.jsx(Center, {
      style: { height: "100%" },
      children: /* @__PURE__ */ jsx_runtime31.jsx(Loader, {
        size: "sm"
      })
    });
  }
  return /* @__PURE__ */ jsx_runtime31.jsxs(Box, {
    style: { height: "100%", display: "flex", flexDirection: "column" },
    children: [
      /* @__PURE__ */ jsx_runtime31.jsx(Box, {
        p: "md",
        style: { borderBottom: "1px solid var(--mantine-color-gray-3)" },
        children: /* @__PURE__ */ jsx_runtime31.jsxs(Stack, {
          gap: "xs",
          children: [
            /* @__PURE__ */ jsx_runtime31.jsx(TextInput, {
              placeholder: "Search layouts...",
              value: searchQuery,
              onChange: (e) => setSearchQuery(e.target.value),
              leftSection: /* @__PURE__ */ jsx_runtime31.jsx(IconSearch, {
                size: 16
              }),
              size: "sm"
            }),
            /* @__PURE__ */ jsx_runtime31.jsxs(Group, {
              gap: "xs",
              children: [
                /* @__PURE__ */ jsx_runtime31.jsx(Button, {
                  variant: "subtle",
                  size: "xs",
                  onClick: expandAll,
                  children: "Expand All"
                }),
                /* @__PURE__ */ jsx_runtime31.jsx(Button, {
                  variant: "subtle",
                  size: "xs",
                  onClick: collapseAll,
                  children: "Collapse All"
                }),
                /* @__PURE__ */ jsx_runtime31.jsx(Button, {
                  variant: "subtle",
                  size: "xs",
                  onClick: deselectAll,
                  children: "Deselect All"
                }),
                /* @__PURE__ */ jsx_runtime31.jsxs(Popover, {
                  opened: isFilterPopoverOpen,
                  onClose: () => setIsFilterPopoverOpen(false),
                  position: "bottom-start",
                  withArrow: true,
                  children: [
                    /* @__PURE__ */ jsx_runtime31.jsx(Popover.Target, {
                      children: /* @__PURE__ */ jsx_runtime31.jsx(Tooltip, {
                        label: "Filter",
                        position: "top",
                        children: /* @__PURE__ */ jsx_runtime31.jsx(ActionIcon, {
                          variant: "subtle",
                          size: "xs",
                          onClick: () => setIsFilterPopoverOpen(!isFilterPopoverOpen),
                          color: activeFilters.length > 0 ? "yellow" : "gray",
                          children: activeFilters.length > 0 ? /* @__PURE__ */ jsx_runtime31.jsx(IconFilterFilled, {
                            size: 14
                          }) : /* @__PURE__ */ jsx_runtime31.jsx(IconFilter, {
                            size: 14
                          })
                        })
                      })
                    }),
                    /* @__PURE__ */ jsx_runtime31.jsx(Popover.Dropdown, {
                      children: /* @__PURE__ */ jsx_runtime31.jsx(MultiSelect, {
                        label: "Filter layouts",
                        placeholder: "Select filters",
                        data: [
                          { value: "Visible", label: "Visible" },
                          { value: "With Manual Crops", label: "With Manual Crops" }
                        ],
                        value: activeFilters,
                        onChange: setActiveFilters,
                        size: "sm",
                        style: { minWidth: 200 }
                      })
                    })
                  ]
                })
              ]
            })
          ]
        })
      }),
      /* @__PURE__ */ jsx_runtime31.jsx(ScrollArea, {
        style: { flex: 1 },
        children: /* @__PURE__ */ jsx_runtime31.jsx(Box, {
          p: "md",
          children: /* @__PURE__ */ jsx_runtime31.jsx(LayoutTree, {
            layouts: filteredLayouts,
            selectedLayoutIds,
            expandedLayouts,
            onToggleExpanded: toggleLayoutExpanded,
            onToggleSelection: toggleLayoutSelection,
            onToggleChildrenSelection: toggleChildrenSelection,
            getCheckboxState
          })
        })
      })
    ]
  });
}
function LayoutTree({
  layouts,
  selectedLayoutIds,
  expandedLayouts,
  onToggleExpanded,
  onToggleSelection,
  onToggleChildrenSelection,
  getCheckboxState
}) {
  return /* @__PURE__ */ jsx_runtime31.jsx(Stack, {
    gap: "xs",
    children: layouts.map((layout) => /* @__PURE__ */ jsx_runtime31.jsx(LayoutTreeItem, {
      layout,
      selectedLayoutIds,
      expandedLayouts,
      onToggleExpanded,
      onToggleSelection,
      onToggleChildrenSelection,
      getCheckboxState
    }, layout.id))
  });
}
function LayoutTreeItem({
  layout,
  selectedLayoutIds,
  expandedLayouts,
  onToggleExpanded,
  onToggleSelection,
  onToggleChildrenSelection,
  getCheckboxState
}) {
  const hasChildren = layout.children.length > 0;
  const isExpanded = expandedLayouts.has(layout.id);
  const isSelected = selectedLayoutIds.includes(layout.id);
  const checkboxState = getCheckboxState(layout);
  const isFilteredParent = layout.isFilteredParent || false;
  return /* @__PURE__ */ jsx_runtime31.jsxs(Box, {
    children: [
      /* @__PURE__ */ jsx_runtime31.jsxs(Group, {
        gap: "xs",
        style: {
          marginLeft: layout.level * 10,
          padding: "4px 8px",
          borderRadius: "4px",
          backgroundColor: isSelected ? "var(--mantine-color-blue-1)" : "transparent",
          opacity: isFilteredParent ? 0.5 : 1
        },
        children: [
          hasChildren ? /* @__PURE__ */ jsx_runtime31.jsx(ActionIcon, {
            variant: "subtle",
            size: "xs",
            onClick: (e) => {
              e.stopPropagation();
              onToggleExpanded(layout.id);
            },
            children: isExpanded ? /* @__PURE__ */ jsx_runtime31.jsx(IconChevronDown, {
              size: 12
            }) : /* @__PURE__ */ jsx_runtime31.jsx(IconChevronRight, {
              size: 12
            })
          }) : /* @__PURE__ */ jsx_runtime31.jsx(Box, {
            style: { width: 20 }
          }),
          hasChildren && /* @__PURE__ */ jsx_runtime31.jsx(Checkbox, {
            checked: checkboxState === "checked",
            indeterminate: checkboxState === "indeterminate",
            onChange: () => onToggleChildrenSelection(layout),
            size: "sm",
            onClick: (e) => e.stopPropagation(),
            disabled: isFilteredParent
          }),
          isFilteredParent ? /* @__PURE__ */ jsx_runtime31.jsx(IconEyeClosed, {
            size: 14,
            color: "gray"
          }) : /* @__PURE__ */ jsx_runtime31.jsx(IconCrop, {
            size: 14,
            color: layout.hasManualCrops ? "orange" : "gray"
          }),
          /* @__PURE__ */ jsx_runtime31.jsx(Text, {
            size: "sm",
            style: {
              flex: 1,
              cursor: isFilteredParent ? "default" : "pointer",
              color: layout.hasManualCrops ? "orange" : undefined
            },
            onClick: isFilteredParent ? undefined : () => onToggleSelection(layout.id),
            children: layout.name
          })
        ]
      }),
      hasChildren && isExpanded && /* @__PURE__ */ jsx_runtime31.jsx(LayoutTree, {
        layouts: layout.children,
        selectedLayoutIds,
        expandedLayouts,
        onToggleExpanded,
        onToggleSelection,
        onToggleChildrenSelection,
        getCheckboxState
      })
    ]
  });
}

// src/components/ManualCropManager/ManualCropEditor.tsx
var import_react280 = __toESM(require_react(), 1);
init_documentHandler();
init_getManualCropsFromDocByConnector();

// src/studio-adapter/setManualCropsForLayout.ts
init_dist();
function setManualCropsForLayout(documentState, layoutId, connectorId, manualCrops) {
  try {
    const updatedDocumentState = JSON.parse(JSON.stringify(documentState));
    console.log("Updated document state:", updatedDocumentState);
    const layout = updatedDocumentState.layouts?.find((l2) => l2.id === layoutId);
    if (!layout) {
      return Result.error(new Error(`Layout with ID ${layoutId} not found`));
    }
    if (!layout.frameProperties) {
      layout.frameProperties = [];
    }
    for (const manualCrop of manualCrops) {
      let frameProperty = layout.frameProperties.find((fp) => fp.id === manualCrop.frameId);
      if (!frameProperty) {
        frameProperty = {
          id: manualCrop.frameId,
          type: "child",
          perAssetCrop: {}
        };
        layout.frameProperties.push(frameProperty);
      }
      if (!frameProperty.perAssetCrop) {
        frameProperty.perAssetCrop = {};
      }
      if (!frameProperty.perAssetCrop[connectorId]) {
        frameProperty.perAssetCrop[connectorId] = {};
      }
      frameProperty.perAssetCrop[connectorId][manualCrop.name] = {
        left: manualCrop.left,
        top: manualCrop.top,
        width: manualCrop.width,
        height: manualCrop.height,
        rotationDegrees: manualCrop.rotationDegrees,
        originalParentWidth: manualCrop.originalParentWidth,
        originalParentHeight: manualCrop.originalParentHeight
      };
    }
    return Result.ok(updatedDocumentState);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error("Failed to set manual crops for layout"));
  }
}

// src/studio-adapter/deleteManualCropsForLayout.ts
init_dist();
function deleteSingleManualCropForLayout(documentState, layoutId, connectorId, frameId, assetName) {
  try {
    const updatedDocumentState = JSON.parse(JSON.stringify(documentState));
    const layout = updatedDocumentState.layouts?.find((l2) => l2.id === layoutId);
    if (!layout) {
      return Result.error(new Error(`Layout with ID ${layoutId} not found`));
    }
    const frameProperty = layout.frameProperties?.find((fp) => fp.id === frameId);
    if (!frameProperty) {
      return Result.error(new Error(`Frame with ID ${frameId} not found in layout ${layoutId}`));
    }
    if (!frameProperty.perAssetCrop || !frameProperty.perAssetCrop[connectorId]) {
      return Result.error(new Error(`No crops found for connector ${connectorId} in frame ${frameId}`));
    }
    if (!frameProperty.perAssetCrop[connectorId][assetName]) {
      return Result.error(new Error(`Asset ${assetName} not found for connector ${connectorId} in frame ${frameId}`));
    }
    delete frameProperty.perAssetCrop[connectorId][assetName];
    if (Object.keys(frameProperty.perAssetCrop[connectorId]).length === 0) {
      delete frameProperty.perAssetCrop[connectorId];
    }
    if (Object.keys(frameProperty.perAssetCrop).length === 0) {
      delete frameProperty.perAssetCrop;
    }
    return Result.ok(updatedDocumentState);
  } catch (error40) {
    return Result.error(error40 instanceof Error ? error40 : new Error("Failed to delete single manual crop for layout"));
  }
}

// src/components/ManualCropManager/CopyCropToLayerModal.tsx
var import_react277 = __toESM(require_react(), 1);
init_getManualCropsFromDocByConnector();
var jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
function CopyCropToLayerModal({
  opened,
  onClose,
  sourceLayoutId,
  checkedCrops,
  selectedConnectorId,
  onCopy
}) {
  const [layouts, setLayouts] = import_react277.useState([]);
  const [searchQuery, setSearchQuery] = import_react277.useState("");
  const [isLoading, setIsLoading] = import_react277.useState(true);
  const [expandedLayouts, setExpandedLayouts] = import_react277.useState(new Set);
  const [selectedLayoutIds, setSelectedLayoutIds] = import_react277.useState([]);
  const raiseError2 = appStore((store) => store.raiseError);
  import_react277.useEffect(() => {
    if (opened) {
      loadLayouts();
      setSelectedLayoutIds([]);
      setSearchQuery("");
    }
  }, [opened]);
  import_react277.useEffect(() => {
    if (selectedConnectorId && opened) {
      updateManualCropIndicators();
    }
  }, [selectedConnectorId, opened]);
  const loadLayouts = async () => {
    try {
      setIsLoading(true);
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error("Failed to get studio: " + studioResult.error?.message));
        return;
      }
      const layoutsResult = await getAllLayouts(studioResult.value);
      if (!layoutsResult.isOk()) {
        raiseError2(new Error("Failed to load layouts: " + layoutsResult.error?.message));
        return;
      }
      const layoutsData = layoutsResult.value;
      const layoutNodes = buildLayoutTree(layoutsData);
      setLayouts(layoutNodes);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to load layouts"));
    } finally {
      setIsLoading(false);
    }
  };
  const updateManualCropIndicators = async () => {
    if (!selectedConnectorId)
      return;
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error("Failed to get studio: " + studioResult.error?.message));
        return;
      }
      const cropsResult = await getManualCropsFromDocByConnector(studioResult.value, selectedConnectorId);
      if (cropsResult.isError()) {
        raiseError2(new Error(`Failed to load manual crops: ${cropsResult.error?.message}`));
        return;
      }
      if (!cropsResult.isOk()) {
        raiseError2(new Error("Failed to load manual crops: Invalid result"));
        return;
      }
      const cropsData = cropsResult.value;
      const layoutsWithCrops = new Set(cropsData.layouts.map((l2) => l2.id));
      setLayouts((prevLayouts) => updateLayoutCropIndicators(prevLayouts, layoutsWithCrops));
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to update manual crop indicators"));
    }
  };
  const updateLayoutCropIndicators = (layouts2, layoutsWithCrops) => {
    return layouts2.map((layout) => ({
      ...layout,
      hasManualCrops: layoutsWithCrops.has(layout.id),
      children: updateLayoutCropIndicators(layout.children, layoutsWithCrops)
    }));
  };
  const buildLayoutTree = (layouts2) => {
    const layoutMap = new Map;
    const rootLayouts = [];
    layouts2.forEach((layout) => {
      layoutMap.set(layout.id, {
        id: layout.id,
        name: layout.name,
        parentId: layout.parentId,
        children: [],
        isExpanded: false,
        hasManualCrops: false,
        level: 0
      });
    });
    layouts2.forEach((layout) => {
      const node2 = layoutMap.get(layout.id);
      if (layout.parentId) {
        const parent = layoutMap.get(layout.parentId);
        if (parent) {
          parent.children.push(node2);
          node2.level = parent.level + 1;
        }
      } else {
        rootLayouts.push(node2);
      }
    });
    return rootLayouts;
  };
  const filteredLayouts = import_react277.useMemo(() => {
    if (!searchQuery.trim())
      return layouts;
    const filterLayouts = (layouts2) => {
      return layouts2.reduce((acc, layout) => {
        const matchesSearch = layout.name.toLowerCase().includes(searchQuery.toLowerCase());
        const filteredChildren = filterLayouts(layout.children);
        if (matchesSearch || filteredChildren.length > 0) {
          acc.push({
            ...layout,
            children: filteredChildren,
            isExpanded: filteredChildren.length > 0 ? true : layout.isExpanded
          });
        }
        return acc;
      }, []);
    };
    return filterLayouts(layouts);
  }, [layouts, searchQuery]);
  const toggleLayoutExpanded = (layoutId) => {
    setExpandedLayouts((prev2) => {
      const newSet = new Set(prev2);
      if (newSet.has(layoutId)) {
        newSet.delete(layoutId);
      } else {
        newSet.add(layoutId);
      }
      return newSet;
    });
  };
  const expandAll = () => {
    const allLayoutIds = new Set;
    const collectIds = (layouts2) => {
      layouts2.forEach((layout) => {
        if (layout.children.length > 0) {
          allLayoutIds.add(layout.id);
        }
        collectIds(layout.children);
      });
    };
    collectIds(layouts);
    setExpandedLayouts(allLayoutIds);
  };
  const collapseAll = () => {
    setExpandedLayouts(new Set);
  };
  const deselectAll = () => {
    setSelectedLayoutIds([]);
  };
  const toggleLayoutSelection = (layoutId) => {
    if (layoutId === sourceLayoutId)
      return;
    const newSelection = selectedLayoutIds.includes(layoutId) ? selectedLayoutIds.filter((id) => id !== layoutId) : [...selectedLayoutIds, layoutId];
    setSelectedLayoutIds(newSelection);
  };
  const handleCopy = async () => {
    try {
      await onCopy(selectedLayoutIds, checkedCrops);
      onClose();
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to copy crops"));
    }
  };
  if (isLoading) {
    return /* @__PURE__ */ jsx_runtime32.jsx(Modal, {
      opened,
      onClose,
      title: "Copy Crops to Layouts",
      size: "lg",
      children: /* @__PURE__ */ jsx_runtime32.jsx(Center, {
        style: { height: 400 },
        children: /* @__PURE__ */ jsx_runtime32.jsx(Loader, {
          size: "sm"
        })
      })
    });
  }
  return /* @__PURE__ */ jsx_runtime32.jsx(Modal, {
    opened,
    onClose,
    title: "Copy Crops to Layouts",
    size: "lg",
    children: /* @__PURE__ */ jsx_runtime32.jsxs(Box, {
      style: { height: 500, display: "flex", flexDirection: "column" },
      children: [
        /* @__PURE__ */ jsx_runtime32.jsx(Box, {
          p: "md",
          style: { borderBottom: "1px solid var(--mantine-color-gray-3)" },
          children: /* @__PURE__ */ jsx_runtime32.jsxs(Stack, {
            gap: "xs",
            children: [
              /* @__PURE__ */ jsx_runtime32.jsx(TextInput, {
                placeholder: "Search layouts...",
                value: searchQuery,
                onChange: (e) => setSearchQuery(e.target.value),
                leftSection: /* @__PURE__ */ jsx_runtime32.jsx(IconSearch, {
                  size: 16
                }),
                size: "sm"
              }),
              /* @__PURE__ */ jsx_runtime32.jsxs(Group, {
                gap: "xs",
                children: [
                  /* @__PURE__ */ jsx_runtime32.jsx(Button, {
                    variant: "subtle",
                    size: "xs",
                    onClick: expandAll,
                    children: "Expand All"
                  }),
                  /* @__PURE__ */ jsx_runtime32.jsx(Button, {
                    variant: "subtle",
                    size: "xs",
                    onClick: collapseAll,
                    children: "Collapse All"
                  }),
                  /* @__PURE__ */ jsx_runtime32.jsx(Button, {
                    variant: "subtle",
                    size: "xs",
                    onClick: deselectAll,
                    children: "Deselect All"
                  })
                ]
              })
            ]
          })
        }),
        /* @__PURE__ */ jsx_runtime32.jsx(ScrollArea, {
          style: { flex: 1 },
          children: /* @__PURE__ */ jsx_runtime32.jsx(Box, {
            p: "md",
            children: /* @__PURE__ */ jsx_runtime32.jsx(CopyLayoutTree, {
              layouts: filteredLayouts,
              selectedLayoutIds,
              expandedLayouts,
              sourceLayoutId,
              onToggleExpanded: toggleLayoutExpanded,
              onToggleSelection: toggleLayoutSelection
            })
          })
        }),
        /* @__PURE__ */ jsx_runtime32.jsxs(Group, {
          justify: "space-between",
          p: "md",
          style: { borderTop: "1px solid var(--mantine-color-gray-3)" },
          children: [
            /* @__PURE__ */ jsx_runtime32.jsxs(Text, {
              size: "sm",
              children: [
                "Layouts Selected: ",
                selectedLayoutIds.length
              ]
            }),
            /* @__PURE__ */ jsx_runtime32.jsxs(Group, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime32.jsx(Button, {
                  variant: "outline",
                  onClick: onClose,
                  children: "Close"
                }),
                /* @__PURE__ */ jsx_runtime32.jsx(Button, {
                  onClick: handleCopy,
                  disabled: selectedLayoutIds.length === 0,
                  color: "blue",
                  children: "Copy"
                })
              ]
            })
          ]
        })
      ]
    })
  });
}
function CopyLayoutTree({
  layouts,
  selectedLayoutIds,
  expandedLayouts,
  sourceLayoutId,
  onToggleExpanded,
  onToggleSelection
}) {
  return /* @__PURE__ */ jsx_runtime32.jsx(Stack, {
    gap: "xs",
    children: layouts.map((layout) => /* @__PURE__ */ jsx_runtime32.jsx(CopyLayoutTreeItem, {
      layout,
      selectedLayoutIds,
      expandedLayouts,
      sourceLayoutId,
      onToggleExpanded,
      onToggleSelection
    }, layout.id))
  });
}
function CopyLayoutTreeItem({
  layout,
  selectedLayoutIds,
  expandedLayouts,
  sourceLayoutId,
  onToggleExpanded,
  onToggleSelection
}) {
  const hasChildren = layout.children.length > 0;
  const isExpanded = expandedLayouts.has(layout.id);
  const isSelected = selectedLayoutIds.includes(layout.id);
  const isSourceLayout = layout.id === sourceLayoutId;
  return /* @__PURE__ */ jsx_runtime32.jsxs(Box, {
    children: [
      /* @__PURE__ */ jsx_runtime32.jsxs(Group, {
        gap: "xs",
        style: {
          paddingLeft: layout.level * 20,
          padding: "4px 8px",
          borderRadius: "4px",
          backgroundColor: isSelected ? "var(--mantine-color-blue-1)" : isSourceLayout ? "var(--mantine-color-gray-2)" : "transparent",
          opacity: isSourceLayout ? 0.5 : 1
        },
        children: [
          hasChildren ? /* @__PURE__ */ jsx_runtime32.jsx(ActionIcon, {
            variant: "subtle",
            size: "xs",
            onClick: (e) => {
              e.stopPropagation();
              onToggleExpanded(layout.id);
            },
            children: isExpanded ? /* @__PURE__ */ jsx_runtime32.jsx(IconChevronDown, {
              size: 12
            }) : /* @__PURE__ */ jsx_runtime32.jsx(IconChevronRight, {
              size: 12
            })
          }) : /* @__PURE__ */ jsx_runtime32.jsx(Box, {
            style: { width: 20 }
          }),
          /* @__PURE__ */ jsx_runtime32.jsx(IconCrop, {
            size: 14,
            color: layout.hasManualCrops ? "orange" : "gray"
          }),
          /* @__PURE__ */ jsx_runtime32.jsxs(Text, {
            size: "sm",
            style: {
              flex: 1,
              cursor: isSourceLayout ? "not-allowed" : "pointer",
              color: layout.hasManualCrops ? "orange" : undefined
            },
            onClick: () => onToggleSelection(layout.id),
            children: [
              layout.name,
              " ",
              isSourceLayout && "(Source - Cannot Select)"
            ]
          })
        ]
      }),
      hasChildren && isExpanded && /* @__PURE__ */ jsx_runtime32.jsx(CopyLayoutTree, {
        layouts: layout.children,
        selectedLayoutIds,
        expandedLayouts,
        sourceLayoutId,
        onToggleExpanded,
        onToggleSelection
      })
    ]
  });
}

// src/components/ManualCropManager/CopyAndAddRowModal.tsx
var import_react278 = __toESM(require_react(), 1);
var jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
function CopyAndAddRowModal2({
  opened,
  onClose,
  crop,
  layoutId,
  existingCrops,
  onAddCopy
}) {
  const [newName, setNewName] = import_react278.useState("");
  const [error40, setError] = import_react278.useState(null);
  const [isLoading, setIsLoading] = import_react278.useState(false);
  import_react278.default.useEffect(() => {
    if (opened) {
      setNewName(crop.name);
      setError(null);
      setIsLoading(false);
    }
  }, [opened, crop]);
  const handleNameChange = (e) => {
    setNewName(e.target.value);
    setError(null);
  };
  const handleCreate = () => {
    if (!newName.trim()) {
      setError("Name cannot be empty");
      return;
    }
    const nameExists = existingCrops.some((c2) => c2.frameId === crop.frameId && c2.name === newName.trim());
    if (nameExists) {
      setError("Name already exists for this frame");
      return;
    }
    setIsLoading(true);
    onAddCopy(crop, newName.trim());
    setIsLoading(false);
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime33.jsx(Modal, {
    opened,
    onClose,
    title: "Copy and Add Row",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime33.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime33.jsx(Text, {
          size: "sm",
          children: "Enter a name for the new manual crop:"
        }),
        /* @__PURE__ */ jsx_runtime33.jsx(TextInput, {
          label: "Asset Name",
          placeholder: "Enter asset name",
          value: newName,
          onChange: handleNameChange,
          error: error40,
          required: true,
          autoFocus: true
        }),
        /* @__PURE__ */ jsx_runtime33.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime33.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime33.jsx(Button, {
              onClick: handleCreate,
              loading: isLoading,
              disabled: !newName.trim(),
              children: "Create"
            })
          ]
        })
      ]
    })
  });
}

// src/components/ManualCropManager/CopyAndReplaceModal.tsx
var import_react279 = __toESM(require_react(), 1);
var jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
function CopyAndReplaceModal2({
  opened,
  onClose,
  crops,
  layoutId,
  existingCrops,
  onAddCopy
}) {
  const [searchText, setSearchText] = import_react279.useState("");
  const [replaceText, setReplaceText] = import_react279.useState("");
  const [errors3, setErrors] = import_react279.useState({});
  const [isLoading, setIsLoading] = import_react279.useState(false);
  const [previewCrop, setPreviewCrop] = import_react279.useState(null);
  const [previewNewName, setPreviewNewName] = import_react279.useState("");
  const [isPreviewNameDifferent, setIsPreviewNameDifferent] = import_react279.useState(false);
  import_react279.useEffect(() => {
    if (opened) {
      setSearchText("");
      setReplaceText("");
      setErrors({});
      setIsLoading(false);
      if (crops.length > 0) {
        setPreviewCrop(crops[0]);
        setPreviewNewName(crops[0].name);
        setIsPreviewNameDifferent(false);
      }
    }
  }, [opened, crops]);
  import_react279.useEffect(() => {
    if (previewCrop) {
      const newName = previewCrop.name.replace(new RegExp(searchText, "g"), replaceText);
      setPreviewNewName(newName);
      setIsPreviewNameDifferent(newName !== previewCrop.name);
    }
  }, [searchText, replaceText, previewCrop]);
  const handleSearchChange = (e) => {
    setSearchText(e.target.value);
    setErrors({});
  };
  const handleReplaceChange = (e) => {
    setReplaceText(e.target.value);
    setErrors({});
  };
  const handleCopyAndReplace = () => {
    if (!searchText.trim()) {
      setErrors({ searchText: "Search text cannot be empty" });
      return;
    }
    setIsLoading(true);
    const newErrors = {};
    let hasErrors = false;
    crops.forEach((crop) => {
      const newName = crop.name.replace(new RegExp(searchText, "g"), replaceText);
      if (newName === crop.name) {
        return;
      }
      const nameExists = existingCrops.some((c2) => c2.frameId === crop.frameId && c2.name === newName);
      if (nameExists) {
        newErrors[`${crop.frameId}-${crop.name}`] = `Name "${newName}" already exists for frame ${crop.frameName}`;
        hasErrors = true;
      }
    });
    if (hasErrors) {
      setErrors(newErrors);
      setIsLoading(false);
      return;
    }
    crops.forEach((crop) => {
      const newName = crop.name.replace(new RegExp(searchText, "g"), replaceText);
      if (newName === crop.name) {
        return;
      }
      onAddCopy(crop, newName);
    });
    setIsLoading(false);
    onClose();
  };
  return /* @__PURE__ */ jsx_runtime34.jsx(Modal, {
    opened,
    onClose,
    title: "Copy and Replace",
    centered: true,
    children: /* @__PURE__ */ jsx_runtime34.jsxs(Stack, {
      children: [
        /* @__PURE__ */ jsx_runtime34.jsx(Text, {
          size: "sm",
          children: "Enter search and replace text to create copies with modified names:"
        }),
        /* @__PURE__ */ jsx_runtime34.jsx(TextInput, {
          label: "Search",
          placeholder: "Text to search for",
          value: searchText,
          onChange: handleSearchChange,
          error: errors3.searchText,
          required: true,
          autoFocus: true
        }),
        /* @__PURE__ */ jsx_runtime34.jsx(TextInput, {
          label: "Replace",
          placeholder: "Text to replace with",
          value: replaceText,
          onChange: handleReplaceChange,
          required: true
        }),
        previewCrop && /* @__PURE__ */ jsx_runtime34.jsxs(Stack, {
          gap: "xs",
          children: [
            /* @__PURE__ */ jsx_runtime34.jsx(Text, {
              size: "sm",
              fw: 500,
              children: "Preview:"
            }),
            /* @__PURE__ */ jsx_runtime34.jsxs(Text, {
              size: "sm",
              c: "dimmed",
              children: [
                "Frame: ",
                previewCrop.frameName
              ]
            }),
            /* @__PURE__ */ jsx_runtime34.jsxs(Text, {
              size: "sm",
              children: [
                "Original:",
                " ",
                /* @__PURE__ */ jsx_runtime34.jsx(Text, {
                  span: true,
                  c: "blue",
                  children: previewCrop.name
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime34.jsxs(Text, {
              size: "sm",
              children: [
                "New:",
                " ",
                /* @__PURE__ */ jsx_runtime34.jsx(Text, {
                  span: true,
                  c: isPreviewNameDifferent ? "green" : "dimmed",
                  children: previewNewName
                })
              ]
            })
          ]
        }),
        Object.keys(errors3).length > 0 && /* @__PURE__ */ jsx_runtime34.jsx(Alert, {
          color: "red",
          title: "Validation Errors",
          children: /* @__PURE__ */ jsx_runtime34.jsx(Stack, {
            gap: "xs",
            children: Object.entries(errors3).map(([key, message]) => /* @__PURE__ */ jsx_runtime34.jsx(Text, {
              size: "sm",
              children: message
            }, key))
          })
        }),
        /* @__PURE__ */ jsx_runtime34.jsxs(Group, {
          justify: "flex-end",
          mt: "md",
          children: [
            /* @__PURE__ */ jsx_runtime34.jsx(Button, {
              variant: "outline",
              onClick: onClose,
              children: "Cancel"
            }),
            /* @__PURE__ */ jsx_runtime34.jsx(Button, {
              onClick: handleCopyAndReplace,
              loading: isLoading,
              disabled: !searchText.trim() || !isPreviewNameDifferent,
              children: "Copy and Replace"
            })
          ]
        })
      ]
    })
  });
}

// src/components/ManualCropManager/ManualCropEditor.tsx
init_dist();
var jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
function CropRow({
  crop,
  layoutId,
  cropIndex,
  onCropChange,
  isChecked,
  onCheckChange,
  isDeleted
}) {
  const [localCrop, setLocalCrop] = import_react280.useState(crop);
  import_react280.useEffect(() => {
    setLocalCrop(crop);
  }, [crop]);
  const handleFieldChange = (field, value) => {
    let processedValue = value;
    if (field !== "frameName" && field !== "name" && field !== "frameId") {
      if (value === "" || value === "." || value === "-" || value === "-.") {
        processedValue = 0;
      } else if (/^-?\d*\.?\d*$/.test(value)) {
        const numValue = parseFloat(value);
        processedValue = isNaN(numValue) ? 0 : numValue;
      } else {
        processedValue = localCrop[field];
        return;
      }
    }
    const updatedCrop = {
      ...localCrop,
      [field]: processedValue
    };
    setLocalCrop(updatedCrop);
    onCropChange(layoutId, cropIndex, updatedCrop);
  };
  if (isDeleted) {
    return null;
  }
  return /* @__PURE__ */ jsx_runtime35.jsxs(Table.Tr, {
    children: [
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(Checkbox, {
          checked: isChecked,
          onChange: (event) => onCheckChange(layoutId, cropIndex, event.currentTarget.checked)
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(Text, {
          size: "sm",
          children: localCrop.frameName
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(TextInput, {
          value: localCrop.name,
          onChange: (e) => handleFieldChange("name", e.target.value),
          size: "xs",
          style: { width: "100%" }
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(TextInput, {
          value: localCrop.left.toString(),
          onChange: (e) => handleFieldChange("left", e.target.value),
          size: "xs",
          style: { width: 80 },
          type: "text",
          inputMode: "decimal"
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(TextInput, {
          value: localCrop.top.toString(),
          onChange: (e) => handleFieldChange("top", e.target.value),
          size: "xs",
          style: { width: 80 },
          type: "text",
          inputMode: "decimal"
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(TextInput, {
          value: localCrop.width.toString(),
          onChange: (e) => handleFieldChange("width", e.target.value),
          size: "xs",
          style: { width: 80 },
          type: "text",
          inputMode: "decimal"
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(Table.Td, {
        children: /* @__PURE__ */ jsx_runtime35.jsx(TextInput, {
          value: localCrop.height.toString(),
          onChange: (e) => handleFieldChange("height", e.target.value),
          size: "xs",
          style: { width: 80 },
          type: "text",
          inputMode: "decimal"
        })
      })
    ]
  });
}
function ManualCropEditor({
  selectedLayoutIds,
  selectedConnectorId,
  onModalClose,
  onCropsSaved
}) {
  const raiseError2 = appStore((store) => store.raiseError);
  const [layoutCrops, setLayoutCrops] = import_react280.useState(new Map);
  const [isLoading, setIsLoading] = import_react280.useState(false);
  const [saveState, setSaveState] = import_react280.useState("idle");
  const [saveMessage, setSaveMessage] = import_react280.useState("");
  const [originalDocumentState, setOriginalDocumentState] = import_react280.useState(null);
  const [changedRows, setChangedRows] = import_react280.useState(new Map);
  const [checkedRows, setCheckedRows] = import_react280.useState(new Set);
  const [copyCropToLayerModalOpened, setCopyCropToLayerModalOpened] = import_react280.useState(false);
  const [currentCopySourceLayoutId, setCurrentCopySourceLayoutId] = import_react280.useState("");
  const [copyAndAddRowModalOpened, setCopyAndAddRowModalOpenedState] = import_react280.useState(false);
  const [currentCropForCopy, setCurrentCropForCopy] = import_react280.useState(null);
  const [currentLayoutIdForCopy, setCurrentLayoutIdForCopy] = import_react280.useState("");
  const [copyAndReplaceModalOpened, setCopyAndReplaceModalOpenedState] = import_react280.useState(false);
  const [currentCropsForReplace, setCurrentCropsForReplace] = import_react280.useState([]);
  const [currentLayoutIdForReplace, setCurrentLayoutIdForReplace] = import_react280.useState("");
  const loadCropsForSelectedLayouts = import_react280.useCallback(async () => {
    if (!selectedConnectorId)
      return;
    try {
      setIsLoading(true);
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const studio2 = studioResult.value;
      const allLayoutsResult = await getAllLayouts(studio2);
      if (!allLayoutsResult.isOk()) {
        raiseError2(new Error("Failed to load layouts: " + allLayoutsResult.error?.message));
        return;
      }
      const allLayouts = allLayoutsResult.value;
      const cropsResult = await getManualCropsFromDocByConnector(studio2, selectedConnectorId);
      if (!cropsResult.isOk()) {
        raiseError2(new Error("Failed to load manual crops: " + cropsResult.error?.message));
        return;
      }
      const cropsData = cropsResult.value;
      const layoutCropsMap = new Map;
      selectedLayoutIds.forEach((layoutId) => {
        const layout = allLayouts.find((l2) => l2.id === layoutId);
        if (layout) {
          const layoutData = cropsData.layouts.find((l2) => l2.id === layoutId);
          layoutCropsMap.set(layoutId, {
            layoutId: layout.id,
            layoutName: layout.name,
            crops: layoutData ? layoutData.manualCrops : []
          });
        }
      });
      setLayoutCrops(layoutCropsMap);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to load manual crops"));
    } finally {
      setIsLoading(false);
    }
  }, [selectedConnectorId, selectedLayoutIds, raiseError2]);
  import_react280.useEffect(() => {
    if (selectedConnectorId && selectedLayoutIds.length > 0) {
      loadCropsForSelectedLayouts();
    } else {
      setLayoutCrops(new Map);
    }
    setChangedRows(new Map);
    setCheckedRows(new Set);
  }, [selectedConnectorId, selectedLayoutIds, loadCropsForSelectedLayouts]);
  const handleCropChange = import_react280.useCallback((layoutId, cropIndex, updatedCrop) => {
    const rowKey = `${layoutId}-${cropIndex}`;
    setChangedRows((prev2) => {
      const newMap = new Map(prev2);
      newMap.set(rowKey, updatedCrop);
      return newMap;
    });
  }, []);
  const handleCheckChange = import_react280.useCallback((layoutId, cropIndex, checked) => {
    const rowKey = `${layoutId}-${cropIndex}`;
    setCheckedRows((prev2) => {
      const newSet = new Set(prev2);
      if (checked) {
        newSet.add(rowKey);
      } else {
        newSet.delete(rowKey);
      }
      return newSet;
    });
  }, []);
  const getCheckedSnapshotsCountForLayout = import_react280.useCallback((layoutId) => {
    return Array.from(checkedRows).filter((rowKey) => rowKey.startsWith(`${layoutId}-`)).length;
  }, [checkedRows]);
  const getCheckedCropsForLayout = import_react280.useCallback((layoutId) => {
    const layoutCrop = layoutCrops.get(layoutId);
    if (!layoutCrop)
      return [];
    const checkedCrops = [];
    Array.from(checkedRows).forEach((rowKey) => {
      if (rowKey.startsWith(`${layoutId}-`)) {
        const [, cropIndexStr] = rowKey.split("-");
        const cropIndex = parseInt(cropIndexStr, 10);
        const changedCrop = changedRows.get(rowKey);
        let crop;
        if (changedCrop && "frameId" in changedCrop) {
          crop = changedCrop;
        } else {
          crop = layoutCrop.crops[cropIndex];
        }
        if (crop) {
          checkedCrops.push(crop);
        }
      }
    });
    return checkedCrops;
  }, [checkedRows, layoutCrops, changedRows]);
  const deleteCheckedSnapshots = import_react280.useCallback((layoutId) => {
    const checkedRowsForLayout = Array.from(checkedRows).filter((rowKey) => rowKey.startsWith(`${layoutId}-`));
    setChangedRows((prev2) => {
      const newMap = new Map(prev2);
      checkedRowsForLayout.forEach((rowKey) => {
        const [, cropIndexStr] = rowKey.split("-");
        const cropIndex = parseInt(cropIndexStr, 10);
        const deleteEntry = {
          layoutId,
          cropIndex
        };
        newMap.set(rowKey, deleteEntry);
      });
      return newMap;
    });
    setCheckedRows((prev2) => {
      const newSet = new Set(prev2);
      checkedRowsForLayout.forEach((rowKey) => {
        newSet.delete(rowKey);
      });
      return newSet;
    });
  }, [checkedRows]);
  const setCopyModalOpened = import_react280.useCallback((opened, layoutId) => {
    if (opened && layoutId) {
      setCurrentCopySourceLayoutId(layoutId);
    }
    setCopyCropToLayerModalOpened(opened);
  }, []);
  const setCopyAndAddRowModalOpened = import_react280.useCallback((opened, layoutId) => {
    if (opened && layoutId) {
      const checkedCrops = getCheckedCropsForLayout(layoutId);
      if (checkedCrops.length === 1) {
        setCurrentCropForCopy(checkedCrops[0]);
        setCurrentLayoutIdForCopy(layoutId);
        setCopyAndAddRowModalOpenedState(true);
      }
    } else {
      setCopyAndAddRowModalOpenedState(false);
      setCurrentCropForCopy(null);
      setCurrentLayoutIdForCopy("");
    }
  }, [getCheckedCropsForLayout]);
  const setCopyAndReplaceModalOpened = import_react280.useCallback((opened, layoutId) => {
    if (opened && layoutId) {
      const checkedCrops = getCheckedCropsForLayout(layoutId);
      if (checkedCrops.length > 0) {
        setCurrentCropsForReplace(checkedCrops);
        setCurrentLayoutIdForReplace(layoutId);
        setCopyAndReplaceModalOpenedState(true);
      }
    } else {
      setCopyAndReplaceModalOpenedState(false);
      setCurrentCropsForReplace([]);
      setCurrentLayoutIdForReplace("");
    }
  }, [getCheckedCropsForLayout]);
  const deselectAllRows = import_react280.useCallback((layoutId) => {
    setCheckedRows((prev2) => {
      const newSet = new Set(prev2);
      Array.from(prev2).forEach((rowKey) => {
        if (rowKey.startsWith(`${layoutId}-`)) {
          newSet.delete(rowKey);
        }
      });
      return newSet;
    });
  }, []);
  const selectAllRowsForLayout = import_react280.useCallback((layoutId) => {
    const layoutCrop = layoutCrops.get(layoutId);
    if (!layoutCrop)
      return;
    setCheckedRows((prev2) => {
      const newSet = new Set(prev2);
      layoutCrop.crops.forEach((_2, index4) => {
        const rowKey = `${layoutId}-${index4}`;
        const changedRow = changedRows.get(rowKey);
        const isDeleted = changedRow && "cropIndex" in changedRow && !("frameId" in changedRow);
        if (!isDeleted) {
          newSet.add(rowKey);
        }
      });
      return newSet;
    });
  }, [layoutCrops, changedRows]);
  const getLayoutCheckboxState = import_react280.useCallback((layoutId) => {
    const layoutCrop = layoutCrops.get(layoutId);
    if (!layoutCrop || layoutCrop.crops.length === 0)
      return "unchecked";
    const nonDeletedCrops = layoutCrop.crops.filter((_2, index4) => {
      const rowKey = `${layoutId}-${index4}`;
      const changedRow = changedRows.get(rowKey);
      const isDeleted = changedRow && "cropIndex" in changedRow && !("frameId" in changedRow);
      return !isDeleted;
    });
    if (nonDeletedCrops.length === 0)
      return "unchecked";
    const checkedCount = nonDeletedCrops.filter((_2, originalIndex) => {
      const cropIndex = layoutCrop.crops.findIndex((crop, idx) => {
        const rowKey2 = `${layoutId}-${idx}`;
        const changedRow = changedRows.get(rowKey2);
        const isDeleted = changedRow && "cropIndex" in changedRow && !("frameId" in changedRow);
        return !isDeleted && crop === nonDeletedCrops[originalIndex];
      });
      const rowKey = `${layoutId}-${cropIndex}`;
      return checkedRows.has(rowKey);
    }).length;
    if (checkedCount === 0)
      return "unchecked";
    if (checkedCount === nonDeletedCrops.length)
      return "checked";
    return "indeterminate";
  }, [layoutCrops, checkedRows, changedRows]);
  const handleLayoutCheckboxChange = import_react280.useCallback((layoutId, checked) => {
    if (checked) {
      selectAllRowsForLayout(layoutId);
    } else {
      deselectAllRows(layoutId);
    }
  }, [selectAllRowsForLayout, deselectAllRows]);
  const getAllChildLayoutIds = import_react280.useCallback((parentLayoutId, allLayouts) => {
    const childIds = [];
    const collectChildren = (layoutId) => {
      allLayouts.forEach((layout) => {
        if (layout.parentId === layoutId) {
          childIds.push(layout.id);
          collectChildren(layout.id);
        }
      });
    };
    collectChildren(parentLayoutId);
    return childIds;
  }, []);
  const copyCropsToLayers = import_react280.useCallback(async (targetLayoutIds, checkedCrops) => {
    const missingLayoutIds = targetLayoutIds.filter((id) => !layoutCrops.has(id));
    let layoutNamesMap = new Map;
    if (missingLayoutIds.length > 0) {
      try {
        const studioResult = await getStudio();
        if (studioResult.isOk()) {
          const allLayoutsResult = await getAllLayouts(studioResult.value);
          if (allLayoutsResult.isOk()) {
            const allLayouts = allLayoutsResult.value;
            missingLayoutIds.forEach((layoutId) => {
              const layout = allLayouts.find((l2) => l2.id === layoutId);
              if (layout) {
                layoutNamesMap.set(layoutId, layout.name);
              }
            });
          }
        }
      } catch (error40) {
        raiseError2(error40 instanceof Error ? error40 : new Error("Failed to load layout names"));
      }
    }
    setLayoutCrops((prevLayoutCrops) => {
      const newLayoutCrops = new Map(prevLayoutCrops);
      targetLayoutIds.forEach((targetLayoutId) => {
        const existingLayoutCrop = newLayoutCrops.get(targetLayoutId);
        if (existingLayoutCrop) {
          const updatedCrops = [...existingLayoutCrop.crops];
          checkedCrops.forEach((newCrop) => {
            const existingIndex = updatedCrops.findIndex((crop) => crop.frameId === newCrop.frameId && crop.name === newCrop.name);
            if (existingIndex !== -1) {
              updatedCrops[existingIndex] = newCrop;
            } else {
              updatedCrops.push(newCrop);
            }
          });
          newLayoutCrops.set(targetLayoutId, {
            ...existingLayoutCrop,
            crops: updatedCrops
          });
        } else {
          const layoutName = layoutNamesMap.get(targetLayoutId) || `Layout ${targetLayoutId}`;
          newLayoutCrops.set(targetLayoutId, {
            layoutId: targetLayoutId,
            layoutName,
            crops: [...checkedCrops]
          });
        }
      });
      return newLayoutCrops;
    });
    setChangedRows((prev2) => {
      const newMap = new Map(prev2);
      targetLayoutIds.forEach((targetLayoutId) => {
        const existingLayoutCrop = layoutCrops.get(targetLayoutId);
        checkedCrops.forEach((crop) => {
          if (existingLayoutCrop) {
            const existingIndex = existingLayoutCrop.crops.findIndex((c2) => c2.frameId === crop.frameId && c2.name === crop.name);
            if (existingIndex !== -1) {
              const rowKey = `${targetLayoutId}-${existingIndex}`;
              newMap.set(rowKey, crop);
            } else {
              const newIndex = existingLayoutCrop.crops.length;
              const rowKey = `${targetLayoutId}-${newIndex}`;
              newMap.set(rowKey, crop);
            }
          } else {
            const newIndex = checkedCrops.indexOf(crop);
            const rowKey = `${targetLayoutId}-${newIndex}`;
            newMap.set(rowKey, crop);
          }
        });
      });
      return newMap;
    });
  }, [layoutCrops, raiseError2]);
  const copySelectedCropsToChildren = import_react280.useCallback(async (sourceLayoutId) => {
    try {
      (await getStudio()).map((studio2) => getAllLayouts(studio2)).fold((layouts) => {
        const childLayoutIds = getAllChildLayoutIds(sourceLayoutId, layouts);
        if (childLayoutIds.length === 0) {
          return Result.error(new Error("No child layouts found for this layout"));
        }
        const selectedCrops = getCheckedCropsForLayout(sourceLayoutId);
        if (selectedCrops.length == 0) {
          return Result.error(new Error("No crops selected to copy"));
        }
        copyCropsToLayers(childLayoutIds, selectedCrops);
      }, (error40) => raiseError2(error40));
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to copy crops to child layouts"));
    }
  }, [getAllChildLayoutIds, getCheckedCropsForLayout, copyCropsToLayers]);
  const addCopyOfCrop = import_react280.useCallback((originalCrop, newName) => {
    const layoutId = currentLayoutIdForCopy;
    if (!layoutId)
      return;
    const newCrop = {
      ...originalCrop,
      name: newName
    };
    setLayoutCrops((prevLayoutCrops) => {
      const newLayoutCrops = new Map(prevLayoutCrops);
      const existingLayoutCrop = newLayoutCrops.get(layoutId);
      if (existingLayoutCrop) {
        const updatedCrops = [...existingLayoutCrop.crops];
        const existingIndex = updatedCrops.findIndex((crop) => crop.frameId === newCrop.frameId && crop.name === newCrop.name);
        if (existingIndex !== -1) {
          updatedCrops[existingIndex] = newCrop;
        } else {
          updatedCrops.push(newCrop);
        }
        newLayoutCrops.set(layoutId, {
          ...existingLayoutCrop,
          crops: updatedCrops
        });
      }
      return newLayoutCrops;
    });
    setChangedRows((prev2) => {
      const newMap = new Map(prev2);
      const existingLayoutCrop = layoutCrops.get(layoutId);
      if (existingLayoutCrop) {
        const existingIndex = existingLayoutCrop.crops.findIndex((crop) => crop.frameId === newCrop.frameId && crop.name === newCrop.name);
        if (existingIndex !== -1) {
          const rowKey = `${layoutId}-${existingIndex}`;
          newMap.set(rowKey, newCrop);
        } else {
          const newIndex = existingLayoutCrop.crops.length;
          const rowKey = `${layoutId}-${newIndex}`;
          newMap.set(rowKey, newCrop);
        }
      }
      return newMap;
    });
  }, [currentLayoutIdForCopy, layoutCrops]);
  const addCopyOfCropForReplace = import_react280.useCallback((originalCrop, newName) => {
    const layoutId = currentLayoutIdForReplace;
    if (!layoutId)
      return;
    const newCrop = {
      ...originalCrop,
      name: newName
    };
    setLayoutCrops((prevLayoutCrops) => {
      const newLayoutCrops = new Map(prevLayoutCrops);
      const existingLayoutCrop = newLayoutCrops.get(layoutId);
      if (existingLayoutCrop) {
        const updatedCrops = [...existingLayoutCrop.crops];
        const existingIndex = updatedCrops.findIndex((crop) => crop.frameId === newCrop.frameId && crop.name === newCrop.name);
        if (existingIndex !== -1) {
          updatedCrops[existingIndex] = newCrop;
        } else {
          updatedCrops.push(newCrop);
        }
        newLayoutCrops.set(layoutId, {
          ...existingLayoutCrop,
          crops: updatedCrops
        });
      }
      return newLayoutCrops;
    });
    setChangedRows((prev2) => {
      const newMap = new Map(prev2);
      const existingLayoutCrop = layoutCrops.get(layoutId);
      if (existingLayoutCrop) {
        const existingIndex = existingLayoutCrop.crops.findIndex((crop) => crop.frameId === newCrop.frameId && crop.name === newCrop.name);
        if (existingIndex !== -1) {
          const rowKey = `${layoutId}-${existingIndex}`;
          newMap.set(rowKey, newCrop);
        } else {
          const newIndex = existingLayoutCrop.crops.length;
          const rowKey = `${layoutId}-${newIndex}`;
          newMap.set(rowKey, newCrop);
        }
      }
      return newMap;
    });
  }, [currentLayoutIdForReplace, layoutCrops]);
  const saveCropChanges = async () => {
    if (changedRows.size === 0)
      return;
    try {
      setSaveState("saving");
      setSaveMessage("Saving Crop Changes...");
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        setSaveState("error");
        setSaveMessage("Error saving changes...");
        return;
      }
      const studio2 = studioResult.value;
      const originalDocStateResult = await getCurrentDocumentState(studio2);
      if (!originalDocStateResult.isOk()) {
        raiseError2(new Error("Failed to get original document state: " + originalDocStateResult.error?.message));
        setSaveState("error");
        setSaveMessage("Error saving changes...");
        return;
      }
      const originalDocumentState2 = originalDocStateResult.value;
      setOriginalDocumentState(originalDocumentState2);
      const layoutChanges = new Map;
      const layoutDeletes = new Map;
      changedRows.forEach((entry, rowKey) => {
        const [layoutId, cropIndexStr] = rowKey.split("-");
        const cropIndex = parseInt(cropIndexStr, 10);
        if ("frameId" in entry) {
          if (!layoutChanges.has(layoutId)) {
            layoutChanges.set(layoutId, new Map);
          }
          layoutChanges.get(layoutId).set(cropIndex, entry);
        } else {
          if (!layoutDeletes.has(layoutId)) {
            layoutDeletes.set(layoutId, new Set);
          }
          layoutDeletes.get(layoutId).add(cropIndex);
        }
      });
      let currentDocumentState = originalDocumentState2;
      for (const [layoutId, deleteIndices] of layoutDeletes) {
        if (deleteIndices.size > 0) {
          const layoutCrop = layoutCrops.get(layoutId);
          if (!layoutCrop) {
            raiseError2(new Error(`Layout crops not found for layout ${layoutId}`));
            return;
          }
          for (const cropIndex of deleteIndices) {
            const crop = layoutCrop.crops[cropIndex];
            if (!crop) {
              raiseError2(new Error(`Crop at index ${cropIndex} not found in layout ${layoutId}`));
              return;
            }
            const result = deleteSingleManualCropForLayout(currentDocumentState, layoutId, selectedConnectorId, crop.frameId, crop.name);
            if (result.isError()) {
              raiseError2(new Error(`Failed to delete manual crop ${crop.name} in frame ${crop.frameId}: ${result.error?.message}`));
              setSaveState("error");
              setSaveMessage("Error reverting changes...");
              if (originalDocumentState2) {
                const revertResult = await loadDocumentFromJsonStr(studio2, JSON.stringify(originalDocumentState2));
                if (revertResult.isError()) {
                  raiseError2(new Error("Failed to revert changes after error"));
                }
              }
              return;
            }
            currentDocumentState = result.value;
          }
        }
      }
      for (const [layoutId, cropChanges] of layoutChanges) {
        const layoutCrop = layoutCrops.get(layoutId);
        if (!layoutCrop)
          continue;
        const updatedCrops = layoutCrop.crops.map((crop, index4) => {
          const changedCrop = cropChanges.get(index4);
          return changedCrop || crop;
        });
        const manualCrops = updatedCrops.map((crop) => ({
          frameId: crop.frameId,
          frameName: crop.frameName,
          name: crop.name,
          left: crop.left,
          top: crop.top,
          width: crop.width,
          height: crop.height,
          rotationDegrees: crop.rotationDegrees,
          originalParentWidth: crop.originalParentWidth,
          originalParentHeight: crop.originalParentHeight
        }));
        console.log("Current document state:", currentDocumentState);
        const result = setManualCropsForLayout(currentDocumentState, layoutId, selectedConnectorId, manualCrops);
        if (result.isError()) {
          raiseError2(new Error("Failed to set manual crops: " + result.error?.message));
          setSaveState("error");
          setSaveMessage("Error reverting changes...");
          if (originalDocumentState2) {
            const revertResult = await loadDocumentFromJsonStr(studio2, JSON.stringify(originalDocumentState2));
            if (revertResult.isError()) {
              raiseError2(new Error("Failed to revert changes after error"));
            }
          }
          return;
        }
        currentDocumentState = result.value;
      }
      const finalResult = await loadDocumentFromJsonStr(studio2, JSON.stringify(currentDocumentState));
      if (finalResult.isError()) {
        raiseError2(new Error("Failed to load final document state: " + finalResult.error?.message));
        setSaveState("error");
        setSaveMessage("Error reverting changes...");
        if (originalDocumentState2) {
          const revertResult = await loadDocumentFromJsonStr(studio2, JSON.stringify(originalDocumentState2));
          if (revertResult.isError()) {
            raiseError2(new Error("Failed to revert changes after error"));
          }
        }
        return;
      }
      setSaveState("success");
      setSaveMessage("Changes Saved!");
      setChangedRows(new Map);
      if (onCropsSaved) {
        onCropsSaved();
      }
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to save crop changes"));
      setSaveState("error");
      setSaveMessage("Error reverting changes...");
      if (originalDocumentState) {
        try {
          const studioResult = await getStudio();
          if (studioResult.isOk()) {
            await loadDocumentFromJsonStr(studioResult.value, JSON.stringify(originalDocumentState));
          }
        } catch (revertError) {
          raiseError2(new Error("Failed to revert changes after error"));
        }
      }
    }
  };
  const handleOkayClick = async () => {
    setSaveState("idle");
    setSaveMessage("");
    await loadCropsForSelectedLayouts();
  };
  const handleCloseClick = () => {
    if (onModalClose) {
      onModalClose();
    } else {
      setSaveState("idle");
      setSaveMessage("");
    }
  };
  if (saveState !== "idle") {
    return /* @__PURE__ */ jsx_runtime35.jsx(Center, {
      style: { height: "100%" },
      children: /* @__PURE__ */ jsx_runtime35.jsxs(Stack, {
        align: "center",
        gap: "md",
        children: [
          saveState === "saving" && /* @__PURE__ */ jsx_runtime35.jsx(Loader, {
            size: "lg"
          }),
          /* @__PURE__ */ jsx_runtime35.jsx(Text, {
            size: "lg",
            fw: 500,
            children: saveMessage
          }),
          saveState === "success" && /* @__PURE__ */ jsx_runtime35.jsxs(Group, {
            gap: "md",
            children: [
              /* @__PURE__ */ jsx_runtime35.jsx(Button, {
                onClick: handleOkayClick,
                color: "blue",
                children: "Okay"
              }),
              /* @__PURE__ */ jsx_runtime35.jsx(Button, {
                onClick: handleCloseClick,
                variant: "outline",
                children: "Close"
              })
            ]
          })
        ]
      })
    });
  }
  if (selectedLayoutIds.length === 0) {
    return /* @__PURE__ */ jsx_runtime35.jsx(Center, {
      style: { height: "100%" },
      children: /* @__PURE__ */ jsx_runtime35.jsx(Text, {
        c: "dimmed",
        children: "Select layouts from the Layout Viewer to view their manual crops"
      })
    });
  }
  return /* @__PURE__ */ jsx_runtime35.jsxs(Box, {
    style: { height: "100%", display: "flex", flexDirection: "column" },
    children: [
      /* @__PURE__ */ jsx_runtime35.jsx(Box, {
        p: "md",
        style: { borderBottom: "1px solid var(--mantine-color-gray-3)" },
        children: /* @__PURE__ */ jsx_runtime35.jsx(Group, {
          justify: "flex-end",
          align: "center",
          children: /* @__PURE__ */ jsx_runtime35.jsx(Button, {
            onClick: saveCropChanges,
            disabled: changedRows.size === 0,
            color: "blue",
            size: "sm",
            children: "Save Crop Changes"
          })
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(ScrollArea, {
        style: { flex: 1 },
        children: /* @__PURE__ */ jsx_runtime35.jsx(Box, {
          p: "md",
          children: isLoading ? /* @__PURE__ */ jsx_runtime35.jsx(Center, {
            style: { height: 200 },
            children: /* @__PURE__ */ jsx_runtime35.jsx(Loader, {
              size: "sm"
            })
          }) : layoutCrops.size === 0 ? /* @__PURE__ */ jsx_runtime35.jsx(Center, {
            style: { height: 200 },
            children: /* @__PURE__ */ jsx_runtime35.jsx(Text, {
              c: "dimmed",
              children: selectedConnectorId ? "No manual crops found for the selected layouts and connector" : "Select a connector to view manual crops"
            })
          }) : /* @__PURE__ */ jsx_runtime35.jsx(Stack, {
            gap: "lg",
            children: Array.from(layoutCrops.values()).map((layoutCrop) => {
              const checkedSnapshotsCount = getCheckedSnapshotsCountForLayout(layoutCrop.layoutId);
              return /* @__PURE__ */ jsx_runtime35.jsxs(Paper, {
                p: "md",
                withBorder: true,
                children: [
                  /* @__PURE__ */ jsx_runtime35.jsxs(Group, {
                    justify: "space-between",
                    align: "center",
                    mb: "md",
                    children: [
                      /* @__PURE__ */ jsx_runtime35.jsx(Title, {
                        order: 4,
                        children: layoutCrop.layoutName
                      }),
                      /* @__PURE__ */ jsx_runtime35.jsx(Group, {
                        gap: "xs",
                        children: checkedSnapshotsCount > 0 && /* @__PURE__ */ jsx_runtime35.jsxs(jsx_runtime35.Fragment, {
                          children: [
                            /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                              label: "Delete selected crops",
                              position: "top",
                              withArrow: true,
                              children: /* @__PURE__ */ jsx_runtime35.jsx(ActionIcon, {
                                color: "red",
                                variant: "filled",
                                onClick: () => deleteCheckedSnapshots(layoutCrop.layoutId),
                                disabled: !selectedConnectorId,
                                children: /* @__PURE__ */ jsx_runtime35.jsx(IconTrash, {
                                  size: 16
                                })
                              })
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                              label: "Copy selected crops to other layouts",
                              position: "top",
                              withArrow: true,
                              children: /* @__PURE__ */ jsx_runtime35.jsx(ActionIcon, {
                                color: "blue",
                                variant: "filled",
                                onClick: () => setCopyModalOpened(true, layoutCrop.layoutId),
                                disabled: !selectedConnectorId,
                                children: /* @__PURE__ */ jsx_runtime35.jsx(IconCopy, {
                                  size: 16
                                })
                              })
                            }),
                            checkedSnapshotsCount === 1 && /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                              label: "Copy selected crop and add as new row",
                              position: "top",
                              withArrow: true,
                              children: /* @__PURE__ */ jsx_runtime35.jsx(ActionIcon, {
                                color: "blue",
                                variant: "filled",
                                onClick: () => setCopyAndAddRowModalOpened(true, layoutCrop.layoutId),
                                disabled: !selectedConnectorId,
                                children: /* @__PURE__ */ jsx_runtime35.jsx(IconCopyPlus, {
                                  size: 16
                                })
                              })
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                              label: "Copy and replace existing crops",
                              position: "top",
                              withArrow: true,
                              children: /* @__PURE__ */ jsx_runtime35.jsx(ActionIcon, {
                                color: "blue",
                                variant: "filled",
                                onClick: () => setCopyAndReplaceModalOpened(true, layoutCrop.layoutId),
                                disabled: !selectedConnectorId,
                                children: /* @__PURE__ */ jsx_runtime35.jsx(IconReplace, {
                                  size: 16
                                })
                              })
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                              label: "Deselect all crops in this layout",
                              position: "top",
                              withArrow: true,
                              children: /* @__PURE__ */ jsx_runtime35.jsx(ActionIcon, {
                                color: "blue",
                                variant: "filled",
                                onClick: () => deselectAllRows(layoutCrop.layoutId),
                                disabled: !selectedConnectorId,
                                children: /* @__PURE__ */ jsx_runtime35.jsx(IconDeselect, {
                                  size: 16
                                })
                              })
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                              label: "Copy selected crops to all child layouts",
                              position: "top",
                              withArrow: true,
                              children: /* @__PURE__ */ jsx_runtime35.jsx(ActionIcon, {
                                color: "blue",
                                variant: "filled",
                                onClick: () => copySelectedCropsToChildren(layoutCrop.layoutId),
                                disabled: !selectedConnectorId,
                                children: /* @__PURE__ */ jsx_runtime35.jsx(IconArrowAutofitDown, {
                                  size: 16
                                })
                              })
                            })
                          ]
                        })
                      })
                    ]
                  }),
                  layoutCrop.crops.length === 0 ? /* @__PURE__ */ jsx_runtime35.jsx(Text, {
                    c: "dimmed",
                    size: "sm",
                    children: "No manual crops for this layout"
                  }) : /* @__PURE__ */ jsx_runtime35.jsxs(Table, {
                    striped: true,
                    highlightOnHover: true,
                    children: [
                      /* @__PURE__ */ jsx_runtime35.jsx(Table.Thead, {
                        children: /* @__PURE__ */ jsx_runtime35.jsxs(Table.Tr, {
                          children: [
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              style: { width: 40 }
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              children: /* @__PURE__ */ jsx_runtime35.jsxs(Group, {
                                gap: "xs",
                                align: "center",
                                children: [
                                  /* @__PURE__ */ jsx_runtime35.jsx(Tooltip, {
                                    label: "Select/deselect all crops in this layout",
                                    position: "top",
                                    withArrow: true,
                                    children: /* @__PURE__ */ jsx_runtime35.jsx(Checkbox, {
                                      checked: getLayoutCheckboxState(layoutCrop.layoutId) === "checked",
                                      indeterminate: getLayoutCheckboxState(layoutCrop.layoutId) === "indeterminate",
                                      onChange: (event) => handleLayoutCheckboxChange(layoutCrop.layoutId, event.currentTarget.checked),
                                      disabled: !selectedConnectorId
                                    })
                                  }),
                                  /* @__PURE__ */ jsx_runtime35.jsx(Text, {
                                    children: "Frame Name"
                                  })
                                ]
                              })
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              children: "Asset Name"
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              children: "Left"
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              children: "Top"
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              children: "Width"
                            }),
                            /* @__PURE__ */ jsx_runtime35.jsx(Table.Th, {
                              children: "Height"
                            })
                          ]
                        })
                      }),
                      /* @__PURE__ */ jsx_runtime35.jsx(Table.Tbody, {
                        children: layoutCrop.crops.map((crop, index4) => {
                          const rowKey = `${layoutCrop.layoutId}-${index4}`;
                          const changedRow = changedRows.get(rowKey);
                          const isDeleted = changedRow && "cropIndex" in changedRow && !("frameId" in changedRow);
                          return /* @__PURE__ */ jsx_runtime35.jsx(CropRow, {
                            crop,
                            layoutId: layoutCrop.layoutId,
                            cropIndex: index4,
                            onCropChange: handleCropChange,
                            isChecked: checkedRows.has(rowKey),
                            onCheckChange: handleCheckChange,
                            isDeleted: !!isDeleted
                          }, `${crop.frameId}-${crop.name}`);
                        })
                      })
                    ]
                  })
                ]
              }, layoutCrop.layoutId);
            })
          })
        })
      }),
      /* @__PURE__ */ jsx_runtime35.jsx(CopyCropToLayerModal, {
        opened: copyCropToLayerModalOpened,
        onClose: () => setCopyCropToLayerModalOpened(false),
        sourceLayoutId: currentCopySourceLayoutId,
        checkedCrops: getCheckedCropsForLayout(currentCopySourceLayoutId),
        selectedConnectorId,
        onCopy: copyCropsToLayers
      }),
      currentCropForCopy && /* @__PURE__ */ jsx_runtime35.jsx(CopyAndAddRowModal2, {
        opened: copyAndAddRowModalOpened,
        onClose: () => setCopyAndAddRowModalOpened(false),
        crop: currentCropForCopy,
        layoutId: currentLayoutIdForCopy,
        existingCrops: layoutCrops.get(currentLayoutIdForCopy)?.crops || [],
        onAddCopy: addCopyOfCrop
      }),
      currentCropsForReplace.length > 0 && /* @__PURE__ */ jsx_runtime35.jsx(CopyAndReplaceModal2, {
        opened: copyAndReplaceModalOpened,
        onClose: () => setCopyAndReplaceModalOpened(false),
        crops: currentCropsForReplace,
        layoutId: currentLayoutIdForReplace,
        existingCrops: layoutCrops.get(currentLayoutIdForReplace)?.crops || [],
        onAddCopy: addCopyOfCropForReplace
      })
    ]
  });
}

// src/components/ManualCropManager/ManualCropManagerModal.tsx
var jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
function ManualCropManagerModal({
  opened,
  onClose
}) {
  const [isLayoutViewerCollapsed, setIsLayoutViewerCollapsed] = import_react281.useState(false);
  const [layoutViewerWidth, setLayoutViewerWidth] = import_react281.useState(400);
  const [selectedLayoutIds, setSelectedLayoutIds] = import_react281.useState([]);
  const [selectedConnectorId, setSelectedConnectorId] = import_react281.useState("");
  const [isResizing, setIsResizing] = import_react281.useState(false);
  const [documentConnectors, setDocumentConnectors] = import_react281.useState([]);
  const [availableConnectors, setAvailableConnectors] = import_react281.useState([]);
  const [layoutViewerRefresh, setLayoutViewerRefresh] = import_react281.useState(null);
  const [showDisabled, setShowDisabled] = import_react281.useState(false);
  const enableToolbar = appStore((state) => state.enableToolbar);
  const disableToolbar = appStore((state) => state.disableToolbar);
  const raiseError2 = appStore((state) => state.raiseError);
  const loadConnectors = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const studio2 = studioResult.value;
      const token2 = (await studio2.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studio2.configuration.getValue("ENVIRONMENT_API")).parsedData;
      if (!token2 || !baseUrl) {
        raiseError2(new Error("Failed to get authentication token or base URL"));
        return;
      }
      const availableConnectorsResult = await getMediaConnectorsAPI(baseUrl, token2);
      if (!availableConnectorsResult.isOk()) {
        raiseError2(new Error("Failed to fetch available connectors: " + availableConnectorsResult.error?.message));
        return;
      }
      const documentConnectorsResult = await getCurrentConnectors(studio2);
      if (!documentConnectorsResult.isOk()) {
        raiseError2(new Error("Failed to load connectors: " + documentConnectorsResult.error?.message));
        return;
      }
      const availableConnectors2 = availableConnectorsResult.value.data.filter((connector) => connector.type === "media");
      const documentConnectors2 = documentConnectorsResult.value;
      setDocumentConnectors(documentConnectors2);
      setAvailableConnectors(availableConnectors2);
      const storedConnectorId = sessionStorage.getItem("tempManualCropManager_selectedConnectorId");
      if (storedConnectorId && availableConnectors2.some((c2) => c2.id === storedConnectorId)) {
        setSelectedConnectorId(storedConnectorId);
      } else if (!selectedConnectorId && availableConnectors2.length > 0) {
        const firstConnectorId = availableConnectors2[0].id;
        setSelectedConnectorId(firstConnectorId);
        sessionStorage.setItem("tempManualCropManager_selectedConnectorId", firstConnectorId);
      }
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error("Failed to load connectors"));
    }
  };
  import_react281.useEffect(() => {
    if (opened) {
      const storedSelected = sessionStorage.getItem("tempManualCropManager_layoutsSelected");
      if (storedSelected) {
        try {
          const selectedIds = JSON.parse(storedSelected);
          setSelectedLayoutIds(selectedIds);
        } catch (error40) {
          setSelectedLayoutIds([]);
        }
      } else {
        setSelectedLayoutIds([]);
      }
      setSelectedConnectorId("");
      disableToolbar();
      loadConnectors();
    } else {
      enableToolbar();
    }
  }, [opened]);
  import_react281.useEffect(() => {
    sessionStorage.setItem("tempManualCropManager_layoutsSelected", JSON.stringify(selectedLayoutIds));
  }, [selectedLayoutIds]);
  const handleMouseDown = (e) => {
    setIsResizing(true);
    e.preventDefault();
  };
  const handleMouseMove = (e) => {
    if (!isResizing)
      return;
    const newWidth = e.clientX;
    if (newWidth >= 200 && newWidth <= 600) {
      setLayoutViewerWidth(newWidth);
    }
  };
  const handleMouseUp = () => {
    setIsResizing(false);
  };
  import_react281.useEffect(() => {
    if (isResizing) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };
    }
  }, [isResizing]);
  const toggleLayoutViewer = () => {
    setIsLayoutViewerCollapsed(!isLayoutViewerCollapsed);
  };
  const handleConnectorChange = (value) => {
    const connectorId = value || "";
    setSelectedConnectorId(connectorId);
    if (connectorId) {
      sessionStorage.setItem("tempManualCropManager_selectedConnectorId", connectorId);
    } else {
      sessionStorage.removeItem("tempManualCropManager_selectedConnectorId");
    }
  };
  const handleClose = () => {
    enableToolbar();
    onClose();
  };
  const handleLayoutViewerRefreshReady = import_react281.useCallback((refreshFn) => {
    setLayoutViewerRefresh(() => refreshFn);
  }, []);
  const filteredConnectors = showDisabled ? availableConnectors : availableConnectors.filter((connector) => connector.enabled);
  import_react281.useEffect(() => {
    if (selectedConnectorId && filteredConnectors.length > 0) {
      const isSelectedConnectorAvailable = filteredConnectors.some((connector) => connector.id === selectedConnectorId);
      if (!isSelectedConnectorAvailable) {
        setSelectedConnectorId("");
        sessionStorage.removeItem("tempManualCropManager_selectedConnectorId");
      }
    }
  }, [selectedConnectorId, filteredConnectors]);
  const handleCropsSaved = import_react281.useCallback(async () => {
    if (layoutViewerRefresh) {
      layoutViewerRefresh();
    }
    if (selectedConnectorId) {
      try {
        const studioResult = await getStudio();
        if (studioResult.isOk()) {
          const { getManualCropsFromDocByConnector: getManualCropsFromDocByConnector2 } = await Promise.resolve().then(() => (init_getManualCropsFromDocByConnector(), exports_getManualCropsFromDocByConnector));
          const cropsResult = await getManualCropsFromDocByConnector2(studioResult.value, selectedConnectorId);
          if (cropsResult.isOk()) {
            const cropsData = cropsResult.value;
            const layoutsWithCrops = new Set(cropsData.layouts.map((l2) => l2.id));
            const newLayoutsWithCrops = Array.from(layoutsWithCrops).filter((layoutId) => !selectedLayoutIds.includes(layoutId));
            if (newLayoutsWithCrops.length > 0) {
              setSelectedLayoutIds((prev2) => [...prev2, ...newLayoutsWithCrops]);
            }
          }
        }
      } catch (error40) {
        console.warn("Failed to auto-select layouts with new crops:", error40);
      }
    }
  }, [layoutViewerRefresh, selectedConnectorId, selectedLayoutIds]);
  return /* @__PURE__ */ jsx_runtime36.jsxs(Modal, {
    opened,
    onClose: handleClose,
    fullScreen: true,
    padding: 0,
    withCloseButton: false,
    children: [
      /* @__PURE__ */ jsx_runtime36.jsx(Box, {
        style: {
          padding: "16px 24px",
          borderBottom: "1px solid var(--mantine-color-gray-3)",
          backgroundColor: "var(--mantine-color-gray-0)"
        },
        children: /* @__PURE__ */ jsx_runtime36.jsxs(Group, {
          justify: "space-between",
          align: "center",
          children: [
            /* @__PURE__ */ jsx_runtime36.jsxs(Group, {
              gap: "lg",
              align: "center",
              children: [
                /* @__PURE__ */ jsx_runtime36.jsx(Text, {
                  size: "lg",
                  fw: 600,
                  children: "Manual Crop Manager"
                }),
                /* @__PURE__ */ jsx_runtime36.jsxs(Group, {
                  gap: "md",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime36.jsx(Switch, {
                      label: "Show Disabled",
                      checked: showDisabled,
                      onChange: (event) => setShowDisabled(event.currentTarget.checked),
                      size: "sm"
                    }),
                    /* @__PURE__ */ jsx_runtime36.jsx(Text, {
                      size: "sm",
                      fw: 500,
                      children: "Show crops for connector:"
                    }),
                    /* @__PURE__ */ jsx_runtime36.jsx(Select, {
                      placeholder: "Select connector",
                      data: filteredConnectors.map((connector) => ({
                        value: connector.id,
                        label: connector.name
                      })),
                      value: selectedConnectorId,
                      onChange: handleConnectorChange,
                      style: { minWidth: 200 },
                      size: "sm"
                    })
                  ]
                })
              ]
            }),
            /* @__PURE__ */ jsx_runtime36.jsx(Button, {
              variant: "subtle",
              color: "gray",
              size: "sm",
              leftSection: /* @__PURE__ */ jsx_runtime36.jsx(IconX, {
                size: 16
              }),
              onClick: handleClose,
              children: "Close"
            })
          ]
        })
      }),
      /* @__PURE__ */ jsx_runtime36.jsxs(Box, {
        style: { display: "flex", height: "calc(100vh - 120px)" },
        children: [
          /* @__PURE__ */ jsx_runtime36.jsx(Box, {
            style: {
              width: isLayoutViewerCollapsed ? 40 : layoutViewerWidth,
              minWidth: isLayoutViewerCollapsed ? 40 : 200,
              maxWidth: isLayoutViewerCollapsed ? 40 : 600,
              borderRight: "1px solid var(--mantine-color-gray-3)",
              display: "flex",
              flexDirection: "column",
              transition: isLayoutViewerCollapsed ? "width 0.2s ease" : "none"
            },
            children: isLayoutViewerCollapsed ? /* @__PURE__ */ jsx_runtime36.jsx(Box, {
              style: {
                padding: "8px",
                display: "flex",
                justifyContent: "center"
              },
              children: /* @__PURE__ */ jsx_runtime36.jsx(Tooltip, {
                label: "Expand Layout Viewer",
                position: "right",
                children: /* @__PURE__ */ jsx_runtime36.jsx(ActionIcon, {
                  variant: "subtle",
                  onClick: toggleLayoutViewer,
                  size: "sm",
                  children: /* @__PURE__ */ jsx_runtime36.jsx(IconChevronRight, {
                    size: 16
                  })
                })
              })
            }) : /* @__PURE__ */ jsx_runtime36.jsxs(jsx_runtime36.Fragment, {
              children: [
                /* @__PURE__ */ jsx_runtime36.jsxs(Group, {
                  justify: "space-between",
                  p: "md",
                  style: {
                    borderBottom: "1px solid var(--mantine-color-gray-3)"
                  },
                  children: [
                    /* @__PURE__ */ jsx_runtime36.jsx(Box, {
                      style: { fontSize: "14px", fontWeight: 500 },
                      children: "Layout Viewer"
                    }),
                    /* @__PURE__ */ jsx_runtime36.jsx(Tooltip, {
                      label: "Collapse Layout Viewer",
                      position: "left",
                      children: /* @__PURE__ */ jsx_runtime36.jsx(ActionIcon, {
                        variant: "subtle",
                        onClick: toggleLayoutViewer,
                        size: "sm",
                        children: /* @__PURE__ */ jsx_runtime36.jsx(IconChevronLeft, {
                          size: 16
                        })
                      })
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime36.jsx(Box, {
                  style: { flex: 1, overflow: "hidden" },
                  children: /* @__PURE__ */ jsx_runtime36.jsx(LayoutViewer, {
                    selectedLayoutIds,
                    onSelectionChange: setSelectedLayoutIds,
                    selectedConnectorId,
                    onRefreshFunctionReady: handleLayoutViewerRefreshReady
                  })
                })
              ]
            })
          }),
          !isLayoutViewerCollapsed && /* @__PURE__ */ jsx_runtime36.jsx(Box, {
            style: {
              width: 4,
              cursor: "col-resize",
              backgroundColor: isResizing ? "var(--mantine-color-blue-5)" : "transparent",
              transition: "background-color 0.2s ease"
            },
            onMouseDown: handleMouseDown
          }),
          /* @__PURE__ */ jsx_runtime36.jsx(Box, {
            style: { flex: 1, display: "flex", flexDirection: "column" },
            children: /* @__PURE__ */ jsx_runtime36.jsx(ManualCropEditor, {
              selectedLayoutIds,
              selectedConnectorId,
              onModalClose: handleClose,
              onCropsSaved: handleCropsSaved
            })
          })
        ]
      })
    ]
  });
}

// src/components/OutTemplateModal.tsx
var import_react282 = __toESM(require_react(), 1);
init_documentHandler();
var import_json_2_csv = __toESM(require_converter(), 1);
var import_jszip = __toESM(require_lib(), 1);
var jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
function OutTemplateModal({ opened, onClose }) {
  const raiseError2 = appStore((store) => store.raiseError);
  const fileInputRef = import_react282.useRef(null);
  const [loading, setLoading] = import_react282.useState(true);
  const [outputSettings, setOutputSettings] = import_react282.useState([]);
  const [selectedOutputIds, setSelectedOutputIds] = import_react282.useState([]);
  const [layouts, setLayouts] = import_react282.useState([]);
  const [selectedLayoutIds, setSelectedLayoutIds] = import_react282.useState([]);
  const [isCreatingOutput, setIsCreatingOutput] = import_react282.useState(false);
  const [variableData, setVariableData] = import_react282.useState(null);
  const [outputTasks, setOutputTasks] = import_react282.useState([]);
  const getEnvironmentId = () => {
    try {
      const urlPath = window.location.href;
      const environmentIdMatch = urlPath.match(/environments\/([\w-]+)\/studio/);
      return environmentIdMatch ? environmentIdMatch[1] : null;
    } catch (error40) {
      console.error("Failed to extract environment ID from URL:", error40);
      return null;
    }
  };
  const loadSelectedOutputs = () => {
    const environmentId = getEnvironmentId();
    if (!environmentId)
      return [];
    const storageKey = `tempOutTemplate_selectedOutputIds_${environmentId}`;
    const saved = localStorage.getItem(storageKey);
    return saved ? JSON.parse(saved) : [];
  };
  const saveSelectedOutputs = (outputIds) => {
    const environmentId = getEnvironmentId();
    if (!environmentId)
      return;
    const storageKey = `tempOutTemplate_selectedOutputIds_${environmentId}`;
    localStorage.setItem(storageKey, JSON.stringify(outputIds));
  };
  import_react282.useEffect(() => {
    if (opened) {
      setLoading(true);
      setOutputSettings([]);
      setSelectedOutputIds([]);
      setLayouts([]);
      setSelectedLayoutIds([]);
      setIsCreatingOutput(false);
      setVariableData(null);
      setOutputTasks([]);
      fetchOutputSettings();
      fetchLayouts();
    }
  }, [opened]);
  const fetchOutputSettings = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      const response = await fetch(`${baseUrl}output/settings`, {
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch output settings: ${response.statusText}`);
      }
      const settingsData = await response.json();
      setOutputSettings(settingsData.data);
      const savedOutputIds = loadSelectedOutputs();
      setSelectedOutputIds(savedOutputIds);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    } finally {
      setLoading(false);
    }
  };
  const fetchLayouts = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const layoutsResult = await getAllLayouts(studioResult.value);
      if (!layoutsResult.isOk()) {
        raiseError2(new Error(layoutsResult.error?.message || "Failed to get layouts"));
        return;
      }
      const availableLayouts = layoutsResult.value.filter((layout) => layout.available !== false).map((layout) => ({
        value: layout.id,
        label: layout.name || "Unnamed Layout"
      }));
      setLayouts(availableLayouts);
      const selectedResult = await getSelected(studioResult.value);
      selectedResult.onSuccess((selectedLayout) => {
        setSelectedLayoutIds([selectedLayout.id]);
      });
      selectedResult.onFailure((error40) => {
        raiseError2(new Error(error40 instanceof Error ? error40.message : "Failed to get selected layout"));
      });
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const handleAttachVariableSheet = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };
  const handleFileChange = async (event) => {
    const file2 = event.target.files?.[0];
    if (!file2)
      return;
    try {
      const reader = new FileReader;
      reader.onload = async (e) => {
        const content = e.target?.result;
        try {
          let jsonData;
          if (file2.name.toLowerCase().endsWith(".csv")) {
            jsonData = import_json_2_csv.csv2json(content);
          } else {
            jsonData = JSON.parse(content);
          }
          setVariableData(jsonData);
          raiseError2(new Error(`Variable sheet loaded successfully: ${file2.name}`));
        } catch (parseError) {
          raiseError2(new Error(`Failed to parse file: ${parseError instanceof Error ? parseError.message : String(parseError)}`));
        }
      };
      reader.readAsText(file2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
    if (event.target) {
      event.target.value = "";
    }
  };
  const handleDownloadVariableJSON = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const variablesResult = await getAllVariables(studioResult.value);
      if (!variablesResult.isOk()) {
        raiseError2(new Error(variablesResult.error?.message || "Failed to get variables"));
        return;
      }
      const variableData2 = variablesResult.value.map((variable) => {
        let value = variable.value;
        if (variable.type === "list" && variable.selected !== undefined) {
          value = variable.selected;
        }
        return {
          [variable.name]: value
        };
      });
      const jsonString = JSON.stringify(variableData2, null, 2);
      const blob = new Blob([jsonString], { type: "application/json" });
      const url2 = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = `variables-${new Date().toISOString().split("T")[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const handleDownloadVariableCSV = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const variablesResult = await getAllVariables(studioResult.value);
      if (!variablesResult.isOk()) {
        raiseError2(new Error(variablesResult.error?.message || "Failed to get variables"));
        return;
      }
      const variableObject = {};
      variablesResult.value.forEach((variable) => {
        let value = variable.value;
        if (variable.type === "list" && variable.selected !== undefined) {
          value = variable.selected;
        }
        variableObject[variable.name] = value;
      });
      const csvData = import_json_2_csv.json2csv([variableObject]);
      const blob = new Blob([csvData], { type: "text/csv" });
      const url2 = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = `variables-${new Date().toISOString().split("T")[0]}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const handleCreateOutput = async () => {
    if (selectedOutputIds.length === 0 || selectedLayoutIds.length === 0) {
      raiseError2(new Error("Please select at least one output setting and one layout"));
      return;
    }
    setIsCreatingOutput(true);
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const documentResult = await getCurrentDocumentState(studioResult.value);
      if (!documentResult.isOk()) {
        raiseError2(new Error(documentResult.error?.message || "Failed to get document state"));
        return;
      }
      const documentJson = documentResult.value;
      const engineVersion = documentJson.engineVersion;
      if (!engineVersion) {
        raiseError2(new Error("Engine version not found in document"));
        return;
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const baseUrl = (await studioResult.value.configuration.getValue("ENVIRONMENT_API")).parsedData;
      if (!token2 || !baseUrl) {
        raiseError2(new Error("Failed to get authentication token or base URL"));
        return;
      }
      const newTasks = [];
      for (const outputId of selectedOutputIds) {
        const outputSetting = outputSettings.find((s2) => s2.id === outputId);
        if (!outputSetting)
          continue;
        for (const layoutId of selectedLayoutIds) {
          const layout = layouts.find((l2) => l2.value === layoutId);
          if (!layout)
            continue;
          const taskId = `${outputId}-${layoutId}-${Date.now()}`;
          const task = {
            id: taskId,
            outputSettingsId: outputId,
            outputSettingName: outputSetting.name,
            outputSettingType: outputSetting.type,
            layoutName: layout.label,
            layoutId,
            status: "loading"
          };
          newTasks.push(task);
        }
      }
      setOutputTasks(newTasks);
      for (const task of newTasks) {
        processOutputTask(task, documentJson, engineVersion, token2, baseUrl);
      }
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    } finally {
      setIsCreatingOutput(false);
    }
  };
  const processOutputTask = async (task, documentJson, engineVersion, token2, baseUrl) => {
    try {
      const endpointMap = {
        JPG: "output/jpg",
        PNG: "output/png",
        PDF: "output/pdf",
        GIF: "output/gif",
        MP4: "output/mp4"
      };
      const endpoint = endpointMap[task.outputSettingType];
      if (!endpoint) {
        updateTaskStatus(task.id, "error", undefined, `Unsupported output type: ${task.outputSettingType}`);
        return;
      }
      const requestBody = {
        documentContent: documentJson,
        layoutsToExport: [task.layoutId],
        outputSettingsId: task.outputSettingsId,
        engineVersion
      };
      if (variableData) {
        requestBody.variables = variableData;
      }
      const outputResponse = await fetch(`${baseUrl}${endpoint}`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (!outputResponse.ok) {
        if (outputResponse.status === 500) {
          const errorResponse = await outputResponse.json();
          updateTaskStatus(task.id, "error", undefined, errorResponse.detail || "Output creation failed");
        } else {
          updateTaskStatus(task.id, "error", undefined, `Output creation failed: ${outputResponse.statusText}`);
        }
        return;
      }
      const taskResponse = await outputResponse.json();
      updateTaskStatus(task.id, "loading", undefined, undefined, taskResponse.links.taskInfo);
      pollTaskStatus(task.id, taskResponse.links.taskInfo, token2);
    } catch (error40) {
      updateTaskStatus(task.id, "error", undefined, error40 instanceof Error ? error40.message : String(error40));
    }
  };
  const updateTaskStatus = (taskId, status, downloadUrl, errorMessage, taskInfoUrl) => {
    setOutputTasks((prev2) => prev2.map((task) => task.id === taskId ? { ...task, status, downloadUrl, errorMessage, taskInfoUrl } : task));
  };
  const pollTaskStatus = async (taskId, taskInfoUrl, token2) => {
    const poll = async () => {
      try {
        const response = await fetch(taskInfoUrl, {
          headers: {
            Authorization: `Bearer ${token2}`,
            "Content-Type": "application/json"
          }
        });
        if (response.status === 202) {
          setTimeout(poll, 1000);
        } else if (response.status === 200) {
          const taskInfo = await response.json();
          if (taskInfo.links?.download) {
            updateTaskStatus(taskId, "success", taskInfo.links.download);
          } else {
            updateTaskStatus(taskId, "error", undefined, "Task completed but no download link available");
          }
        } else if (response.status === 500) {
          const errorResponse = await response.json();
          updateTaskStatus(taskId, "error", undefined, errorResponse.detail || "Task failed");
        } else {
          updateTaskStatus(taskId, "error", undefined, `Task polling failed: ${response.statusText}`);
        }
      } catch (error40) {
        updateTaskStatus(taskId, "error", undefined, error40 instanceof Error ? error40.message : String(error40));
      }
    };
    poll();
  };
  const handleTaskDownload = async (task) => {
    if (!task.downloadUrl)
      return;
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
      const response = await fetch(task.downloadUrl, {
        headers: {
          Authorization: `Bearer ${token2}`
        }
      });
      if (!response.ok) {
        throw new Error(`Download failed: ${response.statusText}`);
      }
      const contentDisposition = response.headers.get("Content-Disposition");
      let filename = `${task.outputSettingName}-${task.layoutName}.${task.outputSettingType.toLowerCase()}`;
      if (contentDisposition) {
        const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
        if (filenameMatch && filenameMatch[1]) {
          filename = filenameMatch[1].replace(/['"]/g, "");
        }
      }
      const blob = await response.blob();
      const url2 = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const generateErrorReport = async (task) => {
    let additionalErrorDetails = "";
    if (task.errorMessage && task.errorMessage.includes("Error report: ")) {
      try {
        const errorReportUrl = task.errorMessage.split("Error report: ")[1];
        const studioResult = await getStudio();
        if (studioResult.isOk()) {
          const token2 = (await studioResult.value.configuration.getValue("GRAFX_AUTH_TOKEN")).parsedData;
          if (token2) {
            const response = await fetch(errorReportUrl, {
              headers: {
                Authorization: `Bearer ${token2}`,
                "Content-Type": "application/json"
              }
            });
            if (response.ok) {
              const errorDetails = await response.text();
              additionalErrorDetails = `

## Detailed Error Report
\`\`\`
${errorDetails}
\`\`\``;
            }
          }
        }
      } catch (error40) {
        console.warn("Failed to fetch additional error details:", error40);
      }
    }
    return `# Error Report for ${task.outputSettingName} - ${task.layoutName}

` + `**Task ID:** ${task.id}
` + `**Output Setting:** ${task.outputSettingName}
` + `**Output Type:** ${task.outputSettingType}
` + `**Layout:** ${task.layoutName}
` + `**Layout ID:** ${task.layoutId}
` + `**Error Message:** ${task.errorMessage || "Unknown error"}
` + `**Task Info URL:** ${task.taskInfoUrl || "Not available"}
` + `**Generated:** ${new Date().toLocaleString()}

` + `## Additional Details
` + `This error occurred during the output generation process. ` + `Please review the error message above and check your template configuration.

` + `If the issue persists, please contact support with this error report.` + additionalErrorDetails;
  };
  const handleErrorReportDownload = async (task) => {
    if (task.status !== "error") {
      raiseError2(new Error("Task is not in error state"));
      return;
    }
    try {
      const errorReport = await generateErrorReport(task);
      const blob = new Blob([errorReport], { type: "text/markdown" });
      const url2 = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = `error-report-${task.outputSettingName}-${task.layoutName}-${new Date().toISOString().split("T")[0]}.md`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const handleDownloadAllErrors = async () => {
    const errorTasks = outputTasks.filter((task) => task.status === "error");
    if (errorTasks.length === 0)
      return;
    try {
      const zip = new import_jszip.default;
      for (let index4 = 0;index4 < errorTasks.length; index4++) {
        const task = errorTasks[index4];
        const errorReport = await generateErrorReport(task);
        zip.file(`error-report-${index4 + 1}.md`, errorReport);
      }
      const zipBlob = await zip.generateAsync({ type: "blob" });
      const url2 = URL.createObjectURL(zipBlob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = `output-errors-${new Date().toISOString().split("T")[0]}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const handleDownloadDocumentState = async () => {
    try {
      const studioResult = await getStudio();
      if (!studioResult.isOk()) {
        raiseError2(new Error(studioResult.error?.message || "Failed to get studio"));
        return;
      }
      const documentResult = await getCurrentDocumentState(studioResult.value);
      if (!documentResult.isOk()) {
        raiseError2(new Error(documentResult.error?.message || "Failed to get document state"));
        return;
      }
      const documentJson = documentResult.value;
      const jsonString = JSON.stringify(documentJson, null, 2);
      const blob = new Blob([jsonString], { type: "application/json" });
      const url2 = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url2;
      link.download = `document-state-${new Date().toISOString().split("T")[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url2);
    } catch (error40) {
      raiseError2(error40 instanceof Error ? error40 : new Error(String(error40)));
    }
  };
  const hasErrors = outputTasks.some((task) => task.status === "error");
  const allTasksComplete = outputTasks.length > 0 && outputTasks.every((task) => task.status !== "loading");
  const hasTasksProcessing = outputTasks.some((task) => task.status === "loading");
  return /* @__PURE__ */ jsx_runtime37.jsxs(Modal, {
    opened,
    onClose,
    withCloseButton: false,
    centered: true,
    size: "75%",
    styles: {
      content: {
        minHeight: "600px"
      },
      body: {
        padding: "2rem"
      }
    },
    children: [
      loading ? /* @__PURE__ */ jsx_runtime37.jsxs(Group, {
        justify: "center",
        style: { minHeight: "400px" },
        children: [
          /* @__PURE__ */ jsx_runtime37.jsx(Loader, {
            size: "lg"
          }),
          /* @__PURE__ */ jsx_runtime37.jsx(Text, {
            children: "Loading output settings..."
          })
        ]
      }) : /* @__PURE__ */ jsx_runtime37.jsxs(Grid, {
        children: [
          /* @__PURE__ */ jsx_runtime37.jsx(Grid.Col, {
            span: 6,
            children: /* @__PURE__ */ jsx_runtime37.jsxs(Stack, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                  size: "xl",
                  fw: 600,
                  children: "Output Settings"
                }),
                /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                  c: "dimmed",
                  children: "Pick your output settings to output the template."
                }),
                hasTasksProcessing ? /* @__PURE__ */ jsx_runtime37.jsxs(Group, {
                  justify: "center",
                  style: { minHeight: "300px" },
                  children: [
                    /* @__PURE__ */ jsx_runtime37.jsx(Loader, {
                      size: "lg"
                    }),
                    /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                      children: "Tasks Processing"
                    })
                  ]
                }) : /* @__PURE__ */ jsx_runtime37.jsxs(jsx_runtime37.Fragment, {
                  children: [
                    /* @__PURE__ */ jsx_runtime37.jsx(MultiSelect, {
                      label: "Output Settings",
                      placeholder: "Select output settings",
                      data: outputSettings.map((setting) => ({
                        value: setting.id,
                        label: setting.name
                      })),
                      value: selectedOutputIds,
                      onChange: (values2) => {
                        setSelectedOutputIds(values2);
                        saveSelectedOutputs(values2);
                      }
                    }),
                    /* @__PURE__ */ jsx_runtime37.jsx(MultiSelect, {
                      label: "Selected Layouts",
                      placeholder: "Select layouts",
                      data: layouts,
                      value: selectedLayoutIds,
                      onChange: setSelectedLayoutIds
                    }),
                    /* @__PURE__ */ jsx_runtime37.jsx(Stack, {
                      gap: "sm",
                      children: /* @__PURE__ */ jsx_runtime37.jsx(Button, {
                        size: "lg",
                        disabled: selectedOutputIds.length === 0 || selectedLayoutIds.length === 0,
                        loading: isCreatingOutput,
                        onClick: handleCreateOutput,
                        style: {
                          height: "60px",
                          fontSize: "1.1rem",
                          fontWeight: 500
                        },
                        children: "Create Output"
                      })
                    })
                  ]
                })
              ]
            })
          }),
          /* @__PURE__ */ jsx_runtime37.jsx(Grid.Col, {
            span: 6,
            children: /* @__PURE__ */ jsx_runtime37.jsxs(Stack, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                  size: "xl",
                  fw: 600,
                  children: "Output Tasks"
                }),
                isCreatingOutput && /* @__PURE__ */ jsx_runtime37.jsxs(Group, {
                  justify: "center",
                  style: { minHeight: "100px" },
                  children: [
                    /* @__PURE__ */ jsx_runtime37.jsx(Loader, {
                      size: "lg"
                    }),
                    /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                      children: "Creating Output..."
                    })
                  ]
                }),
                outputTasks.length === 0 && !isCreatingOutput ? /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                  c: "dimmed",
                  children: "No tasks created yet"
                }) : /* @__PURE__ */ jsx_runtime37.jsxs(Stack, {
                  gap: "sm",
                  children: [
                    outputTasks.map((task) => /* @__PURE__ */ jsx_runtime37.jsx(Card, {
                      withBorder: true,
                      padding: "sm",
                      children: /* @__PURE__ */ jsx_runtime37.jsxs(Group, {
                        justify: "space-between",
                        align: "center",
                        children: [
                          /* @__PURE__ */ jsx_runtime37.jsxs(Stack, {
                            gap: 4,
                            style: { flex: 1 },
                            children: [
                              /* @__PURE__ */ jsx_runtime37.jsxs(Text, {
                                size: "sm",
                                fw: 500,
                                children: [
                                  task.outputSettingType,
                                  " - ",
                                  task.layoutName
                                ]
                              }),
                              /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                                size: "xs",
                                c: "dimmed",
                                children: task.outputSettingName
                              })
                            ]
                          }),
                          task.status === "loading" && /* @__PURE__ */ jsx_runtime37.jsx(ActionIcon, {
                            size: "lg",
                            variant: "light",
                            loading: true,
                            children: /* @__PURE__ */ jsx_runtime37.jsx(IconLoader, {
                              size: 16
                            })
                          }),
                          task.status === "success" && /* @__PURE__ */ jsx_runtime37.jsx(Button, {
                            size: "sm",
                            variant: "light",
                            color: "green",
                            onClick: () => handleTaskDownload(task),
                            leftSection: /* @__PURE__ */ jsx_runtime37.jsx(IconDownload, {
                              size: 16
                            }),
                            children: "Download File"
                          }),
                          task.status === "error" && /* @__PURE__ */ jsx_runtime37.jsx(Button, {
                            size: "sm",
                            variant: "light",
                            color: "red",
                            title: task.errorMessage,
                            onClick: () => handleErrorReportDownload(task),
                            leftSection: /* @__PURE__ */ jsx_runtime37.jsx(IconAlertTriangle, {
                              size: 16
                            }),
                            children: "Download Report"
                          })
                        ]
                      })
                    }, task.id)),
                    hasErrors && /* @__PURE__ */ jsx_runtime37.jsxs(Group, {
                      gap: "sm",
                      style: { marginTop: "1rem" },
                      children: [
                        /* @__PURE__ */ jsx_runtime37.jsx(Button, {
                          variant: "outline",
                          color: "red",
                          size: "sm",
                          onClick: handleDownloadAllErrors,
                          children: "Download All Error Reports"
                        }),
                        /* @__PURE__ */ jsx_runtime37.jsx(Button, {
                          variant: "outline",
                          color: "gray",
                          size: "sm",
                          onClick: handleDownloadDocumentState,
                          children: "Download Document State"
                        })
                      ]
                    }),
                    allTasksComplete && /* @__PURE__ */ jsx_runtime37.jsxs(Group, {
                      justify: "center",
                      style: { marginTop: "1rem" },
                      children: [
                        /* @__PURE__ */ jsx_runtime37.jsx(Text, {
                          size: "lg",
                          c: "green",
                          fw: 500,
                          children: "All tasks completed"
                        }),
                        /* @__PURE__ */ jsx_runtime37.jsx(Button, {
                          onClick: onClose,
                          children: "Close Modal"
                        })
                      ]
                    })
                  ]
                })
              ]
            })
          })
        ]
      }),
      /* @__PURE__ */ jsx_runtime37.jsx("input", {
        type: "file",
        ref: fileInputRef,
        style: { display: "none" },
        accept: ".json,.csv",
        onChange: handleFileChange
      })
    ]
  });
}

// src/components/ToolbarSettingsModal.tsx
var import_react283 = __toESM(require_react(), 1);

// src/utils/appConfig.ts
init_dist();

class ManifestRequestError extends Error {
  _tag = "ManifestRequestError";
  constructor(message) {
    super(message);
    this.name = "ManifestRequestError";
  }
}

class ParseManifestError extends Error {
  _tag = "ParseManifestError";
  constructor(message) {
    super(message);
    this.name = "ParseManifestError";
  }
}
function appConfigFromFullConfig(fullConfig) {
  const config2 = {};
  for (const [key, value] of Object.entries(fullConfig)) {
    config2[key] = value.enabled;
  }
  return config2;
}
async function getDefaultConfig() {
  try {
    const response = await fetch("https://raw.githubusercontent.com/spicy-labs/studio-toolbar-plus/main/manifest.json");
    if (!response.ok) {
      return Result.error(new ManifestRequestError(`Failed to fetch manifest: ${response.status} ${response.statusText}`));
    }
    const manifestData = await response.json();
    if (!manifestData.version || typeof manifestData.version !== "string") {
      return Result.error(new ParseManifestError("Invalid or missing version in manifest"));
    }
    const version3 = manifestData.version;
    if (!manifestData.appConfig || typeof manifestData.appConfig !== "object") {
      return Result.error(new ParseManifestError("Invalid or missing appConfig in manifest"));
    }
    const appConfig = manifestData.appConfig;
    for (const [key, value] of Object.entries(appConfig)) {
      if (!value || typeof value !== "object" || typeof value.enabled !== "boolean" || !["none", "sponsored", "deprecated", "experimental"].includes(value.status)) {
        return Result.error(new ParseManifestError(`Invalid toolbarConfig entry for ${key}: expected {enabled: boolean, status: "none" | "sponsored" | "deprecated" | "experimental"}`));
      }
    }
    return Result.ok([appConfig, manifestData.version]);
  } catch (error40) {
    if (error40 instanceof ManifestRequestError || error40 instanceof ParseManifestError) {
      return Result.error(error40);
    }
    return Result.error(new ManifestRequestError(`Network or parsing error: ${error40 instanceof Error ? error40.message : String(error40)}`));
  }
}

// src/utils/checkVersions.ts
init_dist();

class FromIsNotSemanticError extends Error {
  _tag = "FromIsNotSemanticError";
  constructor(message) {
    super(message);
    this.name = "FromIsNotSemanticError";
  }
}

class ToIsNotSemanticError extends Error {
  _tag = "ToIsNotSemanticError";
  constructor(message) {
    super(message);
    this.name = "ToIsNotSemanticError";
  }
}

class UnknownError extends Error {
  _tag = "UnknownError";
  constructor(message) {
    super(message);
    this.name = "UnknownError";
  }
}
function checkVersions(from2, to) {
  try {
    const fromParts = from2.split(".").map(Number);
    if (fromParts.length !== 3 || fromParts.some((part) => isNaN(part) || part < 0)) {
      return Result.error(new FromIsNotSemanticError(`Invalid semantic version format for 'from': ${from2}. Expected format: x.y.z where x, y, z are non-negative numbers.`));
    }
    const toParts = to.split(".").map(Number);
    if (toParts.length !== 3 || toParts.some((part) => isNaN(part) || part < 0)) {
      return Result.error(new ToIsNotSemanticError(`Invalid semantic version format for 'to': ${to}. Expected format: x.y.z where x, y, z are non-negative numbers.`));
    }
    const [fromMajor, fromMinor, fromPatch] = fromParts;
    const [toMajor, toMinor, toPatch] = toParts;
    if (fromMajor > toMajor) {
      return Result.ok("greater");
    } else if (fromMajor < toMajor) {
      return Result.ok("less");
    }
    if (fromMinor > toMinor) {
      return Result.ok("greater");
    } else if (fromMinor < toMinor) {
      return Result.ok("less");
    }
    if (fromPatch > toPatch) {
      return Result.ok("greater");
    } else if (fromPatch < toPatch) {
      return Result.ok("less");
    }
    return Result.ok("equal");
  } catch (error40) {
    return Result.error(new UnknownError(`Unexpected error during version comparison: ${error40 instanceof Error ? error40.message : String(error40)}`));
  }
}

// src/components/ToolbarSettingsModal.tsx
init_dist();
var jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var disclaimer = /* @__PURE__ */ jsx_runtime38.jsxs(jsx_runtime38.Fragment, {
  children: [
    "The Toolbar is released under the MIT license and is primarily supported by the community. Individual apps may have varying support focus. Apps marked with the",
    " ",
    /* @__PURE__ */ jsx_runtime38.jsx(IconRosetteDiscountCheckFilled, {
      style: { display: "inline", verticalAlign: "middle" },
      size: 16
    }),
    " ",
    "icon indicate active sponsorship."
  ]
});
function ToolbarSettingsModal({
  opened,
  onClose,
  onReloadConfig,
  updateInfo
}) {
  const [defaultConfig, setDefaultConfig] = import_react283.useState(null);
  const [githubVersion, setGithubVersion] = import_react283.useState(null);
  const [config2, setConfig2] = import_react283.useState(null);
  const [errorOnGetDefaultConfig, setErrorOnGetDefaultConfig] = import_react283.useState(null);
  const getStatusIcon = (appKey) => {
    if (!defaultConfig)
      return null;
    const appInfo = defaultConfig[appKey];
    const appStatus = appInfo ? appInfo.status : "none";
    const statusConfig = {
      none: {
        icon: /* @__PURE__ */ jsx_runtime38.jsx(IconRosetteFilled, {
          size: 16,
          color: "blue"
        }),
        tooltip: "Still used, no sponsorship"
      },
      sponsored: {
        icon: /* @__PURE__ */ jsx_runtime38.jsx(IconRosetteDiscountCheckFilled, {
          size: 16,
          color: "green"
        }),
        tooltip: "Still used, under active sponsorship"
      },
      deprecated: {
        icon: /* @__PURE__ */ jsx_runtime38.jsx(IconCircleRectangleFilled, {
          size: 16,
          color: "red"
        }),
        tooltip: "Not used, deprecated; scheduled for removal in future versions"
      },
      experimental: {
        icon: /* @__PURE__ */ jsx_runtime38.jsx(IconRadioactiveFilled, {
          size: 16,
          color: "purple"
        }),
        tooltip: "Experimental; may cause issues or instability"
      }
    };
    const config3 = statusConfig[appStatus];
    if (!config3)
      return null;
    return /* @__PURE__ */ jsx_runtime38.jsx(Tooltip, {
      label: config3.tooltip,
      position: "top",
      withArrow: true,
      children: config3.icon
    });
  };
  const toolConfig = {
    showSnapshot: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconCameraPlus, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Snapshot Image Position tool");
      }
    },
    showFramePositionViewer: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconPhotoCog, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Frame Position Viewer tool");
      }
    },
    showLayoutManager: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconListTree, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Layout Manager tool");
      }
    },
    showMagicLayouts: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconSparkles, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Magic Layouts tool");
      }
    },
    showAspectLock: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconPlaystationSquare, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Aspect Lock tool");
      }
    },
    showLayoutImageMapper: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconMapBolt, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Layout Image Mapper tool");
      }
    },
    showUploadDownload: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconArrowsTransferUpDown, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Upload/Download tool");
      }
    },
    showTestError: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconBug, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Test Error tool");
      }
    },
    showConnectorCleanup: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconPlug, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Connector Cleanup tool");
      }
    },
    showManualCropManager: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconCrop, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Manual Crop Manager tool");
      }
    },
    showConnectorFolderBrowser: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconPhotoSearch, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Image Browser tool");
      }
    },
    showOutput: {
      icon: /* @__PURE__ */ jsx_runtime38.jsx(IconDownload, {
        size: 16
      }),
      handler: () => {
        console.log("Opening Output tool");
      }
    }
  };
  const getToolActionIcon = (appKey) => {
    const tool = toolConfig[appKey];
    if (!tool)
      return null;
    return /* @__PURE__ */ jsx_runtime38.jsx(Tooltip, {
      label: `Run ${appKey.replace("show", "").replace(/([A-Z])/g, " $1").trim()}`,
      position: "left",
      withArrow: true,
      children: /* @__PURE__ */ jsx_runtime38.jsx(ActionIcon, {
        variant: "subtle",
        color: "blue",
        size: "sm",
        onClick: tool.handler,
        "aria-label": `Run ${appKey}`,
        children: tool.icon
      })
    });
  };
  import_react283.useEffect(() => {
    if (opened) {
      if (!defaultConfig && !errorOnGetDefaultConfig) {
        const loadDefaultConfig = async () => {
          const result = await getDefaultConfig();
          result.fold(([appConfig, githubVersion2]) => {
            setDefaultConfig(appConfig);
            setGithubVersion(githubVersion2);
            const localConfig = localStorage.getItem("tempUserConfig");
            Result.try(() => JSON.parse(localConfig)).fold((parsedConfig) => {
              setConfig2({
                ...appConfigFromFullConfig(appConfig),
                ...parsedConfig
              });
            }, (_error) => {
              setConfig2(appConfigFromFullConfig(appConfig));
            });
          }, (error40) => setErrorOnGetDefaultConfig(error40));
        };
        loadDefaultConfig();
      }
    }
  }, [opened, defaultConfig, errorOnGetDefaultConfig]);
  const handleToggle = (key, value) => {
    if (config2 == null)
      return;
    const newConfig = { ...config2, [key]: value };
    setConfig2(newConfig);
  };
  const handleClose = () => {
    setConfig2(null);
    setDefaultConfig(null);
    setGithubVersion(null);
    setErrorOnGetDefaultConfig(null);
    onClose();
  };
  const handleSave = async () => {
    localStorage.setItem("tempUserConfig", JSON.stringify(config2));
    if (config2 == null) {
      handleClose();
      return;
    }
    onReloadConfig(config2);
    handleClose();
  };
  const handleReset = () => {
    if (defaultConfig) {
      localStorage.removeItem("tempUserConfig");
      onReloadConfig(appConfigFromFullConfig(defaultConfig));
    }
  };
  const isLoading = (!config2 || !defaultConfig) && !errorOnGetDefaultConfig;
  console.log(config2, defaultConfig);
  return /* @__PURE__ */ jsx_runtime38.jsx(Modal, {
    opened,
    onClose,
    title: "Toolbar Settings",
    centered: true,
    size: "md",
    children: /* @__PURE__ */ jsx_runtime38.jsx(Stack, {
      children: isLoading ? /* @__PURE__ */ jsx_runtime38.jsx(Center, {
        style: { minHeight: "400px" },
        children: /* @__PURE__ */ jsx_runtime38.jsxs(Stack, {
          align: "center",
          gap: "md",
          children: [
            /* @__PURE__ */ jsx_runtime38.jsx(Loader, {
              size: "lg"
            }),
            /* @__PURE__ */ jsx_runtime38.jsx(Text, {
              children: "Loading toolbar settings..."
            })
          ]
        })
      }) : errorOnGetDefaultConfig ? /* @__PURE__ */ jsx_runtime38.jsx(Center, {
        style: { minHeight: "400px" },
        children: /* @__PURE__ */ jsx_runtime38.jsx(Alert, {
          variant: "light",
          color: "red",
          title: "Error",
          icon: /* @__PURE__ */ jsx_runtime38.jsx(IconBugFilled, {}),
          children: errorOnGetDefaultConfig.message
        })
      }) : config2 && defaultConfig ? /* @__PURE__ */ jsx_runtime38.jsxs(jsx_runtime38.Fragment, {
        children: [
          githubVersion && updateInfo && (() => {
            const versionComparison = checkVersions(updateInfo.currentVersion, githubVersion);
            if (versionComparison.isOk()) {
              const result = versionComparison.value;
              if (result === "equal" || result === "greater") {
                return /* @__PURE__ */ jsx_runtime38.jsxs(Alert, {
                  variant: "light",
                  color: "green",
                  title: "Up to Date",
                  icon: /* @__PURE__ */ jsx_runtime38.jsx(IconInfoCircle, {}),
                  children: [
                    "Toolbar is on most up-to-date version:",
                    " ",
                    updateInfo.currentVersion
                  ]
                });
              } else {
                return /* @__PURE__ */ jsx_runtime38.jsxs(Alert, {
                  variant: "light",
                  color: "red",
                  title: "Update Available",
                  icon: /* @__PURE__ */ jsx_runtime38.jsx(IconInfoCircle, {}),
                  children: [
                    "Toolbar is on an older version:",
                    /* @__PURE__ */ jsx_runtime38.jsx("br", {}),
                    " current: ",
                    updateInfo.currentVersion,
                    " < latest:",
                    " ",
                    githubVersion
                  ]
                });
              }
            }
            return null;
          })(),
          /* @__PURE__ */ jsx_runtime38.jsxs(Text, {
            size: "sm",
            c: "dimmed",
            children: [
              "Configure which tools are visible in the toolbar.",
              /* @__PURE__ */ jsx_runtime38.jsx("br", {}),
              /* @__PURE__ */ jsx_runtime38.jsx("br", {}),
              disclaimer
            ]
          }),
          /* @__PURE__ */ jsx_runtime38.jsx(Title, {
            order: 5,
            children: "Available Tools"
          }),
          /* @__PURE__ */ jsx_runtime38.jsx(ScrollArea.Autosize, {
            mah: 400,
            children: /* @__PURE__ */ jsx_runtime38.jsxs(Stack, {
              gap: "md",
              children: [
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showSnapshot"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Snapshot Image Position"
                        }),
                        getStatusIcon("showSnapshot")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showSnapshot,
                      onChange: (event) => handleToggle("showSnapshot", event.currentTarget.checked),
                      "aria-label": "Toggle Snapshot Image Position"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Tool for capturing frame snapshots"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showFramePositionViewer"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Frame Position Viewer"
                        }),
                        getStatusIcon("showFramePositionViewer")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showFramePositionViewer,
                      onChange: (event) => handleToggle("showFramePositionViewer", event.currentTarget.checked),
                      "aria-label": "Toggle Frame Position Viewer"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "View and analyze frame positions"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showLayoutManager"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Layout Manager"
                        }),
                        getStatusIcon("showLayoutManager")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showLayoutManager,
                      onChange: (event) => handleToggle("showLayoutManager", event.currentTarget.checked),
                      "aria-label": "Toggle Layout Manager"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Manage layout properties and hierarchy"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showMagicLayouts"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Magic Layouts"
                        }),
                        getStatusIcon("showMagicLayouts")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showMagicLayouts,
                      onChange: (event) => handleToggle("showMagicLayouts", event.currentTarget.checked),
                      "aria-label": "Toggle Magic Layouts"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Automated layout generation and management"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showAspectLock"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Aspect Lock"
                        }),
                        getStatusIcon("showAspectLock")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showAspectLock,
                      onChange: (event) => handleToggle("showAspectLock", event.currentTarget.checked),
                      "aria-label": "Toggle Aspect Lock"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Lock aspect ratios for layouts"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showLayoutImageMapper"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Layout Image Mapper"
                        }),
                        getStatusIcon("showLayoutImageMapper")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showLayoutImageMapper,
                      onChange: (event) => handleToggle("showLayoutImageMapper", event.currentTarget.checked),
                      "aria-label": "Toggle Layout Image Mapper"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Map images to layout variables"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showUploadDownload"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Upload/Download Document"
                        }),
                        getStatusIcon("showUploadDownload")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showUploadDownload,
                      onChange: (event) => handleToggle("showUploadDownload", event.currentTarget.checked),
                      "aria-label": "Toggle Upload/Download Document"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Upload and download document JSON"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showTestError"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Test Error"
                        }),
                        getStatusIcon("showTestError")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showTestError,
                      onChange: (event) => handleToggle("showTestError", event.currentTarget.checked),
                      "aria-label": "Toggle Test Error"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Test error handling functionality"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showConnectorCleanup"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Connector Cleanup"
                        }),
                        getStatusIcon("showConnectorCleanup")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showConnectorCleanup,
                      onChange: (event) => handleToggle("showConnectorCleanup", event.currentTarget.checked),
                      "aria-label": "Toggle Connector Cleanup"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Manage and remove unused connectors"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showManualCropManager"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Manual Crop Manager"
                        }),
                        getStatusIcon("showManualCropManager")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showManualCropManager,
                      onChange: (event) => handleToggle("showManualCropManager", event.currentTarget.checked),
                      "aria-label": "Toggle Manual Crop Manager"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Manage manual crops for layouts and connectors"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showConnectorFolderBrowser"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Image Browser"
                        }),
                        getStatusIcon("showConnectorFolderBrowser")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showConnectorFolderBrowser,
                      onChange: (event) => handleToggle("showConnectorFolderBrowser", event.currentTarget.checked),
                      "aria-label": "Toggle Image Browser"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Browse and select images from connectors"
                }),
                /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                  justify: "space-between",
                  align: "center",
                  children: [
                    /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                      gap: "xs",
                      style: { flex: 1 },
                      children: [
                        getToolActionIcon("showOutput"),
                        /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                          children: "Output"
                        }),
                        getStatusIcon("showOutput")
                      ]
                    }),
                    /* @__PURE__ */ jsx_runtime38.jsx(Switch, {
                      checked: config2.showOutput,
                      onChange: (event) => handleToggle("showOutput", event.currentTarget.checked),
                      "aria-label": "Toggle Output"
                    })
                  ]
                }),
                /* @__PURE__ */ jsx_runtime38.jsx(Text, {
                  size: "xs",
                  c: "dimmed",
                  ml: 32,
                  children: "Generate output files from layouts"
                })
              ]
            })
          }),
          /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
            justify: "space-between",
            mt: "xl",
            children: [
              /* @__PURE__ */ jsx_runtime38.jsx(Button, {
                variant: "subtle",
                onClick: handleReset,
                children: "Reset to Default"
              }),
              /* @__PURE__ */ jsx_runtime38.jsxs(Group, {
                children: [
                  /* @__PURE__ */ jsx_runtime38.jsx(Button, {
                    variant: "default",
                    onClick: handleClose,
                    children: "Cancel"
                  }),
                  /* @__PURE__ */ jsx_runtime38.jsx(Button, {
                    onClick: handleSave,
                    children: "Save & Apply"
                  })
                ]
              })
            ]
          })
        ]
      }) : null
    })
  });
}

// src/components/Toolbar.tsx
init_dist();
var jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
function Toolbar() {
  const [visible2, setVisible] = import_react284.useState(false);
  const [isDownloadUploadModalOpen, setIsDownloadUploadModalOpen] = import_react284.useState(false);
  const [isDownloadModalNewOpen, setIsDownloadModalNewOpen] = import_react284.useState(false);
  const [isConvertModalOpen, setIsConvertModalOpen] = import_react284.useState(false);
  const [isUpdateModalOpen, setIsUpdateModalOpen] = import_react284.useState(false);
  const [isFramePositionViewerOpen, setIsFramePositionViewerOpen] = import_react284.useState(false);
  const [isAddFrameSnapshotModalOpen, setIsAddFrameSnapshotModalOpen] = import_react284.useState(false);
  const [isLayoutManagerOpen, setIsLayoutManagerOpen] = import_react284.useState(false);
  const [isMagicLayoutsModalOpen, setIsMagicLayoutsModalOpen] = import_react284.useState(false);
  const [isConnectorCleanupModalOpen, setIsConnectorCleanupModalOpen] = import_react284.useState(false);
  const [isManualCropManagerModalOpen, setIsManualCropManagerModalOpen] = import_react284.useState(false);
  const [isOutTemplateModalOpen, setIsOutTemplateModalOpen] = import_react284.useState(false);
  const [isAspectLockConfirmModalOpen, setIsAspectLockConfirmModalOpen] = import_react284.useState(false);
  const [isAspectLockSuccessModalOpen, setIsAspectLockSuccessModalOpen] = import_react284.useState(false);
  const [aspectLockSuccessMessage, setAspectLockSuccessMessage] = import_react284.useState("");
  const [isSettingsModalOpen, setIsSettingsModalOpen] = import_react284.useState(false);
  const [isImageBrowserOpen, setIsImageBrowserOpen] = import_react284.useState(false);
  const [appConfig, setAppConfig] = import_react284.useState(null);
  const [updateInfo, setUpdateInfo] = import_react284.useState(null);
  const getActionIconColor = (appKey) => {
    const appInfo = appConfig[appKey];
    const appStatus = appInfo ? appInfo.status : "none";
    switch (appStatus) {
      case "none":
        return "blue";
      case "sponsored":
        return "blue";
      case "deprecated":
        return "dark";
      case "experimental":
        return "purple";
      default:
        return "blue";
    }
  };
  const effects = appStore((store) => store.effects);
  const raiseError2 = appStore((store) => store.raiseError);
  const disableToolbar = appStore((store) => store.disableToolbar);
  const handleTestError = () => {
    raiseError2(new Error("This is a test error message"));
  };
  const handleSettings = () => {
    setIsSettingsModalOpen(true);
  };
  const setVisibleIntercept = (value) => {
    const isToolbarEnabled = appStore.getState().state.isToolbarEnabled;
    if (!isToolbarEnabled) {
      setVisible(false);
    } else {
      setVisible(value);
    }
  };
  const handleUploadDownloadClick = () => {
    setIsDownloadUploadModalOpen(true);
  };
  const handleDownloadModalNewClick = () => {
    setIsDownloadModalNewOpen(true);
  };
  const handleDismissUpdate = () => {
    if (updateInfo) {
      localStorage.setItem("toolbarplus_last_notified_version", updateInfo.latestVersion);
    }
    setIsUpdateModalOpen(false);
  };
  const reloadConfig = (config2) => {
    setAppConfig(config2);
  };
  import_react284.useEffect(() => {
    (async () => {
      const localConfig = localStorage.getItem("tempUserConfig");
      Result.try(() => {
        if (localConfig) {
          return JSON.parse(localConfig);
        }
        throw new Error("Local config not found");
      }).fold((parsedConfig) => {
        console.log(parsedConfig);
        setAppConfig(parsedConfig);
      }, async (error40) => {
        (await getDefaultConfig()).fold(([appConfig2, githubVersion]) => {
          reloadConfig(appConfigFromFullConfig(appConfig2));
        }, (error41) => {
          raiseError2(error41);
        });
      });
    })();
  }, []);
  import_react284.useEffect(() => {
    const versionDiv = document.getElementById("toolbar-version");
    if (versionDiv) {
      const currentVersion = versionDiv.dataset.currentVersion;
      const latestVersion = versionDiv.dataset.latestVersion;
      if (currentVersion && latestVersion && currentVersion !== latestVersion) {
        setUpdateInfo({
          currentVersion,
          latestVersion
        });
        setIsUpdateModalOpen(true);
      }
    }
    const handleMouseMove = (event) => {
      if (event.clientY <= 40) {
        setVisibleIntercept(true);
      }
      if (event.clientY > 50) {
        setVisibleIntercept(false);
      }
    };
    document.addEventListener("mousemove", handleMouseMove);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
    };
  }, []);
  const handleLayoutClick = () => {
    setVisible(false);
    disableToolbar();
    effects.modal.showModal();
  };
  const handleFramePositionViewer = () => {
    setVisible(false);
    setIsFramePositionViewerOpen(true);
  };
  const handleSnapshot = () => {
    setVisible(false);
    setIsAddFrameSnapshotModalOpen(true);
  };
  const handleLayoutManager = () => {
    setVisible(false);
    setIsLayoutManagerOpen(true);
  };
  const handleMagicLayouts = () => {
    setVisible(false);
    setIsMagicLayoutsModalOpen(true);
  };
  const handleConnectorCleanup = () => {
    setVisible(false);
    setIsConnectorCleanupModalOpen(true);
  };
  const handleManualCropManager = () => {
    setVisible(false);
    setIsManualCropManagerModalOpen(true);
  };
  const handleOutTemplate = () => {
    setVisible(false);
    setIsOutTemplateModalOpen(true);
  };
  const handleAspectLock = () => {
    setIsAspectLockConfirmModalOpen(true);
  };
  const handleConfirmAspectLock = async (value) => {
    setIsAspectLockConfirmModalOpen(false);
    (await saveLayoutSizingToAction(value)).fold((_2) => {
      setAspectLockSuccessMessage(value ? "Success in turning Aspect Ratio On" : "Success in turning Aspect Ratio Off");
      setIsAspectLockSuccessModalOpen(true);
    }, (err) => raiseError2(err ?? Error(`Error setting aspect lock to ${value}`)));
  };
  return /* @__PURE__ */ jsx_runtime39.jsxs(jsx_runtime39.Fragment, {
    children: [
      /* @__PURE__ */ jsx_runtime39.jsx(Transition, {
        mounted: visible2,
        transition: "slide-down",
        duration: 300,
        timingFunction: "ease",
        children: (styles) => /* @__PURE__ */ jsx_runtime39.jsx(Box, {
          style: {
            ...styles,
            position: "fixed",
            top: 0,
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 1000,
            width: "60%",
            backgroundColor: "#25262b",
            padding: "10px",
            display: "flex",
            justifyContent: "center",
            boxShadow: "0 2px 10px rgba(0, 0, 0, 0.2)",
            borderBottom: "1px solid #373A40"
          },
          onMouseLeave: () => setVisible(false),
          children: appConfig && /* @__PURE__ */ jsx_runtime39.jsxs(Group, {
            gap: "lg",
            children: [
              appConfig.showSnapshot && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Snapshot Image Position",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showSnapshot"),
                  size: "lg",
                  "aria-label": "Snapshot Image Position",
                  onClick: handleSnapshot,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconCameraPlus, {
                    size: 20
                  })
                })
              }),
              appConfig.showFramePositionViewer && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Frame Position Viewer",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showFramePositionViewer"),
                  size: "lg",
                  "aria-label": "Frame Position Viewer",
                  onClick: handleFramePositionViewer,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconPhotoCog, {
                    size: 20
                  })
                })
              }),
              appConfig.showMagicLayouts && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Magic Layouts",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showMagicLayouts"),
                  size: "lg",
                  "aria-label": "Magic Layouts",
                  onClick: handleMagicLayouts,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconSparkles, {
                    size: 20
                  })
                })
              }),
              appConfig.showLayoutManager && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Layout Manager",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showLayoutManager"),
                  size: "lg",
                  "aria-label": "Layout Manager",
                  onClick: handleLayoutManager,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconListTree, {
                    size: 20
                  })
                })
              }),
              appConfig.showAspectLock && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Aspect Lock",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showAspectLock"),
                  size: "lg",
                  "aria-label": "Aspect Lock",
                  onClick: handleAspectLock,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconPlaystationSquare, {
                    size: 20
                  })
                })
              }),
              appConfig.showUploadDownload && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Upload/Download Template",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showUploadDownload"),
                  size: "lg",
                  "aria-label": "Upload/Download",
                  onClick: handleDownloadModalNewClick,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconArrowsTransferUpDown, {
                    size: 20
                  })
                })
              }),
              appConfig.showLayoutImageMapper && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Layout Image Mapper",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showLayoutImageMapper"),
                  size: "lg",
                  "aria-label": "Layout",
                  onClick: handleLayoutClick,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconMapBolt, {
                    size: 20
                  })
                })
              }),
              appConfig.showTestError && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Test Error",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showTestError"),
                  size: "lg",
                  "aria-label": "Test Error",
                  onClick: handleTestError,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconBug, {
                    size: 20
                  })
                })
              }),
              appConfig.showConnectorCleanup && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Connector Cleanup",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showConnectorCleanup"),
                  size: "lg",
                  "aria-label": "Connector Cleanup",
                  onClick: handleConnectorCleanup,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconPlug, {
                    size: 20
                  })
                })
              }),
              appConfig.showManualCropManager && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Manual Crop Manager",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showManualCropManager"),
                  size: "lg",
                  "aria-label": "Manual Crop Manager",
                  onClick: handleManualCropManager,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconCrop, {
                    size: 20
                  })
                })
              }),
              appConfig.showOutput && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Output",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showOutput"),
                  size: "lg",
                  "aria-label": "Output",
                  onClick: handleOutTemplate,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconDownload, {
                    size: 20
                  })
                })
              }),
              appConfig.showConnectorFolderBrowser && /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Image Browser",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: getActionIconColor("showConnectorFolderBrowser"),
                  size: "lg",
                  "aria-label": "Image Browser",
                  onClick: () => {
                    setIsImageBrowserOpen(true);
                  },
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconPhotoSearch, {
                    size: 20
                  })
                })
              }),
              /* @__PURE__ */ jsx_runtime39.jsx(Tooltip, {
                label: "Settings",
                position: "bottom",
                withArrow: true,
                children: /* @__PURE__ */ jsx_runtime39.jsx(ActionIcon, {
                  variant: "filled",
                  color: "gray",
                  size: "lg",
                  "aria-label": "Settings",
                  onClick: handleSettings,
                  children: /* @__PURE__ */ jsx_runtime39.jsx(IconSettings, {
                    size: 20
                  })
                })
              })
            ]
          })
        })
      }),
      /* @__PURE__ */ jsx_runtime39.jsx(Modal, {
        opened: isUpdateModalOpen,
        onClose: () => setIsUpdateModalOpen(false),
        title: "Update Available",
        centered: true,
        children: /* @__PURE__ */ jsx_runtime39.jsxs(Stack, {
          children: [
            /* @__PURE__ */ jsx_runtime39.jsx(Text, {
              children: "A new version of Studio Toolbar Plus is available!"
            }),
            /* @__PURE__ */ jsx_runtime39.jsxs(Text, {
              size: "sm",
              children: [
                "Current version: ",
                updateInfo?.currentVersion,
                /* @__PURE__ */ jsx_runtime39.jsx("br", {}),
                "Latest version: ",
                updateInfo?.latestVersion
              ]
            }),
            /* @__PURE__ */ jsx_runtime39.jsxs(Group, {
              justify: "space-between",
              mt: "md",
              children: [
                /* @__PURE__ */ jsx_runtime39.jsx(Button, {
                  onClick: handleDismissUpdate,
                  variant: "subtle",
                  color: "gray",
                  children: "Dismiss"
                }),
                /* @__PURE__ */ jsx_runtime39.jsx(Button, {
                  component: "a",
                  href: "https://github.com/spicy-labs/studio-toolbar-plus/",
                  target: "_blank",
                  rightSection: /* @__PURE__ */ jsx_runtime39.jsx(IconExternalLink, {
                    size: 16
                  }),
                  color: "blue",
                  children: "Download Update"
                })
              ]
            })
          ]
        })
      }),
      isFramePositionViewerOpen && appConfig?.showFramePositionViewer && /* @__PURE__ */ jsx_runtime39.jsx(FrameSnapshotLayoutModal, {
        opened: isFramePositionViewerOpen,
        onClose: () => setIsFramePositionViewerOpen(false)
      }),
      isAddFrameSnapshotModalOpen && appConfig?.showSnapshot && /* @__PURE__ */ jsx_runtime39.jsx(AddFrameSnapshotModal, {
        opened: isAddFrameSnapshotModalOpen,
        onClose: () => setIsAddFrameSnapshotModalOpen(false),
        raiseError: raiseError2
      }),
      isLayoutManagerOpen && appConfig?.showLayoutManager && /* @__PURE__ */ jsx_runtime39.jsx(LayoutManagerModal, {
        opened: isLayoutManagerOpen,
        onClose: () => setIsLayoutManagerOpen(false)
      }),
      isMagicLayoutsModalOpen && appConfig?.showMagicLayouts && /* @__PURE__ */ jsx_runtime39.jsx(MagicLayoutsModal, {
        opened: isMagicLayoutsModalOpen,
        onClose: () => setIsMagicLayoutsModalOpen(false)
      }),
      appConfig?.showConnectorCleanup && /* @__PURE__ */ jsx_runtime39.jsx(ConnectorCleanupModal, {
        opened: isConnectorCleanupModalOpen,
        onClose: () => setIsConnectorCleanupModalOpen(false)
      }),
      appConfig?.showManualCropManager && /* @__PURE__ */ jsx_runtime39.jsx(ManualCropManagerModal, {
        opened: isManualCropManagerModalOpen,
        onClose: () => setIsManualCropManagerModalOpen(false)
      }),
      appConfig?.showOutput && /* @__PURE__ */ jsx_runtime39.jsx(OutTemplateModal, {
        opened: isOutTemplateModalOpen,
        onClose: () => setIsOutTemplateModalOpen(false)
      }),
      appConfig?.showAspectLock && /* @__PURE__ */ jsx_runtime39.jsxs(Modal, {
        opened: isAspectLockConfirmModalOpen,
        onClose: () => setIsAspectLockConfirmModalOpen(false),
        title: "Confirm Aspect Lock Change",
        centered: true,
        size: "sm",
        children: [
          /* @__PURE__ */ jsx_runtime39.jsx(Text, {
            children: "Turn Aspect Lock On?"
          }),
          /* @__PURE__ */ jsx_runtime39.jsxs(Group, {
            justify: "flex-end",
            mt: "md",
            children: [
              /* @__PURE__ */ jsx_runtime39.jsx(Button, {
                variant: "default",
                onClick: () => handleConfirmAspectLock(false),
                children: "No"
              }),
              /* @__PURE__ */ jsx_runtime39.jsx(Button, {
                color: "blue",
                onClick: () => handleConfirmAspectLock(true),
                children: "Yes"
              })
            ]
          })
        ]
      }),
      appConfig?.showAspectLock && /* @__PURE__ */ jsx_runtime39.jsxs(Modal, {
        opened: isAspectLockSuccessModalOpen,
        onClose: () => {
          setIsAspectLockSuccessModalOpen(false);
          setAspectLockSuccessMessage("");
        },
        title: "Aspect Lock Status",
        centered: true,
        size: "sm",
        children: [
          /* @__PURE__ */ jsx_runtime39.jsx(Text, {
            children: aspectLockSuccessMessage
          }),
          /* @__PURE__ */ jsx_runtime39.jsx(Group, {
            justify: "flex-end",
            mt: "md",
            children: /* @__PURE__ */ jsx_runtime39.jsx(Button, {
              onClick: () => {
                setIsAspectLockSuccessModalOpen(false);
                setAspectLockSuccessMessage("");
              },
              children: "Close"
            })
          })
        ]
      }),
      appConfig?.showUploadDownload && /* @__PURE__ */ jsx_runtime39.jsx(DownloadModalNew, {
        opened: isDownloadModalNewOpen,
        onClose: () => setIsDownloadModalNewOpen(false)
      }),
      appConfig?.showConnectorFolderBrowser && /* @__PURE__ */ jsx_runtime39.jsx(ImageBrowser, {
        opened: isImageBrowserOpen,
        mode: 1 /* FileSelection */,
        onClose: (selection) => {
          setIsImageBrowserOpen(false);
        }
      }),
      appConfig && /* @__PURE__ */ jsx_runtime39.jsx(ToolbarSettingsModal, {
        opened: isSettingsModalOpen,
        onClose: () => setIsSettingsModalOpen(false),
        onReloadConfig: reloadConfig,
        updateInfo: updateInfo ?? undefined
      })
    ]
  });
}

// src/components/AlertsContainer.tsx
var import_react285 = __toESM(require_react(), 1);
var jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
function AlertsContainer() {
  const alerts = appStore((store) => store.alerts);
  const dismissAlert = appStore((store) => store.dismissAlert);
  import_react285.useEffect(() => {
    const timers = [];
    alerts.forEach((alert) => {
      const timer = setTimeout(() => {
        dismissAlert(alert.id);
      }, 7000);
      timers.push(timer);
    });
    return () => {
      timers.forEach((timer) => clearTimeout(timer));
    };
  }, [alerts, dismissAlert]);
  if (alerts.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsx_runtime40.jsx(Box, {
    style: {
      position: "fixed",
      top: "20px",
      left: "20px",
      zIndex: 1001,
      width: "300px"
    },
    children: /* @__PURE__ */ jsx_runtime40.jsx(Stack, {
      gap: "md",
      children: alerts.map((alert) => /* @__PURE__ */ jsx_runtime40.jsx(Alert, {
        icon: /* @__PURE__ */ jsx_runtime40.jsx(IconInfoCircle, {
          size: "1rem"
        }),
        title: "Toolbar Error",
        variant: "filled",
        color: "red",
        withCloseButton: true,
        onClose: () => dismissAlert(alert.id),
        styles: {
          root: {
            animation: "fadeIn 0.3s ease-in-out"
          }
        },
        children: alert.message
      }, alert.id))
    })
  });
}

// src/index.tsx
var jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var theme = createTheme({
  primaryColor: "blue",
  defaultRadius: "sm",
  colors: {}
});
window.test = () => console.log(appStore.getState());
async function renderToolbar(studio2) {
  console.log("Rendering toolbar...");
  if (!window.rootInstance) {
    const modalContainer = document.createElement("div");
    modalContainer.id = "config-modal-root";
    document.body.appendChild(modalContainer);
    window.rootInstance = import_client.createRoot(modalContainer);
  }
  if (!window.toolbarInstance) {
    const toolbarContainer = document.createElement("div");
    toolbarContainer.id = "toolbar-container";
    document.body.appendChild(toolbarContainer);
    window.toolbarInstance = import_client.createRoot(toolbarContainer);
  }
  window.rootInstance.render(/* @__PURE__ */ jsx_runtime41.jsx(import_react286.default.StrictMode, {
    children: /* @__PURE__ */ jsx_runtime41.jsx(LayoutImageMappingModal, {
      onExportCSV: () => console.log("Look")
    })
  }));
  window.toolbarInstance.render(/* @__PURE__ */ jsx_runtime41.jsx(import_react286.default.StrictMode, {
    children: /* @__PURE__ */ jsx_runtime41.jsxs(MantineProvider, {
      children: [
        /* @__PURE__ */ jsx_runtime41.jsx(Toolbar, {}),
        /* @__PURE__ */ jsx_runtime41.jsx(AlertsContainer, {})
      ]
    })
  }));
}
async function checkStudioExist() {
  const studioResult = await getStudio();
  studioResult.fold((studio2) => {
    studio2.config.events.onParagraphStylesChanged.registerCallback(() => {
      console.log("Studio found, rendering toolbar...");
      if (window.customToolbarLoaded == null) {
        window.customToolbarLoaded = true;
        renderToolbar(studio2);
        setEnableActions(studio2, true);
      }
    });
  }, () => {
    console.log("Studio not found, retrying in 200ms...");
    setTimeout(() => {
      checkStudioExist();
    }, 200);
  });
}
checkStudioExist();

//# debugId=AC1436077E05189364756E2164756E21
